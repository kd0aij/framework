
build/org.mro.perh_1.0/basic_uavcan_functionality.elf:     file format elf32-littlearm


Disassembly of section .text:

080031d0 <Reset_Handler>:
                .align  2
                .thumb_func
                .global Reset_Handler
Reset_Handler:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80031d0:	b672      	cpsid	i
                ldr     r0, =__main_stack_end__
                msr     MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80031d2:	4825      	ldr	r0, [pc, #148]	; (8003268 <endfiniloop+0x4>)
                msr     PSP, r0
 80031d4:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80031d8:	4824      	ldr	r0, [pc, #144]	; (800326c <endfiniloop+0x8>)
                movw    r1, #SCB_VTOR & 0xFFFF
 80031da:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 80031de:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80031e2:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80031e4:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80031e6:	f380 8814 	msr	CONTROL, r0
                isb
 80031ea:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 80031ee:	f009 f9e5 	bl	800c5bc <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 80031f2:	f001 f88f 	bl	8004314 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80031f6:	481e      	ldr	r0, [pc, #120]	; (8003270 <endfiniloop+0xc>)
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80031f8:	491e      	ldr	r1, [pc, #120]	; (8003274 <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
 80031fa:	4a1f      	ldr	r2, [pc, #124]	; (8003278 <endfiniloop+0x14>)

080031fc <msloop>:
msloop:
                cmp     r1, r2
 80031fc:	4291      	cmp	r1, r2
                itt     lo
 80031fe:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8003200:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8003204:	e7fa      	bcc.n	80031fc <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8003206:	491d      	ldr	r1, [pc, #116]	; (800327c <endfiniloop+0x18>)
                ldr     r2, =__process_stack_end__
 8003208:	4a17      	ldr	r2, [pc, #92]	; (8003268 <endfiniloop+0x4>)

0800320a <psloop>:
psloop:
                cmp     r1, r2
 800320a:	4291      	cmp	r1, r2
                itt     lo
 800320c:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800320e:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8003212:	e7fa      	bcc.n	800320a <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 8003214:	491a      	ldr	r1, [pc, #104]	; (8003280 <endfiniloop+0x1c>)
                ldr     r2, =_data_start
 8003216:	4a1b      	ldr	r2, [pc, #108]	; (8003284 <endfiniloop+0x20>)
                ldr     r3, =_data_end
 8003218:	4b1b      	ldr	r3, [pc, #108]	; (8003288 <endfiniloop+0x24>)

0800321a <dloop>:
dloop:
                cmp     r2, r3
 800321a:	429a      	cmp	r2, r3
                ittt    lo
 800321c:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 800321e:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8003222:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8003226:	e7f8      	bcc.n	800321a <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8003228:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 800322a:	4918      	ldr	r1, [pc, #96]	; (800328c <endfiniloop+0x28>)
                ldr     r2, =_bss_end
 800322c:	4a18      	ldr	r2, [pc, #96]	; (8003290 <endfiniloop+0x2c>)

0800322e <bloop>:
bloop:
                cmp     r1, r2
 800322e:	4291      	cmp	r1, r2
                itt     lo
 8003230:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8003232:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8003236:	e7fa      	bcc.n	800322e <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8003238:	f009 f9d0 	bl	800c5dc <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800323c:	f009 f9c4 	bl	800c5c8 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 8003240:	4c14      	ldr	r4, [pc, #80]	; (8003294 <endfiniloop+0x30>)
                ldr     r5, =__init_array_end
 8003242:	4d15      	ldr	r5, [pc, #84]	; (8003298 <endfiniloop+0x34>)

08003244 <initloop>:
initloop:
                cmp     r4, r5
 8003244:	42ac      	cmp	r4, r5
                bge     endinitloop
 8003246:	da03      	bge.n	8003250 <endinitloop>
                ldr     r1, [r4], #4
 8003248:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800324c:	4788      	blx	r1
                b       initloop
 800324e:	e7f9      	b.n	8003244 <initloop>

08003250 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8003250:	f009 fbb6 	bl	800c9c0 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 8003254:	4c11      	ldr	r4, [pc, #68]	; (800329c <endfiniloop+0x38>)
                ldr     r5, =__fini_array_end
 8003256:	4d12      	ldr	r5, [pc, #72]	; (80032a0 <endfiniloop+0x3c>)

08003258 <finiloop>:
finiloop:
                cmp     r4, r5
 8003258:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800325a:	da03      	bge.n	8003264 <endfiniloop>
                ldr     r1, [r4], #4
 800325c:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8003260:	4788      	blx	r1
                b       finiloop
 8003262:	e7f9      	b.n	8003258 <finiloop>

08003264 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8003264:	f009 b9b6 	b.w	800c5d4 <__default_exit>
                ldr     r0, =__main_stack_end__
                msr     MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8003268:	20000a00 	.word	0x20000a00
                msr     PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 800326c:	08003000 	.word	0x08003000

                /* Early initialization.*/
                bl      __early_init

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8003270:	55555555 	.word	0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8003274:	20000000 	.word	0x20000000
                ldr     r2, =__main_stack_end__
 8003278:	20000500 	.word	0x20000500
                blo     msloop

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800327c:	20000500 	.word	0x20000500
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 8003280:	0800ed00 	.word	0x0800ed00
                ldr     r2, =_data_start
 8003284:	20000a00 	.word	0x20000a00
                ldr     r3, =_data_end
 8003288:	20000a1c 	.word	0x20000a1c

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
                ldr     r1, =_bss_start
 800328c:	20000a20 	.word	0x20000a20
                ldr     r2, =_bss_end
 8003290:	20001554 	.word	0x20001554
                /* Late initialization..*/
                bl      __late_init

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 8003294:	08003188 	.word	0x08003188
                ldr     r5, =__init_array_end
 8003298:	080031c4 	.word	0x080031c4
                /* Main program invocation, r0 contains the returned value.*/
                bl      main

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 800329c:	080031c4 	.word	0x080031c4
                ldr     r5, =__fini_array_end
 80032a0:	080031c4 	.word	0x080031c4

080032a4 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80032a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80032a8:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80032ac:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80032ae:	469d      	mov	sp, r3
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80032b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080032b4 <_port_thread_start>:
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_thread_start
_port_thread_start:
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80032b4:	f007 fe08 	bl	800aec8 <_dbg_check_unlock>
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80032b8:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80032ba:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80032be:	4628      	mov	r0, r5
                blx     r4
 80032c0:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 80032c2:	2000      	movs	r0, #0
                bl      chThdExit
 80032c4:	f007 f896 	bl	800a3f4 <chThdExit>

080032c8 <_port_switch_from_isr>:
_port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
 80032c8:	f007 fde8 	bl	800ae9c <_dbg_check_lock>
#endif
                bl      chSchDoReschedule
 80032cc:	f008 fad0 	bl	800b870 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80032d0:	f007 fdfa 	bl	800aec8 <_dbg_check_unlock>

080032d4 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80032d4:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80032d6:	e7fe      	b.n	80032d6 <_port_exit_from_isr+0x2>

080032d8 <__aeabi_f2uiz>:
 80032d8:	0042      	lsls	r2, r0, #1
 80032da:	d20e      	bcs.n	80032fa <__aeabi_f2uiz+0x22>
 80032dc:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80032e0:	d30b      	bcc.n	80032fa <__aeabi_f2uiz+0x22>
 80032e2:	f04f 039e 	mov.w	r3, #158	; 0x9e
 80032e6:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 80032ea:	d409      	bmi.n	8003300 <__aeabi_f2uiz+0x28>
 80032ec:	ea4f 2300 	mov.w	r3, r0, lsl #8
 80032f0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80032f4:	fa23 f002 	lsr.w	r0, r3, r2
 80032f8:	4770      	bx	lr
 80032fa:	f04f 0000 	mov.w	r0, #0
 80032fe:	4770      	bx	lr
 8003300:	f112 0f61 	cmn.w	r2, #97	; 0x61
 8003304:	d101      	bne.n	800330a <__aeabi_f2uiz+0x32>
 8003306:	0242      	lsls	r2, r0, #9
 8003308:	d102      	bne.n	8003310 <__aeabi_f2uiz+0x38>
 800330a:	f04f 30ff 	mov.w	r0, #4294967295
 800330e:	4770      	bx	lr
 8003310:	f04f 0000 	mov.w	r0, #0
 8003314:	4770      	bx	lr
 8003316:	bf00      	nop

08003318 <__aeabi_uldivmod>:
 8003318:	b953      	cbnz	r3, 8003330 <__aeabi_uldivmod+0x18>
 800331a:	b94a      	cbnz	r2, 8003330 <__aeabi_uldivmod+0x18>
 800331c:	2900      	cmp	r1, #0
 800331e:	bf08      	it	eq
 8003320:	2800      	cmpeq	r0, #0
 8003322:	bf1c      	itt	ne
 8003324:	f04f 31ff 	movne.w	r1, #4294967295
 8003328:	f04f 30ff 	movne.w	r0, #4294967295
 800332c:	f000 b83c 	b.w	80033a8 <__aeabi_idiv0>
 8003330:	b082      	sub	sp, #8
 8003332:	46ec      	mov	ip, sp
 8003334:	e92d 5000 	stmdb	sp!, {ip, lr}
 8003338:	f000 f81e 	bl	8003378 <__gnu_uldivmod_helper>
 800333c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8003340:	b002      	add	sp, #8
 8003342:	bc0c      	pop	{r2, r3}
 8003344:	4770      	bx	lr
 8003346:	bf00      	nop

08003348 <__gnu_ldivmod_helper>:
 8003348:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800334c:	9c06      	ldr	r4, [sp, #24]
 800334e:	4690      	mov	r8, r2
 8003350:	4606      	mov	r6, r0
 8003352:	460f      	mov	r7, r1
 8003354:	461d      	mov	r5, r3
 8003356:	f000 f829 	bl	80033ac <__divdi3>
 800335a:	fb08 fc01 	mul.w	ip, r8, r1
 800335e:	fba8 2300 	umull	r2, r3, r8, r0
 8003362:	fb00 c505 	mla	r5, r0, r5, ip
 8003366:	1ab2      	subs	r2, r6, r2
 8003368:	442b      	add	r3, r5
 800336a:	eb67 0303 	sbc.w	r3, r7, r3
 800336e:	4686      	mov	lr, r0
 8003370:	e9c4 2300 	strd	r2, r3, [r4]
 8003374:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08003378 <__gnu_uldivmod_helper>:
 8003378:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800337c:	9e08      	ldr	r6, [sp, #32]
 800337e:	4617      	mov	r7, r2
 8003380:	4680      	mov	r8, r0
 8003382:	4689      	mov	r9, r1
 8003384:	461d      	mov	r5, r3
 8003386:	f000 f967 	bl	8003658 <__udivdi3>
 800338a:	fb00 f305 	mul.w	r3, r0, r5
 800338e:	fba0 4507 	umull	r4, r5, r0, r7
 8003392:	fb07 3701 	mla	r7, r7, r1, r3
 8003396:	ebb8 0404 	subs.w	r4, r8, r4
 800339a:	443d      	add	r5, r7
 800339c:	eb69 0505 	sbc.w	r5, r9, r5
 80033a0:	e9c6 4500 	strd	r4, r5, [r6]
 80033a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080033a8 <__aeabi_idiv0>:
 80033a8:	4770      	bx	lr
 80033aa:	bf00      	nop

080033ac <__divdi3>:
 80033ac:	2900      	cmp	r1, #0
 80033ae:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80033b2:	f2c0 80a8 	blt.w	8003506 <__divdi3+0x15a>
 80033b6:	2600      	movs	r6, #0
 80033b8:	2b00      	cmp	r3, #0
 80033ba:	f2c0 809e 	blt.w	80034fa <__divdi3+0x14e>
 80033be:	4681      	mov	r9, r0
 80033c0:	468e      	mov	lr, r1
 80033c2:	4690      	mov	r8, r2
 80033c4:	469c      	mov	ip, r3
 80033c6:	4617      	mov	r7, r2
 80033c8:	4604      	mov	r4, r0
 80033ca:	460d      	mov	r5, r1
 80033cc:	2b00      	cmp	r3, #0
 80033ce:	d13d      	bne.n	800344c <__divdi3+0xa0>
 80033d0:	428a      	cmp	r2, r1
 80033d2:	d959      	bls.n	8003488 <__divdi3+0xdc>
 80033d4:	fab2 f382 	clz	r3, r2
 80033d8:	b13b      	cbz	r3, 80033ea <__divdi3+0x3e>
 80033da:	f1c3 0220 	rsb	r2, r3, #32
 80033de:	409d      	lsls	r5, r3
 80033e0:	fa20 f202 	lsr.w	r2, r0, r2
 80033e4:	409f      	lsls	r7, r3
 80033e6:	4315      	orrs	r5, r2
 80033e8:	409c      	lsls	r4, r3
 80033ea:	0c39      	lsrs	r1, r7, #16
 80033ec:	fbb5 f0f1 	udiv	r0, r5, r1
 80033f0:	fa1f fe87 	uxth.w	lr, r7
 80033f4:	fb01 5510 	mls	r5, r1, r0, r5
 80033f8:	fb0e f300 	mul.w	r3, lr, r0
 80033fc:	0c22      	lsrs	r2, r4, #16
 80033fe:	ea42 4505 	orr.w	r5, r2, r5, lsl #16
 8003402:	42ab      	cmp	r3, r5
 8003404:	d909      	bls.n	800341a <__divdi3+0x6e>
 8003406:	19ed      	adds	r5, r5, r7
 8003408:	f100 32ff 	add.w	r2, r0, #4294967295
 800340c:	f080 810b 	bcs.w	8003626 <__divdi3+0x27a>
 8003410:	42ab      	cmp	r3, r5
 8003412:	f240 8108 	bls.w	8003626 <__divdi3+0x27a>
 8003416:	3802      	subs	r0, #2
 8003418:	443d      	add	r5, r7
 800341a:	1aed      	subs	r5, r5, r3
 800341c:	fbb5 f3f1 	udiv	r3, r5, r1
 8003420:	fb01 5513 	mls	r5, r1, r3, r5
 8003424:	fb0e fe03 	mul.w	lr, lr, r3
 8003428:	b2a4      	uxth	r4, r4
 800342a:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 800342e:	45ae      	cmp	lr, r5
 8003430:	d908      	bls.n	8003444 <__divdi3+0x98>
 8003432:	19ed      	adds	r5, r5, r7
 8003434:	f103 32ff 	add.w	r2, r3, #4294967295
 8003438:	f080 80f7 	bcs.w	800362a <__divdi3+0x27e>
 800343c:	45ae      	cmp	lr, r5
 800343e:	f240 80f4 	bls.w	800362a <__divdi3+0x27e>
 8003442:	3b02      	subs	r3, #2
 8003444:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 8003448:	2200      	movs	r2, #0
 800344a:	e003      	b.n	8003454 <__divdi3+0xa8>
 800344c:	428b      	cmp	r3, r1
 800344e:	d90f      	bls.n	8003470 <__divdi3+0xc4>
 8003450:	2200      	movs	r2, #0
 8003452:	4613      	mov	r3, r2
 8003454:	1c34      	adds	r4, r6, #0
 8003456:	bf18      	it	ne
 8003458:	2401      	movne	r4, #1
 800345a:	4260      	negs	r0, r4
 800345c:	f04f 0500 	mov.w	r5, #0
 8003460:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
 8003464:	4058      	eors	r0, r3
 8003466:	4051      	eors	r1, r2
 8003468:	1900      	adds	r0, r0, r4
 800346a:	4169      	adcs	r1, r5
 800346c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8003470:	fab3 f283 	clz	r2, r3
 8003474:	2a00      	cmp	r2, #0
 8003476:	f040 8089 	bne.w	800358c <__divdi3+0x1e0>
 800347a:	428b      	cmp	r3, r1
 800347c:	d302      	bcc.n	8003484 <__divdi3+0xd8>
 800347e:	4580      	cmp	r8, r0
 8003480:	f200 80e2 	bhi.w	8003648 <__divdi3+0x29c>
 8003484:	2301      	movs	r3, #1
 8003486:	e7e5      	b.n	8003454 <__divdi3+0xa8>
 8003488:	b912      	cbnz	r2, 8003490 <__divdi3+0xe4>
 800348a:	2301      	movs	r3, #1
 800348c:	fbb3 f7f2 	udiv	r7, r3, r2
 8003490:	fab7 f887 	clz	r8, r7
 8003494:	f1b8 0f00 	cmp.w	r8, #0
 8003498:	d13b      	bne.n	8003512 <__divdi3+0x166>
 800349a:	1bed      	subs	r5, r5, r7
 800349c:	ea4f 4c17 	mov.w	ip, r7, lsr #16
 80034a0:	fa1f fe87 	uxth.w	lr, r7
 80034a4:	2201      	movs	r2, #1
 80034a6:	fbb5 f0fc 	udiv	r0, r5, ip
 80034aa:	fb0c 5510 	mls	r5, ip, r0, r5
 80034ae:	fb0e f300 	mul.w	r3, lr, r0
 80034b2:	0c21      	lsrs	r1, r4, #16
 80034b4:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
 80034b8:	42ab      	cmp	r3, r5
 80034ba:	d907      	bls.n	80034cc <__divdi3+0x120>
 80034bc:	19ed      	adds	r5, r5, r7
 80034be:	f100 31ff 	add.w	r1, r0, #4294967295
 80034c2:	d202      	bcs.n	80034ca <__divdi3+0x11e>
 80034c4:	42ab      	cmp	r3, r5
 80034c6:	f200 80c3 	bhi.w	8003650 <__divdi3+0x2a4>
 80034ca:	4608      	mov	r0, r1
 80034cc:	1aed      	subs	r5, r5, r3
 80034ce:	fbb5 f3fc 	udiv	r3, r5, ip
 80034d2:	fb0c 5513 	mls	r5, ip, r3, r5
 80034d6:	fb0e fe03 	mul.w	lr, lr, r3
 80034da:	b2a4      	uxth	r4, r4
 80034dc:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 80034e0:	45ae      	cmp	lr, r5
 80034e2:	d907      	bls.n	80034f4 <__divdi3+0x148>
 80034e4:	19ed      	adds	r5, r5, r7
 80034e6:	f103 31ff 	add.w	r1, r3, #4294967295
 80034ea:	d202      	bcs.n	80034f2 <__divdi3+0x146>
 80034ec:	45ae      	cmp	lr, r5
 80034ee:	f200 80ad 	bhi.w	800364c <__divdi3+0x2a0>
 80034f2:	460b      	mov	r3, r1
 80034f4:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 80034f8:	e7ac      	b.n	8003454 <__divdi3+0xa8>
 80034fa:	4252      	negs	r2, r2
 80034fc:	ea6f 0606 	mvn.w	r6, r6
 8003500:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8003504:	e75b      	b.n	80033be <__divdi3+0x12>
 8003506:	4240      	negs	r0, r0
 8003508:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800350c:	f04f 36ff 	mov.w	r6, #4294967295
 8003510:	e752      	b.n	80033b8 <__divdi3+0xc>
 8003512:	fa07 f708 	lsl.w	r7, r7, r8
 8003516:	f1c8 0220 	rsb	r2, r8, #32
 800351a:	fa25 f302 	lsr.w	r3, r5, r2
 800351e:	ea4f 4c17 	mov.w	ip, r7, lsr #16
 8003522:	fbb3 f1fc 	udiv	r1, r3, ip
 8003526:	fa1f fe87 	uxth.w	lr, r7
 800352a:	fb0c 3311 	mls	r3, ip, r1, r3
 800352e:	fa24 f202 	lsr.w	r2, r4, r2
 8003532:	fa05 f508 	lsl.w	r5, r5, r8
 8003536:	fb0e f901 	mul.w	r9, lr, r1
 800353a:	432a      	orrs	r2, r5
 800353c:	0c10      	lsrs	r0, r2, #16
 800353e:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 8003542:	4599      	cmp	r9, r3
 8003544:	fa04 f408 	lsl.w	r4, r4, r8
 8003548:	d907      	bls.n	800355a <__divdi3+0x1ae>
 800354a:	19db      	adds	r3, r3, r7
 800354c:	f101 30ff 	add.w	r0, r1, #4294967295
 8003550:	d278      	bcs.n	8003644 <__divdi3+0x298>
 8003552:	4599      	cmp	r9, r3
 8003554:	d976      	bls.n	8003644 <__divdi3+0x298>
 8003556:	3902      	subs	r1, #2
 8003558:	443b      	add	r3, r7
 800355a:	ebc9 0303 	rsb	r3, r9, r3
 800355e:	fbb3 f0fc 	udiv	r0, r3, ip
 8003562:	fb0c 3310 	mls	r3, ip, r0, r3
 8003566:	fb0e f500 	mul.w	r5, lr, r0
 800356a:	b292      	uxth	r2, r2
 800356c:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 8003570:	429d      	cmp	r5, r3
 8003572:	d907      	bls.n	8003584 <__divdi3+0x1d8>
 8003574:	19db      	adds	r3, r3, r7
 8003576:	f100 32ff 	add.w	r2, r0, #4294967295
 800357a:	d25f      	bcs.n	800363c <__divdi3+0x290>
 800357c:	429d      	cmp	r5, r3
 800357e:	d95d      	bls.n	800363c <__divdi3+0x290>
 8003580:	3802      	subs	r0, #2
 8003582:	443b      	add	r3, r7
 8003584:	1b5d      	subs	r5, r3, r5
 8003586:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
 800358a:	e78c      	b.n	80034a6 <__divdi3+0xfa>
 800358c:	f1c2 0320 	rsb	r3, r2, #32
 8003590:	fa28 f103 	lsr.w	r1, r8, r3
 8003594:	fa0c fc02 	lsl.w	ip, ip, r2
 8003598:	ea41 0c0c 	orr.w	ip, r1, ip
 800359c:	ea4f 401c 	mov.w	r0, ip, lsr #16
 80035a0:	fa2e f103 	lsr.w	r1, lr, r3
 80035a4:	fbb1 f5f0 	udiv	r5, r1, r0
 80035a8:	fa1f f78c 	uxth.w	r7, ip
 80035ac:	fb00 1115 	mls	r1, r0, r5, r1
 80035b0:	fa29 f303 	lsr.w	r3, r9, r3
 80035b4:	fa0e fe02 	lsl.w	lr, lr, r2
 80035b8:	fb07 f905 	mul.w	r9, r7, r5
 80035bc:	ea43 0e0e 	orr.w	lr, r3, lr
 80035c0:	ea4f 431e 	mov.w	r3, lr, lsr #16
 80035c4:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 80035c8:	4589      	cmp	r9, r1
 80035ca:	fa08 f802 	lsl.w	r8, r8, r2
 80035ce:	d908      	bls.n	80035e2 <__divdi3+0x236>
 80035d0:	eb11 010c 	adds.w	r1, r1, ip
 80035d4:	f105 33ff 	add.w	r3, r5, #4294967295
 80035d8:	d232      	bcs.n	8003640 <__divdi3+0x294>
 80035da:	4589      	cmp	r9, r1
 80035dc:	d930      	bls.n	8003640 <__divdi3+0x294>
 80035de:	3d02      	subs	r5, #2
 80035e0:	4461      	add	r1, ip
 80035e2:	ebc9 0101 	rsb	r1, r9, r1
 80035e6:	fbb1 f3f0 	udiv	r3, r1, r0
 80035ea:	fb00 1113 	mls	r1, r0, r3, r1
 80035ee:	fb07 f703 	mul.w	r7, r7, r3
 80035f2:	fa1f fe8e 	uxth.w	lr, lr
 80035f6:	ea4e 4e01 	orr.w	lr, lr, r1, lsl #16
 80035fa:	4577      	cmp	r7, lr
 80035fc:	d908      	bls.n	8003610 <__divdi3+0x264>
 80035fe:	eb1e 0e0c 	adds.w	lr, lr, ip
 8003602:	f103 31ff 	add.w	r1, r3, #4294967295
 8003606:	d217      	bcs.n	8003638 <__divdi3+0x28c>
 8003608:	4577      	cmp	r7, lr
 800360a:	d915      	bls.n	8003638 <__divdi3+0x28c>
 800360c:	3b02      	subs	r3, #2
 800360e:	44e6      	add	lr, ip
 8003610:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
 8003614:	fba3 8908 	umull	r8, r9, r3, r8
 8003618:	ebc7 0e0e 	rsb	lr, r7, lr
 800361c:	45ce      	cmp	lr, r9
 800361e:	d309      	bcc.n	8003634 <__divdi3+0x288>
 8003620:	d005      	beq.n	800362e <__divdi3+0x282>
 8003622:	2200      	movs	r2, #0
 8003624:	e716      	b.n	8003454 <__divdi3+0xa8>
 8003626:	4610      	mov	r0, r2
 8003628:	e6f7      	b.n	800341a <__divdi3+0x6e>
 800362a:	4613      	mov	r3, r2
 800362c:	e70a      	b.n	8003444 <__divdi3+0x98>
 800362e:	4094      	lsls	r4, r2
 8003630:	4544      	cmp	r4, r8
 8003632:	d2f6      	bcs.n	8003622 <__divdi3+0x276>
 8003634:	3b01      	subs	r3, #1
 8003636:	e7f4      	b.n	8003622 <__divdi3+0x276>
 8003638:	460b      	mov	r3, r1
 800363a:	e7e9      	b.n	8003610 <__divdi3+0x264>
 800363c:	4610      	mov	r0, r2
 800363e:	e7a1      	b.n	8003584 <__divdi3+0x1d8>
 8003640:	461d      	mov	r5, r3
 8003642:	e7ce      	b.n	80035e2 <__divdi3+0x236>
 8003644:	4601      	mov	r1, r0
 8003646:	e788      	b.n	800355a <__divdi3+0x1ae>
 8003648:	4613      	mov	r3, r2
 800364a:	e703      	b.n	8003454 <__divdi3+0xa8>
 800364c:	3b02      	subs	r3, #2
 800364e:	e751      	b.n	80034f4 <__divdi3+0x148>
 8003650:	3802      	subs	r0, #2
 8003652:	443d      	add	r5, r7
 8003654:	e73a      	b.n	80034cc <__divdi3+0x120>
 8003656:	bf00      	nop

08003658 <__udivdi3>:
 8003658:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800365c:	2b00      	cmp	r3, #0
 800365e:	d144      	bne.n	80036ea <__udivdi3+0x92>
 8003660:	428a      	cmp	r2, r1
 8003662:	4615      	mov	r5, r2
 8003664:	4604      	mov	r4, r0
 8003666:	d94f      	bls.n	8003708 <__udivdi3+0xb0>
 8003668:	fab2 f782 	clz	r7, r2
 800366c:	460e      	mov	r6, r1
 800366e:	b14f      	cbz	r7, 8003684 <__udivdi3+0x2c>
 8003670:	f1c7 0320 	rsb	r3, r7, #32
 8003674:	40b9      	lsls	r1, r7
 8003676:	fa20 f603 	lsr.w	r6, r0, r3
 800367a:	fa02 f507 	lsl.w	r5, r2, r7
 800367e:	430e      	orrs	r6, r1
 8003680:	fa00 f407 	lsl.w	r4, r0, r7
 8003684:	0c2f      	lsrs	r7, r5, #16
 8003686:	fbb6 f0f7 	udiv	r0, r6, r7
 800368a:	fa1f fe85 	uxth.w	lr, r5
 800368e:	fb07 6210 	mls	r2, r7, r0, r6
 8003692:	fb0e f100 	mul.w	r1, lr, r0
 8003696:	0c26      	lsrs	r6, r4, #16
 8003698:	ea46 4302 	orr.w	r3, r6, r2, lsl #16
 800369c:	4299      	cmp	r1, r3
 800369e:	d909      	bls.n	80036b4 <__udivdi3+0x5c>
 80036a0:	195b      	adds	r3, r3, r5
 80036a2:	f100 32ff 	add.w	r2, r0, #4294967295
 80036a6:	f080 80ee 	bcs.w	8003886 <__udivdi3+0x22e>
 80036aa:	4299      	cmp	r1, r3
 80036ac:	f240 80eb 	bls.w	8003886 <__udivdi3+0x22e>
 80036b0:	3802      	subs	r0, #2
 80036b2:	442b      	add	r3, r5
 80036b4:	1a59      	subs	r1, r3, r1
 80036b6:	fbb1 f3f7 	udiv	r3, r1, r7
 80036ba:	fb07 1113 	mls	r1, r7, r3, r1
 80036be:	fb0e fe03 	mul.w	lr, lr, r3
 80036c2:	b2a4      	uxth	r4, r4
 80036c4:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
 80036c8:	458e      	cmp	lr, r1
 80036ca:	d908      	bls.n	80036de <__udivdi3+0x86>
 80036cc:	1949      	adds	r1, r1, r5
 80036ce:	f103 32ff 	add.w	r2, r3, #4294967295
 80036d2:	f080 80da 	bcs.w	800388a <__udivdi3+0x232>
 80036d6:	458e      	cmp	lr, r1
 80036d8:	f240 80d7 	bls.w	800388a <__udivdi3+0x232>
 80036dc:	3b02      	subs	r3, #2
 80036de:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80036e2:	2600      	movs	r6, #0
 80036e4:	4631      	mov	r1, r6
 80036e6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80036ea:	428b      	cmp	r3, r1
 80036ec:	d847      	bhi.n	800377e <__udivdi3+0x126>
 80036ee:	fab3 f683 	clz	r6, r3
 80036f2:	2e00      	cmp	r6, #0
 80036f4:	d148      	bne.n	8003788 <__udivdi3+0x130>
 80036f6:	428b      	cmp	r3, r1
 80036f8:	d302      	bcc.n	8003700 <__udivdi3+0xa8>
 80036fa:	4282      	cmp	r2, r0
 80036fc:	f200 80cf 	bhi.w	800389e <__udivdi3+0x246>
 8003700:	2001      	movs	r0, #1
 8003702:	4631      	mov	r1, r6
 8003704:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8003708:	b912      	cbnz	r2, 8003710 <__udivdi3+0xb8>
 800370a:	2501      	movs	r5, #1
 800370c:	fbb5 f5f2 	udiv	r5, r5, r2
 8003710:	fab5 fc85 	clz	ip, r5
 8003714:	f1bc 0f00 	cmp.w	ip, #0
 8003718:	d178      	bne.n	800380c <__udivdi3+0x1b4>
 800371a:	1b49      	subs	r1, r1, r5
 800371c:	0c2f      	lsrs	r7, r5, #16
 800371e:	fa1f fe85 	uxth.w	lr, r5
 8003722:	2601      	movs	r6, #1
 8003724:	fbb1 f0f7 	udiv	r0, r1, r7
 8003728:	fb07 1110 	mls	r1, r7, r0, r1
 800372c:	fb0e f200 	mul.w	r2, lr, r0
 8003730:	0c23      	lsrs	r3, r4, #16
 8003732:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8003736:	428a      	cmp	r2, r1
 8003738:	d907      	bls.n	800374a <__udivdi3+0xf2>
 800373a:	1949      	adds	r1, r1, r5
 800373c:	f100 33ff 	add.w	r3, r0, #4294967295
 8003740:	d202      	bcs.n	8003748 <__udivdi3+0xf0>
 8003742:	428a      	cmp	r2, r1
 8003744:	f200 80bc 	bhi.w	80038c0 <__udivdi3+0x268>
 8003748:	4618      	mov	r0, r3
 800374a:	1a89      	subs	r1, r1, r2
 800374c:	fbb1 f3f7 	udiv	r3, r1, r7
 8003750:	fb07 1113 	mls	r1, r7, r3, r1
 8003754:	fb0e fe03 	mul.w	lr, lr, r3
 8003758:	b2a4      	uxth	r4, r4
 800375a:	ea44 4201 	orr.w	r2, r4, r1, lsl #16
 800375e:	4596      	cmp	lr, r2
 8003760:	d908      	bls.n	8003774 <__udivdi3+0x11c>
 8003762:	1952      	adds	r2, r2, r5
 8003764:	f103 31ff 	add.w	r1, r3, #4294967295
 8003768:	f080 8091 	bcs.w	800388e <__udivdi3+0x236>
 800376c:	4596      	cmp	lr, r2
 800376e:	f240 808e 	bls.w	800388e <__udivdi3+0x236>
 8003772:	3b02      	subs	r3, #2
 8003774:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8003778:	4631      	mov	r1, r6
 800377a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800377e:	2600      	movs	r6, #0
 8003780:	4630      	mov	r0, r6
 8003782:	4631      	mov	r1, r6
 8003784:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8003788:	f1c6 0420 	rsb	r4, r6, #32
 800378c:	fa22 f504 	lsr.w	r5, r2, r4
 8003790:	40b3      	lsls	r3, r6
 8003792:	432b      	orrs	r3, r5
 8003794:	fa21 f704 	lsr.w	r7, r1, r4
 8003798:	ea4f 4813 	mov.w	r8, r3, lsr #16
 800379c:	fbb7 fcf8 	udiv	ip, r7, r8
 80037a0:	fa1f f983 	uxth.w	r9, r3
 80037a4:	fb08 771c 	mls	r7, r8, ip, r7
 80037a8:	fa20 fe04 	lsr.w	lr, r0, r4
 80037ac:	fa01 f506 	lsl.w	r5, r1, r6
 80037b0:	fb09 f40c 	mul.w	r4, r9, ip
 80037b4:	ea4e 0505 	orr.w	r5, lr, r5
 80037b8:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80037bc:	ea4e 4707 	orr.w	r7, lr, r7, lsl #16
 80037c0:	42bc      	cmp	r4, r7
 80037c2:	fa02 f206 	lsl.w	r2, r2, r6
 80037c6:	d904      	bls.n	80037d2 <__udivdi3+0x17a>
 80037c8:	18ff      	adds	r7, r7, r3
 80037ca:	f10c 31ff 	add.w	r1, ip, #4294967295
 80037ce:	d368      	bcc.n	80038a2 <__udivdi3+0x24a>
 80037d0:	468c      	mov	ip, r1
 80037d2:	1b3f      	subs	r7, r7, r4
 80037d4:	fbb7 f4f8 	udiv	r4, r7, r8
 80037d8:	fb08 7714 	mls	r7, r8, r4, r7
 80037dc:	fb09 f904 	mul.w	r9, r9, r4
 80037e0:	b2ad      	uxth	r5, r5
 80037e2:	ea45 4107 	orr.w	r1, r5, r7, lsl #16
 80037e6:	4589      	cmp	r9, r1
 80037e8:	d904      	bls.n	80037f4 <__udivdi3+0x19c>
 80037ea:	18c9      	adds	r1, r1, r3
 80037ec:	f104 35ff 	add.w	r5, r4, #4294967295
 80037f0:	d35d      	bcc.n	80038ae <__udivdi3+0x256>
 80037f2:	462c      	mov	r4, r5
 80037f4:	ea44 440c 	orr.w	r4, r4, ip, lsl #16
 80037f8:	fba4 2302 	umull	r2, r3, r4, r2
 80037fc:	ebc9 0101 	rsb	r1, r9, r1
 8003800:	4299      	cmp	r1, r3
 8003802:	d349      	bcc.n	8003898 <__udivdi3+0x240>
 8003804:	d045      	beq.n	8003892 <__udivdi3+0x23a>
 8003806:	4620      	mov	r0, r4
 8003808:	2600      	movs	r6, #0
 800380a:	e76b      	b.n	80036e4 <__udivdi3+0x8c>
 800380c:	f1cc 0420 	rsb	r4, ip, #32
 8003810:	fa05 f50c 	lsl.w	r5, r5, ip
 8003814:	fa21 f304 	lsr.w	r3, r1, r4
 8003818:	0c2a      	lsrs	r2, r5, #16
 800381a:	fbb3 f6f2 	udiv	r6, r3, r2
 800381e:	fa1f fe85 	uxth.w	lr, r5
 8003822:	fb02 3816 	mls	r8, r2, r6, r3
 8003826:	fa20 f704 	lsr.w	r7, r0, r4
 800382a:	fa01 f10c 	lsl.w	r1, r1, ip
 800382e:	fb0e f906 	mul.w	r9, lr, r6
 8003832:	430f      	orrs	r7, r1
 8003834:	0c3c      	lsrs	r4, r7, #16
 8003836:	ea44 4308 	orr.w	r3, r4, r8, lsl #16
 800383a:	4599      	cmp	r9, r3
 800383c:	fa00 f40c 	lsl.w	r4, r0, ip
 8003840:	d907      	bls.n	8003852 <__udivdi3+0x1fa>
 8003842:	195b      	adds	r3, r3, r5
 8003844:	f106 31ff 	add.w	r1, r6, #4294967295
 8003848:	d238      	bcs.n	80038bc <__udivdi3+0x264>
 800384a:	4599      	cmp	r9, r3
 800384c:	d936      	bls.n	80038bc <__udivdi3+0x264>
 800384e:	3e02      	subs	r6, #2
 8003850:	442b      	add	r3, r5
 8003852:	ebc9 0303 	rsb	r3, r9, r3
 8003856:	fbb3 f0f2 	udiv	r0, r3, r2
 800385a:	fb02 3310 	mls	r3, r2, r0, r3
 800385e:	fb0e f100 	mul.w	r1, lr, r0
 8003862:	b2bf      	uxth	r7, r7
 8003864:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
 8003868:	4299      	cmp	r1, r3
 800386a:	d907      	bls.n	800387c <__udivdi3+0x224>
 800386c:	195b      	adds	r3, r3, r5
 800386e:	f100 37ff 	add.w	r7, r0, #4294967295
 8003872:	d221      	bcs.n	80038b8 <__udivdi3+0x260>
 8003874:	4299      	cmp	r1, r3
 8003876:	d91f      	bls.n	80038b8 <__udivdi3+0x260>
 8003878:	3802      	subs	r0, #2
 800387a:	442b      	add	r3, r5
 800387c:	4617      	mov	r7, r2
 800387e:	1a59      	subs	r1, r3, r1
 8003880:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 8003884:	e74e      	b.n	8003724 <__udivdi3+0xcc>
 8003886:	4610      	mov	r0, r2
 8003888:	e714      	b.n	80036b4 <__udivdi3+0x5c>
 800388a:	4613      	mov	r3, r2
 800388c:	e727      	b.n	80036de <__udivdi3+0x86>
 800388e:	460b      	mov	r3, r1
 8003890:	e770      	b.n	8003774 <__udivdi3+0x11c>
 8003892:	40b0      	lsls	r0, r6
 8003894:	4290      	cmp	r0, r2
 8003896:	d2b6      	bcs.n	8003806 <__udivdi3+0x1ae>
 8003898:	1e60      	subs	r0, r4, #1
 800389a:	2600      	movs	r6, #0
 800389c:	e722      	b.n	80036e4 <__udivdi3+0x8c>
 800389e:	4630      	mov	r0, r6
 80038a0:	e720      	b.n	80036e4 <__udivdi3+0x8c>
 80038a2:	42bc      	cmp	r4, r7
 80038a4:	d994      	bls.n	80037d0 <__udivdi3+0x178>
 80038a6:	f1ac 0c02 	sub.w	ip, ip, #2
 80038aa:	441f      	add	r7, r3
 80038ac:	e791      	b.n	80037d2 <__udivdi3+0x17a>
 80038ae:	4589      	cmp	r9, r1
 80038b0:	d99f      	bls.n	80037f2 <__udivdi3+0x19a>
 80038b2:	3c02      	subs	r4, #2
 80038b4:	4419      	add	r1, r3
 80038b6:	e79d      	b.n	80037f4 <__udivdi3+0x19c>
 80038b8:	4638      	mov	r0, r7
 80038ba:	e7df      	b.n	800387c <__udivdi3+0x224>
 80038bc:	460e      	mov	r6, r1
 80038be:	e7c8      	b.n	8003852 <__udivdi3+0x1fa>
 80038c0:	3802      	subs	r0, #2
 80038c2:	4429      	add	r1, r5
 80038c4:	e741      	b.n	800374a <__udivdi3+0xf2>
 80038c6:	bf00      	nop

080038c8 <__aeabi_frsub>:
 80038c8:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 80038cc:	e002      	b.n	80038d4 <__addsf3>
 80038ce:	bf00      	nop

080038d0 <__aeabi_fsub>:
 80038d0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

080038d4 <__addsf3>:
 80038d4:	0042      	lsls	r2, r0, #1
 80038d6:	bf1f      	itttt	ne
 80038d8:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 80038dc:	ea92 0f03 	teqne	r2, r3
 80038e0:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 80038e4:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80038e8:	d06a      	beq.n	80039c0 <__addsf3+0xec>
 80038ea:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80038ee:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 80038f2:	bfc1      	itttt	gt
 80038f4:	18d2      	addgt	r2, r2, r3
 80038f6:	4041      	eorgt	r1, r0
 80038f8:	4048      	eorgt	r0, r1
 80038fa:	4041      	eorgt	r1, r0
 80038fc:	bfb8      	it	lt
 80038fe:	425b      	neglt	r3, r3
 8003900:	2b19      	cmp	r3, #25
 8003902:	bf88      	it	hi
 8003904:	4770      	bxhi	lr
 8003906:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 800390a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 800390e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8003912:	bf18      	it	ne
 8003914:	4240      	negne	r0, r0
 8003916:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800391a:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 800391e:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8003922:	bf18      	it	ne
 8003924:	4249      	negne	r1, r1
 8003926:	ea92 0f03 	teq	r2, r3
 800392a:	d03f      	beq.n	80039ac <__addsf3+0xd8>
 800392c:	f1a2 0201 	sub.w	r2, r2, #1
 8003930:	fa41 fc03 	asr.w	ip, r1, r3
 8003934:	eb10 000c 	adds.w	r0, r0, ip
 8003938:	f1c3 0320 	rsb	r3, r3, #32
 800393c:	fa01 f103 	lsl.w	r1, r1, r3
 8003940:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8003944:	d502      	bpl.n	800394c <__addsf3+0x78>
 8003946:	4249      	negs	r1, r1
 8003948:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 800394c:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8003950:	d313      	bcc.n	800397a <__addsf3+0xa6>
 8003952:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8003956:	d306      	bcc.n	8003966 <__addsf3+0x92>
 8003958:	0840      	lsrs	r0, r0, #1
 800395a:	ea4f 0131 	mov.w	r1, r1, rrx
 800395e:	f102 0201 	add.w	r2, r2, #1
 8003962:	2afe      	cmp	r2, #254	; 0xfe
 8003964:	d251      	bcs.n	8003a0a <__addsf3+0x136>
 8003966:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 800396a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 800396e:	bf08      	it	eq
 8003970:	f020 0001 	biceq.w	r0, r0, #1
 8003974:	ea40 0003 	orr.w	r0, r0, r3
 8003978:	4770      	bx	lr
 800397a:	0049      	lsls	r1, r1, #1
 800397c:	eb40 0000 	adc.w	r0, r0, r0
 8003980:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 8003984:	f1a2 0201 	sub.w	r2, r2, #1
 8003988:	d1ed      	bne.n	8003966 <__addsf3+0x92>
 800398a:	fab0 fc80 	clz	ip, r0
 800398e:	f1ac 0c08 	sub.w	ip, ip, #8
 8003992:	ebb2 020c 	subs.w	r2, r2, ip
 8003996:	fa00 f00c 	lsl.w	r0, r0, ip
 800399a:	bfaa      	itet	ge
 800399c:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 80039a0:	4252      	neglt	r2, r2
 80039a2:	4318      	orrge	r0, r3
 80039a4:	bfbc      	itt	lt
 80039a6:	40d0      	lsrlt	r0, r2
 80039a8:	4318      	orrlt	r0, r3
 80039aa:	4770      	bx	lr
 80039ac:	f092 0f00 	teq	r2, #0
 80039b0:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 80039b4:	bf06      	itte	eq
 80039b6:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 80039ba:	3201      	addeq	r2, #1
 80039bc:	3b01      	subne	r3, #1
 80039be:	e7b5      	b.n	800392c <__addsf3+0x58>
 80039c0:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80039c4:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80039c8:	bf18      	it	ne
 80039ca:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80039ce:	d021      	beq.n	8003a14 <__addsf3+0x140>
 80039d0:	ea92 0f03 	teq	r2, r3
 80039d4:	d004      	beq.n	80039e0 <__addsf3+0x10c>
 80039d6:	f092 0f00 	teq	r2, #0
 80039da:	bf08      	it	eq
 80039dc:	4608      	moveq	r0, r1
 80039de:	4770      	bx	lr
 80039e0:	ea90 0f01 	teq	r0, r1
 80039e4:	bf1c      	itt	ne
 80039e6:	2000      	movne	r0, #0
 80039e8:	4770      	bxne	lr
 80039ea:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 80039ee:	d104      	bne.n	80039fa <__addsf3+0x126>
 80039f0:	0040      	lsls	r0, r0, #1
 80039f2:	bf28      	it	cs
 80039f4:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 80039f8:	4770      	bx	lr
 80039fa:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 80039fe:	bf3c      	itt	cc
 8003a00:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 8003a04:	4770      	bxcc	lr
 8003a06:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8003a0a:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 8003a0e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8003a12:	4770      	bx	lr
 8003a14:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8003a18:	bf16      	itet	ne
 8003a1a:	4608      	movne	r0, r1
 8003a1c:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8003a20:	4601      	movne	r1, r0
 8003a22:	0242      	lsls	r2, r0, #9
 8003a24:	bf06      	itte	eq
 8003a26:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8003a2a:	ea90 0f01 	teqeq	r0, r1
 8003a2e:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 8003a32:	4770      	bx	lr

08003a34 <__aeabi_ui2f>:
 8003a34:	f04f 0300 	mov.w	r3, #0
 8003a38:	e004      	b.n	8003a44 <__aeabi_i2f+0x8>
 8003a3a:	bf00      	nop

08003a3c <__aeabi_i2f>:
 8003a3c:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8003a40:	bf48      	it	mi
 8003a42:	4240      	negmi	r0, r0
 8003a44:	ea5f 0c00 	movs.w	ip, r0
 8003a48:	bf08      	it	eq
 8003a4a:	4770      	bxeq	lr
 8003a4c:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8003a50:	4601      	mov	r1, r0
 8003a52:	f04f 0000 	mov.w	r0, #0
 8003a56:	e01c      	b.n	8003a92 <__aeabi_l2f+0x2a>

08003a58 <__aeabi_ul2f>:
 8003a58:	ea50 0201 	orrs.w	r2, r0, r1
 8003a5c:	bf08      	it	eq
 8003a5e:	4770      	bxeq	lr
 8003a60:	f04f 0300 	mov.w	r3, #0
 8003a64:	e00a      	b.n	8003a7c <__aeabi_l2f+0x14>
 8003a66:	bf00      	nop

08003a68 <__aeabi_l2f>:
 8003a68:	ea50 0201 	orrs.w	r2, r0, r1
 8003a6c:	bf08      	it	eq
 8003a6e:	4770      	bxeq	lr
 8003a70:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8003a74:	d502      	bpl.n	8003a7c <__aeabi_l2f+0x14>
 8003a76:	4240      	negs	r0, r0
 8003a78:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8003a7c:	ea5f 0c01 	movs.w	ip, r1
 8003a80:	bf02      	ittt	eq
 8003a82:	4684      	moveq	ip, r0
 8003a84:	4601      	moveq	r1, r0
 8003a86:	2000      	moveq	r0, #0
 8003a88:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 8003a8c:	bf08      	it	eq
 8003a8e:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8003a92:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8003a96:	fabc f28c 	clz	r2, ip
 8003a9a:	3a08      	subs	r2, #8
 8003a9c:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8003aa0:	db10      	blt.n	8003ac4 <__aeabi_l2f+0x5c>
 8003aa2:	fa01 fc02 	lsl.w	ip, r1, r2
 8003aa6:	4463      	add	r3, ip
 8003aa8:	fa00 fc02 	lsl.w	ip, r0, r2
 8003aac:	f1c2 0220 	rsb	r2, r2, #32
 8003ab0:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8003ab4:	fa20 f202 	lsr.w	r2, r0, r2
 8003ab8:	eb43 0002 	adc.w	r0, r3, r2
 8003abc:	bf08      	it	eq
 8003abe:	f020 0001 	biceq.w	r0, r0, #1
 8003ac2:	4770      	bx	lr
 8003ac4:	f102 0220 	add.w	r2, r2, #32
 8003ac8:	fa01 fc02 	lsl.w	ip, r1, r2
 8003acc:	f1c2 0220 	rsb	r2, r2, #32
 8003ad0:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8003ad4:	fa21 f202 	lsr.w	r2, r1, r2
 8003ad8:	eb43 0002 	adc.w	r0, r3, r2
 8003adc:	bf08      	it	eq
 8003ade:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8003ae2:	4770      	bx	lr

08003ae4 <__aeabi_fmul>:
 8003ae4:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8003ae8:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8003aec:	bf1e      	ittt	ne
 8003aee:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8003af2:	ea92 0f0c 	teqne	r2, ip
 8003af6:	ea93 0f0c 	teqne	r3, ip
 8003afa:	d06f      	beq.n	8003bdc <__aeabi_fmul+0xf8>
 8003afc:	441a      	add	r2, r3
 8003afe:	ea80 0c01 	eor.w	ip, r0, r1
 8003b02:	0240      	lsls	r0, r0, #9
 8003b04:	bf18      	it	ne
 8003b06:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 8003b0a:	d01e      	beq.n	8003b4a <__aeabi_fmul+0x66>
 8003b0c:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8003b10:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 8003b14:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 8003b18:	fba0 3101 	umull	r3, r1, r0, r1
 8003b1c:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8003b20:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8003b24:	bf3e      	ittt	cc
 8003b26:	0049      	lslcc	r1, r1, #1
 8003b28:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 8003b2c:	005b      	lslcc	r3, r3, #1
 8003b2e:	ea40 0001 	orr.w	r0, r0, r1
 8003b32:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 8003b36:	2afd      	cmp	r2, #253	; 0xfd
 8003b38:	d81d      	bhi.n	8003b76 <__aeabi_fmul+0x92>
 8003b3a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8003b3e:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8003b42:	bf08      	it	eq
 8003b44:	f020 0001 	biceq.w	r0, r0, #1
 8003b48:	4770      	bx	lr
 8003b4a:	f090 0f00 	teq	r0, #0
 8003b4e:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8003b52:	bf08      	it	eq
 8003b54:	0249      	lsleq	r1, r1, #9
 8003b56:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8003b5a:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 8003b5e:	3a7f      	subs	r2, #127	; 0x7f
 8003b60:	bfc2      	ittt	gt
 8003b62:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8003b66:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8003b6a:	4770      	bxgt	lr
 8003b6c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8003b70:	f04f 0300 	mov.w	r3, #0
 8003b74:	3a01      	subs	r2, #1
 8003b76:	dc5d      	bgt.n	8003c34 <__aeabi_fmul+0x150>
 8003b78:	f112 0f19 	cmn.w	r2, #25
 8003b7c:	bfdc      	itt	le
 8003b7e:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 8003b82:	4770      	bxle	lr
 8003b84:	f1c2 0200 	rsb	r2, r2, #0
 8003b88:	0041      	lsls	r1, r0, #1
 8003b8a:	fa21 f102 	lsr.w	r1, r1, r2
 8003b8e:	f1c2 0220 	rsb	r2, r2, #32
 8003b92:	fa00 fc02 	lsl.w	ip, r0, r2
 8003b96:	ea5f 0031 	movs.w	r0, r1, rrx
 8003b9a:	f140 0000 	adc.w	r0, r0, #0
 8003b9e:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 8003ba2:	bf08      	it	eq
 8003ba4:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8003ba8:	4770      	bx	lr
 8003baa:	f092 0f00 	teq	r2, #0
 8003bae:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8003bb2:	bf02      	ittt	eq
 8003bb4:	0040      	lsleq	r0, r0, #1
 8003bb6:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8003bba:	3a01      	subeq	r2, #1
 8003bbc:	d0f9      	beq.n	8003bb2 <__aeabi_fmul+0xce>
 8003bbe:	ea40 000c 	orr.w	r0, r0, ip
 8003bc2:	f093 0f00 	teq	r3, #0
 8003bc6:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8003bca:	bf02      	ittt	eq
 8003bcc:	0049      	lsleq	r1, r1, #1
 8003bce:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8003bd2:	3b01      	subeq	r3, #1
 8003bd4:	d0f9      	beq.n	8003bca <__aeabi_fmul+0xe6>
 8003bd6:	ea41 010c 	orr.w	r1, r1, ip
 8003bda:	e78f      	b.n	8003afc <__aeabi_fmul+0x18>
 8003bdc:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8003be0:	ea92 0f0c 	teq	r2, ip
 8003be4:	bf18      	it	ne
 8003be6:	ea93 0f0c 	teqne	r3, ip
 8003bea:	d00a      	beq.n	8003c02 <__aeabi_fmul+0x11e>
 8003bec:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8003bf0:	bf18      	it	ne
 8003bf2:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8003bf6:	d1d8      	bne.n	8003baa <__aeabi_fmul+0xc6>
 8003bf8:	ea80 0001 	eor.w	r0, r0, r1
 8003bfc:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8003c00:	4770      	bx	lr
 8003c02:	f090 0f00 	teq	r0, #0
 8003c06:	bf17      	itett	ne
 8003c08:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 8003c0c:	4608      	moveq	r0, r1
 8003c0e:	f091 0f00 	teqne	r1, #0
 8003c12:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 8003c16:	d014      	beq.n	8003c42 <__aeabi_fmul+0x15e>
 8003c18:	ea92 0f0c 	teq	r2, ip
 8003c1c:	d101      	bne.n	8003c22 <__aeabi_fmul+0x13e>
 8003c1e:	0242      	lsls	r2, r0, #9
 8003c20:	d10f      	bne.n	8003c42 <__aeabi_fmul+0x15e>
 8003c22:	ea93 0f0c 	teq	r3, ip
 8003c26:	d103      	bne.n	8003c30 <__aeabi_fmul+0x14c>
 8003c28:	024b      	lsls	r3, r1, #9
 8003c2a:	bf18      	it	ne
 8003c2c:	4608      	movne	r0, r1
 8003c2e:	d108      	bne.n	8003c42 <__aeabi_fmul+0x15e>
 8003c30:	ea80 0001 	eor.w	r0, r0, r1
 8003c34:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8003c38:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8003c3c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8003c40:	4770      	bx	lr
 8003c42:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8003c46:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 8003c4a:	4770      	bx	lr

08003c4c <__aeabi_fdiv>:
 8003c4c:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8003c50:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8003c54:	bf1e      	ittt	ne
 8003c56:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8003c5a:	ea92 0f0c 	teqne	r2, ip
 8003c5e:	ea93 0f0c 	teqne	r3, ip
 8003c62:	d069      	beq.n	8003d38 <__aeabi_fdiv+0xec>
 8003c64:	eba2 0203 	sub.w	r2, r2, r3
 8003c68:	ea80 0c01 	eor.w	ip, r0, r1
 8003c6c:	0249      	lsls	r1, r1, #9
 8003c6e:	ea4f 2040 	mov.w	r0, r0, lsl #9
 8003c72:	d037      	beq.n	8003ce4 <__aeabi_fdiv+0x98>
 8003c74:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8003c78:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 8003c7c:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8003c80:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8003c84:	428b      	cmp	r3, r1
 8003c86:	bf38      	it	cc
 8003c88:	005b      	lslcc	r3, r3, #1
 8003c8a:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 8003c8e:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 8003c92:	428b      	cmp	r3, r1
 8003c94:	bf24      	itt	cs
 8003c96:	1a5b      	subcs	r3, r3, r1
 8003c98:	ea40 000c 	orrcs.w	r0, r0, ip
 8003c9c:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 8003ca0:	bf24      	itt	cs
 8003ca2:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 8003ca6:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8003caa:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 8003cae:	bf24      	itt	cs
 8003cb0:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 8003cb4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8003cb8:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 8003cbc:	bf24      	itt	cs
 8003cbe:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 8003cc2:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8003cc6:	011b      	lsls	r3, r3, #4
 8003cc8:	bf18      	it	ne
 8003cca:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 8003cce:	d1e0      	bne.n	8003c92 <__aeabi_fdiv+0x46>
 8003cd0:	2afd      	cmp	r2, #253	; 0xfd
 8003cd2:	f63f af50 	bhi.w	8003b76 <__aeabi_fmul+0x92>
 8003cd6:	428b      	cmp	r3, r1
 8003cd8:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8003cdc:	bf08      	it	eq
 8003cde:	f020 0001 	biceq.w	r0, r0, #1
 8003ce2:	4770      	bx	lr
 8003ce4:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8003ce8:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8003cec:	327f      	adds	r2, #127	; 0x7f
 8003cee:	bfc2      	ittt	gt
 8003cf0:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8003cf4:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8003cf8:	4770      	bxgt	lr
 8003cfa:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8003cfe:	f04f 0300 	mov.w	r3, #0
 8003d02:	3a01      	subs	r2, #1
 8003d04:	e737      	b.n	8003b76 <__aeabi_fmul+0x92>
 8003d06:	f092 0f00 	teq	r2, #0
 8003d0a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8003d0e:	bf02      	ittt	eq
 8003d10:	0040      	lsleq	r0, r0, #1
 8003d12:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8003d16:	3a01      	subeq	r2, #1
 8003d18:	d0f9      	beq.n	8003d0e <__aeabi_fdiv+0xc2>
 8003d1a:	ea40 000c 	orr.w	r0, r0, ip
 8003d1e:	f093 0f00 	teq	r3, #0
 8003d22:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8003d26:	bf02      	ittt	eq
 8003d28:	0049      	lsleq	r1, r1, #1
 8003d2a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8003d2e:	3b01      	subeq	r3, #1
 8003d30:	d0f9      	beq.n	8003d26 <__aeabi_fdiv+0xda>
 8003d32:	ea41 010c 	orr.w	r1, r1, ip
 8003d36:	e795      	b.n	8003c64 <__aeabi_fdiv+0x18>
 8003d38:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8003d3c:	ea92 0f0c 	teq	r2, ip
 8003d40:	d108      	bne.n	8003d54 <__aeabi_fdiv+0x108>
 8003d42:	0242      	lsls	r2, r0, #9
 8003d44:	f47f af7d 	bne.w	8003c42 <__aeabi_fmul+0x15e>
 8003d48:	ea93 0f0c 	teq	r3, ip
 8003d4c:	f47f af70 	bne.w	8003c30 <__aeabi_fmul+0x14c>
 8003d50:	4608      	mov	r0, r1
 8003d52:	e776      	b.n	8003c42 <__aeabi_fmul+0x15e>
 8003d54:	ea93 0f0c 	teq	r3, ip
 8003d58:	d104      	bne.n	8003d64 <__aeabi_fdiv+0x118>
 8003d5a:	024b      	lsls	r3, r1, #9
 8003d5c:	f43f af4c 	beq.w	8003bf8 <__aeabi_fmul+0x114>
 8003d60:	4608      	mov	r0, r1
 8003d62:	e76e      	b.n	8003c42 <__aeabi_fmul+0x15e>
 8003d64:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8003d68:	bf18      	it	ne
 8003d6a:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8003d6e:	d1ca      	bne.n	8003d06 <__aeabi_fdiv+0xba>
 8003d70:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8003d74:	f47f af5c 	bne.w	8003c30 <__aeabi_fmul+0x14c>
 8003d78:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 8003d7c:	f47f af3c 	bne.w	8003bf8 <__aeabi_fmul+0x114>
 8003d80:	e75f      	b.n	8003c42 <__aeabi_fmul+0x15e>
 8003d82:	bf00      	nop

08003d84 <allocation_start_request_timer.lto_priv.72>:
        uavcan_set_node_id(instance->uavcan_idx, msg->node_id);
        allocation_stop_and_cleanup(instance);
    }
}

static void allocation_start_request_timer(struct allocatee_instance_s* instance) {
 8003d84:	b590      	push	{r4, r7, lr}
 8003d86:	b087      	sub	sp, #28
 8003d88:	af02      	add	r7, sp, #8
 8003d8a:	6078      	str	r0, [r7, #4]
    if (!allocation_running(instance)) {
 8003d8c:	6878      	ldr	r0, [r7, #4]
 8003d8e:	f000 f88d 	bl	8003eac <allocation_running.lto_priv.73>
 8003d92:	4603      	mov	r3, r0
 8003d94:	f083 0301 	eor.w	r3, r3, #1
 8003d98:	b2db      	uxtb	r3, r3
 8003d9a:	2b00      	cmp	r3, #0
 8003d9c:	d003      	beq.n	8003da6 <allocation_start_request_timer.lto_priv.72+0x22>
        allocation_stop_and_cleanup(instance);
 8003d9e:	6878      	ldr	r0, [r7, #4]
 8003da0:	f001 fcf8 	bl	8005794 <allocation_stop_and_cleanup.lto_priv.64>
 8003da4:	e02e      	b.n	8003e04 <allocation_start_request_timer.lto_priv.72+0x80>
        return;
    }

    float request_delay_ms = UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MIN_REQUEST_PERIOD_MS + (getRandomFloat() * (UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MAX_REQUEST_PERIOD_MS-UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MIN_REQUEST_PERIOD_MS));
 8003da6:	f000 f895 	bl	8003ed4 <getRandomFloat>
 8003daa:	4603      	mov	r3, r0
 8003dac:	4618      	mov	r0, r3
 8003dae:	4917      	ldr	r1, [pc, #92]	; (8003e0c <allocation_start_request_timer.lto_priv.72+0x88>)
 8003db0:	f7ff fe98 	bl	8003ae4 <__aeabi_fmul>
 8003db4:	4603      	mov	r3, r0
 8003db6:	4618      	mov	r0, r3
 8003db8:	4915      	ldr	r1, [pc, #84]	; (8003e10 <allocation_start_request_timer.lto_priv.72+0x8c>)
 8003dba:	f7ff fd8b 	bl	80038d4 <__addsf3>
 8003dbe:	4603      	mov	r3, r0
 8003dc0:	60fb      	str	r3, [r7, #12]

    worker_thread_remove_timer_task(&WT, &instance->request_transmit_task);
 8003dc2:	687b      	ldr	r3, [r7, #4]
 8003dc4:	3308      	adds	r3, #8
 8003dc6:	4813      	ldr	r0, [pc, #76]	; (8003e14 <allocation_start_request_timer.lto_priv.72+0x90>)
 8003dc8:	4619      	mov	r1, r3
 8003dca:	f004 fe5f 	bl	8008a8c <worker_thread_remove_timer_task>
    worker_thread_add_timer_task(&WT, &instance->request_transmit_task, allocation_timer_expired, instance, MS2ST(request_delay_ms), false);
 8003dce:	687b      	ldr	r3, [r7, #4]
 8003dd0:	f103 0408 	add.w	r4, r3, #8
 8003dd4:	68f8      	ldr	r0, [r7, #12]
 8003dd6:	f7ff fa7f 	bl	80032d8 <__aeabi_f2uiz>
 8003dda:	4602      	mov	r2, r0
 8003ddc:	f242 7310 	movw	r3, #10000	; 0x2710
 8003de0:	fb03 f302 	mul.w	r3, r3, r2
 8003de4:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
 8003de8:	4a0b      	ldr	r2, [pc, #44]	; (8003e18 <allocation_start_request_timer.lto_priv.72+0x94>)
 8003dea:	fba2 2303 	umull	r2, r3, r2, r3
 8003dee:	099b      	lsrs	r3, r3, #6
 8003df0:	b29b      	uxth	r3, r3
 8003df2:	9300      	str	r3, [sp, #0]
 8003df4:	2300      	movs	r3, #0
 8003df6:	9301      	str	r3, [sp, #4]
 8003df8:	4806      	ldr	r0, [pc, #24]	; (8003e14 <allocation_start_request_timer.lto_priv.72+0x90>)
 8003dfa:	4621      	mov	r1, r4
 8003dfc:	4a07      	ldr	r2, [pc, #28]	; (8003e1c <allocation_start_request_timer.lto_priv.72+0x98>)
 8003dfe:	687b      	ldr	r3, [r7, #4]
 8003e00:	f004 fdb8 	bl	8008974 <worker_thread_add_timer_task>
}
 8003e04:	3714      	adds	r7, #20
 8003e06:	46bd      	mov	sp, r7
 8003e08:	bd90      	pop	{r4, r7, pc}
 8003e0a:	bf00      	nop
 8003e0c:	43c80000 	.word	0x43c80000
 8003e10:	44160000 	.word	0x44160000
 8003e14:	20000a20 	.word	0x20000a20
 8003e18:	10624dd3 	.word	0x10624dd3
 8003e1c:	080057c1 	.word	0x080057c1

08003e20 <allocation_start_followup_timer.lto_priv.71>:

static void allocation_start_followup_timer(struct allocatee_instance_s* instance) {
 8003e20:	b590      	push	{r4, r7, lr}
 8003e22:	b087      	sub	sp, #28
 8003e24:	af02      	add	r7, sp, #8
 8003e26:	6078      	str	r0, [r7, #4]
    if (!allocation_running(instance)) {
 8003e28:	6878      	ldr	r0, [r7, #4]
 8003e2a:	f000 f83f 	bl	8003eac <allocation_running.lto_priv.73>
 8003e2e:	4603      	mov	r3, r0
 8003e30:	f083 0301 	eor.w	r3, r3, #1
 8003e34:	b2db      	uxtb	r3, r3
 8003e36:	2b00      	cmp	r3, #0
 8003e38:	d003      	beq.n	8003e42 <allocation_start_followup_timer.lto_priv.71+0x22>
        allocation_stop_and_cleanup(instance);
 8003e3a:	6878      	ldr	r0, [r7, #4]
 8003e3c:	f001 fcaa 	bl	8005794 <allocation_stop_and_cleanup.lto_priv.64>
 8003e40:	e029      	b.n	8003e96 <allocation_start_followup_timer.lto_priv.71+0x76>
        return;
    }

    float request_delay_ms = UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MIN_FOLLOWUP_DELAY_MS + (getRandomFloat() * (UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MAX_FOLLOWUP_DELAY_MS-UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MIN_FOLLOWUP_DELAY_MS));
 8003e42:	f000 f847 	bl	8003ed4 <getRandomFloat>
 8003e46:	4603      	mov	r3, r0
 8003e48:	4618      	mov	r0, r3
 8003e4a:	4914      	ldr	r1, [pc, #80]	; (8003e9c <allocation_start_followup_timer.lto_priv.71+0x7c>)
 8003e4c:	f7ff fe4a 	bl	8003ae4 <__aeabi_fmul>
 8003e50:	4603      	mov	r3, r0
 8003e52:	60fb      	str	r3, [r7, #12]

    worker_thread_remove_timer_task(&WT, &instance->request_transmit_task);
 8003e54:	687b      	ldr	r3, [r7, #4]
 8003e56:	3308      	adds	r3, #8
 8003e58:	4811      	ldr	r0, [pc, #68]	; (8003ea0 <allocation_start_followup_timer.lto_priv.71+0x80>)
 8003e5a:	4619      	mov	r1, r3
 8003e5c:	f004 fe16 	bl	8008a8c <worker_thread_remove_timer_task>
    worker_thread_add_timer_task(&WT, &instance->request_transmit_task, allocation_timer_expired, instance, MS2ST(request_delay_ms), false);
 8003e60:	687b      	ldr	r3, [r7, #4]
 8003e62:	f103 0408 	add.w	r4, r3, #8
 8003e66:	68f8      	ldr	r0, [r7, #12]
 8003e68:	f7ff fa36 	bl	80032d8 <__aeabi_f2uiz>
 8003e6c:	4602      	mov	r2, r0
 8003e6e:	f242 7310 	movw	r3, #10000	; 0x2710
 8003e72:	fb03 f302 	mul.w	r3, r3, r2
 8003e76:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
 8003e7a:	4a0a      	ldr	r2, [pc, #40]	; (8003ea4 <allocation_start_followup_timer.lto_priv.71+0x84>)
 8003e7c:	fba2 2303 	umull	r2, r3, r2, r3
 8003e80:	099b      	lsrs	r3, r3, #6
 8003e82:	b29b      	uxth	r3, r3
 8003e84:	9300      	str	r3, [sp, #0]
 8003e86:	2300      	movs	r3, #0
 8003e88:	9301      	str	r3, [sp, #4]
 8003e8a:	4805      	ldr	r0, [pc, #20]	; (8003ea0 <allocation_start_followup_timer.lto_priv.71+0x80>)
 8003e8c:	4621      	mov	r1, r4
 8003e8e:	4a06      	ldr	r2, [pc, #24]	; (8003ea8 <allocation_start_followup_timer.lto_priv.71+0x88>)
 8003e90:	687b      	ldr	r3, [r7, #4]
 8003e92:	f004 fd6f 	bl	8008974 <worker_thread_add_timer_task>
}
 8003e96:	3714      	adds	r7, #20
 8003e98:	46bd      	mov	sp, r7
 8003e9a:	bd90      	pop	{r4, r7, pc}
 8003e9c:	43c80000 	.word	0x43c80000
 8003ea0:	20000a20 	.word	0x20000a20
 8003ea4:	10624dd3 	.word	0x10624dd3
 8003ea8:	080057c1 	.word	0x080057c1

08003eac <allocation_running.lto_priv.73>:

static bool allocation_running(struct allocatee_instance_s* instance) {
 8003eac:	b580      	push	{r7, lr}
 8003eae:	b082      	sub	sp, #8
 8003eb0:	af00      	add	r7, sp, #0
 8003eb2:	6078      	str	r0, [r7, #4]
    return uavcan_get_node_id(instance->uavcan_idx) == 0;
 8003eb4:	687b      	ldr	r3, [r7, #4]
 8003eb6:	781b      	ldrb	r3, [r3, #0]
 8003eb8:	4618      	mov	r0, r3
 8003eba:	f002 fc89 	bl	80067d0 <uavcan_get_node_id>
 8003ebe:	4603      	mov	r3, r0
 8003ec0:	2b00      	cmp	r3, #0
 8003ec2:	bf0c      	ite	eq
 8003ec4:	2301      	moveq	r3, #1
 8003ec6:	2300      	movne	r3, #0
 8003ec8:	b2db      	uxtb	r3, r3
}
 8003eca:	4618      	mov	r0, r3
 8003ecc:	3708      	adds	r7, #8
 8003ece:	46bd      	mov	sp, r7
 8003ed0:	bd80      	pop	{r7, pc}
 8003ed2:	bf00      	nop

08003ed4 <getRandomFloat>:

static float getRandomFloat(void) {
 8003ed4:	b580      	push	{r7, lr}
 8003ed6:	b086      	sub	sp, #24
 8003ed8:	af00      	add	r7, sp, #0
    static uint32_t state;
    if (state == 0) {
 8003eda:	4b1f      	ldr	r3, [pc, #124]	; (8003f58 <getRandomFloat+0x84>)
 8003edc:	681b      	ldr	r3, [r3, #0]
 8003ede:	2b00      	cmp	r3, #0
 8003ee0:	d11a      	bne.n	8003f18 <getRandomFloat+0x44>
        uint8_t unique_id[16];
        board_get_unique_id(unique_id, sizeof(unique_id));
 8003ee2:	1d3b      	adds	r3, r7, #4
 8003ee4:	4618      	mov	r0, r3
 8003ee6:	2110      	movs	r1, #16
 8003ee8:	f000 fa1a 	bl	8004320 <board_get_unique_id>

        const uint32_t* unique_32 = (uint32_t*)&unique_id[0];
 8003eec:	1d3b      	adds	r3, r7, #4
 8003eee:	617b      	str	r3, [r7, #20]

        state = micros() ^ unique_32[0] ^ unique_32[1] ^ unique_32[2] ^ unique_32[3];
 8003ef0:	f003 ff30 	bl	8007d54 <micros>
 8003ef4:	4602      	mov	r2, r0
 8003ef6:	697b      	ldr	r3, [r7, #20]
 8003ef8:	681b      	ldr	r3, [r3, #0]
 8003efa:	405a      	eors	r2, r3
 8003efc:	697b      	ldr	r3, [r7, #20]
 8003efe:	3304      	adds	r3, #4
 8003f00:	681b      	ldr	r3, [r3, #0]
 8003f02:	405a      	eors	r2, r3
 8003f04:	697b      	ldr	r3, [r7, #20]
 8003f06:	3308      	adds	r3, #8
 8003f08:	681b      	ldr	r3, [r3, #0]
 8003f0a:	405a      	eors	r2, r3
 8003f0c:	697b      	ldr	r3, [r7, #20]
 8003f0e:	330c      	adds	r3, #12
 8003f10:	681b      	ldr	r3, [r3, #0]
 8003f12:	4053      	eors	r3, r2
 8003f14:	4a10      	ldr	r2, [pc, #64]	; (8003f58 <getRandomFloat+0x84>)
 8003f16:	6013      	str	r3, [r2, #0]
    }

    state = state * 747796405U;
 8003f18:	4b0f      	ldr	r3, [pc, #60]	; (8003f58 <getRandomFloat+0x84>)
 8003f1a:	681b      	ldr	r3, [r3, #0]
 8003f1c:	4a0f      	ldr	r2, [pc, #60]	; (8003f5c <getRandomFloat+0x88>)
 8003f1e:	fb02 f303 	mul.w	r3, r2, r3
 8003f22:	4a0d      	ldr	r2, [pc, #52]	; (8003f58 <getRandomFloat+0x84>)
 8003f24:	6013      	str	r3, [r2, #0]
    return (float)(uint16_t)(((state >> 11u) ^ state) >> ((state >> 30u) + 11u)) / UINT16_MAX;
 8003f26:	4b0c      	ldr	r3, [pc, #48]	; (8003f58 <getRandomFloat+0x84>)
 8003f28:	681b      	ldr	r3, [r3, #0]
 8003f2a:	0ada      	lsrs	r2, r3, #11
 8003f2c:	4b0a      	ldr	r3, [pc, #40]	; (8003f58 <getRandomFloat+0x84>)
 8003f2e:	681b      	ldr	r3, [r3, #0]
 8003f30:	4053      	eors	r3, r2
 8003f32:	4a09      	ldr	r2, [pc, #36]	; (8003f58 <getRandomFloat+0x84>)
 8003f34:	6812      	ldr	r2, [r2, #0]
 8003f36:	0f92      	lsrs	r2, r2, #30
 8003f38:	320b      	adds	r2, #11
 8003f3a:	40d3      	lsrs	r3, r2
 8003f3c:	b29b      	uxth	r3, r3
 8003f3e:	4618      	mov	r0, r3
 8003f40:	f7ff fd78 	bl	8003a34 <__aeabi_ui2f>
 8003f44:	4603      	mov	r3, r0
 8003f46:	4618      	mov	r0, r3
 8003f48:	4905      	ldr	r1, [pc, #20]	; (8003f60 <getRandomFloat+0x8c>)
 8003f4a:	f7ff fe7f 	bl	8003c4c <__aeabi_fdiv>
 8003f4e:	4603      	mov	r3, r0
}
 8003f50:	4618      	mov	r0, r3
 8003f52:	3718      	adds	r7, #24
 8003f54:	46bd      	mov	sp, r7
 8003f56:	bd80      	pop	{r7, pc}
 8003f58:	200014f4 	.word	0x200014f4
 8003f5c:	2c9277b5 	.word	0x2c9277b5
 8003f60:	477fff00 	.word	0x477fff00

08003f64 <NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
 8003f64:	b480      	push	{r7}
 8003f66:	af00      	add	r7, sp, #0
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8003f68:	f3bf 8f4f 	dsb	sy
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8003f6c:	4905      	ldr	r1, [pc, #20]	; (8003f84 <NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8003f6e:	4b05      	ldr	r3, [pc, #20]	; (8003f84 <NVIC_SystemReset+0x20>)
 8003f70:	68db      	ldr	r3, [r3, #12]
 8003f72:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8003f76:	4b04      	ldr	r3, [pc, #16]	; (8003f88 <NVIC_SystemReset+0x24>)
 8003f78:	4313      	orrs	r3, r2
 8003f7a:	60cb      	str	r3, [r1, #12]
 8003f7c:	f3bf 8f4f 	dsb	sy
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 8003f80:	bf00      	nop
 8003f82:	e7fd      	b.n	8003f80 <NVIC_SystemReset+0x1c>
 8003f84:	e000ed00 	.word	0xe000ed00
 8003f88:	05fa0004 	.word	0x05fa0004

08003f8c <LL_MS2ST>:
 * @param[in] msec      number of milliseconds
 * @return              The number of ticks.
 *
 * @api
 */
static inline systime_t LL_MS2ST(unsigned int msec) {
 8003f8c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8003f90:	b086      	sub	sp, #24
 8003f92:	af00      	add	r7, sp, #0
 8003f94:	60f8      	str	r0, [r7, #12]
  uint64_t ticks = (((uint64_t)msec * (uint64_t)CH_CFG_ST_FREQUENCY) + 999ULL)
 8003f96:	68f9      	ldr	r1, [r7, #12]
 8003f98:	460c      	mov	r4, r1
 8003f9a:	f04f 0500 	mov.w	r5, #0
 8003f9e:	4620      	mov	r0, r4
 8003fa0:	4629      	mov	r1, r5
 8003fa2:	ea4f 0b81 	mov.w	fp, r1, lsl #2
 8003fa6:	ea4b 7b90 	orr.w	fp, fp, r0, lsr #30
 8003faa:	ea4f 0a80 	mov.w	sl, r0, lsl #2
 8003fae:	4650      	mov	r0, sl
 8003fb0:	4659      	mov	r1, fp
 8003fb2:	014b      	lsls	r3, r1, #5
 8003fb4:	ea43 63d0 	orr.w	r3, r3, r0, lsr #27
 8003fb8:	0142      	lsls	r2, r0, #5
 8003fba:	1a12      	subs	r2, r2, r0
 8003fbc:	eb63 0301 	sbc.w	r3, r3, r1
 8003fc0:	18a4      	adds	r4, r4, r2
 8003fc2:	eb45 0503 	adc.w	r5, r5, r3
 8003fc6:	4622      	mov	r2, r4
 8003fc8:	462b      	mov	r3, r5
 8003fca:	0099      	lsls	r1, r3, #2
 8003fcc:	6079      	str	r1, [r7, #4]
 8003fce:	6879      	ldr	r1, [r7, #4]
 8003fd0:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
 8003fd4:	6079      	str	r1, [r7, #4]
 8003fd6:	0091      	lsls	r1, r2, #2
 8003fd8:	6039      	str	r1, [r7, #0]
 8003fda:	e9d7 0100 	ldrd	r0, r1, [r7]
 8003fde:	1880      	adds	r0, r0, r2
 8003fe0:	eb41 0103 	adc.w	r1, r1, r3
 8003fe4:	4602      	mov	r2, r0
 8003fe6:	460b      	mov	r3, r1
 8003fe8:	ea4f 1903 	mov.w	r9, r3, lsl #4
 8003fec:	ea49 7912 	orr.w	r9, r9, r2, lsr #28
 8003ff0:	ea4f 1802 	mov.w	r8, r2, lsl #4
 8003ff4:	4642      	mov	r2, r8
 8003ff6:	464b      	mov	r3, r9
 8003ff8:	4610      	mov	r0, r2
 8003ffa:	4619      	mov	r1, r3
 8003ffc:	f240 32e7 	movw	r2, #999	; 0x3e7
 8004000:	f04f 0300 	mov.w	r3, #0
 8004004:	1812      	adds	r2, r2, r0
 8004006:	eb43 0301 	adc.w	r3, r3, r1
 800400a:	4610      	mov	r0, r2
 800400c:	4619      	mov	r1, r3
 800400e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8004012:	f04f 0300 	mov.w	r3, #0
 8004016:	f7ff f97f 	bl	8003318 <__aeabi_uldivmod>
 800401a:	4602      	mov	r2, r0
 800401c:	460b      	mov	r3, r1
 800401e:	e9c7 2304 	strd	r2, r3, [r7, #16]
                   / 1000ULL;

  chDbgAssert(ticks <= (uint64_t)TIME_MAXIMUM, "conversion overflow");
 8004022:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8004026:	f64f 70fe 	movw	r0, #65534	; 0xfffe
 800402a:	f04f 0100 	mov.w	r1, #0
 800402e:	4299      	cmp	r1, r3
 8004030:	bf08      	it	eq
 8004032:	4290      	cmpeq	r0, r2
 8004034:	d202      	bcs.n	800403c <LL_MS2ST+0xb0>
 8004036:	4804      	ldr	r0, [pc, #16]	; (8004048 <LL_MS2ST+0xbc>)
 8004038:	f006 fee2 	bl	800ae00 <chSysHalt>

  return (systime_t)ticks;
 800403c:	8a3b      	ldrh	r3, [r7, #16]
}
 800403e:	4618      	mov	r0, r3
 8004040:	3718      	adds	r7, #24
 8004042:	46bd      	mov	sp, r7
 8004044:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8004048:	0800ecdc 	.word	0x0800ecdc

0800404c <_local_ctor_25>:

static struct worker_thread_timer_task_s delayed_restart_task;
static struct worker_thread_listener_task_s restart_req_listener_task;
static void restart_req_handler(size_t msg_size, const void* buf, void* ctx);

RUN_AFTER(UAVCAN_INIT) {
 800404c:	b580      	push	{r7, lr}
 800404e:	b084      	sub	sp, #16
 8004050:	af02      	add	r7, sp, #8
    struct pubsub_topic_s* restart_topic = uavcan_get_message_topic(0, &uavcan_protocol_RestartNode_req_descriptor);
 8004052:	2000      	movs	r0, #0
 8004054:	4907      	ldr	r1, [pc, #28]	; (8004074 <_local_ctor_25+0x28>)
 8004056:	f002 fb7b 	bl	8006750 <uavcan_get_message_topic>
 800405a:	6078      	str	r0, [r7, #4]
    worker_thread_add_listener_task(&WT, &restart_req_listener_task, restart_topic, restart_req_handler, NULL);
 800405c:	2300      	movs	r3, #0
 800405e:	9300      	str	r3, [sp, #0]
 8004060:	4805      	ldr	r0, [pc, #20]	; (8004078 <_local_ctor_25+0x2c>)
 8004062:	4906      	ldr	r1, [pc, #24]	; (800407c <_local_ctor_25+0x30>)
 8004064:	687a      	ldr	r2, [r7, #4]
 8004066:	4b06      	ldr	r3, [pc, #24]	; (8004080 <_local_ctor_25+0x34>)
 8004068:	f004 fd32 	bl	8008ad0 <worker_thread_add_listener_task>
}
 800406c:	3708      	adds	r7, #8
 800406e:	46bd      	mov	sp, r7
 8004070:	bd80      	pop	{r7, pc}
 8004072:	bf00      	nop
 8004074:	0800e738 	.word	0x0800e738
 8004078:	20000a20 	.word	0x20000a20
 800407c:	2000150c 	.word	0x2000150c
 8004080:	08004099 	.word	0x08004099

08004084 <delayed_restart_func>:

static void delayed_restart_func(struct worker_thread_timer_task_s* task) {
 8004084:	b580      	push	{r7, lr}
 8004086:	b082      	sub	sp, #8
 8004088:	af00      	add	r7, sp, #0
 800408a:	6078      	str	r0, [r7, #4]
    union shared_msg_payload_u msg;
    boot_msg_fill_shared_canbus_info(&msg.canbus_info);
    shared_msg_finalize_and_write(SHARED_MSG_CANBUS_INFO, &msg);
#endif

    NVIC_SystemReset();
 800408c:	f7ff ff6a 	bl	8003f64 <NVIC_SystemReset>
}
 8004090:	3708      	adds	r7, #8
 8004092:	46bd      	mov	sp, r7
 8004094:	bd80      	pop	{r7, pc}
 8004096:	bf00      	nop

08004098 <restart_req_handler>:

static void restart_req_handler(size_t msg_size, const void* buf, void* ctx) {
 8004098:	b580      	push	{r7, lr}
 800409a:	b08a      	sub	sp, #40	; 0x28
 800409c:	af02      	add	r7, sp, #8
 800409e:	60f8      	str	r0, [r7, #12]
 80040a0:	60b9      	str	r1, [r7, #8]
 80040a2:	607a      	str	r2, [r7, #4]
    (void)msg_size;
    (void)ctx;

    const struct uavcan_deserialized_message_s* msg_wrapper = buf;
 80040a4:	68bb      	ldr	r3, [r7, #8]
 80040a6:	61fb      	str	r3, [r7, #28]
    const struct uavcan_protocol_RestartNode_req_s* msg = (const struct uavcan_protocol_RestartNode_req_s*)msg_wrapper->msg;
 80040a8:	69fb      	ldr	r3, [r7, #28]
 80040aa:	3310      	adds	r3, #16
 80040ac:	61bb      	str	r3, [r7, #24]

    struct uavcan_protocol_RestartNode_res_s res;

    res.ok = false;
 80040ae:	2300      	movs	r3, #0
 80040b0:	753b      	strb	r3, [r7, #20]

    if (msg->magic_number == UAVCAN_PROTOCOL_RESTARTNODE_REQ_MAGIC_NUMBER && system_get_restart_allowed()) {
 80040b2:	69bb      	ldr	r3, [r7, #24]
 80040b4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80040b8:	a116      	add	r1, pc, #88	; (adr r1, 8004114 <restart_req_handler+0x7c>)
 80040ba:	e9d1 0100 	ldrd	r0, r1, [r1]
 80040be:	428b      	cmp	r3, r1
 80040c0:	bf08      	it	eq
 80040c2:	4282      	cmpeq	r2, r0
 80040c4:	d113      	bne.n	80040ee <restart_req_handler+0x56>
 80040c6:	f003 ff37 	bl	8007f38 <system_get_restart_allowed>
 80040ca:	4603      	mov	r3, r0
 80040cc:	2b00      	cmp	r3, #0
 80040ce:	d00e      	beq.n	80040ee <restart_req_handler+0x56>
        res.ok = true;
 80040d0:	2301      	movs	r3, #1
 80040d2:	753b      	strb	r3, [r7, #20]
        worker_thread_add_timer_task(&WT, &delayed_restart_task, delayed_restart_func, NULL, LL_MS2ST(UAVCAN_RESTART_DELAY_MS), false);
 80040d4:	200a      	movs	r0, #10
 80040d6:	f7ff ff59 	bl	8003f8c <LL_MS2ST>
 80040da:	4603      	mov	r3, r0
 80040dc:	9300      	str	r3, [sp, #0]
 80040de:	2300      	movs	r3, #0
 80040e0:	9301      	str	r3, [sp, #4]
 80040e2:	4809      	ldr	r0, [pc, #36]	; (8004108 <restart_req_handler+0x70>)
 80040e4:	4909      	ldr	r1, [pc, #36]	; (800410c <restart_req_handler+0x74>)
 80040e6:	4a0a      	ldr	r2, [pc, #40]	; (8004110 <restart_req_handler+0x78>)
 80040e8:	2300      	movs	r3, #0
 80040ea:	f004 fc43 	bl	8008974 <worker_thread_add_timer_task>
    }

    uavcan_respond(msg_wrapper->uavcan_idx, msg_wrapper, &res);
 80040ee:	69fb      	ldr	r3, [r7, #28]
 80040f0:	781a      	ldrb	r2, [r3, #0]
 80040f2:	f107 0314 	add.w	r3, r7, #20
 80040f6:	4610      	mov	r0, r2
 80040f8:	69f9      	ldr	r1, [r7, #28]
 80040fa:	461a      	mov	r2, r3
 80040fc:	f000 ff68 	bl	8004fd0 <uavcan_respond>
}
 8004100:	3720      	adds	r7, #32
 8004102:	46bd      	mov	sp, r7
 8004104:	bd80      	pop	{r7, pc}
 8004106:	bf00      	nop
 8004108:	20000a20 	.word	0x20000a20
 800410c:	200014f8 	.word	0x200014f8
 8004110:	08004085 	.word	0x08004085
 8004114:	ce551b1e 	.word	0xce551b1e
 8004118:	000000ac 	.word	0x000000ac

0800411c <uavcan_send_debug_msg>:
#include <string.h>
#include <chprintf.h>
#include <memstreams.h>

void uavcan_send_debug_msg(uint8_t debug_level, char* source, const char *fmt, ...)
{
 800411c:	b40c      	push	{r2, r3}
 800411e:	b580      	push	{r7, lr}
 8004120:	b0a8      	sub	sp, #160	; 0xa0
 8004122:	af00      	add	r7, sp, #0
 8004124:	4603      	mov	r3, r0
 8004126:	6039      	str	r1, [r7, #0]
 8004128:	71fb      	strb	r3, [r7, #7]
    MemoryStream ms;
    BaseSequentialStream *chp;

    /* Memory stream object to be used as a string writer, reserving one
     byte for the final zero.*/
    msObjectInit(&ms, (uint8_t *)log_msg.text, sizeof(log_msg.text), 0);
 800412a:	f107 0208 	add.w	r2, r7, #8
 800412e:	f107 0320 	add.w	r3, r7, #32
 8004132:	3322      	adds	r3, #34	; 0x22
 8004134:	4610      	mov	r0, r2
 8004136:	4619      	mov	r1, r3
 8004138:	225a      	movs	r2, #90	; 0x5a
 800413a:	2300      	movs	r3, #0
 800413c:	f000 fc52 	bl	80049e4 <msObjectInit>

    /* Performing the print operation using the common code.*/
    chp = (BaseSequentialStream *)(void *)&ms;
 8004140:	f107 0308 	add.w	r3, r7, #8
 8004144:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    va_start(ap, fmt);
 8004148:	f107 03ac 	add.w	r3, r7, #172	; 0xac
 800414c:	61fb      	str	r3, [r7, #28]
    log_msg.text_len = MIN((size_t)chvprintf(chp, fmt, ap), sizeof(log_msg.text));
 800414e:	f8d7 009c 	ldr.w	r0, [r7, #156]	; 0x9c
 8004152:	f8d7 10a8 	ldr.w	r1, [r7, #168]	; 0xa8
 8004156:	69fa      	ldr	r2, [r7, #28]
 8004158:	f000 f97c 	bl	8004454 <chvprintf>
 800415c:	4603      	mov	r3, r0
 800415e:	2b59      	cmp	r3, #89	; 0x59
 8004160:	d809      	bhi.n	8004176 <uavcan_send_debug_msg+0x5a>
 8004162:	f8d7 009c 	ldr.w	r0, [r7, #156]	; 0x9c
 8004166:	f8d7 10a8 	ldr.w	r1, [r7, #168]	; 0xa8
 800416a:	69fa      	ldr	r2, [r7, #28]
 800416c:	f000 f972 	bl	8004454 <chvprintf>
 8004170:	4603      	mov	r3, r0
 8004172:	b2db      	uxtb	r3, r3
 8004174:	e000      	b.n	8004178 <uavcan_send_debug_msg+0x5c>
 8004176:	235a      	movs	r3, #90	; 0x5a
 8004178:	f887 3041 	strb.w	r3, [r7, #65]	; 0x41
    va_end(ap);

    log_msg.source_len = strnlen(source, sizeof(log_msg.source));
 800417c:	6838      	ldr	r0, [r7, #0]
 800417e:	211f      	movs	r1, #31
 8004180:	f00a fa2c 	bl	800e5dc <strnlen>
 8004184:	4603      	mov	r3, r0
 8004186:	b2db      	uxtb	r3, r3
 8004188:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
    memcpy(log_msg.source, source, log_msg.source_len);
 800418c:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8004190:	461a      	mov	r2, r3
 8004192:	f107 0320 	add.w	r3, r7, #32
 8004196:	3302      	adds	r3, #2
 8004198:	4618      	mov	r0, r3
 800419a:	6839      	ldr	r1, [r7, #0]
 800419c:	f00a f9f0 	bl	800e580 <memcpy>

    log_msg.level.value = debug_level;
 80041a0:	79fb      	ldrb	r3, [r7, #7]
 80041a2:	f887 3020 	strb.w	r3, [r7, #32]

    uavcan_broadcast(0, &uavcan_protocol_debug_LogMessage_descriptor, CANARD_TRANSFER_PRIORITY_LOWEST, &log_msg);
 80041a6:	f107 0320 	add.w	r3, r7, #32
 80041aa:	2000      	movs	r0, #0
 80041ac:	4904      	ldr	r1, [pc, #16]	; (80041c0 <uavcan_send_debug_msg+0xa4>)
 80041ae:	221f      	movs	r2, #31
 80041b0:	f000 feca 	bl	8004f48 <uavcan_broadcast>
}
 80041b4:	37a0      	adds	r7, #160	; 0xa0
 80041b6:	46bd      	mov	sp, r7
 80041b8:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 80041bc:	b002      	add	sp, #8
 80041be:	4770      	bx	lr
 80041c0:	0800e778 	.word	0x0800e778

080041c4 <_local_ctor_31>:
WORKER_THREAD_DECLARE_EXTERN(WT)

static struct worker_thread_timer_task_s stack_print_task;
static void stack_print_task_func(struct worker_thread_timer_task_s* task);

RUN_AFTER(WORKER_THREADS_INIT) {
 80041c4:	b580      	push	{r7, lr}
 80041c6:	b082      	sub	sp, #8
 80041c8:	af02      	add	r7, sp, #8
    worker_thread_add_timer_task(&WT, &stack_print_task, stack_print_task_func, NULL, S2ST(1), true);
 80041ca:	f242 7310 	movw	r3, #10000	; 0x2710
 80041ce:	9300      	str	r3, [sp, #0]
 80041d0:	2301      	movs	r3, #1
 80041d2:	9301      	str	r3, [sp, #4]
 80041d4:	4803      	ldr	r0, [pc, #12]	; (80041e4 <_local_ctor_31+0x20>)
 80041d6:	4904      	ldr	r1, [pc, #16]	; (80041e8 <_local_ctor_31+0x24>)
 80041d8:	4a04      	ldr	r2, [pc, #16]	; (80041ec <_local_ctor_31+0x28>)
 80041da:	2300      	movs	r3, #0
 80041dc:	f004 fbca 	bl	8008974 <worker_thread_add_timer_task>
}
 80041e0:	46bd      	mov	sp, r7
 80041e2:	bd80      	pop	{r7, pc}
 80041e4:	20000a20 	.word	0x20000a20
 80041e8:	20001540 	.word	0x20001540
 80041ec:	080042a9 	.word	0x080042a9

080041f0 <_print_thread_free_stack>:

extern uint8_t __process_stack_base__;
extern uint8_t __main_stack_base__;

static void _print_thread_free_stack(const char* name, void* stack_base) {
 80041f0:	b580      	push	{r7, lr}
 80041f2:	b086      	sub	sp, #24
 80041f4:	af02      	add	r7, sp, #8
 80041f6:	6078      	str	r0, [r7, #4]
 80041f8:	6039      	str	r1, [r7, #0]

    uint8_t* startp = (uint8_t*)stack_base;
 80041fa:	683b      	ldr	r3, [r7, #0]
 80041fc:	60bb      	str	r3, [r7, #8]

    size_t n = 0;
 80041fe:	2300      	movs	r3, #0
 8004200:	60fb      	str	r3, [r7, #12]
    while (true) {
        if (*(startp+n) != CH_DBG_STACK_FILL_VALUE) {
 8004202:	68ba      	ldr	r2, [r7, #8]
 8004204:	68fb      	ldr	r3, [r7, #12]
 8004206:	4413      	add	r3, r2
 8004208:	781b      	ldrb	r3, [r3, #0]
 800420a:	2b55      	cmp	r3, #85	; 0x55
 800420c:	d103      	bne.n	8004216 <_print_thread_free_stack+0x26>
            break;
        }
        n++;
 800420e:	68fb      	ldr	r3, [r7, #12]
 8004210:	3301      	adds	r3, #1
 8004212:	60fb      	str	r3, [r7, #12]
 8004214:	e7f5      	b.n	8004202 <_print_thread_free_stack+0x12>
    }
    uavcan_send_debug_msg(UAVCAN_PROTOCOL_DEBUG_LOGLEVEL_INFO, "", "%s : %u free", name, n);
 8004216:	68fb      	ldr	r3, [r7, #12]
 8004218:	9300      	str	r3, [sp, #0]
 800421a:	2001      	movs	r0, #1
 800421c:	4903      	ldr	r1, [pc, #12]	; (800422c <_print_thread_free_stack+0x3c>)
 800421e:	4a04      	ldr	r2, [pc, #16]	; (8004230 <_print_thread_free_stack+0x40>)
 8004220:	687b      	ldr	r3, [r7, #4]
 8004222:	f7ff ff7b 	bl	800411c <uavcan_send_debug_msg>
}
 8004226:	3710      	adds	r7, #16
 8004228:	46bd      	mov	sp, r7
 800422a:	bd80      	pop	{r7, pc}
 800422c:	0800e600 	.word	0x0800e600
 8004230:	0800e604 	.word	0x0800e604

08004234 <print_thread_free_stack>:

static void print_thread_free_stack(thread_t* thread) {
 8004234:	b580      	push	{r7, lr}
 8004236:	b082      	sub	sp, #8
 8004238:	af00      	add	r7, sp, #0
 800423a:	6078      	str	r0, [r7, #4]
    if (!thread->wabase) {
 800423c:	687b      	ldr	r3, [r7, #4]
 800423e:	69db      	ldr	r3, [r3, #28]
 8004240:	2b00      	cmp	r3, #0
 8004242:	d106      	bne.n	8004252 <print_thread_free_stack+0x1e>
        _print_thread_free_stack(thread->name, &__process_stack_base__);
 8004244:	687b      	ldr	r3, [r7, #4]
 8004246:	699b      	ldr	r3, [r3, #24]
 8004248:	4618      	mov	r0, r3
 800424a:	490f      	ldr	r1, [pc, #60]	; (8004288 <print_thread_free_stack+0x54>)
 800424c:	f7ff ffd0 	bl	80041f0 <_print_thread_free_stack>
 8004250:	e016      	b.n	8004280 <print_thread_free_stack+0x4c>
    } else if(thread->wabase == ch_idle_thread_wa) {
 8004252:	687b      	ldr	r3, [r7, #4]
 8004254:	69db      	ldr	r3, [r3, #28]
 8004256:	4a0d      	ldr	r2, [pc, #52]	; (800428c <print_thread_free_stack+0x58>)
 8004258:	4293      	cmp	r3, r2
 800425a:	d108      	bne.n	800426e <print_thread_free_stack+0x3a>
        _print_thread_free_stack(thread->name, thread->wabase);
 800425c:	687b      	ldr	r3, [r7, #4]
 800425e:	699a      	ldr	r2, [r3, #24]
 8004260:	687b      	ldr	r3, [r7, #4]
 8004262:	69db      	ldr	r3, [r3, #28]
 8004264:	4610      	mov	r0, r2
 8004266:	4619      	mov	r1, r3
 8004268:	f7ff ffc2 	bl	80041f0 <_print_thread_free_stack>
 800426c:	e008      	b.n	8004280 <print_thread_free_stack+0x4c>
    } else {
        _print_thread_free_stack(thread->name, (uint8_t*)thread->wabase + sizeof(thread_t));
 800426e:	687b      	ldr	r3, [r7, #4]
 8004270:	699a      	ldr	r2, [r3, #24]
 8004272:	687b      	ldr	r3, [r7, #4]
 8004274:	69db      	ldr	r3, [r3, #28]
 8004276:	3338      	adds	r3, #56	; 0x38
 8004278:	4610      	mov	r0, r2
 800427a:	4619      	mov	r1, r3
 800427c:	f7ff ffb8 	bl	80041f0 <_print_thread_free_stack>
    }
}
 8004280:	3708      	adds	r7, #8
 8004282:	46bd      	mov	sp, r7
 8004284:	bd80      	pop	{r7, pc}
 8004286:	bf00      	nop
 8004288:	20000500 	.word	0x20000500
 800428c:	20001268 	.word	0x20001268

08004290 <print_exception_free_stack>:

static void print_exception_free_stack(void) {
 8004290:	b580      	push	{r7, lr}
 8004292:	af00      	add	r7, sp, #0
    _print_thread_free_stack("exceptions", &__main_stack_base__);
 8004294:	4802      	ldr	r0, [pc, #8]	; (80042a0 <print_exception_free_stack+0x10>)
 8004296:	4903      	ldr	r1, [pc, #12]	; (80042a4 <print_exception_free_stack+0x14>)
 8004298:	f7ff ffaa 	bl	80041f0 <_print_thread_free_stack>
}
 800429c:	bd80      	pop	{r7, pc}
 800429e:	bf00      	nop
 80042a0:	0800e614 	.word	0x0800e614
 80042a4:	20000000 	.word	0x20000000

080042a8 <stack_print_task_func>:

static void stack_print_task_func(struct worker_thread_timer_task_s* task) {
 80042a8:	b580      	push	{r7, lr}
 80042aa:	b084      	sub	sp, #16
 80042ac:	af00      	add	r7, sp, #0
 80042ae:	6078      	str	r0, [r7, #4]
    (void)task;

    thread_t* thread = chRegFirstThread();
 80042b0:	f006 fa16 	bl	800a6e0 <chRegFirstThread>
 80042b4:	60f8      	str	r0, [r7, #12]
 80042b6:	e006      	b.n	80042c6 <stack_print_task_func+0x1e>
    while(thread) {
        print_thread_free_stack(thread);
 80042b8:	68f8      	ldr	r0, [r7, #12]
 80042ba:	f7ff ffbb 	bl	8004234 <print_thread_free_stack>
        thread = chRegNextThread(thread);
 80042be:	68f8      	ldr	r0, [r7, #12]
 80042c0:	f006 fa28 	bl	800a714 <chRegNextThread>
 80042c4:	60f8      	str	r0, [r7, #12]

static void stack_print_task_func(struct worker_thread_timer_task_s* task) {
    (void)task;

    thread_t* thread = chRegFirstThread();
    while(thread) {
 80042c6:	68fb      	ldr	r3, [r7, #12]
 80042c8:	2b00      	cmp	r3, #0
 80042ca:	d1f5      	bne.n	80042b8 <stack_print_task_func+0x10>
        print_thread_free_stack(thread);
        thread = chRegNextThread(thread);
    }
    print_exception_free_stack();
 80042cc:	f7ff ffe0 	bl	8004290 <print_exception_free_stack>
}
 80042d0:	3710      	adds	r7, #16
 80042d2:	46bd      	mov	sp, r7
 80042d4:	bd80      	pop	{r7, pc}
 80042d6:	bf00      	nop

080042d8 <_local_ctor_14>:
#error Please define REQUIRED_RAM_MARGIN_AFTER_INIT (bytes) in framework_conf.h.
#endif

uint8_t _module_freemem_init_phase = 1;

RUN_AFTER(INIT_END) {
 80042d8:	b580      	push	{r7, lr}
 80042da:	af00      	add	r7, sp, #0
#if REQUIRED_RAM_MARGIN_AFTER_INIT != 0
    if (chCoreGetStatusX() < REQUIRED_RAM_MARGIN_AFTER_INIT) {
 80042dc:	f005 fdb0 	bl	8009e40 <chCoreGetStatusX>
 80042e0:	4603      	mov	r3, r0
 80042e2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80042e6:	d202      	bcs.n	80042ee <_local_ctor_14+0x16>
        chSysHalt(NULL);
 80042e8:	2000      	movs	r0, #0
 80042ea:	f006 fd89 	bl	800ae00 <chSysHalt>
    }
#endif

#ifdef MODULE_UAVCAN_DEBUG_ENABLED
    uavcan_send_debug_msg(UAVCAN_PROTOCOL_DEBUG_LOGLEVEL_INFO, "", "freemem %u", chCoreGetStatusX());
 80042ee:	f005 fda7 	bl	8009e40 <chCoreGetStatusX>
 80042f2:	4603      	mov	r3, r0
 80042f4:	2001      	movs	r0, #1
 80042f6:	4904      	ldr	r1, [pc, #16]	; (8004308 <_local_ctor_14+0x30>)
 80042f8:	4a04      	ldr	r2, [pc, #16]	; (800430c <_local_ctor_14+0x34>)
 80042fa:	f7ff ff0f 	bl	800411c <uavcan_send_debug_msg>
#endif

    _module_freemem_init_phase = 0;
 80042fe:	4b04      	ldr	r3, [pc, #16]	; (8004310 <_local_ctor_14+0x38>)
 8004300:	2200      	movs	r2, #0
 8004302:	701a      	strb	r2, [r3, #0]
}
 8004304:	bd80      	pop	{r7, pc}
 8004306:	bf00      	nop
 8004308:	0800e600 	.word	0x0800e600
 800430c:	0800e620 	.word	0x0800e620
 8004310:	20000a18 	.word	0x20000a18

08004314 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 8004314:	b580      	push	{r7, lr}
 8004316:	af00      	add	r7, sp, #0
    stm32_clock_init();
 8004318:	f005 f8d6 	bl	80094c8 <stm32_clock_init>
}
 800431c:	bd80      	pop	{r7, pc}
 800431e:	bf00      	nop

08004320 <board_get_unique_id>:

void board_get_unique_id(uint8_t* buf, uint8_t len) {
 8004320:	b580      	push	{r7, lr}
 8004322:	b086      	sub	sp, #24
 8004324:	af00      	add	r7, sp, #0
 8004326:	6078      	str	r0, [r7, #4]
 8004328:	460b      	mov	r3, r1
 800432a:	70fb      	strb	r3, [r7, #3]
    uint32_t unique_id_uint32[3];
    unique_id_uint32[0] = ((uint32_t*)0x1ffff7e8)[2];
 800432c:	4b12      	ldr	r3, [pc, #72]	; (8004378 <board_get_unique_id+0x58>)
 800432e:	681b      	ldr	r3, [r3, #0]
 8004330:	60fb      	str	r3, [r7, #12]
    unique_id_uint32[1] = ((uint32_t*)0x1ffff7e8)[1];
 8004332:	4b12      	ldr	r3, [pc, #72]	; (800437c <board_get_unique_id+0x5c>)
 8004334:	681b      	ldr	r3, [r3, #0]
 8004336:	613b      	str	r3, [r7, #16]
    unique_id_uint32[2] = ((uint32_t*)0x1ffff7e8)[0];
 8004338:	4b11      	ldr	r3, [pc, #68]	; (8004380 <board_get_unique_id+0x60>)
 800433a:	681b      	ldr	r3, [r3, #0]
 800433c:	617b      	str	r3, [r7, #20]

    if (len>12) {
 800433e:	78fb      	ldrb	r3, [r7, #3]
 8004340:	2b0c      	cmp	r3, #12
 8004342:	d90d      	bls.n	8004360 <board_get_unique_id+0x40>
        memset(buf, 0, len);
 8004344:	78fb      	ldrb	r3, [r7, #3]
 8004346:	6878      	ldr	r0, [r7, #4]
 8004348:	2100      	movs	r1, #0
 800434a:	461a      	mov	r2, r3
 800434c:	f00a f93e 	bl	800e5cc <memset>
        memcpy(buf, unique_id_uint32, 12);
 8004350:	f107 030c 	add.w	r3, r7, #12
 8004354:	6878      	ldr	r0, [r7, #4]
 8004356:	4619      	mov	r1, r3
 8004358:	220c      	movs	r2, #12
 800435a:	f00a f911 	bl	800e580 <memcpy>
 800435e:	e007      	b.n	8004370 <board_get_unique_id+0x50>
    } else {
        memcpy(buf, unique_id_uint32, len);
 8004360:	78fb      	ldrb	r3, [r7, #3]
 8004362:	f107 020c 	add.w	r2, r7, #12
 8004366:	6878      	ldr	r0, [r7, #4]
 8004368:	4611      	mov	r1, r2
 800436a:	461a      	mov	r2, r3
 800436c:	f00a f908 	bl	800e580 <memcpy>
    }
}
 8004370:	3718      	adds	r7, #24
 8004372:	46bd      	mov	sp, r7
 8004374:	bd80      	pop	{r7, pc}
 8004376:	bf00      	nop
 8004378:	1ffff7f0 	.word	0x1ffff7f0
 800437c:	1ffff7ec 	.word	0x1ffff7ec
 8004380:	1ffff7e8 	.word	0x1ffff7e8

08004384 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 8004384:	b480      	push	{r7}
 8004386:	b089      	sub	sp, #36	; 0x24
 8004388:	af00      	add	r7, sp, #0
 800438a:	60f8      	str	r0, [r7, #12]
 800438c:	60b9      	str	r1, [r7, #8]
 800438e:	607a      	str	r2, [r7, #4]
 8004390:	603b      	str	r3, [r7, #0]
  int i;
  char *q;
  long l, ll;

  l = num;
 8004392:	68bb      	ldr	r3, [r7, #8]
 8004394:	617b      	str	r3, [r7, #20]
  if (divisor == 0) {
 8004396:	683b      	ldr	r3, [r7, #0]
 8004398:	2b00      	cmp	r3, #0
 800439a:	d102      	bne.n	80043a2 <long_to_string_with_divisor+0x1e>
    ll = num;
 800439c:	68bb      	ldr	r3, [r7, #8]
 800439e:	613b      	str	r3, [r7, #16]
 80043a0:	e001      	b.n	80043a6 <long_to_string_with_divisor+0x22>
  } else {
    ll = divisor;
 80043a2:	683b      	ldr	r3, [r7, #0]
 80043a4:	613b      	str	r3, [r7, #16]
  }

  q = p + MAX_FILLER;
 80043a6:	68fb      	ldr	r3, [r7, #12]
 80043a8:	330b      	adds	r3, #11
 80043aa:	61bb      	str	r3, [r7, #24]
  do {
    i = (int)(l % radix);
 80043ac:	697b      	ldr	r3, [r7, #20]
 80043ae:	687a      	ldr	r2, [r7, #4]
 80043b0:	fbb3 f2f2 	udiv	r2, r3, r2
 80043b4:	6879      	ldr	r1, [r7, #4]
 80043b6:	fb01 f202 	mul.w	r2, r1, r2
 80043ba:	1a9b      	subs	r3, r3, r2
 80043bc:	61fb      	str	r3, [r7, #28]
    i += '0';
 80043be:	69fb      	ldr	r3, [r7, #28]
 80043c0:	3330      	adds	r3, #48	; 0x30
 80043c2:	61fb      	str	r3, [r7, #28]
    if (i > '9')
 80043c4:	69fb      	ldr	r3, [r7, #28]
 80043c6:	2b39      	cmp	r3, #57	; 0x39
 80043c8:	dd02      	ble.n	80043d0 <long_to_string_with_divisor+0x4c>
      i += 'A' - '0' - 10;
 80043ca:	69fb      	ldr	r3, [r7, #28]
 80043cc:	3307      	adds	r3, #7
 80043ce:	61fb      	str	r3, [r7, #28]
    *--q = i;
 80043d0:	69bb      	ldr	r3, [r7, #24]
 80043d2:	3b01      	subs	r3, #1
 80043d4:	61bb      	str	r3, [r7, #24]
 80043d6:	69fb      	ldr	r3, [r7, #28]
 80043d8:	b2da      	uxtb	r2, r3
 80043da:	69bb      	ldr	r3, [r7, #24]
 80043dc:	701a      	strb	r2, [r3, #0]
    l /= radix;
 80043de:	697a      	ldr	r2, [r7, #20]
 80043e0:	687b      	ldr	r3, [r7, #4]
 80043e2:	fbb2 f3f3 	udiv	r3, r2, r3
 80043e6:	617b      	str	r3, [r7, #20]
  } while ((ll /= radix) != 0);
 80043e8:	693a      	ldr	r2, [r7, #16]
 80043ea:	687b      	ldr	r3, [r7, #4]
 80043ec:	fbb2 f3f3 	udiv	r3, r2, r3
 80043f0:	613b      	str	r3, [r7, #16]
 80043f2:	693b      	ldr	r3, [r7, #16]
 80043f4:	2b00      	cmp	r3, #0
 80043f6:	d1d9      	bne.n	80043ac <long_to_string_with_divisor+0x28>

  i = (int)(p + MAX_FILLER - q);
 80043f8:	68fb      	ldr	r3, [r7, #12]
 80043fa:	330b      	adds	r3, #11
 80043fc:	461a      	mov	r2, r3
 80043fe:	69bb      	ldr	r3, [r7, #24]
 8004400:	1ad3      	subs	r3, r2, r3
 8004402:	61fb      	str	r3, [r7, #28]
  do
    *p++ = *q++;
 8004404:	68fb      	ldr	r3, [r7, #12]
 8004406:	1c5a      	adds	r2, r3, #1
 8004408:	60fa      	str	r2, [r7, #12]
 800440a:	69ba      	ldr	r2, [r7, #24]
 800440c:	1c51      	adds	r1, r2, #1
 800440e:	61b9      	str	r1, [r7, #24]
 8004410:	7812      	ldrb	r2, [r2, #0]
 8004412:	701a      	strb	r2, [r3, #0]
  while (--i);
 8004414:	69fb      	ldr	r3, [r7, #28]
 8004416:	3b01      	subs	r3, #1
 8004418:	61fb      	str	r3, [r7, #28]
 800441a:	69fb      	ldr	r3, [r7, #28]
 800441c:	2b00      	cmp	r3, #0
 800441e:	d1f1      	bne.n	8004404 <long_to_string_with_divisor+0x80>

  return p;
 8004420:	68fb      	ldr	r3, [r7, #12]
}
 8004422:	4618      	mov	r0, r3
 8004424:	3724      	adds	r7, #36	; 0x24
 8004426:	46bd      	mov	sp, r7
 8004428:	f85d 7b04 	ldr.w	r7, [sp], #4
 800442c:	4770      	bx	lr
 800442e:	bf00      	nop

08004430 <ch_ltoa>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 8004430:	b580      	push	{r7, lr}
 8004432:	b084      	sub	sp, #16
 8004434:	af00      	add	r7, sp, #0
 8004436:	60f8      	str	r0, [r7, #12]
 8004438:	60b9      	str	r1, [r7, #8]
 800443a:	607a      	str	r2, [r7, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
 800443c:	68f8      	ldr	r0, [r7, #12]
 800443e:	68b9      	ldr	r1, [r7, #8]
 8004440:	687a      	ldr	r2, [r7, #4]
 8004442:	2300      	movs	r3, #0
 8004444:	f7ff ff9e 	bl	8004384 <long_to_string_with_divisor>
 8004448:	4603      	mov	r3, r0
}
 800444a:	4618      	mov	r0, r3
 800444c:	3710      	adds	r7, #16
 800444e:	46bd      	mov	sp, r7
 8004450:	bd80      	pop	{r7, pc}
 8004452:	bf00      	nop

08004454 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8004454:	b580      	push	{r7, lr}
 8004456:	b090      	sub	sp, #64	; 0x40
 8004458:	af00      	add	r7, sp, #0
 800445a:	60f8      	str	r0, [r7, #12]
 800445c:	60b9      	str	r1, [r7, #8]
 800445e:	607a      	str	r2, [r7, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8004460:	2300      	movs	r3, #0
 8004462:	627b      	str	r3, [r7, #36]	; 0x24
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8004464:	68bb      	ldr	r3, [r7, #8]
 8004466:	1c5a      	adds	r2, r3, #1
 8004468:	60ba      	str	r2, [r7, #8]
 800446a:	781b      	ldrb	r3, [r3, #0]
 800446c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    if (c == 0)
 8004470:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8004474:	2b00      	cmp	r3, #0
 8004476:	d101      	bne.n	800447c <chvprintf+0x28>
      return n;
 8004478:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800447a:	e20e      	b.n	800489a <chvprintf+0x446>
    if (c != '%') {
 800447c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8004480:	2b25      	cmp	r3, #37	; 0x25
 8004482:	d00b      	beq.n	800449c <chvprintf+0x48>
      streamPut(chp, (uint8_t)c);
 8004484:	68fb      	ldr	r3, [r7, #12]
 8004486:	681b      	ldr	r3, [r3, #0]
 8004488:	689b      	ldr	r3, [r3, #8]
 800448a:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 800448e:	68f8      	ldr	r0, [r7, #12]
 8004490:	4611      	mov	r1, r2
 8004492:	4798      	blx	r3
      n++;
 8004494:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004496:	3301      	adds	r3, #1
 8004498:	627b      	str	r3, [r7, #36]	; 0x24
 800449a:	e7e3      	b.n	8004464 <chvprintf+0x10>
      continue;
    }
    p = tmpbuf;
 800449c:	f107 0310 	add.w	r3, r7, #16
 80044a0:	63fb      	str	r3, [r7, #60]	; 0x3c
    s = tmpbuf;
 80044a2:	f107 0310 	add.w	r3, r7, #16
 80044a6:	63bb      	str	r3, [r7, #56]	; 0x38
    left_align = FALSE;
 80044a8:	2300      	movs	r3, #0
 80044aa:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
    if (*fmt == '-') {
 80044ae:	68bb      	ldr	r3, [r7, #8]
 80044b0:	781b      	ldrb	r3, [r3, #0]
 80044b2:	2b2d      	cmp	r3, #45	; 0x2d
 80044b4:	d105      	bne.n	80044c2 <chvprintf+0x6e>
      fmt++;
 80044b6:	68bb      	ldr	r3, [r7, #8]
 80044b8:	3301      	adds	r3, #1
 80044ba:	60bb      	str	r3, [r7, #8]
      left_align = TRUE;
 80044bc:	2301      	movs	r3, #1
 80044be:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
    }
    filler = ' ';
 80044c2:	2320      	movs	r3, #32
 80044c4:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
    if (*fmt == '0') {
 80044c8:	68bb      	ldr	r3, [r7, #8]
 80044ca:	781b      	ldrb	r3, [r3, #0]
 80044cc:	2b30      	cmp	r3, #48	; 0x30
 80044ce:	d105      	bne.n	80044dc <chvprintf+0x88>
      fmt++;
 80044d0:	68bb      	ldr	r3, [r7, #8]
 80044d2:	3301      	adds	r3, #1
 80044d4:	60bb      	str	r3, [r7, #8]
      filler = '0';
 80044d6:	2330      	movs	r3, #48	; 0x30
 80044d8:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
    }
    width = 0;
 80044dc:	2300      	movs	r3, #0
 80044de:	62bb      	str	r3, [r7, #40]	; 0x28
    while (TRUE) {
      c = *fmt++;
 80044e0:	68bb      	ldr	r3, [r7, #8]
 80044e2:	1c5a      	adds	r2, r3, #1
 80044e4:	60ba      	str	r2, [r7, #8]
 80044e6:	781b      	ldrb	r3, [r3, #0]
 80044e8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
      if (c >= '0' && c <= '9')
 80044ec:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80044f0:	2b2f      	cmp	r3, #47	; 0x2f
 80044f2:	d909      	bls.n	8004508 <chvprintf+0xb4>
 80044f4:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80044f8:	2b39      	cmp	r3, #57	; 0x39
 80044fa:	d805      	bhi.n	8004508 <chvprintf+0xb4>
        c -= '0';
 80044fc:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8004500:	3b30      	subs	r3, #48	; 0x30
 8004502:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 8004506:	e009      	b.n	800451c <chvprintf+0xc8>
      else if (c == '*')
 8004508:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800450c:	2b2a      	cmp	r3, #42	; 0x2a
 800450e:	d110      	bne.n	8004532 <chvprintf+0xde>
        c = va_arg(ap, int);
 8004510:	687b      	ldr	r3, [r7, #4]
 8004512:	1d1a      	adds	r2, r3, #4
 8004514:	607a      	str	r2, [r7, #4]
 8004516:	681b      	ldr	r3, [r3, #0]
 8004518:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
      else
        break;
      width = width * 10 + c;
 800451c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800451e:	4613      	mov	r3, r2
 8004520:	009b      	lsls	r3, r3, #2
 8004522:	4413      	add	r3, r2
 8004524:	005b      	lsls	r3, r3, #1
 8004526:	461a      	mov	r2, r3
 8004528:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800452c:	4413      	add	r3, r2
 800452e:	62bb      	str	r3, [r7, #40]	; 0x28
 8004530:	e7d6      	b.n	80044e0 <chvprintf+0x8c>
    }
    precision = 0;
 8004532:	2300      	movs	r3, #0
 8004534:	62fb      	str	r3, [r7, #44]	; 0x2c
    if (c == '.') {
 8004536:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800453a:	2b2e      	cmp	r3, #46	; 0x2e
 800453c:	d129      	bne.n	8004592 <chvprintf+0x13e>
      while (TRUE) {
        c = *fmt++;
 800453e:	68bb      	ldr	r3, [r7, #8]
 8004540:	1c5a      	adds	r2, r3, #1
 8004542:	60ba      	str	r2, [r7, #8]
 8004544:	781b      	ldrb	r3, [r3, #0]
 8004546:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        if (c >= '0' && c <= '9')
 800454a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800454e:	2b2f      	cmp	r3, #47	; 0x2f
 8004550:	d909      	bls.n	8004566 <chvprintf+0x112>
 8004552:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8004556:	2b39      	cmp	r3, #57	; 0x39
 8004558:	d805      	bhi.n	8004566 <chvprintf+0x112>
          c -= '0';
 800455a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800455e:	3b30      	subs	r3, #48	; 0x30
 8004560:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 8004564:	e009      	b.n	800457a <chvprintf+0x126>
        else if (c == '*')
 8004566:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800456a:	2b2a      	cmp	r3, #42	; 0x2a
 800456c:	d111      	bne.n	8004592 <chvprintf+0x13e>
          c = va_arg(ap, int);
 800456e:	687b      	ldr	r3, [r7, #4]
 8004570:	1d1a      	adds	r2, r3, #4
 8004572:	607a      	str	r2, [r7, #4]
 8004574:	681b      	ldr	r3, [r3, #0]
 8004576:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        else
          break;
        precision *= 10;
 800457a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800457c:	4613      	mov	r3, r2
 800457e:	009b      	lsls	r3, r3, #2
 8004580:	4413      	add	r3, r2
 8004582:	005b      	lsls	r3, r3, #1
 8004584:	62fb      	str	r3, [r7, #44]	; 0x2c
        precision += c;
 8004586:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800458a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800458c:	4413      	add	r3, r2
 800458e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8004590:	e7d5      	b.n	800453e <chvprintf+0xea>
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8004592:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8004596:	2b6c      	cmp	r3, #108	; 0x6c
 8004598:	d003      	beq.n	80045a2 <chvprintf+0x14e>
 800459a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800459e:	2b4c      	cmp	r3, #76	; 0x4c
 80045a0:	d10d      	bne.n	80045be <chvprintf+0x16a>
      is_long = TRUE;
 80045a2:	2301      	movs	r3, #1
 80045a4:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
      if (*fmt)
 80045a8:	68bb      	ldr	r3, [r7, #8]
 80045aa:	781b      	ldrb	r3, [r3, #0]
 80045ac:	2b00      	cmp	r3, #0
 80045ae:	d01a      	beq.n	80045e6 <chvprintf+0x192>
        c = *fmt++;
 80045b0:	68bb      	ldr	r3, [r7, #8]
 80045b2:	1c5a      	adds	r2, r3, #1
 80045b4:	60ba      	str	r2, [r7, #8]
 80045b6:	781b      	ldrb	r3, [r3, #0]
 80045b8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 80045bc:	e014      	b.n	80045e8 <chvprintf+0x194>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
 80045be:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80045c2:	2b40      	cmp	r3, #64	; 0x40
 80045c4:	d905      	bls.n	80045d2 <chvprintf+0x17e>
 80045c6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80045ca:	2b5a      	cmp	r3, #90	; 0x5a
 80045cc:	d801      	bhi.n	80045d2 <chvprintf+0x17e>
 80045ce:	2301      	movs	r3, #1
 80045d0:	e000      	b.n	80045d4 <chvprintf+0x180>
 80045d2:	2300      	movs	r3, #0
 80045d4:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 80045d8:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 80045dc:	f003 0301 	and.w	r3, r3, #1
 80045e0:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 80045e4:	e000      	b.n	80045e8 <chvprintf+0x194>
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 80045e6:	bf00      	nop
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80045e8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80045ec:	3b44      	subs	r3, #68	; 0x44
 80045ee:	2b34      	cmp	r3, #52	; 0x34
 80045f0:	f200 80e3 	bhi.w	80047ba <chvprintf+0x366>
 80045f4:	a201      	add	r2, pc, #4	; (adr r2, 80045fc <chvprintf+0x1a8>)
 80045f6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80045fa:	bf00      	nop
 80045fc:	08004733 	.word	0x08004733
 8004600:	080047bb 	.word	0x080047bb
 8004604:	080047bb 	.word	0x080047bb
 8004608:	080047bb 	.word	0x080047bb
 800460c:	080047bb 	.word	0x080047bb
 8004610:	08004733 	.word	0x08004733
 8004614:	080047bb 	.word	0x080047bb
 8004618:	080047bb 	.word	0x080047bb
 800461c:	080047bb 	.word	0x080047bb
 8004620:	080047bb 	.word	0x080047bb
 8004624:	080047bb 	.word	0x080047bb
 8004628:	08004785 	.word	0x08004785
 800462c:	080047bb 	.word	0x080047bb
 8004630:	080047bb 	.word	0x080047bb
 8004634:	080047bb 	.word	0x080047bb
 8004638:	080047bb 	.word	0x080047bb
 800463c:	080047bb 	.word	0x080047bb
 8004640:	0800477d 	.word	0x0800477d
 8004644:	080047bb 	.word	0x080047bb
 8004648:	080047bb 	.word	0x080047bb
 800464c:	08004775 	.word	0x08004775
 8004650:	080047bb 	.word	0x080047bb
 8004654:	080047bb 	.word	0x080047bb
 8004658:	080047bb 	.word	0x080047bb
 800465c:	080047bb 	.word	0x080047bb
 8004660:	080047bb 	.word	0x080047bb
 8004664:	080047bb 	.word	0x080047bb
 8004668:	080047bb 	.word	0x080047bb
 800466c:	080047bb 	.word	0x080047bb
 8004670:	080047bb 	.word	0x080047bb
 8004674:	080047bb 	.word	0x080047bb
 8004678:	080046d1 	.word	0x080046d1
 800467c:	08004733 	.word	0x08004733
 8004680:	080047bb 	.word	0x080047bb
 8004684:	080047bb 	.word	0x080047bb
 8004688:	080047bb 	.word	0x080047bb
 800468c:	080047bb 	.word	0x080047bb
 8004690:	08004733 	.word	0x08004733
 8004694:	080047bb 	.word	0x080047bb
 8004698:	080047bb 	.word	0x080047bb
 800469c:	080047bb 	.word	0x080047bb
 80046a0:	080047bb 	.word	0x080047bb
 80046a4:	080047bb 	.word	0x080047bb
 80046a8:	08004785 	.word	0x08004785
 80046ac:	080047bb 	.word	0x080047bb
 80046b0:	080047bb 	.word	0x080047bb
 80046b4:	080047bb 	.word	0x080047bb
 80046b8:	080046eb 	.word	0x080046eb
 80046bc:	080047bb 	.word	0x080047bb
 80046c0:	0800477d 	.word	0x0800477d
 80046c4:	080047bb 	.word	0x080047bb
 80046c8:	080047bb 	.word	0x080047bb
 80046cc:	08004775 	.word	0x08004775
    case 'c':
      filler = ' ';
 80046d0:	2320      	movs	r3, #32
 80046d2:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
      *p++ = va_arg(ap, int);
 80046d6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80046d8:	1c5a      	adds	r2, r3, #1
 80046da:	63fa      	str	r2, [r7, #60]	; 0x3c
 80046dc:	687a      	ldr	r2, [r7, #4]
 80046de:	1d11      	adds	r1, r2, #4
 80046e0:	6079      	str	r1, [r7, #4]
 80046e2:	6812      	ldr	r2, [r2, #0]
 80046e4:	b2d2      	uxtb	r2, r2
 80046e6:	701a      	strb	r2, [r3, #0]
 80046e8:	e06d      	b.n	80047c6 <chvprintf+0x372>
      break;
    case 's':
      filler = ' ';
 80046ea:	2320      	movs	r3, #32
 80046ec:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
      if ((s = va_arg(ap, char *)) == 0)
 80046f0:	687b      	ldr	r3, [r7, #4]
 80046f2:	1d1a      	adds	r2, r3, #4
 80046f4:	607a      	str	r2, [r7, #4]
 80046f6:	681b      	ldr	r3, [r3, #0]
 80046f8:	63bb      	str	r3, [r7, #56]	; 0x38
 80046fa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80046fc:	2b00      	cmp	r3, #0
 80046fe:	d101      	bne.n	8004704 <chvprintf+0x2b0>
        s = "(null)";
 8004700:	4b68      	ldr	r3, [pc, #416]	; (80048a4 <chvprintf+0x450>)
 8004702:	63bb      	str	r3, [r7, #56]	; 0x38
      if (precision == 0)
 8004704:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004706:	2b00      	cmp	r3, #0
 8004708:	d102      	bne.n	8004710 <chvprintf+0x2bc>
        precision = 32767;
 800470a:	f647 73ff 	movw	r3, #32767	; 0x7fff
 800470e:	62fb      	str	r3, [r7, #44]	; 0x2c
      for (p = s; *p && (--precision >= 0); p++)
 8004710:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004712:	63fb      	str	r3, [r7, #60]	; 0x3c
 8004714:	e002      	b.n	800471c <chvprintf+0x2c8>
 8004716:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8004718:	3301      	adds	r3, #1
 800471a:	63fb      	str	r3, [r7, #60]	; 0x3c
 800471c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800471e:	781b      	ldrb	r3, [r3, #0]
 8004720:	2b00      	cmp	r3, #0
 8004722:	d050      	beq.n	80047c6 <chvprintf+0x372>
 8004724:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004726:	3b01      	subs	r3, #1
 8004728:	62fb      	str	r3, [r7, #44]	; 0x2c
 800472a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800472c:	2b00      	cmp	r3, #0
 800472e:	daf2      	bge.n	8004716 <chvprintf+0x2c2>
 8004730:	e049      	b.n	80047c6 <chvprintf+0x372>
      break;
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
 8004732:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8004736:	2b00      	cmp	r3, #0
 8004738:	d005      	beq.n	8004746 <chvprintf+0x2f2>
        l = va_arg(ap, long);
 800473a:	687b      	ldr	r3, [r7, #4]
 800473c:	1d1a      	adds	r2, r3, #4
 800473e:	607a      	str	r2, [r7, #4]
 8004740:	681b      	ldr	r3, [r3, #0]
 8004742:	61fb      	str	r3, [r7, #28]
 8004744:	e004      	b.n	8004750 <chvprintf+0x2fc>
      else
        l = va_arg(ap, int);
 8004746:	687b      	ldr	r3, [r7, #4]
 8004748:	1d1a      	adds	r2, r3, #4
 800474a:	607a      	str	r2, [r7, #4]
 800474c:	681b      	ldr	r3, [r3, #0]
 800474e:	61fb      	str	r3, [r7, #28]
      if (l < 0) {
 8004750:	69fb      	ldr	r3, [r7, #28]
 8004752:	2b00      	cmp	r3, #0
 8004754:	da07      	bge.n	8004766 <chvprintf+0x312>
        *p++ = '-';
 8004756:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8004758:	1c5a      	adds	r2, r3, #1
 800475a:	63fa      	str	r2, [r7, #60]	; 0x3c
 800475c:	222d      	movs	r2, #45	; 0x2d
 800475e:	701a      	strb	r2, [r3, #0]
        l = -l;
 8004760:	69fb      	ldr	r3, [r7, #28]
 8004762:	425b      	negs	r3, r3
 8004764:	61fb      	str	r3, [r7, #28]
      }
      p = ch_ltoa(p, l, 10);
 8004766:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8004768:	69f9      	ldr	r1, [r7, #28]
 800476a:	220a      	movs	r2, #10
 800476c:	f7ff fe60 	bl	8004430 <ch_ltoa>
 8004770:	63f8      	str	r0, [r7, #60]	; 0x3c
 8004772:	e028      	b.n	80047c6 <chvprintf+0x372>
      p = ftoa(p, f, precision);
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
 8004774:	2310      	movs	r3, #16
 8004776:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 800477a:	e006      	b.n	800478a <chvprintf+0x336>
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
 800477c:	230a      	movs	r3, #10
 800477e:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 8004782:	e002      	b.n	800478a <chvprintf+0x336>
      goto unsigned_common;
    case 'O':
    case 'o':
      c = 8;
 8004784:	2308      	movs	r3, #8
 8004786:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
unsigned_common:
      if (is_long)
 800478a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800478e:	2b00      	cmp	r3, #0
 8004790:	d005      	beq.n	800479e <chvprintf+0x34a>
        l = va_arg(ap, unsigned long);
 8004792:	687b      	ldr	r3, [r7, #4]
 8004794:	1d1a      	adds	r2, r3, #4
 8004796:	607a      	str	r2, [r7, #4]
 8004798:	681b      	ldr	r3, [r3, #0]
 800479a:	61fb      	str	r3, [r7, #28]
 800479c:	e004      	b.n	80047a8 <chvprintf+0x354>
      else
        l = va_arg(ap, unsigned int);
 800479e:	687b      	ldr	r3, [r7, #4]
 80047a0:	1d1a      	adds	r2, r3, #4
 80047a2:	607a      	str	r2, [r7, #4]
 80047a4:	681b      	ldr	r3, [r3, #0]
 80047a6:	61fb      	str	r3, [r7, #28]
      p = ch_ltoa(p, l, c);
 80047a8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80047ac:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80047ae:	69f9      	ldr	r1, [r7, #28]
 80047b0:	461a      	mov	r2, r3
 80047b2:	f7ff fe3d 	bl	8004430 <ch_ltoa>
 80047b6:	63f8      	str	r0, [r7, #60]	; 0x3c
 80047b8:	e005      	b.n	80047c6 <chvprintf+0x372>
      break;
    default:
      *p++ = c;
 80047ba:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80047bc:	1c5a      	adds	r2, r3, #1
 80047be:	63fa      	str	r2, [r7, #60]	; 0x3c
 80047c0:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 80047c4:	701a      	strb	r2, [r3, #0]
      break;
    }
    i = (int)(p - s);
 80047c6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80047c8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80047ca:	1ad3      	subs	r3, r2, r3
 80047cc:	633b      	str	r3, [r7, #48]	; 0x30
    if ((width -= i) < 0)
 80047ce:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80047d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80047d2:	1ad3      	subs	r3, r2, r3
 80047d4:	62bb      	str	r3, [r7, #40]	; 0x28
 80047d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80047d8:	2b00      	cmp	r3, #0
 80047da:	da01      	bge.n	80047e0 <chvprintf+0x38c>
      width = 0;
 80047dc:	2300      	movs	r3, #0
 80047de:	62bb      	str	r3, [r7, #40]	; 0x28
    if (left_align == FALSE)
 80047e0:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 80047e4:	f083 0301 	eor.w	r3, r3, #1
 80047e8:	b2db      	uxtb	r3, r3
 80047ea:	2b00      	cmp	r3, #0
 80047ec:	d002      	beq.n	80047f4 <chvprintf+0x3a0>
      width = -width;
 80047ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80047f0:	425b      	negs	r3, r3
 80047f2:	62bb      	str	r3, [r7, #40]	; 0x28
    if (width < 0) {
 80047f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80047f6:	2b00      	cmp	r3, #0
 80047f8:	da36      	bge.n	8004868 <chvprintf+0x414>
      if (*s == '-' && filler == '0') {
 80047fa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80047fc:	781b      	ldrb	r3, [r3, #0]
 80047fe:	2b2d      	cmp	r3, #45	; 0x2d
 8004800:	d113      	bne.n	800482a <chvprintf+0x3d6>
 8004802:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8004806:	2b30      	cmp	r3, #48	; 0x30
 8004808:	d10f      	bne.n	800482a <chvprintf+0x3d6>
        streamPut(chp, (uint8_t)*s++);
 800480a:	68fb      	ldr	r3, [r7, #12]
 800480c:	681b      	ldr	r3, [r3, #0]
 800480e:	689a      	ldr	r2, [r3, #8]
 8004810:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004812:	1c59      	adds	r1, r3, #1
 8004814:	63b9      	str	r1, [r7, #56]	; 0x38
 8004816:	781b      	ldrb	r3, [r3, #0]
 8004818:	68f8      	ldr	r0, [r7, #12]
 800481a:	4619      	mov	r1, r3
 800481c:	4790      	blx	r2
        n++;
 800481e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004820:	3301      	adds	r3, #1
 8004822:	627b      	str	r3, [r7, #36]	; 0x24
        i--;
 8004824:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004826:	3b01      	subs	r3, #1
 8004828:	633b      	str	r3, [r7, #48]	; 0x30
      }
      do {
        streamPut(chp, (uint8_t)filler);
 800482a:	68fb      	ldr	r3, [r7, #12]
 800482c:	681b      	ldr	r3, [r3, #0]
 800482e:	689b      	ldr	r3, [r3, #8]
 8004830:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
 8004834:	68f8      	ldr	r0, [r7, #12]
 8004836:	4611      	mov	r1, r2
 8004838:	4798      	blx	r3
        n++;
 800483a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800483c:	3301      	adds	r3, #1
 800483e:	627b      	str	r3, [r7, #36]	; 0x24
      } while (++width != 0);
 8004840:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004842:	3301      	adds	r3, #1
 8004844:	62bb      	str	r3, [r7, #40]	; 0x28
 8004846:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004848:	2b00      	cmp	r3, #0
 800484a:	d1ee      	bne.n	800482a <chvprintf+0x3d6>
 800484c:	e00c      	b.n	8004868 <chvprintf+0x414>
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 800484e:	68fb      	ldr	r3, [r7, #12]
 8004850:	681b      	ldr	r3, [r3, #0]
 8004852:	689a      	ldr	r2, [r3, #8]
 8004854:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004856:	1c59      	adds	r1, r3, #1
 8004858:	63b9      	str	r1, [r7, #56]	; 0x38
 800485a:	781b      	ldrb	r3, [r3, #0]
 800485c:	68f8      	ldr	r0, [r7, #12]
 800485e:	4619      	mov	r1, r3
 8004860:	4790      	blx	r2
      n++;
 8004862:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004864:	3301      	adds	r3, #1
 8004866:	627b      	str	r3, [r7, #36]	; 0x24
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8004868:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800486a:	3b01      	subs	r3, #1
 800486c:	633b      	str	r3, [r7, #48]	; 0x30
 800486e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004870:	2b00      	cmp	r3, #0
 8004872:	daec      	bge.n	800484e <chvprintf+0x3fa>
 8004874:	e00d      	b.n	8004892 <chvprintf+0x43e>
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
      streamPut(chp, (uint8_t)filler);
 8004876:	68fb      	ldr	r3, [r7, #12]
 8004878:	681b      	ldr	r3, [r3, #0]
 800487a:	689b      	ldr	r3, [r3, #8]
 800487c:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
 8004880:	68f8      	ldr	r0, [r7, #12]
 8004882:	4611      	mov	r1, r2
 8004884:	4798      	blx	r3
      n++;
 8004886:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004888:	3301      	adds	r3, #1
 800488a:	627b      	str	r3, [r7, #36]	; 0x24
      width--;
 800488c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800488e:	3b01      	subs	r3, #1
 8004890:	62bb      	str	r3, [r7, #40]	; 0x28
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8004892:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004894:	2b00      	cmp	r3, #0
 8004896:	d1ee      	bne.n	8004876 <chvprintf+0x422>
 8004898:	e5e4      	b.n	8004464 <chvprintf+0x10>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 800489a:	4618      	mov	r0, r3
 800489c:	3740      	adds	r7, #64	; 0x40
 800489e:	46bd      	mov	sp, r7
 80048a0:	bd80      	pop	{r7, pc}
 80048a2:	bf00      	nop
 80048a4:	0800e62c 	.word	0x0800e62c

080048a8 <_writes>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t _writes(void *ip, const uint8_t *bp, size_t n) {
 80048a8:	b580      	push	{r7, lr}
 80048aa:	b086      	sub	sp, #24
 80048ac:	af00      	add	r7, sp, #0
 80048ae:	60f8      	str	r0, [r7, #12]
 80048b0:	60b9      	str	r1, [r7, #8]
 80048b2:	607a      	str	r2, [r7, #4]
  MemoryStream *msp = ip;
 80048b4:	68fb      	ldr	r3, [r7, #12]
 80048b6:	617b      	str	r3, [r7, #20]

  if (msp->size - msp->eos < n)
 80048b8:	697b      	ldr	r3, [r7, #20]
 80048ba:	689a      	ldr	r2, [r3, #8]
 80048bc:	697b      	ldr	r3, [r7, #20]
 80048be:	68db      	ldr	r3, [r3, #12]
 80048c0:	1ad2      	subs	r2, r2, r3
 80048c2:	687b      	ldr	r3, [r7, #4]
 80048c4:	429a      	cmp	r2, r3
 80048c6:	d205      	bcs.n	80048d4 <_writes+0x2c>
    n = msp->size - msp->eos;
 80048c8:	697b      	ldr	r3, [r7, #20]
 80048ca:	689a      	ldr	r2, [r3, #8]
 80048cc:	697b      	ldr	r3, [r7, #20]
 80048ce:	68db      	ldr	r3, [r3, #12]
 80048d0:	1ad3      	subs	r3, r2, r3
 80048d2:	607b      	str	r3, [r7, #4]
  memcpy(msp->buffer + msp->eos, bp, n);
 80048d4:	697b      	ldr	r3, [r7, #20]
 80048d6:	685a      	ldr	r2, [r3, #4]
 80048d8:	697b      	ldr	r3, [r7, #20]
 80048da:	68db      	ldr	r3, [r3, #12]
 80048dc:	4413      	add	r3, r2
 80048de:	4618      	mov	r0, r3
 80048e0:	68b9      	ldr	r1, [r7, #8]
 80048e2:	687a      	ldr	r2, [r7, #4]
 80048e4:	f009 fe4c 	bl	800e580 <memcpy>
  msp->eos += n;
 80048e8:	697b      	ldr	r3, [r7, #20]
 80048ea:	68da      	ldr	r2, [r3, #12]
 80048ec:	687b      	ldr	r3, [r7, #4]
 80048ee:	441a      	add	r2, r3
 80048f0:	697b      	ldr	r3, [r7, #20]
 80048f2:	60da      	str	r2, [r3, #12]
  return n;
 80048f4:	687b      	ldr	r3, [r7, #4]
}
 80048f6:	4618      	mov	r0, r3
 80048f8:	3718      	adds	r7, #24
 80048fa:	46bd      	mov	sp, r7
 80048fc:	bd80      	pop	{r7, pc}
 80048fe:	bf00      	nop

08004900 <_reads>:

static size_t _reads(void *ip, uint8_t *bp, size_t n) {
 8004900:	b580      	push	{r7, lr}
 8004902:	b086      	sub	sp, #24
 8004904:	af00      	add	r7, sp, #0
 8004906:	60f8      	str	r0, [r7, #12]
 8004908:	60b9      	str	r1, [r7, #8]
 800490a:	607a      	str	r2, [r7, #4]
  MemoryStream *msp = ip;
 800490c:	68fb      	ldr	r3, [r7, #12]
 800490e:	617b      	str	r3, [r7, #20]

  if (msp->eos - msp->offset < n)
 8004910:	697b      	ldr	r3, [r7, #20]
 8004912:	68da      	ldr	r2, [r3, #12]
 8004914:	697b      	ldr	r3, [r7, #20]
 8004916:	691b      	ldr	r3, [r3, #16]
 8004918:	1ad2      	subs	r2, r2, r3
 800491a:	687b      	ldr	r3, [r7, #4]
 800491c:	429a      	cmp	r2, r3
 800491e:	d205      	bcs.n	800492c <_reads+0x2c>
    n = msp->eos - msp->offset;
 8004920:	697b      	ldr	r3, [r7, #20]
 8004922:	68da      	ldr	r2, [r3, #12]
 8004924:	697b      	ldr	r3, [r7, #20]
 8004926:	691b      	ldr	r3, [r3, #16]
 8004928:	1ad3      	subs	r3, r2, r3
 800492a:	607b      	str	r3, [r7, #4]
  memcpy(bp, msp->buffer + msp->offset, n);
 800492c:	697b      	ldr	r3, [r7, #20]
 800492e:	685a      	ldr	r2, [r3, #4]
 8004930:	697b      	ldr	r3, [r7, #20]
 8004932:	691b      	ldr	r3, [r3, #16]
 8004934:	4413      	add	r3, r2
 8004936:	68b8      	ldr	r0, [r7, #8]
 8004938:	4619      	mov	r1, r3
 800493a:	687a      	ldr	r2, [r7, #4]
 800493c:	f009 fe20 	bl	800e580 <memcpy>
  msp->offset += n;
 8004940:	697b      	ldr	r3, [r7, #20]
 8004942:	691a      	ldr	r2, [r3, #16]
 8004944:	687b      	ldr	r3, [r7, #4]
 8004946:	441a      	add	r2, r3
 8004948:	697b      	ldr	r3, [r7, #20]
 800494a:	611a      	str	r2, [r3, #16]
  return n;
 800494c:	687b      	ldr	r3, [r7, #4]
}
 800494e:	4618      	mov	r0, r3
 8004950:	3718      	adds	r7, #24
 8004952:	46bd      	mov	sp, r7
 8004954:	bd80      	pop	{r7, pc}
 8004956:	bf00      	nop

08004958 <_put.lto_priv.6>:

static msg_t _put(void *ip, uint8_t b) {
 8004958:	b480      	push	{r7}
 800495a:	b085      	sub	sp, #20
 800495c:	af00      	add	r7, sp, #0
 800495e:	6078      	str	r0, [r7, #4]
 8004960:	460b      	mov	r3, r1
 8004962:	70fb      	strb	r3, [r7, #3]
  MemoryStream *msp = ip;
 8004964:	687b      	ldr	r3, [r7, #4]
 8004966:	60fb      	str	r3, [r7, #12]

  if (msp->size - msp->eos <= 0)
 8004968:	68fb      	ldr	r3, [r7, #12]
 800496a:	689a      	ldr	r2, [r3, #8]
 800496c:	68fb      	ldr	r3, [r7, #12]
 800496e:	68db      	ldr	r3, [r3, #12]
 8004970:	429a      	cmp	r2, r3
 8004972:	d102      	bne.n	800497a <_put.lto_priv.6+0x22>
    return MSG_RESET;
 8004974:	f06f 0301 	mvn.w	r3, #1
 8004978:	e00c      	b.n	8004994 <_put.lto_priv.6+0x3c>
  *(msp->buffer + msp->eos) = b;
 800497a:	68fb      	ldr	r3, [r7, #12]
 800497c:	685a      	ldr	r2, [r3, #4]
 800497e:	68fb      	ldr	r3, [r7, #12]
 8004980:	68db      	ldr	r3, [r3, #12]
 8004982:	4413      	add	r3, r2
 8004984:	78fa      	ldrb	r2, [r7, #3]
 8004986:	701a      	strb	r2, [r3, #0]
  msp->eos += 1;
 8004988:	68fb      	ldr	r3, [r7, #12]
 800498a:	68db      	ldr	r3, [r3, #12]
 800498c:	1c5a      	adds	r2, r3, #1
 800498e:	68fb      	ldr	r3, [r7, #12]
 8004990:	60da      	str	r2, [r3, #12]
  return MSG_OK;
 8004992:	2300      	movs	r3, #0
}
 8004994:	4618      	mov	r0, r3
 8004996:	3714      	adds	r7, #20
 8004998:	46bd      	mov	sp, r7
 800499a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800499e:	4770      	bx	lr

080049a0 <_get.lto_priv.4>:

static msg_t _get(void *ip) {
 80049a0:	b480      	push	{r7}
 80049a2:	b085      	sub	sp, #20
 80049a4:	af00      	add	r7, sp, #0
 80049a6:	6078      	str	r0, [r7, #4]
  uint8_t b;
  MemoryStream *msp = ip;
 80049a8:	687b      	ldr	r3, [r7, #4]
 80049aa:	60fb      	str	r3, [r7, #12]

  if (msp->eos - msp->offset <= 0)
 80049ac:	68fb      	ldr	r3, [r7, #12]
 80049ae:	68da      	ldr	r2, [r3, #12]
 80049b0:	68fb      	ldr	r3, [r7, #12]
 80049b2:	691b      	ldr	r3, [r3, #16]
 80049b4:	429a      	cmp	r2, r3
 80049b6:	d102      	bne.n	80049be <_get.lto_priv.4+0x1e>
    return MSG_RESET;
 80049b8:	f06f 0301 	mvn.w	r3, #1
 80049bc:	e00c      	b.n	80049d8 <_get.lto_priv.4+0x38>
  b = *(msp->buffer + msp->offset);
 80049be:	68fb      	ldr	r3, [r7, #12]
 80049c0:	685a      	ldr	r2, [r3, #4]
 80049c2:	68fb      	ldr	r3, [r7, #12]
 80049c4:	691b      	ldr	r3, [r3, #16]
 80049c6:	4413      	add	r3, r2
 80049c8:	781b      	ldrb	r3, [r3, #0]
 80049ca:	72fb      	strb	r3, [r7, #11]
  msp->offset += 1;
 80049cc:	68fb      	ldr	r3, [r7, #12]
 80049ce:	691b      	ldr	r3, [r3, #16]
 80049d0:	1c5a      	adds	r2, r3, #1
 80049d2:	68fb      	ldr	r3, [r7, #12]
 80049d4:	611a      	str	r2, [r3, #16]
  return b;
 80049d6:	7afb      	ldrb	r3, [r7, #11]
}
 80049d8:	4618      	mov	r0, r3
 80049da:	3714      	adds	r7, #20
 80049dc:	46bd      	mov	sp, r7
 80049de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80049e2:	4770      	bx	lr

080049e4 <msObjectInit>:
 * @param[in] eos       initial End Of Stream offset. Normally you need to
 *                      put this to zero for RAM buffers or equal to @p size
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {
 80049e4:	b480      	push	{r7}
 80049e6:	b085      	sub	sp, #20
 80049e8:	af00      	add	r7, sp, #0
 80049ea:	60f8      	str	r0, [r7, #12]
 80049ec:	60b9      	str	r1, [r7, #8]
 80049ee:	607a      	str	r2, [r7, #4]
 80049f0:	603b      	str	r3, [r7, #0]

  msp->vmt    = &vmt;
 80049f2:	68fb      	ldr	r3, [r7, #12]
 80049f4:	4a09      	ldr	r2, [pc, #36]	; (8004a1c <msObjectInit+0x38>)
 80049f6:	601a      	str	r2, [r3, #0]
  msp->buffer = buffer;
 80049f8:	68fb      	ldr	r3, [r7, #12]
 80049fa:	68ba      	ldr	r2, [r7, #8]
 80049fc:	605a      	str	r2, [r3, #4]
  msp->size   = size;
 80049fe:	68fb      	ldr	r3, [r7, #12]
 8004a00:	687a      	ldr	r2, [r7, #4]
 8004a02:	609a      	str	r2, [r3, #8]
  msp->eos    = eos;
 8004a04:	68fb      	ldr	r3, [r7, #12]
 8004a06:	683a      	ldr	r2, [r7, #0]
 8004a08:	60da      	str	r2, [r3, #12]
  msp->offset = 0;
 8004a0a:	68fb      	ldr	r3, [r7, #12]
 8004a0c:	2200      	movs	r2, #0
 8004a0e:	611a      	str	r2, [r3, #16]
}
 8004a10:	3714      	adds	r7, #20
 8004a12:	46bd      	mov	sp, r7
 8004a14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004a18:	4770      	bx	lr
 8004a1a:	bf00      	nop
 8004a1c:	0800ece8 	.word	0x0800ece8

08004a20 <_uavcan_set_node_id.lto_priv.97>:

uint8_t uavcan_get_node_id(uint8_t uavcan_idx) {
    return _uavcan_get_node_id(uavcan_get_instance(uavcan_idx));
}

static void _uavcan_set_node_id(struct uavcan_instance_s* instance, uint8_t node_id) {
 8004a20:	b580      	push	{r7, lr}
 8004a22:	b082      	sub	sp, #8
 8004a24:	af00      	add	r7, sp, #0
 8004a26:	6078      	str	r0, [r7, #4]
 8004a28:	460b      	mov	r3, r1
 8004a2a:	70fb      	strb	r3, [r7, #3]
    if (!instance) {
 8004a2c:	687b      	ldr	r3, [r7, #4]
 8004a2e:	2b00      	cmp	r3, #0
 8004a30:	d017      	beq.n	8004a62 <_uavcan_set_node_id.lto_priv.97+0x42>
        return;
    }

    can_set_auto_retransmit_mode(instance->can_instance, node_id != 0);
 8004a32:	687b      	ldr	r3, [r7, #4]
 8004a34:	685a      	ldr	r2, [r3, #4]
 8004a36:	78fb      	ldrb	r3, [r7, #3]
 8004a38:	2b00      	cmp	r3, #0
 8004a3a:	bf14      	ite	ne
 8004a3c:	2301      	movne	r3, #1
 8004a3e:	2300      	moveq	r3, #0
 8004a40:	b2db      	uxtb	r3, r3
 8004a42:	4610      	mov	r0, r2
 8004a44:	4619      	mov	r1, r3
 8004a46:	f003 f81b 	bl	8007a80 <can_set_auto_retransmit_mode>
    chSysLock();
 8004a4a:	f001 fc8f 	bl	800636c <chSysLock.lto_priv.77>
    canardSetLocalNodeID(&instance->canard, node_id);
 8004a4e:	687b      	ldr	r3, [r7, #4]
 8004a50:	f103 0208 	add.w	r2, r3, #8
 8004a54:	78fb      	ldrb	r3, [r7, #3]
 8004a56:	4610      	mov	r0, r2
 8004a58:	4619      	mov	r1, r3
 8004a5a:	f008 f81d 	bl	800ca98 <canardSetLocalNodeID>
    chSysUnlock();
 8004a5e:	f001 fc8d 	bl	800637c <chSysUnlock.lto_priv.76>
}
 8004a62:	3708      	adds	r7, #8
 8004a64:	46bd      	mov	sp, r7
 8004a66:	bd80      	pop	{r7, pc}

08004a68 <uavcan_set_node_id>:

void uavcan_set_node_id(uint8_t uavcan_idx, uint8_t node_id) {
 8004a68:	b580      	push	{r7, lr}
 8004a6a:	b082      	sub	sp, #8
 8004a6c:	af00      	add	r7, sp, #0
 8004a6e:	4603      	mov	r3, r0
 8004a70:	460a      	mov	r2, r1
 8004a72:	71fb      	strb	r3, [r7, #7]
 8004a74:	4613      	mov	r3, r2
 8004a76:	71bb      	strb	r3, [r7, #6]
    return _uavcan_set_node_id(uavcan_get_instance(uavcan_idx), node_id);
 8004a78:	79fb      	ldrb	r3, [r7, #7]
 8004a7a:	4618      	mov	r0, r3
 8004a7c:	f000 fb20 	bl	80050c0 <uavcan_get_instance.lto_priv.96>
 8004a80:	4602      	mov	r2, r0
 8004a82:	79bb      	ldrb	r3, [r7, #6]
 8004a84:	4610      	mov	r0, r2
 8004a86:	4619      	mov	r1, r3
 8004a88:	f7ff ffca 	bl	8004a20 <_uavcan_set_node_id.lto_priv.97>
}
 8004a8c:	3708      	adds	r7, #8
 8004a8e:	46bd      	mov	sp, r7
 8004a90:	bd80      	pop	{r7, pc}
 8004a92:	bf00      	nop

08004a94 <copy_bit_array>:

/**
 * Bit array copy routine, originally developed by Ben Dyer for Libuavcan. Thanks Ben.
 */

static void __attribute__((optimize("O3"))) copy_bit_array(const uint8_t* src, uint32_t src_offset, uint32_t src_len, uint8_t* dst, uint32_t dst_offset) {
 8004a94:	e92d 4f70 	stmdb	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}
    // Normalizing inputs
    src += src_offset / 8;
    dst += dst_offset / 8;

    src_offset %= 8;
 8004a98:	f001 0607 	and.w	r6, r1, #7

/**
 * Bit array copy routine, originally developed by Ben Dyer for Libuavcan. Thanks Ben.
 */

static void __attribute__((optimize("O3"))) copy_bit_array(const uint8_t* src, uint32_t src_offset, uint32_t src_len, uint8_t* dst, uint32_t dst_offset) {
 8004a9c:	9c08      	ldr	r4, [sp, #32]
    dst += dst_offset / 8;

    src_offset %= 8;
    dst_offset %= 8;

    const size_t last_bit = src_offset + src_len;
 8004a9e:	4432      	add	r2, r6
    while (last_bit - src_offset)
 8004aa0:	4296      	cmp	r6, r2
 * Bit array copy routine, originally developed by Ben Dyer for Libuavcan. Thanks Ben.
 */

static void __attribute__((optimize("O3"))) copy_bit_array(const uint8_t* src, uint32_t src_offset, uint32_t src_len, uint8_t* dst, uint32_t dst_offset) {
    // Normalizing inputs
    src += src_offset / 8;
 8004aa2:	ea4f 01d1 	mov.w	r1, r1, lsr #3
    dst += dst_offset / 8;
 8004aa6:	ea4f 09d4 	mov.w	r9, r4, lsr #3

    src_offset %= 8;
    dst_offset %= 8;
 8004aaa:	f004 0c07 	and.w	ip, r4, #7

    const size_t last_bit = src_offset + src_len;
    while (last_bit - src_offset)
 8004aae:	d02d      	beq.n	8004b0c <copy_bit_array+0x78>
 8004ab0:	4408      	add	r0, r1
        const uint8_t dst_bit_offset = (uint8_t)(dst_offset % 8U);

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
 8004ab2:	f44f 417f 	mov.w	r1, #65280	; 0xff00
    dst_offset %= 8;

    const size_t last_bit = src_offset + src_len;
    while (last_bit - src_offset)
    {
        const uint8_t src_bit_offset = (uint8_t)(src_offset % 8U);
 8004ab6:	f006 0b07 	and.w	fp, r6, #7
        const uint8_t dst_bit_offset = (uint8_t)(dst_offset % 8U);
 8004aba:	f00c 0507 	and.w	r5, ip, #7

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);
 8004abe:	455d      	cmp	r5, fp
 8004ac0:	462c      	mov	r4, r5
 8004ac2:	bf38      	it	cc
 8004ac4:	465c      	movcc	r4, fp
 8004ac6:	ebc6 0e02 	rsb	lr, r6, r2
 8004aca:	f1c4 0408 	rsb	r4, r4, #8
 8004ace:	45a6      	cmp	lr, r4
 8004ad0:	bf28      	it	cs
 8004ad2:	46a6      	movcs	lr, r4

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);
 8004ad4:	08f4      	lsrs	r4, r6, #3
 8004ad6:	f810 a004 	ldrb.w	sl, [r0, r4]
 8004ada:	eb09 08dc 	add.w	r8, r9, ip, lsr #3
        const uint8_t dst_bit_offset = (uint8_t)(dst_offset % 8U);

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
 8004ade:	fa21 f40e 	lsr.w	r4, r1, lr
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);
 8004ae2:	fa0a fa0b 	lsl.w	sl, sl, fp
 8004ae6:	b2e4      	uxtb	r4, r4

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));
 8004ae8:	f813 b008 	ldrb.w	fp, [r3, r8]

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);
 8004aec:	fa4a fa05 	asr.w	sl, sl, r5
        const uint8_t dst_bit_offset = (uint8_t)(dst_offset % 8U);

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
 8004af0:	fa44 f505 	asr.w	r5, r4, r5
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));
 8004af4:	ea05 0a0a 	and.w	sl, r5, sl
 8004af8:	ea2b 0405 	bic.w	r4, fp, r5

        src_offset += copy_bits;
 8004afc:	4476      	add	r6, lr
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));
 8004afe:	ea4a 0404 	orr.w	r4, sl, r4

    src_offset %= 8;
    dst_offset %= 8;

    const size_t last_bit = src_offset + src_len;
    while (last_bit - src_offset)
 8004b02:	42b2      	cmp	r2, r6
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));

        src_offset += copy_bits;
        dst_offset += copy_bits;
 8004b04:	44f4      	add	ip, lr
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));
 8004b06:	f803 4008 	strb.w	r4, [r3, r8]

    src_offset %= 8;
    dst_offset %= 8;

    const size_t last_bit = src_offset + src_len;
    while (last_bit - src_offset)
 8004b0a:	d1d4      	bne.n	8004ab6 <copy_bit_array+0x22>
 8004b0c:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}

08004b10 <uavcan_transmit_chunk_handler>:
}

static void __attribute__((optimize("O3"))) uavcan_transmit_chunk_handler(uint8_t* chunk, size_t bitlen, void* ctx) {
    struct uavcan_transmit_state_s* tx_state = ctx;

    if (tx_state->failed || bitlen == 0) {
 8004b10:	7813      	ldrb	r3, [r2, #0]
 8004b12:	2b00      	cmp	r3, #0
 8004b14:	d146      	bne.n	8004ba4 <uavcan_transmit_chunk_handler+0x94>
 8004b16:	2900      	cmp	r1, #0
 8004b18:	d044      	beq.n	8004ba4 <uavcan_transmit_chunk_handler+0x94>
        src_offset += copy_bits;
        dst_offset += copy_bits;
    }
}

static void __attribute__((optimize("O3"))) uavcan_transmit_chunk_handler(uint8_t* chunk, size_t bitlen, void* ctx) {
 8004b1a:	e92d 4f70 	stmdb	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}

    if (tx_state->failed || bitlen == 0) {
        return;
    }

    if (!tx_state->frame_list_tail) {
 8004b1e:	68d4      	ldr	r4, [r2, #12]
        src_offset += copy_bits;
        dst_offset += copy_bits;
    }
}

static void __attribute__((optimize("O3"))) uavcan_transmit_chunk_handler(uint8_t* chunk, size_t bitlen, void* ctx) {
 8004b20:	b082      	sub	sp, #8
 8004b22:	460e      	mov	r6, r1
 8004b24:	4680      	mov	r8, r0
 8004b26:	4615      	mov	r5, r2

    if (tx_state->failed || bitlen == 0) {
        return;
    }

    if (!tx_state->frame_list_tail) {
 8004b28:	2c00      	cmp	r4, #0
 8004b2a:	d050      	beq.n	8004bce <uavcan_transmit_chunk_handler+0xbe>
        src_offset += copy_bits;
        dst_offset += copy_bits;
    }
}

static void __attribute__((optimize("O3"))) uavcan_transmit_chunk_handler(uint8_t* chunk, size_t bitlen, void* ctx) {
 8004b2c:	f04f 0b00 	mov.w	fp, #0

    while (chunk_bit_ofs < bitlen) {
        size_t frame_copy_bits = MIN(bitlen-chunk_bit_ofs, 7*8-tx_state->frame_bit_ofs);
        if (frame_copy_bits == 0) {
            bool make_room_for_crc = tx_state->frame_list_head->next == NULL;
            tx_state->frame_list_tail = can_allocate_tx_frame_and_append(tx_state->instance->can_instance, &tx_state->frame_list_head);
 8004b30:	f105 0a08 	add.w	sl, r5, #8
 8004b34:	e017      	b.n	8004b66 <uavcan_transmit_chunk_handler+0x56>
 8004b36:	686a      	ldr	r2, [r5, #4]
    size_t chunk_bit_ofs = 0;

    while (chunk_bit_ofs < bitlen) {
        size_t frame_copy_bits = MIN(bitlen-chunk_bit_ofs, 7*8-tx_state->frame_bit_ofs);
        if (frame_copy_bits == 0) {
            bool make_room_for_crc = tx_state->frame_list_head->next == NULL;
 8004b38:	68ab      	ldr	r3, [r5, #8]
            tx_state->frame_list_tail = can_allocate_tx_frame_and_append(tx_state->instance->can_instance, &tx_state->frame_list_head);
 8004b3a:	6850      	ldr	r0, [r2, #4]
 8004b3c:	4651      	mov	r1, sl
    size_t chunk_bit_ofs = 0;

    while (chunk_bit_ofs < bitlen) {
        size_t frame_copy_bits = MIN(bitlen-chunk_bit_ofs, 7*8-tx_state->frame_bit_ofs);
        if (frame_copy_bits == 0) {
            bool make_room_for_crc = tx_state->frame_list_head->next == NULL;
 8004b3e:	f8d3 9018 	ldr.w	r9, [r3, #24]
            tx_state->frame_list_tail = can_allocate_tx_frame_and_append(tx_state->instance->can_instance, &tx_state->frame_list_head);
 8004b42:	f000 ff43 	bl	80059cc <can_allocate_tx_frame_and_append>
 8004b46:	60e8      	str	r0, [r5, #12]
            if (!tx_state->frame_list_tail) {
 8004b48:	b368      	cbz	r0, 8004ba6 <uavcan_transmit_chunk_handler+0x96>
                tx_state->failed = true;
                return;
            }
            memset(tx_state->frame_list_tail->content.data, 0, 8);
 8004b4a:	7204      	strb	r4, [r0, #8]
 8004b4c:	7244      	strb	r4, [r0, #9]
 8004b4e:	7284      	strb	r4, [r0, #10]
 8004b50:	72c4      	strb	r4, [r0, #11]
 8004b52:	7304      	strb	r4, [r0, #12]
 8004b54:	7344      	strb	r4, [r0, #13]
 8004b56:	7384      	strb	r4, [r0, #14]
 8004b58:	73c4      	strb	r4, [r0, #15]
            if (make_room_for_crc) {
 8004b5a:	f1b9 0f00 	cmp.w	r9, #0
 8004b5e:	d027      	beq.n	8004bb0 <uavcan_transmit_chunk_handler+0xa0>
                memcpy(tx_state->frame_list_tail->content.data, &tx_state->frame_list_head->content.data[5], 2);
                memmove(&tx_state->frame_list_head->content.data[2], tx_state->frame_list_head->content.data, 5);
                tx_state->frame_bit_ofs = 16;
            } else {
                tx_state->frame_bit_ofs = 0;
 8004b60:	612c      	str	r4, [r5, #16]
        memset(tx_state->frame_list_tail->content.data, 0, 8);
    }

    size_t chunk_bit_ofs = 0;

    while (chunk_bit_ofs < bitlen) {
 8004b62:	455e      	cmp	r6, fp
 8004b64:	d921      	bls.n	8004baa <uavcan_transmit_chunk_handler+0x9a>
        size_t frame_copy_bits = MIN(bitlen-chunk_bit_ofs, 7*8-tx_state->frame_bit_ofs);
 8004b66:	692a      	ldr	r2, [r5, #16]
 8004b68:	ebcb 0406 	rsb	r4, fp, r6
 8004b6c:	f1c2 0338 	rsb	r3, r2, #56	; 0x38
 8004b70:	429c      	cmp	r4, r3
 8004b72:	bf28      	it	cs
 8004b74:	461c      	movcs	r4, r3
        if (frame_copy_bits == 0) {
 8004b76:	2c00      	cmp	r4, #0
 8004b78:	d0dd      	beq.n	8004b36 <uavcan_transmit_chunk_handler+0x26>
                tx_state->frame_bit_ofs = 0;
            }
            continue;
        }

        copy_bit_array(chunk, chunk_bit_ofs, frame_copy_bits, tx_state->frame_list_tail->content.data, tx_state->frame_bit_ofs);
 8004b7a:	68eb      	ldr	r3, [r5, #12]
 8004b7c:	4659      	mov	r1, fp
 8004b7e:	9200      	str	r2, [sp, #0]
 8004b80:	3308      	adds	r3, #8
 8004b82:	4622      	mov	r2, r4
 8004b84:	4640      	mov	r0, r8
 8004b86:	f7ff ff85 	bl	8004a94 <copy_bit_array>
        chunk_bit_ofs += frame_copy_bits;
        tx_state->frame_bit_ofs += frame_copy_bits;
 8004b8a:	692b      	ldr	r3, [r5, #16]
        tx_state->frame_list_tail->content.DLC = (tx_state->frame_bit_ofs+7)/8 + 1;
 8004b8c:	68ea      	ldr	r2, [r5, #12]
            continue;
        }

        copy_bit_array(chunk, chunk_bit_ofs, frame_copy_bits, tx_state->frame_list_tail->content.data, tx_state->frame_bit_ofs);
        chunk_bit_ofs += frame_copy_bits;
        tx_state->frame_bit_ofs += frame_copy_bits;
 8004b8e:	4423      	add	r3, r4
 8004b90:	612b      	str	r3, [r5, #16]
        tx_state->frame_list_tail->content.DLC = (tx_state->frame_bit_ofs+7)/8 + 1;
 8004b92:	3307      	adds	r3, #7
 8004b94:	7811      	ldrb	r1, [r2, #0]
 8004b96:	08db      	lsrs	r3, r3, #3
 8004b98:	3301      	adds	r3, #1
 8004b9a:	f363 0185 	bfi	r1, r3, #2, #4
            }
            continue;
        }

        copy_bit_array(chunk, chunk_bit_ofs, frame_copy_bits, tx_state->frame_list_tail->content.data, tx_state->frame_bit_ofs);
        chunk_bit_ofs += frame_copy_bits;
 8004b9e:	44a3      	add	fp, r4
        tx_state->frame_bit_ofs += frame_copy_bits;
        tx_state->frame_list_tail->content.DLC = (tx_state->frame_bit_ofs+7)/8 + 1;
 8004ba0:	7011      	strb	r1, [r2, #0]
 8004ba2:	e7de      	b.n	8004b62 <uavcan_transmit_chunk_handler+0x52>
 8004ba4:	4770      	bx	lr
    }

    if (!tx_state->frame_list_tail) {
        tx_state->frame_list_tail = can_allocate_tx_frame_and_append(tx_state->instance->can_instance, &tx_state->frame_list_head);
        if (!tx_state->frame_list_tail) {
            tx_state->failed = true;
 8004ba6:	2301      	movs	r3, #1
 8004ba8:	702b      	strb	r3, [r5, #0]
        copy_bit_array(chunk, chunk_bit_ofs, frame_copy_bits, tx_state->frame_list_tail->content.data, tx_state->frame_bit_ofs);
        chunk_bit_ofs += frame_copy_bits;
        tx_state->frame_bit_ofs += frame_copy_bits;
        tx_state->frame_list_tail->content.DLC = (tx_state->frame_bit_ofs+7)/8 + 1;
    }
}
 8004baa:	b002      	add	sp, #8
 8004bac:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}
                tx_state->failed = true;
                return;
            }
            memset(tx_state->frame_list_tail->content.data, 0, 8);
            if (make_room_for_crc) {
                memcpy(tx_state->frame_list_tail->content.data, &tx_state->frame_list_head->content.data[5], 2);
 8004bb0:	68aa      	ldr	r2, [r5, #8]
 8004bb2:	68eb      	ldr	r3, [r5, #12]
 8004bb4:	f8b2 100d 	ldrh.w	r1, [r2, #13]
                memmove(&tx_state->frame_list_head->content.data[2], tx_state->frame_list_head->content.data, 5);
 8004bb8:	2205      	movs	r2, #5
                tx_state->failed = true;
                return;
            }
            memset(tx_state->frame_list_tail->content.data, 0, 8);
            if (make_room_for_crc) {
                memcpy(tx_state->frame_list_tail->content.data, &tx_state->frame_list_head->content.data[5], 2);
 8004bba:	8119      	strh	r1, [r3, #8]
                memmove(&tx_state->frame_list_head->content.data[2], tx_state->frame_list_head->content.data, 5);
 8004bbc:	68a9      	ldr	r1, [r5, #8]
 8004bbe:	f101 000a 	add.w	r0, r1, #10
 8004bc2:	3108      	adds	r1, #8
 8004bc4:	f009 fce7 	bl	800e596 <memmove>
                tx_state->frame_bit_ofs = 16;
 8004bc8:	2310      	movs	r3, #16
 8004bca:	612b      	str	r3, [r5, #16]
 8004bcc:	e7c9      	b.n	8004b62 <uavcan_transmit_chunk_handler+0x52>
    if (tx_state->failed || bitlen == 0) {
        return;
    }

    if (!tx_state->frame_list_tail) {
        tx_state->frame_list_tail = can_allocate_tx_frame_and_append(tx_state->instance->can_instance, &tx_state->frame_list_head);
 8004bce:	6853      	ldr	r3, [r2, #4]
 8004bd0:	f102 0108 	add.w	r1, r2, #8
 8004bd4:	6858      	ldr	r0, [r3, #4]
 8004bd6:	f000 fef9 	bl	80059cc <can_allocate_tx_frame_and_append>
 8004bda:	60e8      	str	r0, [r5, #12]
        if (!tx_state->frame_list_tail) {
 8004bdc:	2800      	cmp	r0, #0
 8004bde:	d0e2      	beq.n	8004ba6 <uavcan_transmit_chunk_handler+0x96>
            tx_state->failed = true;
            return;
        }
        memset(tx_state->frame_list_tail->content.data, 0, 8);
 8004be0:	7204      	strb	r4, [r0, #8]
 8004be2:	7244      	strb	r4, [r0, #9]
 8004be4:	7284      	strb	r4, [r0, #10]
 8004be6:	72c4      	strb	r4, [r0, #11]
 8004be8:	7304      	strb	r4, [r0, #12]
 8004bea:	7344      	strb	r4, [r0, #13]
 8004bec:	7384      	strb	r4, [r0, #14]
 8004bee:	73c4      	strb	r4, [r0, #15]
 8004bf0:	e79c      	b.n	8004b2c <uavcan_transmit_chunk_handler+0x1c>
 8004bf2:	bf00      	nop

08004bf4 <_uavcan_send>:
        tx_state->frame_bit_ofs += frame_copy_bits;
        tx_state->frame_list_tail->content.DLC = (tx_state->frame_bit_ofs+7)/8 + 1;
    }
}

static bool _uavcan_send(struct uavcan_instance_s* instance, const struct uavcan_message_descriptor_s* const msg_descriptor, uint16_t data_type_id, uint8_t priority, uint8_t transfer_id, uint8_t dest_node_id, void* msg_data) {
 8004bf4:	b580      	push	{r7, lr}
 8004bf6:	b08e      	sub	sp, #56	; 0x38
 8004bf8:	af00      	add	r7, sp, #0
 8004bfa:	60f8      	str	r0, [r7, #12]
 8004bfc:	60b9      	str	r1, [r7, #8]
 8004bfe:	4611      	mov	r1, r2
 8004c00:	461a      	mov	r2, r3
 8004c02:	460b      	mov	r3, r1
 8004c04:	80fb      	strh	r3, [r7, #6]
 8004c06:	4613      	mov	r3, r2
 8004c08:	717b      	strb	r3, [r7, #5]
    if (!instance || !msg_descriptor || !msg_descriptor->serializer_func || !msg_data) {
 8004c0a:	68fb      	ldr	r3, [r7, #12]
 8004c0c:	2b00      	cmp	r3, #0
 8004c0e:	d009      	beq.n	8004c24 <_uavcan_send+0x30>
 8004c10:	68bb      	ldr	r3, [r7, #8]
 8004c12:	2b00      	cmp	r3, #0
 8004c14:	d006      	beq.n	8004c24 <_uavcan_send+0x30>
 8004c16:	68bb      	ldr	r3, [r7, #8]
 8004c18:	695b      	ldr	r3, [r3, #20]
 8004c1a:	2b00      	cmp	r3, #0
 8004c1c:	d002      	beq.n	8004c24 <_uavcan_send+0x30>
 8004c1e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8004c20:	2b00      	cmp	r3, #0
 8004c22:	d101      	bne.n	8004c28 <_uavcan_send+0x34>
        return false;
 8004c24:	2300      	movs	r3, #0
 8004c26:	e183      	b.n	8004f30 <_uavcan_send+0x33c>
    }

    if (_uavcan_get_node_id(instance) == 0 && (data_type_id > 0b11 || msg_descriptor->transfer_type != CanardTransferTypeBroadcast)) {
 8004c28:	68f8      	ldr	r0, [r7, #12]
 8004c2a:	f001 fdb7 	bl	800679c <_uavcan_get_node_id.lto_priv.78>
 8004c2e:	4603      	mov	r3, r0
 8004c30:	2b00      	cmp	r3, #0
 8004c32:	d108      	bne.n	8004c46 <_uavcan_send+0x52>
 8004c34:	88fb      	ldrh	r3, [r7, #6]
 8004c36:	2b03      	cmp	r3, #3
 8004c38:	d803      	bhi.n	8004c42 <_uavcan_send+0x4e>
 8004c3a:	68bb      	ldr	r3, [r7, #8]
 8004c3c:	7a9b      	ldrb	r3, [r3, #10]
 8004c3e:	2b02      	cmp	r3, #2
 8004c40:	d001      	beq.n	8004c46 <_uavcan_send+0x52>
        return false;
 8004c42:	2300      	movs	r3, #0
 8004c44:	e174      	b.n	8004f30 <_uavcan_send+0x33c>
    }

    if (msg_descriptor->transfer_type != CanardTransferTypeBroadcast && data_type_id > 0xff) {
 8004c46:	68bb      	ldr	r3, [r7, #8]
 8004c48:	7a9b      	ldrb	r3, [r3, #10]
 8004c4a:	2b02      	cmp	r3, #2
 8004c4c:	d004      	beq.n	8004c58 <_uavcan_send+0x64>
 8004c4e:	88fb      	ldrh	r3, [r7, #6]
 8004c50:	2bff      	cmp	r3, #255	; 0xff
 8004c52:	d901      	bls.n	8004c58 <_uavcan_send+0x64>
        return false;
 8004c54:	2300      	movs	r3, #0
 8004c56:	e16b      	b.n	8004f30 <_uavcan_send+0x33c>
    }

    if (_uavcan_get_node_id(instance) > 127) {
 8004c58:	68f8      	ldr	r0, [r7, #12]
 8004c5a:	f001 fd9f 	bl	800679c <_uavcan_get_node_id.lto_priv.78>
 8004c5e:	4603      	mov	r3, r0
 8004c60:	b2db      	uxtb	r3, r3
 8004c62:	b25b      	sxtb	r3, r3
 8004c64:	2b00      	cmp	r3, #0
 8004c66:	da01      	bge.n	8004c6c <_uavcan_send+0x78>
        return false;
 8004c68:	2300      	movs	r3, #0
 8004c6a:	e161      	b.n	8004f30 <_uavcan_send+0x33c>
    }

    struct uavcan_transmit_state_s tx_state = {
 8004c6c:	2300      	movs	r3, #0
 8004c6e:	763b      	strb	r3, [r7, #24]
 8004c70:	68fb      	ldr	r3, [r7, #12]
 8004c72:	61fb      	str	r3, [r7, #28]
 8004c74:	2300      	movs	r3, #0
 8004c76:	623b      	str	r3, [r7, #32]
 8004c78:	2300      	movs	r3, #0
 8004c7a:	627b      	str	r3, [r7, #36]	; 0x24
 8004c7c:	2300      	movs	r3, #0
 8004c7e:	62bb      	str	r3, [r7, #40]	; 0x28
        false, instance, NULL, NULL, 0
    };

    msg_descriptor->serializer_func(msg_data, uavcan_transmit_chunk_handler, &tx_state);
 8004c80:	68bb      	ldr	r3, [r7, #8]
 8004c82:	695b      	ldr	r3, [r3, #20]
 8004c84:	f107 0218 	add.w	r2, r7, #24
 8004c88:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8004c8a:	49ab      	ldr	r1, [pc, #684]	; (8004f38 <_uavcan_send+0x344>)
 8004c8c:	4798      	blx	r3
    if (tx_state.failed || !tx_state.frame_list_head) {
 8004c8e:	7e3b      	ldrb	r3, [r7, #24]
 8004c90:	2b00      	cmp	r3, #0
 8004c92:	d102      	bne.n	8004c9a <_uavcan_send+0xa6>
 8004c94:	6a3b      	ldr	r3, [r7, #32]
 8004c96:	2b00      	cmp	r3, #0
 8004c98:	d10a      	bne.n	8004cb0 <_uavcan_send+0xbc>
        can_free_tx_frames(instance->can_instance, &tx_state.frame_list_head);
 8004c9a:	68fb      	ldr	r3, [r7, #12]
 8004c9c:	685a      	ldr	r2, [r3, #4]
 8004c9e:	f107 0318 	add.w	r3, r7, #24
 8004ca2:	3308      	adds	r3, #8
 8004ca4:	4610      	mov	r0, r2
 8004ca6:	4619      	mov	r1, r3
 8004ca8:	f000 fee2 	bl	8005a70 <can_free_tx_frames>
        return false;
 8004cac:	2300      	movs	r3, #0
 8004cae:	e13f      	b.n	8004f30 <_uavcan_send+0x33c>
    }

    /* debug message */
    LED_ON;
 8004cb0:	4ba2      	ldr	r3, [pc, #648]	; (8004f3c <_uavcan_send+0x348>)
 8004cb2:	2202      	movs	r2, #2
 8004cb4:	611a      	str	r2, [r3, #16]
    chnWrite(&SD1, (const uint8_t *)"snd\n", 5);
 8004cb6:	4ba2      	ldr	r3, [pc, #648]	; (8004f40 <_uavcan_send+0x34c>)
 8004cb8:	681b      	ldr	r3, [r3, #0]
 8004cba:	681b      	ldr	r3, [r3, #0]
 8004cbc:	48a0      	ldr	r0, [pc, #640]	; (8004f40 <_uavcan_send+0x34c>)
 8004cbe:	49a1      	ldr	r1, [pc, #644]	; (8004f44 <_uavcan_send+0x350>)
 8004cc0:	2205      	movs	r2, #5
 8004cc2:	4798      	blx	r3

    uint32_t can_id = 0;
 8004cc4:	2300      	movs	r3, #0
 8004cc6:	637b      	str	r3, [r7, #52]	; 0x34
    can_id |= (uint32_t)(priority&0x1f) << 24;
 8004cc8:	797b      	ldrb	r3, [r7, #5]
 8004cca:	f003 031f 	and.w	r3, r3, #31
 8004cce:	061b      	lsls	r3, r3, #24
 8004cd0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004cd2:	4313      	orrs	r3, r2
 8004cd4:	637b      	str	r3, [r7, #52]	; 0x34
    if (msg_descriptor->transfer_type == CanardTransferTypeBroadcast) {
 8004cd6:	68bb      	ldr	r3, [r7, #8]
 8004cd8:	7a9b      	ldrb	r3, [r3, #10]
 8004cda:	2b02      	cmp	r3, #2
 8004cdc:	d105      	bne.n	8004cea <_uavcan_send+0xf6>
        can_id |= (uint32_t)(data_type_id) << 8;
 8004cde:	88fb      	ldrh	r3, [r7, #6]
 8004ce0:	021b      	lsls	r3, r3, #8
 8004ce2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004ce4:	4313      	orrs	r3, r2
 8004ce6:	637b      	str	r3, [r7, #52]	; 0x34
 8004ce8:	e018      	b.n	8004d1c <_uavcan_send+0x128>
    } else {
        can_id |= data_type_id<<16;
 8004cea:	88fb      	ldrh	r3, [r7, #6]
 8004cec:	041b      	lsls	r3, r3, #16
 8004cee:	461a      	mov	r2, r3
 8004cf0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004cf2:	4313      	orrs	r3, r2
 8004cf4:	637b      	str	r3, [r7, #52]	; 0x34
        if (msg_descriptor->transfer_type == CanardTransferTypeRequest) {
 8004cf6:	68bb      	ldr	r3, [r7, #8]
 8004cf8:	7a9b      	ldrb	r3, [r3, #10]
 8004cfa:	2b01      	cmp	r3, #1
 8004cfc:	d103      	bne.n	8004d06 <_uavcan_send+0x112>
            can_id |= 1<<15;
 8004cfe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004d00:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8004d04:	637b      	str	r3, [r7, #52]	; 0x34
        }
        can_id |= dest_node_id<<8;
 8004d06:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
 8004d0a:	021b      	lsls	r3, r3, #8
 8004d0c:	461a      	mov	r2, r3
 8004d0e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004d10:	4313      	orrs	r3, r2
 8004d12:	637b      	str	r3, [r7, #52]	; 0x34
        can_id |= 1<<7;
 8004d14:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004d16:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004d1a:	637b      	str	r3, [r7, #52]	; 0x34
    }

    if (_uavcan_get_node_id(instance) == 0) {
 8004d1c:	68f8      	ldr	r0, [r7, #12]
 8004d1e:	f001 fd3d 	bl	800679c <_uavcan_get_node_id.lto_priv.78>
 8004d22:	4603      	mov	r3, r0
 8004d24:	2b00      	cmp	r3, #0
 8004d26:	d110      	bne.n	8004d4a <_uavcan_send+0x156>
        can_id |= (uint32_t)(crc16_ccitt(tx_state.frame_list_head->content.data, 7, 0xffff) & 0xfffc)<<8;
 8004d28:	6a3b      	ldr	r3, [r7, #32]
 8004d2a:	3308      	adds	r3, #8
 8004d2c:	4618      	mov	r0, r3
 8004d2e:	2107      	movs	r1, #7
 8004d30:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8004d34:	f002 ff94 	bl	8007c60 <crc16_ccitt>
 8004d38:	4603      	mov	r3, r0
 8004d3a:	461a      	mov	r2, r3
 8004d3c:	f64f 73fc 	movw	r3, #65532	; 0xfffc
 8004d40:	4013      	ands	r3, r2
 8004d42:	021b      	lsls	r3, r3, #8
 8004d44:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004d46:	4313      	orrs	r3, r2
 8004d48:	637b      	str	r3, [r7, #52]	; 0x34
    }

    can_id |= _uavcan_get_node_id(instance);
 8004d4a:	68f8      	ldr	r0, [r7, #12]
 8004d4c:	f001 fd26 	bl	800679c <_uavcan_get_node_id.lto_priv.78>
 8004d50:	4603      	mov	r3, r0
 8004d52:	461a      	mov	r2, r3
 8004d54:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004d56:	4313      	orrs	r3, r2
 8004d58:	637b      	str	r3, [r7, #52]	; 0x34

    uint8_t toggle = 0;
 8004d5a:	2300      	movs	r3, #0
 8004d5c:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    struct can_tx_frame_s* frame = tx_state.frame_list_head;
 8004d60:	6a3b      	ldr	r3, [r7, #32]
 8004d62:	62fb      	str	r3, [r7, #44]	; 0x2c
 8004d64:	e088      	b.n	8004e78 <_uavcan_send+0x284>
    while (frame != NULL) {
        frame->content.IDE = 1;
 8004d66:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004d68:	7813      	ldrb	r3, [r2, #0]
 8004d6a:	f043 0302 	orr.w	r3, r3, #2
 8004d6e:	7013      	strb	r3, [r2, #0]
        frame->content.RTR = 0;
 8004d70:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004d72:	7813      	ldrb	r3, [r2, #0]
 8004d74:	f36f 0300 	bfc	r3, #0, #1
 8004d78:	7013      	strb	r3, [r2, #0]
        frame->content.EID = can_id;
 8004d7a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004d7c:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 8004d80:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004d82:	6853      	ldr	r3, [r2, #4]
 8004d84:	f361 031c 	bfi	r3, r1, #0, #29
 8004d88:	6053      	str	r3, [r2, #4]
        if (frame == tx_state.frame_list_head) {
 8004d8a:	6a3a      	ldr	r2, [r7, #32]
 8004d8c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004d8e:	429a      	cmp	r2, r3
 8004d90:	d115      	bne.n	8004dbe <_uavcan_send+0x1ca>
            frame->content.data[frame->content.DLC-1] |= 1<<7;
 8004d92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004d94:	781b      	ldrb	r3, [r3, #0]
 8004d96:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8004d9a:	b2db      	uxtb	r3, r3
 8004d9c:	3b01      	subs	r3, #1
 8004d9e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004da0:	7812      	ldrb	r2, [r2, #0]
 8004da2:	f3c2 0283 	ubfx	r2, r2, #2, #4
 8004da6:	b2d2      	uxtb	r2, r2
 8004da8:	3a01      	subs	r2, #1
 8004daa:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8004dac:	440a      	add	r2, r1
 8004dae:	7a12      	ldrb	r2, [r2, #8]
 8004db0:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8004db4:	b2d1      	uxtb	r1, r2
 8004db6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004db8:	4413      	add	r3, r2
 8004dba:	460a      	mov	r2, r1
 8004dbc:	721a      	strb	r2, [r3, #8]
        }
        if (frame == tx_state.frame_list_tail) {
 8004dbe:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8004dc0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004dc2:	429a      	cmp	r2, r3
 8004dc4:	d115      	bne.n	8004df2 <_uavcan_send+0x1fe>
            frame->content.data[frame->content.DLC-1] |= 1<<6;
 8004dc6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004dc8:	781b      	ldrb	r3, [r3, #0]
 8004dca:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8004dce:	b2db      	uxtb	r3, r3
 8004dd0:	3b01      	subs	r3, #1
 8004dd2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004dd4:	7812      	ldrb	r2, [r2, #0]
 8004dd6:	f3c2 0283 	ubfx	r2, r2, #2, #4
 8004dda:	b2d2      	uxtb	r2, r2
 8004ddc:	3a01      	subs	r2, #1
 8004dde:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8004de0:	440a      	add	r2, r1
 8004de2:	7a12      	ldrb	r2, [r2, #8]
 8004de4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8004de8:	b2d1      	uxtb	r1, r2
 8004dea:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004dec:	4413      	add	r3, r2
 8004dee:	460a      	mov	r2, r1
 8004df0:	721a      	strb	r2, [r3, #8]
        }
        frame->content.data[frame->content.DLC-1] |= toggle << 5;
 8004df2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004df4:	781b      	ldrb	r3, [r3, #0]
 8004df6:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8004dfa:	b2db      	uxtb	r3, r3
 8004dfc:	3b01      	subs	r3, #1
 8004dfe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004e00:	7812      	ldrb	r2, [r2, #0]
 8004e02:	f3c2 0283 	ubfx	r2, r2, #2, #4
 8004e06:	b2d2      	uxtb	r2, r2
 8004e08:	3a01      	subs	r2, #1
 8004e0a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8004e0c:	440a      	add	r2, r1
 8004e0e:	7a12      	ldrb	r2, [r2, #8]
 8004e10:	b2d1      	uxtb	r1, r2
 8004e12:	f897 2033 	ldrb.w	r2, [r7, #51]	; 0x33
 8004e16:	0152      	lsls	r2, r2, #5
 8004e18:	b2d2      	uxtb	r2, r2
 8004e1a:	430a      	orrs	r2, r1
 8004e1c:	b2d2      	uxtb	r2, r2
 8004e1e:	b2d1      	uxtb	r1, r2
 8004e20:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004e22:	4413      	add	r3, r2
 8004e24:	460a      	mov	r2, r1
 8004e26:	721a      	strb	r2, [r3, #8]
        frame->content.data[frame->content.DLC-1] |= transfer_id&0x1f;
 8004e28:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004e2a:	781b      	ldrb	r3, [r3, #0]
 8004e2c:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8004e30:	b2db      	uxtb	r3, r3
 8004e32:	3b01      	subs	r3, #1
 8004e34:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004e36:	7812      	ldrb	r2, [r2, #0]
 8004e38:	f3c2 0283 	ubfx	r2, r2, #2, #4
 8004e3c:	b2d2      	uxtb	r2, r2
 8004e3e:	3a01      	subs	r2, #1
 8004e40:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8004e42:	440a      	add	r2, r1
 8004e44:	7a12      	ldrb	r2, [r2, #8]
 8004e46:	b2d1      	uxtb	r1, r2
 8004e48:	f897 2040 	ldrb.w	r2, [r7, #64]	; 0x40
 8004e4c:	f002 021f 	and.w	r2, r2, #31
 8004e50:	b2d2      	uxtb	r2, r2
 8004e52:	430a      	orrs	r2, r1
 8004e54:	b2d2      	uxtb	r2, r2
 8004e56:	b2d1      	uxtb	r1, r2
 8004e58:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004e5a:	4413      	add	r3, r2
 8004e5c:	460a      	mov	r2, r1
 8004e5e:	721a      	strb	r2, [r3, #8]

        toggle = toggle?0:1;
 8004e60:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8004e64:	2b00      	cmp	r3, #0
 8004e66:	bf0c      	ite	eq
 8004e68:	2301      	moveq	r3, #1
 8004e6a:	2300      	movne	r3, #0
 8004e6c:	b2db      	uxtb	r3, r3
 8004e6e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

        frame = frame->next;
 8004e72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004e74:	699b      	ldr	r3, [r3, #24]
 8004e76:	62fb      	str	r3, [r7, #44]	; 0x2c

    can_id |= _uavcan_get_node_id(instance);

    uint8_t toggle = 0;
    struct can_tx_frame_s* frame = tx_state.frame_list_head;
    while (frame != NULL) {
 8004e78:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004e7a:	2b00      	cmp	r3, #0
 8004e7c:	f47f af73 	bne.w	8004d66 <_uavcan_send+0x172>
        toggle = toggle?0:1;

        frame = frame->next;
    }

    if (tx_state.frame_list_head != tx_state.frame_list_tail) {
 8004e80:	6a3a      	ldr	r2, [r7, #32]
 8004e82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004e84:	429a      	cmp	r2, r3
 8004e86:	d046      	beq.n	8004f16 <_uavcan_send+0x322>
        uint16_t crc16 = crc16_ccitt((void*)&msg_descriptor->data_type_signature, 8, 0xffff);
 8004e88:	68bb      	ldr	r3, [r7, #8]
 8004e8a:	4618      	mov	r0, r3
 8004e8c:	2108      	movs	r1, #8
 8004e8e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8004e92:	f002 fee5 	bl	8007c60 <crc16_ccitt>
 8004e96:	4603      	mov	r3, r0
 8004e98:	82fb      	strh	r3, [r7, #22]

        frame = tx_state.frame_list_head;
 8004e9a:	6a3b      	ldr	r3, [r7, #32]
 8004e9c:	62fb      	str	r3, [r7, #44]	; 0x2c
        crc16 = crc16_ccitt(&frame->content.data[2], 5, crc16);
 8004e9e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004ea0:	f103 020a 	add.w	r2, r3, #10
 8004ea4:	8afb      	ldrh	r3, [r7, #22]
 8004ea6:	4610      	mov	r0, r2
 8004ea8:	2105      	movs	r1, #5
 8004eaa:	461a      	mov	r2, r3
 8004eac:	f002 fed8 	bl	8007c60 <crc16_ccitt>
 8004eb0:	4603      	mov	r3, r0
 8004eb2:	82fb      	strh	r3, [r7, #22]
        frame = frame->next;
 8004eb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004eb6:	699b      	ldr	r3, [r3, #24]
 8004eb8:	62fb      	str	r3, [r7, #44]	; 0x2c
 8004eba:	e00d      	b.n	8004ed8 <_uavcan_send+0x2e4>

        while (frame->next != NULL) {
            crc16 = crc16_ccitt(&frame->content.data[0], 7, crc16);
 8004ebc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004ebe:	f103 0208 	add.w	r2, r3, #8
 8004ec2:	8afb      	ldrh	r3, [r7, #22]
 8004ec4:	4610      	mov	r0, r2
 8004ec6:	2107      	movs	r1, #7
 8004ec8:	461a      	mov	r2, r3
 8004eca:	f002 fec9 	bl	8007c60 <crc16_ccitt>
 8004ece:	4603      	mov	r3, r0
 8004ed0:	82fb      	strh	r3, [r7, #22]
            frame = frame->next;
 8004ed2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004ed4:	699b      	ldr	r3, [r3, #24]
 8004ed6:	62fb      	str	r3, [r7, #44]	; 0x2c

        frame = tx_state.frame_list_head;
        crc16 = crc16_ccitt(&frame->content.data[2], 5, crc16);
        frame = frame->next;

        while (frame->next != NULL) {
 8004ed8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004eda:	699b      	ldr	r3, [r3, #24]
 8004edc:	2b00      	cmp	r3, #0
 8004ede:	d1ed      	bne.n	8004ebc <_uavcan_send+0x2c8>
            crc16 = crc16_ccitt(&frame->content.data[0], 7, crc16);
            frame = frame->next;
        }
        crc16 = crc16_ccitt(&frame->content.data[0], frame->content.DLC-1, crc16);
 8004ee0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004ee2:	f103 0208 	add.w	r2, r3, #8
 8004ee6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004ee8:	781b      	ldrb	r3, [r3, #0]
 8004eea:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8004eee:	b2db      	uxtb	r3, r3
 8004ef0:	3b01      	subs	r3, #1
 8004ef2:	4619      	mov	r1, r3
 8004ef4:	8afb      	ldrh	r3, [r7, #22]
 8004ef6:	4610      	mov	r0, r2
 8004ef8:	461a      	mov	r2, r3
 8004efa:	f002 feb1 	bl	8007c60 <crc16_ccitt>
 8004efe:	4603      	mov	r3, r0
 8004f00:	82fb      	strh	r3, [r7, #22]
        memcpy(tx_state.frame_list_head->content.data, &crc16, 2);
 8004f02:	6a3b      	ldr	r3, [r7, #32]
 8004f04:	f103 0208 	add.w	r2, r3, #8
 8004f08:	f107 0316 	add.w	r3, r7, #22
 8004f0c:	4610      	mov	r0, r2
 8004f0e:	4619      	mov	r1, r3
 8004f10:	2202      	movs	r2, #2
 8004f12:	f009 fb35 	bl	800e580 <memcpy>
    }

    can_enqueue_tx_frames(instance->can_instance, &tx_state.frame_list_head, TIME_INFINITE, NULL);
 8004f16:	68fb      	ldr	r3, [r7, #12]
 8004f18:	685a      	ldr	r2, [r3, #4]
 8004f1a:	f107 0318 	add.w	r3, r7, #24
 8004f1e:	3308      	adds	r3, #8
 8004f20:	4610      	mov	r0, r2
 8004f22:	4619      	mov	r1, r3
 8004f24:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8004f28:	2300      	movs	r3, #0
 8004f2a:	f000 fd63 	bl	80059f4 <can_enqueue_tx_frames>

    return true;
 8004f2e:	2301      	movs	r3, #1
}
 8004f30:	4618      	mov	r0, r3
 8004f32:	3738      	adds	r7, #56	; 0x38
 8004f34:	46bd      	mov	sp, r7
 8004f36:	bd80      	pop	{r7, pc}
 8004f38:	08004b11 	.word	0x08004b11
 8004f3c:	40010c00 	.word	0x40010c00
 8004f40:	200013ac 	.word	0x200013ac
 8004f44:	0800e634 	.word	0x0800e634

08004f48 <uavcan_broadcast>:

bool uavcan_broadcast(uint8_t uavcan_idx, const struct uavcan_message_descriptor_s* const msg_descriptor, uint8_t priority, void* msg_data) {
 8004f48:	b590      	push	{r4, r7, lr}
 8004f4a:	b08d      	sub	sp, #52	; 0x34
 8004f4c:	af04      	add	r7, sp, #16
 8004f4e:	60b9      	str	r1, [r7, #8]
 8004f50:	607b      	str	r3, [r7, #4]
 8004f52:	4603      	mov	r3, r0
 8004f54:	73fb      	strb	r3, [r7, #15]
 8004f56:	4613      	mov	r3, r2
 8004f58:	73bb      	strb	r3, [r7, #14]
    struct uavcan_instance_s* instance = uavcan_get_instance(uavcan_idx);
 8004f5a:	7bfb      	ldrb	r3, [r7, #15]
 8004f5c:	4618      	mov	r0, r3
 8004f5e:	f000 f8af 	bl	80050c0 <uavcan_get_instance.lto_priv.96>
 8004f62:	61f8      	str	r0, [r7, #28]
    if (!instance) {
 8004f64:	69fb      	ldr	r3, [r7, #28]
 8004f66:	2b00      	cmp	r3, #0
 8004f68:	d101      	bne.n	8004f6e <uavcan_broadcast+0x26>
        return false;
 8004f6a:	2300      	movs	r3, #0
 8004f6c:	e02b      	b.n	8004fc6 <uavcan_broadcast+0x7e>
    }

    uint16_t data_type_id = msg_descriptor->default_data_type_id;
 8004f6e:	68bb      	ldr	r3, [r7, #8]
 8004f70:	891b      	ldrh	r3, [r3, #8]
 8004f72:	837b      	strh	r3, [r7, #26]
    chSysLock();
 8004f74:	f001 f9fa 	bl	800636c <chSysLock.lto_priv.77>
    uint8_t* transfer_id = uavcan_transfer_id_map_retrieve(&instance->transfer_id_map, false, data_type_id, 0);
 8004f78:	69fb      	ldr	r3, [r7, #28]
 8004f7a:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8004f7e:	8b7b      	ldrh	r3, [r7, #26]
 8004f80:	4610      	mov	r0, r2
 8004f82:	2100      	movs	r1, #0
 8004f84:	461a      	mov	r2, r3
 8004f86:	2300      	movs	r3, #0
 8004f88:	f000 fa22 	bl	80053d0 <uavcan_transfer_id_map_retrieve>
 8004f8c:	6178      	str	r0, [r7, #20]
    chSysUnlock();
 8004f8e:	f001 f9f5 	bl	800637c <chSysUnlock.lto_priv.76>
    if(_uavcan_send(instance, msg_descriptor, data_type_id, priority, *transfer_id, 0, msg_data)) {
 8004f92:	697b      	ldr	r3, [r7, #20]
 8004f94:	781b      	ldrb	r3, [r3, #0]
 8004f96:	8b7a      	ldrh	r2, [r7, #26]
 8004f98:	7bbc      	ldrb	r4, [r7, #14]
 8004f9a:	9300      	str	r3, [sp, #0]
 8004f9c:	2300      	movs	r3, #0
 8004f9e:	9301      	str	r3, [sp, #4]
 8004fa0:	687b      	ldr	r3, [r7, #4]
 8004fa2:	9302      	str	r3, [sp, #8]
 8004fa4:	69f8      	ldr	r0, [r7, #28]
 8004fa6:	68b9      	ldr	r1, [r7, #8]
 8004fa8:	4623      	mov	r3, r4
 8004faa:	f7ff fe23 	bl	8004bf4 <_uavcan_send>
 8004fae:	4603      	mov	r3, r0
 8004fb0:	2b00      	cmp	r3, #0
 8004fb2:	d007      	beq.n	8004fc4 <uavcan_broadcast+0x7c>
        (*transfer_id)++;
 8004fb4:	697b      	ldr	r3, [r7, #20]
 8004fb6:	781b      	ldrb	r3, [r3, #0]
 8004fb8:	3301      	adds	r3, #1
 8004fba:	b2da      	uxtb	r2, r3
 8004fbc:	697b      	ldr	r3, [r7, #20]
 8004fbe:	701a      	strb	r2, [r3, #0]
        return true;
 8004fc0:	2301      	movs	r3, #1
 8004fc2:	e000      	b.n	8004fc6 <uavcan_broadcast+0x7e>
    } else {
        return false;
 8004fc4:	2300      	movs	r3, #0
    }
}
 8004fc6:	4618      	mov	r0, r3
 8004fc8:	3724      	adds	r7, #36	; 0x24
 8004fca:	46bd      	mov	sp, r7
 8004fcc:	bd90      	pop	{r4, r7, pc}
 8004fce:	bf00      	nop

08004fd0 <uavcan_respond>:
    } else {
        return false;
    }
}

bool uavcan_respond(uint8_t uavcan_idx, const struct uavcan_deserialized_message_s* const req_msg, void* msg_data) {
 8004fd0:	b590      	push	{r4, r7, lr}
 8004fd2:	b08d      	sub	sp, #52	; 0x34
 8004fd4:	af04      	add	r7, sp, #16
 8004fd6:	4603      	mov	r3, r0
 8004fd8:	60b9      	str	r1, [r7, #8]
 8004fda:	607a      	str	r2, [r7, #4]
 8004fdc:	73fb      	strb	r3, [r7, #15]
    struct uavcan_instance_s* instance = uavcan_get_instance(uavcan_idx);
 8004fde:	7bfb      	ldrb	r3, [r7, #15]
 8004fe0:	4618      	mov	r0, r3
 8004fe2:	f000 f86d 	bl	80050c0 <uavcan_get_instance.lto_priv.96>
 8004fe6:	61f8      	str	r0, [r7, #28]
    if (!instance) {
 8004fe8:	69fb      	ldr	r3, [r7, #28]
 8004fea:	2b00      	cmp	r3, #0
 8004fec:	d101      	bne.n	8004ff2 <uavcan_respond+0x22>
        return false;
 8004fee:	2300      	movs	r3, #0
 8004ff0:	e01d      	b.n	800502e <uavcan_respond+0x5e>
    }

    const struct uavcan_message_descriptor_s* msg_descriptor = req_msg->descriptor->resp_descriptor;
 8004ff2:	68bb      	ldr	r3, [r7, #8]
 8004ff4:	685b      	ldr	r3, [r3, #4]
 8004ff6:	69db      	ldr	r3, [r3, #28]
 8004ff8:	61bb      	str	r3, [r7, #24]
    uint8_t priority = req_msg->priority;
 8004ffa:	68bb      	ldr	r3, [r7, #8]
 8004ffc:	7adb      	ldrb	r3, [r3, #11]
 8004ffe:	75fb      	strb	r3, [r7, #23]
    uint8_t transfer_id = req_msg->transfer_id;
 8005000:	68bb      	ldr	r3, [r7, #8]
 8005002:	7a9b      	ldrb	r3, [r3, #10]
 8005004:	75bb      	strb	r3, [r7, #22]
    uint8_t dest_node_id = req_msg->source_node_id;
 8005006:	68bb      	ldr	r3, [r7, #8]
 8005008:	7b1b      	ldrb	r3, [r3, #12]
 800500a:	757b      	strb	r3, [r7, #21]
    uint16_t data_type_id = msg_descriptor->default_data_type_id;
 800500c:	69bb      	ldr	r3, [r7, #24]
 800500e:	891b      	ldrh	r3, [r3, #8]
 8005010:	827b      	strh	r3, [r7, #18]
    return _uavcan_send(instance, msg_descriptor, data_type_id, priority, transfer_id, dest_node_id, msg_data);
 8005012:	8a7a      	ldrh	r2, [r7, #18]
 8005014:	7dfc      	ldrb	r4, [r7, #23]
 8005016:	7dbb      	ldrb	r3, [r7, #22]
 8005018:	9300      	str	r3, [sp, #0]
 800501a:	7d7b      	ldrb	r3, [r7, #21]
 800501c:	9301      	str	r3, [sp, #4]
 800501e:	687b      	ldr	r3, [r7, #4]
 8005020:	9302      	str	r3, [sp, #8]
 8005022:	69f8      	ldr	r0, [r7, #28]
 8005024:	69b9      	ldr	r1, [r7, #24]
 8005026:	4623      	mov	r3, r4
 8005028:	f7ff fde4 	bl	8004bf4 <_uavcan_send>
 800502c:	4603      	mov	r3, r0
}
 800502e:	4618      	mov	r0, r3
 8005030:	3724      	adds	r7, #36	; 0x24
 8005032:	46bd      	mov	sp, r7
 8005034:	bd90      	pop	{r4, r7, pc}
 8005036:	bf00      	nop

08005038 <uavcan_can_rx_handler.lto_priv.81>:

static void uavcan_can_rx_handler(size_t msg_size, const void* msg, void* ctx) {
 8005038:	b580      	push	{r7, lr}
 800503a:	b08c      	sub	sp, #48	; 0x30
 800503c:	af00      	add	r7, sp, #0
 800503e:	60f8      	str	r0, [r7, #12]
 8005040:	60b9      	str	r1, [r7, #8]
 8005042:	607a      	str	r2, [r7, #4]
    (void) msg_size;
    struct uavcan_instance_s* instance = ctx;
 8005044:	687b      	ldr	r3, [r7, #4]
 8005046:	62fb      	str	r3, [r7, #44]	; 0x2c

    const struct can_rx_frame_s* frame = msg;
 8005048:	68bb      	ldr	r3, [r7, #8]
 800504a:	62bb      	str	r3, [r7, #40]	; 0x28

    CanardCANFrame canard_frame = convert_can_frame_to_CanardCANFrame(&frame->content);
 800504c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800504e:	f107 0210 	add.w	r2, r7, #16
 8005052:	4610      	mov	r0, r2
 8005054:	4619      	mov	r1, r3
 8005056:	f000 f893 	bl	8005180 <convert_can_frame_to_CanardCANFrame>

    uint64_t timestamp = micros64();
 800505a:	f002 feb3 	bl	8007dc4 <micros64>
 800505e:	e9c7 0108 	strd	r0, r1, [r7, #32]
    canardHandleRxFrame(&instance->canard, &canard_frame, timestamp);
 8005062:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005064:	f103 0208 	add.w	r2, r3, #8
 8005068:	f107 0310 	add.w	r3, r7, #16
 800506c:	4610      	mov	r0, r2
 800506e:	4619      	mov	r1, r3
 8005070:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8005074:	f007 fd36 	bl	800cae4 <canardHandleRxFrame>

    /* debug message */
    LED_OFF;
 8005078:	4b02      	ldr	r3, [pc, #8]	; (8005084 <uavcan_can_rx_handler.lto_priv.81+0x4c>)
 800507a:	2202      	movs	r2, #2
 800507c:	615a      	str	r2, [r3, #20]
//    chnWrite(&SD1, (const uint8_t *)"rcv\n", 5);
}
 800507e:	3730      	adds	r7, #48	; 0x30
 8005080:	46bd      	mov	sp, r7
 8005082:	bd80      	pop	{r7, pc}
 8005084:	40010c00 	.word	0x40010c00

08005088 <stale_transfer_cleanup_task_func.lto_priv.83>:

static void stale_transfer_cleanup_task_func(struct worker_thread_timer_task_s* task) {
 8005088:	b590      	push	{r4, r7, lr}
 800508a:	b085      	sub	sp, #20
 800508c:	af00      	add	r7, sp, #0
 800508e:	6078      	str	r0, [r7, #4]
    (void)task;
    struct uavcan_instance_s* instance = NULL;
 8005090:	2300      	movs	r3, #0
 8005092:	60fb      	str	r3, [r7, #12]
 8005094:	e009      	b.n	80050aa <stale_transfer_cleanup_task_func.lto_priv.83+0x22>

    while (uavcan_iterate_instances(&instance)) {
        canardCleanupStaleTransfers(&instance->canard, micros64());
 8005096:	68fb      	ldr	r3, [r7, #12]
 8005098:	f103 0408 	add.w	r4, r3, #8
 800509c:	f002 fe92 	bl	8007dc4 <micros64>
 80050a0:	4602      	mov	r2, r0
 80050a2:	460b      	mov	r3, r1
 80050a4:	4620      	mov	r0, r4
 80050a6:	f008 f84b 	bl	800d140 <canardCleanupStaleTransfers>

static void stale_transfer_cleanup_task_func(struct worker_thread_timer_task_s* task) {
    (void)task;
    struct uavcan_instance_s* instance = NULL;

    while (uavcan_iterate_instances(&instance)) {
 80050aa:	f107 030c 	add.w	r3, r7, #12
 80050ae:	4618      	mov	r0, r3
 80050b0:	f001 fad4 	bl	800665c <uavcan_iterate_instances.lto_priv.75>
 80050b4:	4603      	mov	r3, r0
 80050b6:	2b00      	cmp	r3, #0
 80050b8:	d1ed      	bne.n	8005096 <stale_transfer_cleanup_task_func.lto_priv.83+0xe>
        canardCleanupStaleTransfers(&instance->canard, micros64());
    }
}
 80050ba:	3714      	adds	r7, #20
 80050bc:	46bd      	mov	sp, r7
 80050be:	bd90      	pop	{r4, r7, pc}

080050c0 <uavcan_get_instance.lto_priv.96>:

static struct uavcan_instance_s* uavcan_get_instance(uint8_t idx) {
 80050c0:	b480      	push	{r7}
 80050c2:	b085      	sub	sp, #20
 80050c4:	af00      	add	r7, sp, #0
 80050c6:	4603      	mov	r3, r0
 80050c8:	71fb      	strb	r3, [r7, #7]
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
 80050ca:	4b0e      	ldr	r3, [pc, #56]	; (8005104 <uavcan_get_instance.lto_priv.96+0x44>)
 80050cc:	681b      	ldr	r3, [r3, #0]
 80050ce:	60fb      	str	r3, [r7, #12]
 80050d0:	e005      	b.n	80050de <uavcan_get_instance.lto_priv.96+0x1e>
    while (instance && idx != 0) {
        idx--;
 80050d2:	79fb      	ldrb	r3, [r7, #7]
 80050d4:	3b01      	subs	r3, #1
 80050d6:	71fb      	strb	r3, [r7, #7]
        instance = instance->next;
 80050d8:	68fb      	ldr	r3, [r7, #12]
 80050da:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80050dc:	60fb      	str	r3, [r7, #12]
    }
}

static struct uavcan_instance_s* uavcan_get_instance(uint8_t idx) {
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
    while (instance && idx != 0) {
 80050de:	68fb      	ldr	r3, [r7, #12]
 80050e0:	2b00      	cmp	r3, #0
 80050e2:	d002      	beq.n	80050ea <uavcan_get_instance.lto_priv.96+0x2a>
 80050e4:	79fb      	ldrb	r3, [r7, #7]
 80050e6:	2b00      	cmp	r3, #0
 80050e8:	d1f3      	bne.n	80050d2 <uavcan_get_instance.lto_priv.96+0x12>
        idx--;
        instance = instance->next;
    }

    if (idx != 0) {
 80050ea:	79fb      	ldrb	r3, [r7, #7]
 80050ec:	2b00      	cmp	r3, #0
 80050ee:	d001      	beq.n	80050f4 <uavcan_get_instance.lto_priv.96+0x34>
        return NULL;
 80050f0:	2300      	movs	r3, #0
 80050f2:	e000      	b.n	80050f6 <uavcan_get_instance.lto_priv.96+0x36>
    } else {
        return instance;
 80050f4:	68fb      	ldr	r3, [r7, #12]
    }
}
 80050f6:	4618      	mov	r0, r3
 80050f8:	3714      	adds	r7, #20
 80050fa:	46bd      	mov	sp, r7
 80050fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005100:	4770      	bx	lr
 8005102:	bf00      	nop
 8005104:	2000149c 	.word	0x2000149c

08005108 <uavcan_get_num_instances>:

uint8_t uavcan_get_num_instances(void) {
 8005108:	b480      	push	{r7}
 800510a:	b083      	sub	sp, #12
 800510c:	af00      	add	r7, sp, #0
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
 800510e:	4b0b      	ldr	r3, [pc, #44]	; (800513c <uavcan_get_num_instances+0x34>)
 8005110:	681b      	ldr	r3, [r3, #0]
 8005112:	607b      	str	r3, [r7, #4]
    uint8_t count = 0;
 8005114:	2300      	movs	r3, #0
 8005116:	70fb      	strb	r3, [r7, #3]
 8005118:	e005      	b.n	8005126 <uavcan_get_num_instances+0x1e>
    while (instance) {
        count++;
 800511a:	78fb      	ldrb	r3, [r7, #3]
 800511c:	3301      	adds	r3, #1
 800511e:	70fb      	strb	r3, [r7, #3]
        instance = instance->next;
 8005120:	687b      	ldr	r3, [r7, #4]
 8005122:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8005124:	607b      	str	r3, [r7, #4]
}

uint8_t uavcan_get_num_instances(void) {
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
    uint8_t count = 0;
    while (instance) {
 8005126:	687b      	ldr	r3, [r7, #4]
 8005128:	2b00      	cmp	r3, #0
 800512a:	d1f6      	bne.n	800511a <uavcan_get_num_instances+0x12>
        count++;
        instance = instance->next;
    }
    return count;
 800512c:	78fb      	ldrb	r3, [r7, #3]
}
 800512e:	4618      	mov	r0, r3
 8005130:	370c      	adds	r7, #12
 8005132:	46bd      	mov	sp, r7
 8005134:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005138:	4770      	bx	lr
 800513a:	bf00      	nop
 800513c:	2000149c 	.word	0x2000149c

08005140 <uavcan_get_idx.lto_priv.98>:

static uint8_t uavcan_get_idx(struct uavcan_instance_s* instance_arg) {
 8005140:	b480      	push	{r7}
 8005142:	b085      	sub	sp, #20
 8005144:	af00      	add	r7, sp, #0
 8005146:	6078      	str	r0, [r7, #4]
    uint8_t idx = 0;
 8005148:	2300      	movs	r3, #0
 800514a:	73fb      	strb	r3, [r7, #15]
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
 800514c:	4b0b      	ldr	r3, [pc, #44]	; (800517c <uavcan_get_idx.lto_priv.98+0x3c>)
 800514e:	681b      	ldr	r3, [r3, #0]
 8005150:	60bb      	str	r3, [r7, #8]
 8005152:	e005      	b.n	8005160 <uavcan_get_idx.lto_priv.98+0x20>
    while (instance && instance != instance_arg) {
        idx++;
 8005154:	7bfb      	ldrb	r3, [r7, #15]
 8005156:	3301      	adds	r3, #1
 8005158:	73fb      	strb	r3, [r7, #15]
        instance = instance->next;
 800515a:	68bb      	ldr	r3, [r7, #8]
 800515c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800515e:	60bb      	str	r3, [r7, #8]
}

static uint8_t uavcan_get_idx(struct uavcan_instance_s* instance_arg) {
    uint8_t idx = 0;
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
    while (instance && instance != instance_arg) {
 8005160:	68bb      	ldr	r3, [r7, #8]
 8005162:	2b00      	cmp	r3, #0
 8005164:	d003      	beq.n	800516e <uavcan_get_idx.lto_priv.98+0x2e>
 8005166:	68ba      	ldr	r2, [r7, #8]
 8005168:	687b      	ldr	r3, [r7, #4]
 800516a:	429a      	cmp	r2, r3
 800516c:	d1f2      	bne.n	8005154 <uavcan_get_idx.lto_priv.98+0x14>
        idx++;
        instance = instance->next;
    }
    return idx;
 800516e:	7bfb      	ldrb	r3, [r7, #15]
}
 8005170:	4618      	mov	r0, r3
 8005172:	3714      	adds	r7, #20
 8005174:	46bd      	mov	sp, r7
 8005176:	f85d 7b04 	ldr.w	r7, [sp], #4
 800517a:	4770      	bx	lr
 800517c:	2000149c 	.word	0x2000149c

08005180 <convert_can_frame_to_CanardCANFrame>:

static CanardCANFrame convert_can_frame_to_CanardCANFrame(const struct can_frame_s* frame) {
 8005180:	b590      	push	{r4, r7, lr}
 8005182:	b087      	sub	sp, #28
 8005184:	af00      	add	r7, sp, #0
 8005186:	6078      	str	r0, [r7, #4]
 8005188:	6039      	str	r1, [r7, #0]
    CanardCANFrame ret;
    if (frame->IDE) {
 800518a:	683b      	ldr	r3, [r7, #0]
 800518c:	781b      	ldrb	r3, [r3, #0]
 800518e:	f003 0302 	and.w	r3, r3, #2
 8005192:	b2db      	uxtb	r3, r3
 8005194:	2b00      	cmp	r3, #0
 8005196:	d007      	beq.n	80051a8 <convert_can_frame_to_CanardCANFrame+0x28>
        ret.id = frame->EID | CANARD_CAN_FRAME_EFF;
 8005198:	683b      	ldr	r3, [r7, #0]
 800519a:	685b      	ldr	r3, [r3, #4]
 800519c:	f3c3 031c 	ubfx	r3, r3, #0, #29
 80051a0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80051a4:	60bb      	str	r3, [r7, #8]
 80051a6:	e005      	b.n	80051b4 <convert_can_frame_to_CanardCANFrame+0x34>
    } else {
        ret.id = frame->SID;
 80051a8:	683b      	ldr	r3, [r7, #0]
 80051aa:	889b      	ldrh	r3, [r3, #4]
 80051ac:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80051b0:	b29b      	uxth	r3, r3
 80051b2:	60bb      	str	r3, [r7, #8]
    }

    if (frame->RTR) {
 80051b4:	683b      	ldr	r3, [r7, #0]
 80051b6:	781b      	ldrb	r3, [r3, #0]
 80051b8:	f003 0301 	and.w	r3, r3, #1
 80051bc:	b2db      	uxtb	r3, r3
 80051be:	2b00      	cmp	r3, #0
 80051c0:	d003      	beq.n	80051ca <convert_can_frame_to_CanardCANFrame+0x4a>
        ret.id |= CANARD_CAN_FRAME_RTR;
 80051c2:	68bb      	ldr	r3, [r7, #8]
 80051c4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80051c8:	60bb      	str	r3, [r7, #8]
    }

    ret.data_len = frame->DLC;
 80051ca:	683b      	ldr	r3, [r7, #0]
 80051cc:	781b      	ldrb	r3, [r3, #0]
 80051ce:	f3c3 0383 	ubfx	r3, r3, #2, #4
 80051d2:	b2db      	uxtb	r3, r3
 80051d4:	753b      	strb	r3, [r7, #20]
    memcpy(ret.data, frame->data, ret.data_len);
 80051d6:	683b      	ldr	r3, [r7, #0]
 80051d8:	f103 0208 	add.w	r2, r3, #8
 80051dc:	7d3b      	ldrb	r3, [r7, #20]
 80051de:	461c      	mov	r4, r3
 80051e0:	f107 0308 	add.w	r3, r7, #8
 80051e4:	3304      	adds	r3, #4
 80051e6:	4618      	mov	r0, r3
 80051e8:	4611      	mov	r1, r2
 80051ea:	4622      	mov	r2, r4
 80051ec:	f009 f9c8 	bl	800e580 <memcpy>
    return ret;
 80051f0:	687b      	ldr	r3, [r7, #4]
 80051f2:	461c      	mov	r4, r3
 80051f4:	f107 0308 	add.w	r3, r7, #8
 80051f8:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80051fa:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 80051fe:	6878      	ldr	r0, [r7, #4]
 8005200:	371c      	adds	r7, #28
 8005202:	46bd      	mov	sp, r7
 8005204:	bd90      	pop	{r4, r7, pc}
 8005206:	bf00      	nop

08005208 <uavcan_message_writer_func>:
    uint8_t uavcan_idx;
    CanardRxTransfer* transfer;
    const struct uavcan_message_descriptor_s* const descriptor;
};

static void uavcan_message_writer_func(size_t msg_size, void* write_buf, void* ctx) {
 8005208:	b580      	push	{r7, lr}
 800520a:	b086      	sub	sp, #24
 800520c:	af00      	add	r7, sp, #0
 800520e:	60f8      	str	r0, [r7, #12]
 8005210:	60b9      	str	r1, [r7, #8]
 8005212:	607a      	str	r2, [r7, #4]
    (void)msg_size;
    struct uavcan_message_writer_func_args* args = ctx;
 8005214:	687b      	ldr	r3, [r7, #4]
 8005216:	617b      	str	r3, [r7, #20]
    struct uavcan_deserialized_message_s* deserialized_message = write_buf;
 8005218:	68bb      	ldr	r3, [r7, #8]
 800521a:	613b      	str	r3, [r7, #16]
    deserialized_message->uavcan_idx = args->uavcan_idx;
 800521c:	697b      	ldr	r3, [r7, #20]
 800521e:	781a      	ldrb	r2, [r3, #0]
 8005220:	693b      	ldr	r3, [r7, #16]
 8005222:	701a      	strb	r2, [r3, #0]
    deserialized_message->descriptor = args->descriptor;
 8005224:	697b      	ldr	r3, [r7, #20]
 8005226:	689a      	ldr	r2, [r3, #8]
 8005228:	693b      	ldr	r3, [r7, #16]
 800522a:	605a      	str	r2, [r3, #4]
    deserialized_message->data_type_id = args->transfer->data_type_id;
 800522c:	697b      	ldr	r3, [r7, #20]
 800522e:	685b      	ldr	r3, [r3, #4]
 8005230:	8ada      	ldrh	r2, [r3, #22]
 8005232:	693b      	ldr	r3, [r7, #16]
 8005234:	811a      	strh	r2, [r3, #8]
    deserialized_message->transfer_id = args->transfer->transfer_id;
 8005236:	697b      	ldr	r3, [r7, #20]
 8005238:	685b      	ldr	r3, [r3, #4]
 800523a:	7e5a      	ldrb	r2, [r3, #25]
 800523c:	693b      	ldr	r3, [r7, #16]
 800523e:	729a      	strb	r2, [r3, #10]
    deserialized_message->priority = args->transfer->priority;
 8005240:	697b      	ldr	r3, [r7, #20]
 8005242:	685b      	ldr	r3, [r3, #4]
 8005244:	7e9a      	ldrb	r2, [r3, #26]
 8005246:	693b      	ldr	r3, [r7, #16]
 8005248:	72da      	strb	r2, [r3, #11]
    deserialized_message->source_node_id = args->transfer->source_node_id;
 800524a:	697b      	ldr	r3, [r7, #20]
 800524c:	685b      	ldr	r3, [r3, #4]
 800524e:	7eda      	ldrb	r2, [r3, #27]
 8005250:	693b      	ldr	r3, [r7, #16]
 8005252:	731a      	strb	r2, [r3, #12]
    args->descriptor->deserializer_func(args->transfer, deserialized_message->msg);
 8005254:	697b      	ldr	r3, [r7, #20]
 8005256:	689b      	ldr	r3, [r3, #8]
 8005258:	699b      	ldr	r3, [r3, #24]
 800525a:	697a      	ldr	r2, [r7, #20]
 800525c:	6851      	ldr	r1, [r2, #4]
 800525e:	693a      	ldr	r2, [r7, #16]
 8005260:	3210      	adds	r2, #16
 8005262:	4608      	mov	r0, r1
 8005264:	4611      	mov	r1, r2
 8005266:	4798      	blx	r3
}
 8005268:	3718      	adds	r7, #24
 800526a:	46bd      	mov	sp, r7
 800526c:	bd80      	pop	{r7, pc}
 800526e:	bf00      	nop

08005270 <uavcan_on_transfer_rx.lto_priv.79>:

static void uavcan_on_transfer_rx(CanardInstance* canard, CanardRxTransfer* transfer) {
 8005270:	b580      	push	{r7, lr}
 8005272:	b088      	sub	sp, #32
 8005274:	af00      	add	r7, sp, #0
 8005276:	6078      	str	r0, [r7, #4]
 8005278:	6039      	str	r1, [r7, #0]
    if (!canard || !transfer) {
 800527a:	687b      	ldr	r3, [r7, #4]
 800527c:	2b00      	cmp	r3, #0
 800527e:	d03c      	beq.n	80052fa <uavcan_on_transfer_rx.lto_priv.79+0x8a>
 8005280:	683b      	ldr	r3, [r7, #0]
 8005282:	2b00      	cmp	r3, #0
 8005284:	d039      	beq.n	80052fa <uavcan_on_transfer_rx.lto_priv.79+0x8a>
        return;
    }

    struct uavcan_instance_s* instance = canardGetUserReference(canard);
 8005286:	6878      	ldr	r0, [r7, #4]
 8005288:	f007 fbfa 	bl	800ca80 <canardGetUserReference>
 800528c:	61b8      	str	r0, [r7, #24]
    if (!instance) {
 800528e:	69bb      	ldr	r3, [r7, #24]
 8005290:	2b00      	cmp	r3, #0
 8005292:	d032      	beq.n	80052fa <uavcan_on_transfer_rx.lto_priv.79+0x8a>
        return;
    }

    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
 8005294:	69bb      	ldr	r3, [r7, #24]
 8005296:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8005298:	61fb      	str	r3, [r7, #28]
 800529a:	e02b      	b.n	80052f4 <uavcan_on_transfer_rx.lto_priv.79+0x84>
    while (rx_list_item) {
        if (rx_list_item->msg_descriptor->transfer_type == transfer->transfer_type && _uavcan_get_message_data_type_id(instance, rx_list_item->msg_descriptor) == transfer->data_type_id) {
 800529c:	69fb      	ldr	r3, [r7, #28]
 800529e:	681b      	ldr	r3, [r3, #0]
 80052a0:	7a9a      	ldrb	r2, [r3, #10]
 80052a2:	683b      	ldr	r3, [r7, #0]
 80052a4:	7e1b      	ldrb	r3, [r3, #24]
 80052a6:	429a      	cmp	r2, r3
 80052a8:	d121      	bne.n	80052ee <uavcan_on_transfer_rx.lto_priv.79+0x7e>
 80052aa:	69fb      	ldr	r3, [r7, #28]
 80052ac:	681b      	ldr	r3, [r3, #0]
 80052ae:	69b8      	ldr	r0, [r7, #24]
 80052b0:	4619      	mov	r1, r3
 80052b2:	f001 fa61 	bl	8006778 <_uavcan_get_message_data_type_id.lto_priv.74>
 80052b6:	4603      	mov	r3, r0
 80052b8:	461a      	mov	r2, r3
 80052ba:	683b      	ldr	r3, [r7, #0]
 80052bc:	8adb      	ldrh	r3, [r3, #22]
 80052be:	429a      	cmp	r2, r3
 80052c0:	d115      	bne.n	80052ee <uavcan_on_transfer_rx.lto_priv.79+0x7e>
            struct uavcan_message_writer_func_args writer_args = { instance->idx, transfer, rx_list_item->msg_descriptor };
 80052c2:	69bb      	ldr	r3, [r7, #24]
 80052c4:	781b      	ldrb	r3, [r3, #0]
 80052c6:	733b      	strb	r3, [r7, #12]
 80052c8:	683b      	ldr	r3, [r7, #0]
 80052ca:	613b      	str	r3, [r7, #16]
 80052cc:	69fb      	ldr	r3, [r7, #28]
 80052ce:	681b      	ldr	r3, [r3, #0]
 80052d0:	617b      	str	r3, [r7, #20]
            pubsub_publish_message(&rx_list_item->topic, rx_list_item->msg_descriptor->deserialized_size+sizeof(struct uavcan_deserialized_message_s), uavcan_message_writer_func, &writer_args);
 80052d2:	69fb      	ldr	r3, [r7, #28]
 80052d4:	1d19      	adds	r1, r3, #4
 80052d6:	69fb      	ldr	r3, [r7, #28]
 80052d8:	681b      	ldr	r3, [r3, #0]
 80052da:	68db      	ldr	r3, [r3, #12]
 80052dc:	f103 0210 	add.w	r2, r3, #16
 80052e0:	f107 030c 	add.w	r3, r7, #12
 80052e4:	4608      	mov	r0, r1
 80052e6:	4611      	mov	r1, r2
 80052e8:	4a05      	ldr	r2, [pc, #20]	; (8005300 <uavcan_on_transfer_rx.lto_priv.79+0x90>)
 80052ea:	f003 f887 	bl	80083fc <pubsub_publish_message>
        }

        rx_list_item = rx_list_item->next;
 80052ee:	69fb      	ldr	r3, [r7, #28]
 80052f0:	691b      	ldr	r3, [r3, #16]
 80052f2:	61fb      	str	r3, [r7, #28]
    if (!instance) {
        return;
    }

    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
    while (rx_list_item) {
 80052f4:	69fb      	ldr	r3, [r7, #28]
 80052f6:	2b00      	cmp	r3, #0
 80052f8:	d1d0      	bne.n	800529c <uavcan_on_transfer_rx.lto_priv.79+0x2c>
            pubsub_publish_message(&rx_list_item->topic, rx_list_item->msg_descriptor->deserialized_size+sizeof(struct uavcan_deserialized_message_s), uavcan_message_writer_func, &writer_args);
        }

        rx_list_item = rx_list_item->next;
    }
}
 80052fa:	3720      	adds	r7, #32
 80052fc:	46bd      	mov	sp, r7
 80052fe:	bd80      	pop	{r7, pc}
 8005300:	08005209 	.word	0x08005209

08005304 <uavcan_should_accept_transfer.lto_priv.80>:

static bool uavcan_should_accept_transfer(const CanardInstance* canard, uint64_t* out_data_type_signature, uint16_t data_type_id, CanardTransferType transfer_type, uint8_t source_node_id) {
 8005304:	b580      	push	{r7, lr}
 8005306:	b086      	sub	sp, #24
 8005308:	af00      	add	r7, sp, #0
 800530a:	60f8      	str	r0, [r7, #12]
 800530c:	60b9      	str	r1, [r7, #8]
 800530e:	4611      	mov	r1, r2
 8005310:	461a      	mov	r2, r3
 8005312:	460b      	mov	r3, r1
 8005314:	80fb      	strh	r3, [r7, #6]
 8005316:	4613      	mov	r3, r2
 8005318:	717b      	strb	r3, [r7, #5]
    (void)source_node_id;
    if (!canard || !out_data_type_signature) {
 800531a:	68fb      	ldr	r3, [r7, #12]
 800531c:	2b00      	cmp	r3, #0
 800531e:	d002      	beq.n	8005326 <uavcan_should_accept_transfer.lto_priv.80+0x22>
 8005320:	68bb      	ldr	r3, [r7, #8]
 8005322:	2b00      	cmp	r3, #0
 8005324:	d101      	bne.n	800532a <uavcan_should_accept_transfer.lto_priv.80+0x26>
        return false;
 8005326:	2300      	movs	r3, #0
 8005328:	e02d      	b.n	8005386 <uavcan_should_accept_transfer.lto_priv.80+0x82>
    }

    struct uavcan_instance_s* instance = canardGetUserReference((CanardInstance*)canard);
 800532a:	68f8      	ldr	r0, [r7, #12]
 800532c:	f007 fba8 	bl	800ca80 <canardGetUserReference>
 8005330:	6138      	str	r0, [r7, #16]
    if (!instance) {
 8005332:	693b      	ldr	r3, [r7, #16]
 8005334:	2b00      	cmp	r3, #0
 8005336:	d101      	bne.n	800533c <uavcan_should_accept_transfer.lto_priv.80+0x38>
        return false;
 8005338:	2300      	movs	r3, #0
 800533a:	e024      	b.n	8005386 <uavcan_should_accept_transfer.lto_priv.80+0x82>
    }

    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
 800533c:	693b      	ldr	r3, [r7, #16]
 800533e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8005340:	617b      	str	r3, [r7, #20]
 8005342:	e01c      	b.n	800537e <uavcan_should_accept_transfer.lto_priv.80+0x7a>
    while (rx_list_item) {
        if (transfer_type == rx_list_item->msg_descriptor->transfer_type && data_type_id == _uavcan_get_message_data_type_id(instance, rx_list_item->msg_descriptor)) {
 8005344:	697b      	ldr	r3, [r7, #20]
 8005346:	681b      	ldr	r3, [r3, #0]
 8005348:	7a9b      	ldrb	r3, [r3, #10]
 800534a:	797a      	ldrb	r2, [r7, #5]
 800534c:	429a      	cmp	r2, r3
 800534e:	d113      	bne.n	8005378 <uavcan_should_accept_transfer.lto_priv.80+0x74>
 8005350:	697b      	ldr	r3, [r7, #20]
 8005352:	681b      	ldr	r3, [r3, #0]
 8005354:	6938      	ldr	r0, [r7, #16]
 8005356:	4619      	mov	r1, r3
 8005358:	f001 fa0e 	bl	8006778 <_uavcan_get_message_data_type_id.lto_priv.74>
 800535c:	4603      	mov	r3, r0
 800535e:	461a      	mov	r2, r3
 8005360:	88fb      	ldrh	r3, [r7, #6]
 8005362:	4293      	cmp	r3, r2
 8005364:	d108      	bne.n	8005378 <uavcan_should_accept_transfer.lto_priv.80+0x74>
            *out_data_type_signature = rx_list_item->msg_descriptor->data_type_signature;
 8005366:	697b      	ldr	r3, [r7, #20]
 8005368:	681b      	ldr	r3, [r3, #0]
 800536a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800536e:	68b9      	ldr	r1, [r7, #8]
 8005370:	e9c1 2300 	strd	r2, r3, [r1]
            return true;
 8005374:	2301      	movs	r3, #1
 8005376:	e006      	b.n	8005386 <uavcan_should_accept_transfer.lto_priv.80+0x82>
        }

        rx_list_item = rx_list_item->next;
 8005378:	697b      	ldr	r3, [r7, #20]
 800537a:	691b      	ldr	r3, [r3, #16]
 800537c:	617b      	str	r3, [r7, #20]
    if (!instance) {
        return false;
    }

    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
    while (rx_list_item) {
 800537e:	697b      	ldr	r3, [r7, #20]
 8005380:	2b00      	cmp	r3, #0
 8005382:	d1df      	bne.n	8005344 <uavcan_should_accept_transfer.lto_priv.80+0x40>
        }

        rx_list_item = rx_list_item->next;
    }

    return false;
 8005384:	2300      	movs	r3, #0
}
 8005386:	4618      	mov	r0, r3
 8005388:	3718      	adds	r7, #24
 800538a:	46bd      	mov	sp, r7
 800538c:	bd80      	pop	{r7, pc}
 800538e:	bf00      	nop

08005390 <uavcan_transfer_id_map_init.lto_priv.99>:

#define UAVCAN_TRANSFER_ID_MAP_MAX_LEN ((1<<7)-1)

static void uavcan_transfer_id_map_init(struct transfer_id_map_s* map, size_t map_mem_size, void* map_mem) {
 8005390:	b480      	push	{r7}
 8005392:	b085      	sub	sp, #20
 8005394:	af00      	add	r7, sp, #0
 8005396:	60f8      	str	r0, [r7, #12]
 8005398:	60b9      	str	r1, [r7, #8]
 800539a:	607a      	str	r2, [r7, #4]
    if (!map) {
 800539c:	68fb      	ldr	r3, [r7, #12]
 800539e:	2b00      	cmp	r3, #0
 80053a0:	d011      	beq.n	80053c6 <uavcan_transfer_id_map_init.lto_priv.99+0x36>
        return;
    }
    map->entries = map_mem;
 80053a2:	68fb      	ldr	r3, [r7, #12]
 80053a4:	687a      	ldr	r2, [r7, #4]
 80053a6:	601a      	str	r2, [r3, #0]
    map->size = map_mem_size/sizeof(struct map_entry_s);
 80053a8:	68bb      	ldr	r3, [r7, #8]
 80053aa:	089b      	lsrs	r3, r3, #2
 80053ac:	b29a      	uxth	r2, r3
 80053ae:	68fb      	ldr	r3, [r7, #12]
 80053b0:	809a      	strh	r2, [r3, #4]
    if (map->size > UAVCAN_TRANSFER_ID_MAP_MAX_LEN) {
 80053b2:	68fb      	ldr	r3, [r7, #12]
 80053b4:	889b      	ldrh	r3, [r3, #4]
 80053b6:	2b7f      	cmp	r3, #127	; 0x7f
 80053b8:	d902      	bls.n	80053c0 <uavcan_transfer_id_map_init.lto_priv.99+0x30>
        map->size = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
 80053ba:	68fb      	ldr	r3, [r7, #12]
 80053bc:	227f      	movs	r2, #127	; 0x7f
 80053be:	809a      	strh	r2, [r3, #4]
    }
    map->head = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
 80053c0:	68fb      	ldr	r3, [r7, #12]
 80053c2:	227f      	movs	r2, #127	; 0x7f
 80053c4:	80da      	strh	r2, [r3, #6]
}
 80053c6:	3714      	adds	r7, #20
 80053c8:	46bd      	mov	sp, r7
 80053ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80053ce:	4770      	bx	lr

080053d0 <uavcan_transfer_id_map_retrieve>:

static uint8_t* uavcan_transfer_id_map_retrieve(struct transfer_id_map_s* map, bool service_not_message, uint16_t data_type_id, uint8_t dest_node_id) {
 80053d0:	b480      	push	{r7}
 80053d2:	b087      	sub	sp, #28
 80053d4:	af00      	add	r7, sp, #0
 80053d6:	6078      	str	r0, [r7, #4]
 80053d8:	4608      	mov	r0, r1
 80053da:	4611      	mov	r1, r2
 80053dc:	461a      	mov	r2, r3
 80053de:	4603      	mov	r3, r0
 80053e0:	70fb      	strb	r3, [r7, #3]
 80053e2:	460b      	mov	r3, r1
 80053e4:	803b      	strh	r3, [r7, #0]
 80053e6:	4613      	mov	r3, r2
 80053e8:	70bb      	strb	r3, [r7, #2]
    if (!map || !map->entries) {
 80053ea:	687b      	ldr	r3, [r7, #4]
 80053ec:	2b00      	cmp	r3, #0
 80053ee:	d003      	beq.n	80053f8 <uavcan_transfer_id_map_retrieve+0x28>
 80053f0:	687b      	ldr	r3, [r7, #4]
 80053f2:	681b      	ldr	r3, [r3, #0]
 80053f4:	2b00      	cmp	r3, #0
 80053f6:	d101      	bne.n	80053fc <uavcan_transfer_id_map_retrieve+0x2c>
        return 0;
 80053f8:	2300      	movs	r3, #0
 80053fa:	e0a6      	b.n	800554a <uavcan_transfer_id_map_retrieve+0x17a>
    }

    uint32_t key;
    if (service_not_message) {
 80053fc:	78fb      	ldrb	r3, [r7, #3]
 80053fe:	2b00      	cmp	r3, #0
 8005400:	d008      	beq.n	8005414 <uavcan_transfer_id_map_retrieve+0x44>
        key = (1<<16) | ((data_type_id << 8) & 0xFF00) | ((dest_node_id << 0) & 0x00FF);
 8005402:	883b      	ldrh	r3, [r7, #0]
 8005404:	021b      	lsls	r3, r3, #8
 8005406:	b29b      	uxth	r3, r3
 8005408:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 800540c:	78bb      	ldrb	r3, [r7, #2]
 800540e:	4313      	orrs	r3, r2
 8005410:	617b      	str	r3, [r7, #20]
 8005412:	e001      	b.n	8005418 <uavcan_transfer_id_map_retrieve+0x48>
    } else {
        key = data_type_id;
 8005414:	883b      	ldrh	r3, [r7, #0]
 8005416:	617b      	str	r3, [r7, #20]
    }

    uint16_t count = 0;
 8005418:	2300      	movs	r3, #0
 800541a:	827b      	strh	r3, [r7, #18]
    uint16_t entry = map->head;
 800541c:	687b      	ldr	r3, [r7, #4]
 800541e:	88db      	ldrh	r3, [r3, #6]
 8005420:	823b      	strh	r3, [r7, #16]
    uint16_t entry_prev = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
 8005422:	237f      	movs	r3, #127	; 0x7f
 8005424:	81fb      	strh	r3, [r7, #14]
    uint16_t entry_prev_prev = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
 8005426:	237f      	movs	r3, #127	; 0x7f
 8005428:	81bb      	strh	r3, [r7, #12]
 800542a:	e010      	b.n	800544e <uavcan_transfer_id_map_retrieve+0x7e>

    while (entry != UAVCAN_TRANSFER_ID_MAP_MAX_LEN && map->entries[entry].key != key) {
        count++;
 800542c:	8a7b      	ldrh	r3, [r7, #18]
 800542e:	3301      	adds	r3, #1
 8005430:	827b      	strh	r3, [r7, #18]
        entry_prev_prev = entry_prev;
 8005432:	89fb      	ldrh	r3, [r7, #14]
 8005434:	81bb      	strh	r3, [r7, #12]
        entry_prev = entry;
 8005436:	8a3b      	ldrh	r3, [r7, #16]
 8005438:	81fb      	strh	r3, [r7, #14]
        entry = map->entries[entry].next;
 800543a:	687b      	ldr	r3, [r7, #4]
 800543c:	681a      	ldr	r2, [r3, #0]
 800543e:	8a3b      	ldrh	r3, [r7, #16]
 8005440:	009b      	lsls	r3, r3, #2
 8005442:	4413      	add	r3, r2
 8005444:	789b      	ldrb	r3, [r3, #2]
 8005446:	f3c3 0346 	ubfx	r3, r3, #1, #7
 800544a:	b2db      	uxtb	r3, r3
 800544c:	823b      	strh	r3, [r7, #16]
    uint16_t count = 0;
    uint16_t entry = map->head;
    uint16_t entry_prev = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
    uint16_t entry_prev_prev = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;

    while (entry != UAVCAN_TRANSFER_ID_MAP_MAX_LEN && map->entries[entry].key != key) {
 800544e:	8a3b      	ldrh	r3, [r7, #16]
 8005450:	2b7f      	cmp	r3, #127	; 0x7f
 8005452:	d011      	beq.n	8005478 <uavcan_transfer_id_map_retrieve+0xa8>
 8005454:	687b      	ldr	r3, [r7, #4]
 8005456:	681a      	ldr	r2, [r3, #0]
 8005458:	8a3b      	ldrh	r3, [r7, #16]
 800545a:	009b      	lsls	r3, r3, #2
 800545c:	4413      	add	r3, r2
 800545e:	781a      	ldrb	r2, [r3, #0]
 8005460:	7859      	ldrb	r1, [r3, #1]
 8005462:	0209      	lsls	r1, r1, #8
 8005464:	430a      	orrs	r2, r1
 8005466:	789b      	ldrb	r3, [r3, #2]
 8005468:	f003 0301 	and.w	r3, r3, #1
 800546c:	041b      	lsls	r3, r3, #16
 800546e:	4313      	orrs	r3, r2
 8005470:	461a      	mov	r2, r3
 8005472:	697b      	ldr	r3, [r7, #20]
 8005474:	429a      	cmp	r2, r3
 8005476:	d1d9      	bne.n	800542c <uavcan_transfer_id_map_retrieve+0x5c>
        entry_prev_prev = entry_prev;
        entry_prev = entry;
        entry = map->entries[entry].next;
    }

    if (entry == UAVCAN_TRANSFER_ID_MAP_MAX_LEN) {
 8005478:	8a3b      	ldrh	r3, [r7, #16]
 800547a:	2b7f      	cmp	r3, #127	; 0x7f
 800547c:	d138      	bne.n	80054f0 <uavcan_transfer_id_map_retrieve+0x120>
        // Not found. Allocate an entry.
        if (count >= map->size) {
 800547e:	687b      	ldr	r3, [r7, #4]
 8005480:	889b      	ldrh	r3, [r3, #4]
 8005482:	8a7a      	ldrh	r2, [r7, #18]
 8005484:	429a      	cmp	r2, r3
 8005486:	d304      	bcc.n	8005492 <uavcan_transfer_id_map_retrieve+0xc2>
            // list is full - entry_prev is the LRU entry
            entry = entry_prev;
 8005488:	89fb      	ldrh	r3, [r7, #14]
 800548a:	823b      	strh	r3, [r7, #16]
            entry_prev = entry_prev_prev;
 800548c:	89bb      	ldrh	r3, [r7, #12]
 800548e:	81fb      	strh	r3, [r7, #14]
 8005490:	e001      	b.n	8005496 <uavcan_transfer_id_map_retrieve+0xc6>
        } else {
            // list is not full - allocate next available element
            entry = count;
 8005492:	8a7b      	ldrh	r3, [r7, #18]
 8005494:	823b      	strh	r3, [r7, #16]
        }

        // Populate the allocated entry
        map->entries[entry].key = key;
 8005496:	687b      	ldr	r3, [r7, #4]
 8005498:	681a      	ldr	r2, [r3, #0]
 800549a:	8a3b      	ldrh	r3, [r7, #16]
 800549c:	009b      	lsls	r3, r3, #2
 800549e:	4413      	add	r3, r2
 80054a0:	697a      	ldr	r2, [r7, #20]
 80054a2:	f3c2 0210 	ubfx	r2, r2, #0, #17
 80054a6:	b2d1      	uxtb	r1, r2
 80054a8:	2000      	movs	r0, #0
 80054aa:	4301      	orrs	r1, r0
 80054ac:	7019      	strb	r1, [r3, #0]
 80054ae:	0a11      	lsrs	r1, r2, #8
 80054b0:	b2c9      	uxtb	r1, r1
 80054b2:	2000      	movs	r0, #0
 80054b4:	4301      	orrs	r1, r0
 80054b6:	7059      	strb	r1, [r3, #1]
 80054b8:	0c12      	lsrs	r2, r2, #16
 80054ba:	f002 0201 	and.w	r2, r2, #1
 80054be:	f002 0001 	and.w	r0, r2, #1
 80054c2:	789a      	ldrb	r2, [r3, #2]
 80054c4:	f022 0201 	bic.w	r2, r2, #1
 80054c8:	4611      	mov	r1, r2
 80054ca:	4602      	mov	r2, r0
 80054cc:	430a      	orrs	r2, r1
 80054ce:	709a      	strb	r2, [r3, #2]
        map->entries[entry].transfer_id = 0;
 80054d0:	687b      	ldr	r3, [r7, #4]
 80054d2:	681a      	ldr	r2, [r3, #0]
 80054d4:	8a3b      	ldrh	r3, [r7, #16]
 80054d6:	009b      	lsls	r3, r3, #2
 80054d8:	4413      	add	r3, r2
 80054da:	2200      	movs	r2, #0
 80054dc:	70da      	strb	r2, [r3, #3]
        map->entries[entry].next = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
 80054de:	687b      	ldr	r3, [r7, #4]
 80054e0:	681a      	ldr	r2, [r3, #0]
 80054e2:	8a3b      	ldrh	r3, [r7, #16]
 80054e4:	009b      	lsls	r3, r3, #2
 80054e6:	441a      	add	r2, r3
 80054e8:	7893      	ldrb	r3, [r2, #2]
 80054ea:	f043 03fe 	orr.w	r3, r3, #254	; 0xfe
 80054ee:	7093      	strb	r3, [r2, #2]
    }

    // Move to front
    if (entry_prev != UAVCAN_TRANSFER_ID_MAP_MAX_LEN) {
 80054f0:	89fb      	ldrh	r3, [r7, #14]
 80054f2:	2b7f      	cmp	r3, #127	; 0x7f
 80054f4:	d020      	beq.n	8005538 <uavcan_transfer_id_map_retrieve+0x168>
        map->entries[entry_prev].next = map->entries[entry].next;
 80054f6:	687b      	ldr	r3, [r7, #4]
 80054f8:	681a      	ldr	r2, [r3, #0]
 80054fa:	89fb      	ldrh	r3, [r7, #14]
 80054fc:	009b      	lsls	r3, r3, #2
 80054fe:	441a      	add	r2, r3
 8005500:	687b      	ldr	r3, [r7, #4]
 8005502:	6819      	ldr	r1, [r3, #0]
 8005504:	8a3b      	ldrh	r3, [r7, #16]
 8005506:	009b      	lsls	r3, r3, #2
 8005508:	440b      	add	r3, r1
 800550a:	789b      	ldrb	r3, [r3, #2]
 800550c:	f3c3 0346 	ubfx	r3, r3, #1, #7
 8005510:	b2d9      	uxtb	r1, r3
 8005512:	7893      	ldrb	r3, [r2, #2]
 8005514:	f361 0347 	bfi	r3, r1, #1, #7
 8005518:	7093      	strb	r3, [r2, #2]
        map->entries[entry].next = map->head;
 800551a:	687b      	ldr	r3, [r7, #4]
 800551c:	681a      	ldr	r2, [r3, #0]
 800551e:	8a3b      	ldrh	r3, [r7, #16]
 8005520:	009b      	lsls	r3, r3, #2
 8005522:	441a      	add	r2, r3
 8005524:	687b      	ldr	r3, [r7, #4]
 8005526:	88db      	ldrh	r3, [r3, #6]
 8005528:	b2db      	uxtb	r3, r3
 800552a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800552e:	b2d9      	uxtb	r1, r3
 8005530:	7893      	ldrb	r3, [r2, #2]
 8005532:	f361 0347 	bfi	r3, r1, #1, #7
 8005536:	7093      	strb	r3, [r2, #2]
    }
    map->head = entry;
 8005538:	687b      	ldr	r3, [r7, #4]
 800553a:	8a3a      	ldrh	r2, [r7, #16]
 800553c:	80da      	strh	r2, [r3, #6]

    return &map->entries[entry].transfer_id;
 800553e:	687b      	ldr	r3, [r7, #4]
 8005540:	681a      	ldr	r2, [r3, #0]
 8005542:	8a3b      	ldrh	r3, [r7, #16]
 8005544:	009b      	lsls	r3, r3, #2
 8005546:	4413      	add	r3, r2
 8005548:	3303      	adds	r3, #3
}
 800554a:	4618      	mov	r0, r3
 800554c:	371c      	adds	r7, #28
 800554e:	46bd      	mov	sp, r7
 8005550:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005554:	4770      	bx	lr
 8005556:	bf00      	nop

08005558 <uavcan_nodestatus_publisher_get_nodestatus_message>:

static void node_status_publisher_task_func(struct worker_thread_timer_task_s* task);

// TODO mechanism to change node status

const struct uavcan_protocol_NodeStatus_s* uavcan_nodestatus_publisher_get_nodestatus_message(void) {
 8005558:	b480      	push	{r7}
 800555a:	af00      	add	r7, sp, #0
    return &node_status;
 800555c:	4b02      	ldr	r3, [pc, #8]	; (8005568 <uavcan_nodestatus_publisher_get_nodestatus_message+0x10>)
}
 800555e:	4618      	mov	r0, r3
 8005560:	46bd      	mov	sp, r7
 8005562:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005566:	4770      	bx	lr
 8005568:	200014a0 	.word	0x200014a0

0800556c <_local_ctor_24>:

RUN_AFTER(UAVCAN_INIT) {
 800556c:	b580      	push	{r7, lr}
 800556e:	b082      	sub	sp, #8
 8005570:	af02      	add	r7, sp, #8
    node_status.uptime_sec = 0;
 8005572:	4b0e      	ldr	r3, [pc, #56]	; (80055ac <_local_ctor_24+0x40>)
 8005574:	2200      	movs	r2, #0
 8005576:	601a      	str	r2, [r3, #0]
    node_status.health = UAVCAN_PROTOCOL_NODESTATUS_HEALTH_OK;
 8005578:	4b0c      	ldr	r3, [pc, #48]	; (80055ac <_local_ctor_24+0x40>)
 800557a:	2200      	movs	r2, #0
 800557c:	711a      	strb	r2, [r3, #4]
    node_status.mode = UAVCAN_PROTOCOL_NODESTATUS_MODE_OPERATIONAL;
 800557e:	4b0b      	ldr	r3, [pc, #44]	; (80055ac <_local_ctor_24+0x40>)
 8005580:	2200      	movs	r2, #0
 8005582:	715a      	strb	r2, [r3, #5]
    node_status.sub_mode = 0;
 8005584:	4b09      	ldr	r3, [pc, #36]	; (80055ac <_local_ctor_24+0x40>)
 8005586:	2200      	movs	r2, #0
 8005588:	719a      	strb	r2, [r3, #6]
    node_status.vendor_specific_status_code = 0;
 800558a:	4b08      	ldr	r3, [pc, #32]	; (80055ac <_local_ctor_24+0x40>)
 800558c:	2200      	movs	r2, #0
 800558e:	811a      	strh	r2, [r3, #8]

    worker_thread_add_timer_task(&WT, &node_status_publisher_task, node_status_publisher_task_func, NULL, S2ST(1), true);
 8005590:	f242 7310 	movw	r3, #10000	; 0x2710
 8005594:	9300      	str	r3, [sp, #0]
 8005596:	2301      	movs	r3, #1
 8005598:	9301      	str	r3, [sp, #4]
 800559a:	4805      	ldr	r0, [pc, #20]	; (80055b0 <_local_ctor_24+0x44>)
 800559c:	4905      	ldr	r1, [pc, #20]	; (80055b4 <_local_ctor_24+0x48>)
 800559e:	4a06      	ldr	r2, [pc, #24]	; (80055b8 <_local_ctor_24+0x4c>)
 80055a0:	2300      	movs	r3, #0
 80055a2:	f003 f9e7 	bl	8008974 <worker_thread_add_timer_task>
}
 80055a6:	46bd      	mov	sp, r7
 80055a8:	bd80      	pop	{r7, pc}
 80055aa:	bf00      	nop
 80055ac:	200014a0 	.word	0x200014a0
 80055b0:	20000a20 	.word	0x20000a20
 80055b4:	200014ac 	.word	0x200014ac
 80055b8:	080055bd 	.word	0x080055bd

080055bc <node_status_publisher_task_func>:
void set_node_mode(uint8_t mode) {
    node_status.mode = mode;
}


static void node_status_publisher_task_func(struct worker_thread_timer_task_s* task) {
 80055bc:	b580      	push	{r7, lr}
 80055be:	b082      	sub	sp, #8
 80055c0:	af00      	add	r7, sp, #0
 80055c2:	6078      	str	r0, [r7, #4]
    (void)task;

    chnWrite(&SD1, (const uint8_t *)"sts\n", 5);
 80055c4:	4b0a      	ldr	r3, [pc, #40]	; (80055f0 <node_status_publisher_task_func+0x34>)
 80055c6:	681b      	ldr	r3, [r3, #0]
 80055c8:	681b      	ldr	r3, [r3, #0]
 80055ca:	4809      	ldr	r0, [pc, #36]	; (80055f0 <node_status_publisher_task_func+0x34>)
 80055cc:	4909      	ldr	r1, [pc, #36]	; (80055f4 <node_status_publisher_task_func+0x38>)
 80055ce:	2205      	movs	r2, #5
 80055d0:	4798      	blx	r3

    node_status.uptime_sec++;
 80055d2:	4b09      	ldr	r3, [pc, #36]	; (80055f8 <node_status_publisher_task_func+0x3c>)
 80055d4:	681b      	ldr	r3, [r3, #0]
 80055d6:	3301      	adds	r3, #1
 80055d8:	4a07      	ldr	r2, [pc, #28]	; (80055f8 <node_status_publisher_task_func+0x3c>)
 80055da:	6013      	str	r3, [r2, #0]
    uavcan_broadcast(0, &uavcan_protocol_NodeStatus_descriptor, CANARD_TRANSFER_PRIORITY_LOW, &node_status);
 80055dc:	2000      	movs	r0, #0
 80055de:	4907      	ldr	r1, [pc, #28]	; (80055fc <node_status_publisher_task_func+0x40>)
 80055e0:	2218      	movs	r2, #24
 80055e2:	4b05      	ldr	r3, [pc, #20]	; (80055f8 <node_status_publisher_task_func+0x3c>)
 80055e4:	f7ff fcb0 	bl	8004f48 <uavcan_broadcast>
}
 80055e8:	3708      	adds	r7, #8
 80055ea:	46bd      	mov	sp, r7
 80055ec:	bd80      	pop	{r7, pc}
 80055ee:	bf00      	nop
 80055f0:	200013ac 	.word	0x200013ac
 80055f4:	0800e63c 	.word	0x0800e63c
 80055f8:	200014a0 	.word	0x200014a0
 80055fc:	0800e6f8 	.word	0x0800e6f8

08005600 <_local_ctor_26>:
#include <uavcan.protocol.GetNodeInfo.h>

static struct worker_thread_listener_task_s getnodeinfo_req_listener_task;
static void getnodeinfo_req_handler(size_t msg_size, const void* buf, void* ctx);

RUN_AFTER(UAVCAN_INIT) {
 8005600:	b580      	push	{r7, lr}
 8005602:	b084      	sub	sp, #16
 8005604:	af02      	add	r7, sp, #8
    struct pubsub_topic_s* getnodeinfo_req_topic = uavcan_get_message_topic(0, &uavcan_protocol_GetNodeInfo_req_descriptor);
 8005606:	2000      	movs	r0, #0
 8005608:	4907      	ldr	r1, [pc, #28]	; (8005628 <_local_ctor_26+0x28>)
 800560a:	f001 f8a1 	bl	8006750 <uavcan_get_message_topic>
 800560e:	6078      	str	r0, [r7, #4]
    worker_thread_add_listener_task(&WT, &getnodeinfo_req_listener_task, getnodeinfo_req_topic, getnodeinfo_req_handler, NULL);
 8005610:	2300      	movs	r3, #0
 8005612:	9300      	str	r3, [sp, #0]
 8005614:	4805      	ldr	r0, [pc, #20]	; (800562c <_local_ctor_26+0x2c>)
 8005616:	4906      	ldr	r1, [pc, #24]	; (8005630 <_local_ctor_26+0x30>)
 8005618:	687a      	ldr	r2, [r7, #4]
 800561a:	4b06      	ldr	r3, [pc, #24]	; (8005634 <_local_ctor_26+0x34>)
 800561c:	f003 fa58 	bl	8008ad0 <worker_thread_add_listener_task>
}
 8005620:	3708      	adds	r7, #8
 8005622:	46bd      	mov	sp, r7
 8005624:	bd80      	pop	{r7, pc}
 8005626:	bf00      	nop
 8005628:	0800e7b8 	.word	0x0800e7b8
 800562c:	20000a20 	.word	0x20000a20
 8005630:	200014c0 	.word	0x200014c0
 8005634:	08005639 	.word	0x08005639

08005638 <getnodeinfo_req_handler>:

static void getnodeinfo_req_handler(size_t msg_size, const void* buf, void* ctx) {
 8005638:	b580      	push	{r7, lr}
 800563a:	b0e8      	sub	sp, #416	; 0x1a0
 800563c:	af00      	add	r7, sp, #0
 800563e:	f107 030c 	add.w	r3, r7, #12
 8005642:	6018      	str	r0, [r3, #0]
 8005644:	f107 0308 	add.w	r3, r7, #8
 8005648:	6019      	str	r1, [r3, #0]
 800564a:	1d3b      	adds	r3, r7, #4
 800564c:	601a      	str	r2, [r3, #0]
    (void)msg_size;
    (void)ctx;

    const struct uavcan_deserialized_message_s* msg_wrapper = buf;
 800564e:	f107 0308 	add.w	r3, r7, #8
 8005652:	681b      	ldr	r3, [r3, #0]
 8005654:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c

    struct uavcan_protocol_GetNodeInfo_res_s res;
    memset(&res, 0, sizeof(struct uavcan_protocol_GetNodeInfo_res_s));
 8005658:	f107 0310 	add.w	r3, r7, #16
 800565c:	4618      	mov	r0, r3
 800565e:	2100      	movs	r1, #0
 8005660:	f44f 72c4 	mov.w	r2, #392	; 0x188
 8005664:	f008 ffb2 	bl	800e5cc <memset>

    res.status = *uavcan_nodestatus_publisher_get_nodestatus_message();
 8005668:	f7ff ff76 	bl	8005558 <uavcan_nodestatus_publisher_get_nodestatus_message>
 800566c:	4602      	mov	r2, r0
 800566e:	f107 0310 	add.w	r3, r7, #16
 8005672:	ca07      	ldmia	r2, {r0, r1, r2}
 8005674:	e883 0007 	stmia.w	r3, {r0, r1, r2}

    board_get_unique_id(res.hardware_version.unique_id, sizeof(res.hardware_version.unique_id));
 8005678:	f107 0310 	add.w	r3, r7, #16
 800567c:	3322      	adds	r3, #34	; 0x22
 800567e:	4618      	mov	r0, r3
 8005680:	2110      	movs	r1, #16
 8005682:	f7fe fe4d 	bl	8004320 <board_get_unique_id>
        res.hardware_version.minor = boot_msg.boot_info_msg.hw_info->hw_minor_version;
    }
#endif

#ifdef MODULE_APP_DESCRIPTOR_ENABLED
    res.software_version.major = shared_app_descriptor.major_version;
 8005686:	4b14      	ldr	r3, [pc, #80]	; (80056d8 <getnodeinfo_req_handler+0xa0>)
 8005688:	7e1a      	ldrb	r2, [r3, #24]
 800568a:	f107 0310 	add.w	r3, r7, #16
 800568e:	741a      	strb	r2, [r3, #16]
    res.software_version.minor = shared_app_descriptor.minor_version;
 8005690:	4b11      	ldr	r3, [pc, #68]	; (80056d8 <getnodeinfo_req_handler+0xa0>)
 8005692:	7e5a      	ldrb	r2, [r3, #25]
 8005694:	f107 0310 	add.w	r3, r7, #16
 8005698:	745a      	strb	r2, [r3, #17]
    res.software_version.optional_field_flags = UAVCAN_PROTOCOL_SOFTWAREVERSION_OPTIONAL_FIELD_FLAG_VCS_COMMIT |
 800569a:	f107 0310 	add.w	r3, r7, #16
 800569e:	2203      	movs	r2, #3
 80056a0:	749a      	strb	r2, [r3, #18]
                                                UAVCAN_PROTOCOL_SOFTWAREVERSION_OPTIONAL_FIELD_FLAG_IMAGE_CRC;
    res.software_version.vcs_commit = shared_app_descriptor.vcs_commit;
 80056a2:	4b0d      	ldr	r3, [pc, #52]	; (80056d8 <getnodeinfo_req_handler+0xa0>)
 80056a4:	695a      	ldr	r2, [r3, #20]
 80056a6:	f107 0310 	add.w	r3, r7, #16
 80056aa:	615a      	str	r2, [r3, #20]
    res.software_version.image_crc = *(volatile uint64_t*)&shared_app_descriptor.image_crc;
 80056ac:	4b0a      	ldr	r3, [pc, #40]	; (80056d8 <getnodeinfo_req_handler+0xa0>)
 80056ae:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80056b2:	f107 0110 	add.w	r1, r7, #16
 80056b6:	e9c1 2306 	strd	r2, r3, [r1, #24]
#endif

    uavcan_respond(msg_wrapper->uavcan_idx, msg_wrapper, &res);
 80056ba:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 80056be:	781a      	ldrb	r2, [r3, #0]
 80056c0:	f107 0310 	add.w	r3, r7, #16
 80056c4:	4610      	mov	r0, r2
 80056c6:	f8d7 119c 	ldr.w	r1, [r7, #412]	; 0x19c
 80056ca:	461a      	mov	r2, r3
 80056cc:	f7ff fc80 	bl	8004fd0 <uavcan_respond>
}
 80056d0:	f507 77d0 	add.w	r7, r7, #416	; 0x1a0
 80056d4:	46bd      	mov	sp, r7
 80056d6:	bd80      	pop	{r7, pc}
 80056d8:	08003160 	.word	0x08003160

080056dc <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
static inline void *chCoreAlloc(size_t size) {
 80056dc:	b580      	push	{r7, lr}
 80056de:	b082      	sub	sp, #8
 80056e0:	af00      	add	r7, sp, #0
 80056e2:	6078      	str	r0, [r7, #4]

  return chCoreAllocAlignedWithOffset(size, PORT_NATURAL_ALIGN, 0U);
 80056e4:	6878      	ldr	r0, [r7, #4]
 80056e6:	2104      	movs	r1, #4
 80056e8:	2200      	movs	r2, #0
 80056ea:	f004 fb93 	bl	8009e14 <chCoreAllocAlignedWithOffset>
 80056ee:	4603      	mov	r3, r0
}
 80056f0:	4618      	mov	r0, r3
 80056f2:	3708      	adds	r7, #8
 80056f4:	46bd      	mov	sp, r7
 80056f6:	bd80      	pop	{r7, pc}

080056f8 <_local_ctor_34>:
    struct worker_thread_timer_task_s request_transmit_task;
    struct worker_thread_listener_task_s allocation_listener_task;
};


RUN_AFTER(UAVCAN_INIT) {
 80056f8:	b580      	push	{r7, lr}
 80056fa:	b086      	sub	sp, #24
 80056fc:	af02      	add	r7, sp, #8
     for (uint8_t i=0; i<uavcan_get_num_instances(); i++) {
 80056fe:	2300      	movs	r3, #0
 8005700:	73fb      	strb	r3, [r7, #15]
 8005702:	e034      	b.n	800576e <_local_ctor_34+0x76>
        if (uavcan_get_node_id(i) != 0) {
 8005704:	7bfb      	ldrb	r3, [r7, #15]
 8005706:	4618      	mov	r0, r3
 8005708:	f001 f862 	bl	80067d0 <uavcan_get_node_id>
 800570c:	4603      	mov	r3, r0
 800570e:	2b00      	cmp	r3, #0
 8005710:	d127      	bne.n	8005762 <_local_ctor_34+0x6a>
            continue;
        }

        struct allocatee_instance_s* instance = chCoreAlloc(sizeof(struct allocatee_instance_s));
 8005712:	2050      	movs	r0, #80	; 0x50
 8005714:	f7ff ffe2 	bl	80056dc <chCoreAlloc>
 8005718:	60b8      	str	r0, [r7, #8]

        chDbgCheck(instance != NULL);
 800571a:	68bb      	ldr	r3, [r7, #8]
 800571c:	2b00      	cmp	r3, #0
 800571e:	d102      	bne.n	8005726 <_local_ctor_34+0x2e>
 8005720:	4818      	ldr	r0, [pc, #96]	; (8005784 <_local_ctor_34+0x8c>)
 8005722:	f005 fb6d 	bl	800ae00 <chSysHalt>
        if (!instance) {
 8005726:	68bb      	ldr	r3, [r7, #8]
 8005728:	2b00      	cmp	r3, #0
 800572a:	d01c      	beq.n	8005766 <_local_ctor_34+0x6e>
            continue;
        }

        struct pubsub_topic_s* allocation_topic = uavcan_get_message_topic(i, &uavcan_protocol_dynamic_node_id_Allocation_descriptor);
 800572c:	7bfb      	ldrb	r3, [r7, #15]
 800572e:	4618      	mov	r0, r3
 8005730:	4915      	ldr	r1, [pc, #84]	; (8005788 <_local_ctor_34+0x90>)
 8005732:	f001 f80d 	bl	8006750 <uavcan_get_message_topic>
 8005736:	6078      	str	r0, [r7, #4]

        instance->uavcan_idx = i;
 8005738:	68bb      	ldr	r3, [r7, #8]
 800573a:	7bfa      	ldrb	r2, [r7, #15]
 800573c:	701a      	strb	r2, [r3, #0]
        instance->unique_id_offset = 0;
 800573e:	68bb      	ldr	r3, [r7, #8]
 8005740:	2200      	movs	r2, #0
 8005742:	605a      	str	r2, [r3, #4]
        worker_thread_add_listener_task(&WT, &instance->allocation_listener_task, allocation_topic, allocation_message_handler, instance);
 8005744:	68bb      	ldr	r3, [r7, #8]
 8005746:	f103 021c 	add.w	r2, r3, #28
 800574a:	68bb      	ldr	r3, [r7, #8]
 800574c:	9300      	str	r3, [sp, #0]
 800574e:	480f      	ldr	r0, [pc, #60]	; (800578c <_local_ctor_34+0x94>)
 8005750:	4611      	mov	r1, r2
 8005752:	687a      	ldr	r2, [r7, #4]
 8005754:	4b0e      	ldr	r3, [pc, #56]	; (8005790 <_local_ctor_34+0x98>)
 8005756:	f003 f9bb 	bl	8008ad0 <worker_thread_add_listener_task>
        allocation_start_request_timer(instance);
 800575a:	68b8      	ldr	r0, [r7, #8]
 800575c:	f7fe fb12 	bl	8003d84 <allocation_start_request_timer.lto_priv.72>
 8005760:	e002      	b.n	8005768 <_local_ctor_34+0x70>


RUN_AFTER(UAVCAN_INIT) {
     for (uint8_t i=0; i<uavcan_get_num_instances(); i++) {
        if (uavcan_get_node_id(i) != 0) {
            continue;
 8005762:	bf00      	nop
 8005764:	e000      	b.n	8005768 <_local_ctor_34+0x70>

        struct allocatee_instance_s* instance = chCoreAlloc(sizeof(struct allocatee_instance_s));

        chDbgCheck(instance != NULL);
        if (!instance) {
            continue;
 8005766:	bf00      	nop
    struct worker_thread_listener_task_s allocation_listener_task;
};


RUN_AFTER(UAVCAN_INIT) {
     for (uint8_t i=0; i<uavcan_get_num_instances(); i++) {
 8005768:	7bfb      	ldrb	r3, [r7, #15]
 800576a:	3301      	adds	r3, #1
 800576c:	73fb      	strb	r3, [r7, #15]
 800576e:	f7ff fccb 	bl	8005108 <uavcan_get_num_instances>
 8005772:	4603      	mov	r3, r0
 8005774:	461a      	mov	r2, r3
 8005776:	7bfb      	ldrb	r3, [r7, #15]
 8005778:	4293      	cmp	r3, r2
 800577a:	d3c3      	bcc.n	8005704 <_local_ctor_34+0xc>
        instance->uavcan_idx = i;
        instance->unique_id_offset = 0;
        worker_thread_add_listener_task(&WT, &instance->allocation_listener_task, allocation_topic, allocation_message_handler, instance);
        allocation_start_request_timer(instance);
    }
}
 800577c:	3710      	adds	r7, #16
 800577e:	46bd      	mov	sp, r7
 8005780:	bd80      	pop	{r7, pc}
 8005782:	bf00      	nop
 8005784:	0800eccc 	.word	0x0800eccc
 8005788:	0800e758 	.word	0x0800e758
 800578c:	20000a20 	.word	0x20000a20
 8005790:	08005865 	.word	0x08005865

08005794 <allocation_stop_and_cleanup.lto_priv.64>:

static void allocation_stop_and_cleanup(struct allocatee_instance_s* instance) {
 8005794:	b580      	push	{r7, lr}
 8005796:	b082      	sub	sp, #8
 8005798:	af00      	add	r7, sp, #0
 800579a:	6078      	str	r0, [r7, #4]
    worker_thread_remove_timer_task(&WT, &instance->request_transmit_task);
 800579c:	687b      	ldr	r3, [r7, #4]
 800579e:	3308      	adds	r3, #8
 80057a0:	4806      	ldr	r0, [pc, #24]	; (80057bc <allocation_stop_and_cleanup.lto_priv.64+0x28>)
 80057a2:	4619      	mov	r1, r3
 80057a4:	f003 f972 	bl	8008a8c <worker_thread_remove_timer_task>
    worker_thread_remove_listener_task(&WT, &instance->allocation_listener_task);
 80057a8:	687b      	ldr	r3, [r7, #4]
 80057aa:	331c      	adds	r3, #28
 80057ac:	4803      	ldr	r0, [pc, #12]	; (80057bc <allocation_stop_and_cleanup.lto_priv.64+0x28>)
 80057ae:	4619      	mov	r1, r3
 80057b0:	f001 f820 	bl	80067f4 <worker_thread_remove_listener_task>
}
 80057b4:	3708      	adds	r7, #8
 80057b6:	46bd      	mov	sp, r7
 80057b8:	bd80      	pop	{r7, pc}
 80057ba:	bf00      	nop
 80057bc:	20000a20 	.word	0x20000a20

080057c0 <allocation_timer_expired.lto_priv.7>:

static void allocation_timer_expired(struct worker_thread_timer_task_s* task) {
 80057c0:	b590      	push	{r4, r7, lr}
 80057c2:	b08d      	sub	sp, #52	; 0x34
 80057c4:	af00      	add	r7, sp, #0
 80057c6:	6078      	str	r0, [r7, #4]
    struct allocatee_instance_s* instance = worker_thread_task_get_user_context(task);
 80057c8:	6878      	ldr	r0, [r7, #4]
 80057ca:	f003 f96f 	bl	8008aac <worker_thread_task_get_user_context>
 80057ce:	62f8      	str	r0, [r7, #44]	; 0x2c

    if (!allocation_running(instance)) {
 80057d0:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80057d2:	f7fe fb6b 	bl	8003eac <allocation_running.lto_priv.73>
 80057d6:	4603      	mov	r3, r0
 80057d8:	f083 0301 	eor.w	r3, r3, #1
 80057dc:	b2db      	uxtb	r3, r3
 80057de:	2b00      	cmp	r3, #0
 80057e0:	d003      	beq.n	80057ea <allocation_timer_expired.lto_priv.7+0x2a>
        allocation_stop_and_cleanup(instance);
 80057e2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80057e4:	f7ff ffd6 	bl	8005794 <allocation_stop_and_cleanup.lto_priv.64>
 80057e8:	e036      	b.n	8005858 <allocation_timer_expired.lto_priv.7+0x98>
        return;
    }

    // Start allocation request timer
    allocation_start_request_timer(instance);
 80057ea:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80057ec:	f7fe faca 	bl	8003d84 <allocation_start_request_timer.lto_priv.72>

    // Send allocation message
    struct uavcan_protocol_dynamic_node_id_Allocation_s msg;

    uint8_t my_unique_id[16];
    board_get_unique_id(my_unique_id, sizeof(my_unique_id));
 80057f0:	f107 0308 	add.w	r3, r7, #8
 80057f4:	4618      	mov	r0, r3
 80057f6:	2110      	movs	r1, #16
 80057f8:	f7fe fd92 	bl	8004320 <board_get_unique_id>

    msg.node_id = 0;
 80057fc:	2300      	movs	r3, #0
 80057fe:	763b      	strb	r3, [r7, #24]
    msg.first_part_of_unique_id = (instance->unique_id_offset == 0);
 8005800:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005802:	685b      	ldr	r3, [r3, #4]
 8005804:	2b00      	cmp	r3, #0
 8005806:	bf0c      	ite	eq
 8005808:	2301      	moveq	r3, #1
 800580a:	2300      	movne	r3, #0
 800580c:	b2db      	uxtb	r3, r3
 800580e:	767b      	strb	r3, [r7, #25]
    msg.unique_id_len = MIN(16-instance->unique_id_offset, UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MAX_LENGTH_OF_UNIQUE_ID_IN_REQUEST);
 8005810:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005812:	685b      	ldr	r3, [r3, #4]
 8005814:	f1c3 0310 	rsb	r3, r3, #16
 8005818:	2b06      	cmp	r3, #6
 800581a:	bf28      	it	cs
 800581c:	2306      	movcs	r3, #6
 800581e:	b2db      	uxtb	r3, r3
 8005820:	76bb      	strb	r3, [r7, #26]
    memcpy(&msg.unique_id, &my_unique_id[instance->unique_id_offset], msg.unique_id_len);
 8005822:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005824:	685b      	ldr	r3, [r3, #4]
 8005826:	f107 0208 	add.w	r2, r7, #8
 800582a:	441a      	add	r2, r3
 800582c:	7ebb      	ldrb	r3, [r7, #26]
 800582e:	461c      	mov	r4, r3
 8005830:	f107 0318 	add.w	r3, r7, #24
 8005834:	3303      	adds	r3, #3
 8005836:	4618      	mov	r0, r3
 8005838:	4611      	mov	r1, r2
 800583a:	4622      	mov	r2, r4
 800583c:	f008 fea0 	bl	800e580 <memcpy>
    uavcan_broadcast(instance->uavcan_idx, &uavcan_protocol_dynamic_node_id_Allocation_descriptor, CANARD_TRANSFER_PRIORITY_LOW, &msg);
 8005840:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005842:	781a      	ldrb	r2, [r3, #0]
 8005844:	f107 0318 	add.w	r3, r7, #24
 8005848:	4610      	mov	r0, r2
 800584a:	4905      	ldr	r1, [pc, #20]	; (8005860 <allocation_timer_expired.lto_priv.7+0xa0>)
 800584c:	2218      	movs	r2, #24
 800584e:	f7ff fb7b 	bl	8004f48 <uavcan_broadcast>
    instance->unique_id_offset = 0;
 8005852:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005854:	2200      	movs	r2, #0
 8005856:	605a      	str	r2, [r3, #4]
}
 8005858:	3734      	adds	r7, #52	; 0x34
 800585a:	46bd      	mov	sp, r7
 800585c:	bd90      	pop	{r4, r7, pc}
 800585e:	bf00      	nop
 8005860:	0800e758 	.word	0x0800e758

08005864 <allocation_message_handler>:

static void allocation_message_handler(size_t msg_size, const void* buf, void* ctx) {
 8005864:	b590      	push	{r4, r7, lr}
 8005866:	b08d      	sub	sp, #52	; 0x34
 8005868:	af00      	add	r7, sp, #0
 800586a:	60f8      	str	r0, [r7, #12]
 800586c:	60b9      	str	r1, [r7, #8]
 800586e:	607a      	str	r2, [r7, #4]
    (void)msg_size;

    const struct uavcan_deserialized_message_s* wrapper = buf;
 8005870:	68bb      	ldr	r3, [r7, #8]
 8005872:	62fb      	str	r3, [r7, #44]	; 0x2c
    const struct uavcan_protocol_dynamic_node_id_Allocation_s* msg = (const struct uavcan_protocol_dynamic_node_id_Allocation_s*)wrapper->msg;
 8005874:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005876:	3310      	adds	r3, #16
 8005878:	62bb      	str	r3, [r7, #40]	; 0x28

    struct allocatee_instance_s* instance = ctx;
 800587a:	687b      	ldr	r3, [r7, #4]
 800587c:	627b      	str	r3, [r7, #36]	; 0x24

    if (!allocation_running(instance)) {
 800587e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8005880:	f7fe fb14 	bl	8003eac <allocation_running.lto_priv.73>
 8005884:	4603      	mov	r3, r0
 8005886:	f083 0301 	eor.w	r3, r3, #1
 800588a:	b2db      	uxtb	r3, r3
 800588c:	2b00      	cmp	r3, #0
 800588e:	d003      	beq.n	8005898 <allocation_message_handler+0x34>
        allocation_stop_and_cleanup(instance);
 8005890:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8005892:	f7ff ff7f 	bl	8005794 <allocation_stop_and_cleanup.lto_priv.64>
 8005896:	e036      	b.n	8005906 <allocation_message_handler+0xa2>
        return;
    }

    allocation_start_request_timer(instance);
 8005898:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800589a:	f7fe fa73 	bl	8003d84 <allocation_start_request_timer.lto_priv.72>
    instance->unique_id_offset = 0;
 800589e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80058a0:	2200      	movs	r2, #0
 80058a2:	605a      	str	r2, [r3, #4]

    if (wrapper->source_node_id == 0) {
 80058a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80058a6:	7b1b      	ldrb	r3, [r3, #12]
 80058a8:	2b00      	cmp	r3, #0
 80058aa:	d02c      	beq.n	8005906 <allocation_message_handler+0xa2>
        return;
    }

    uint8_t my_unique_id[16];
    board_get_unique_id(my_unique_id, sizeof(my_unique_id));
 80058ac:	f107 0314 	add.w	r3, r7, #20
 80058b0:	4618      	mov	r0, r3
 80058b2:	2110      	movs	r1, #16
 80058b4:	f7fe fd34 	bl	8004320 <board_get_unique_id>

    if (memcmp(my_unique_id, msg->unique_id, msg->unique_id_len) != 0) {
 80058b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80058ba:	1cda      	adds	r2, r3, #3
 80058bc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80058be:	789b      	ldrb	r3, [r3, #2]
 80058c0:	461c      	mov	r4, r3
 80058c2:	f107 0314 	add.w	r3, r7, #20
 80058c6:	4618      	mov	r0, r3
 80058c8:	4611      	mov	r1, r2
 80058ca:	4622      	mov	r2, r4
 80058cc:	f008 fe48 	bl	800e560 <memcmp>
 80058d0:	4603      	mov	r3, r0
 80058d2:	2b00      	cmp	r3, #0
 80058d4:	d117      	bne.n	8005906 <allocation_message_handler+0xa2>
        // If unique ID does not match, return
        return;
    }

    if (msg->unique_id_len < 16) {
 80058d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80058d8:	789b      	ldrb	r3, [r3, #2]
 80058da:	2b0f      	cmp	r3, #15
 80058dc:	d808      	bhi.n	80058f0 <allocation_message_handler+0x8c>
        // Unique ID partially matches - set the UID offset and start the followup timer
        instance->unique_id_offset = msg->unique_id_len;
 80058de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80058e0:	789b      	ldrb	r3, [r3, #2]
 80058e2:	461a      	mov	r2, r3
 80058e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80058e6:	605a      	str	r2, [r3, #4]
        allocation_start_followup_timer(instance);
 80058e8:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80058ea:	f7fe fa99 	bl	8003e20 <allocation_start_followup_timer.lto_priv.71>
 80058ee:	e00a      	b.n	8005906 <allocation_message_handler+0xa2>
    } else {
        // Complete match received
        uavcan_set_node_id(instance->uavcan_idx, msg->node_id);
 80058f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80058f2:	781a      	ldrb	r2, [r3, #0]
 80058f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80058f6:	781b      	ldrb	r3, [r3, #0]
 80058f8:	4610      	mov	r0, r2
 80058fa:	4619      	mov	r1, r3
 80058fc:	f7ff f8b4 	bl	8004a68 <uavcan_set_node_id>
        allocation_stop_and_cleanup(instance);
 8005900:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8005902:	f7ff ff47 	bl	8005794 <allocation_stop_and_cleanup.lto_priv.64>
    }
}
 8005906:	3734      	adds	r7, #52	; 0x34
 8005908:	46bd      	mov	sp, r7
 800590a:	bd90      	pop	{r4, r7, pc}

0800590c <can_start>:
        instance->baudrate_confirmed = false;
    }
    instance->baudrate = baudrate;
}

void can_start(struct can_instance_s* instance, bool silent, bool auto_retransmit, uint32_t baudrate) {
 800590c:	b580      	push	{r7, lr}
 800590e:	b084      	sub	sp, #16
 8005910:	af00      	add	r7, sp, #0
 8005912:	60f8      	str	r0, [r7, #12]
 8005914:	607b      	str	r3, [r7, #4]
 8005916:	460b      	mov	r3, r1
 8005918:	72fb      	strb	r3, [r7, #11]
 800591a:	4613      	mov	r3, r2
 800591c:	72bb      	strb	r3, [r7, #10]
    chSysLock();
 800591e:	f001 ffe3 	bl	80078e8 <chSysLock.lto_priv.102>
    can_start_I(instance, silent, auto_retransmit, baudrate);
 8005922:	7afa      	ldrb	r2, [r7, #11]
 8005924:	7abb      	ldrb	r3, [r7, #10]
 8005926:	68f8      	ldr	r0, [r7, #12]
 8005928:	4611      	mov	r1, r2
 800592a:	461a      	mov	r2, r3
 800592c:	687b      	ldr	r3, [r7, #4]
 800592e:	f002 f8fd 	bl	8007b2c <can_start_I>
    chSysUnlock();
 8005932:	f001 ffe1 	bl	80078f8 <chSysUnlock.lto_priv.101>
}
 8005936:	3710      	adds	r7, #16
 8005938:	46bd      	mov	sp, r7
 800593a:	bd80      	pop	{r7, pc}

0800593c <can_stop_I>:

void can_stop_I(struct can_instance_s* instance) {
 800593c:	b580      	push	{r7, lr}
 800593e:	b082      	sub	sp, #8
 8005940:	af00      	add	r7, sp, #0
 8005942:	6078      	str	r0, [r7, #4]
    if (!instance) {
 8005944:	687b      	ldr	r3, [r7, #4]
 8005946:	2b00      	cmp	r3, #0
 8005948:	d00d      	beq.n	8005966 <can_stop_I+0x2a>
        return;
    }

    if (instance->started) {
 800594a:	687b      	ldr	r3, [r7, #4]
 800594c:	785b      	ldrb	r3, [r3, #1]
 800594e:	2b00      	cmp	r3, #0
 8005950:	d009      	beq.n	8005966 <can_stop_I+0x2a>
        instance->driver_iface->stop(instance->driver_ctx);
 8005952:	687b      	ldr	r3, [r7, #4]
 8005954:	691b      	ldr	r3, [r3, #16]
 8005956:	685b      	ldr	r3, [r3, #4]
 8005958:	687a      	ldr	r2, [r7, #4]
 800595a:	68d2      	ldr	r2, [r2, #12]
 800595c:	4610      	mov	r0, r2
 800595e:	4798      	blx	r3
        instance->started = true;
 8005960:	687b      	ldr	r3, [r7, #4]
 8005962:	2201      	movs	r2, #1
 8005964:	705a      	strb	r2, [r3, #1]
    }
}
 8005966:	3708      	adds	r7, #8
 8005968:	46bd      	mov	sp, r7
 800596a:	bd80      	pop	{r7, pc}

0800596c <can_allocate_tx_frame_and_append_I>:
    chSysLock();
    can_stop_I(instance);
    chSysUnlock();
}

struct can_tx_frame_s* can_allocate_tx_frame_and_append_I(struct can_instance_s* instance, struct can_tx_frame_s** frame_list) {
 800596c:	b580      	push	{r7, lr}
 800596e:	b084      	sub	sp, #16
 8005970:	af00      	add	r7, sp, #0
 8005972:	6078      	str	r0, [r7, #4]
 8005974:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 8005976:	f005 fb21 	bl	800afbc <chDbgCheckClassI>
    
    if (!instance || !frame_list) {
 800597a:	687b      	ldr	r3, [r7, #4]
 800597c:	2b00      	cmp	r3, #0
 800597e:	d002      	beq.n	8005986 <can_allocate_tx_frame_and_append_I+0x1a>
 8005980:	683b      	ldr	r3, [r7, #0]
 8005982:	2b00      	cmp	r3, #0
 8005984:	d101      	bne.n	800598a <can_allocate_tx_frame_and_append_I+0x1e>
        return NULL;
 8005986:	2300      	movs	r3, #0
 8005988:	e01c      	b.n	80059c4 <can_allocate_tx_frame_and_append_I+0x58>
    }
    
    struct can_tx_frame_s* new_frame = chPoolAllocI(&instance->frame_pool);
 800598a:	687b      	ldr	r3, [r7, #4]
 800598c:	3330      	adds	r3, #48	; 0x30
 800598e:	4618      	mov	r0, r3
 8005990:	f004 faf4 	bl	8009f7c <chPoolAllocI>
 8005994:	60b8      	str	r0, [r7, #8]
    if (!new_frame) {
 8005996:	68bb      	ldr	r3, [r7, #8]
 8005998:	2b00      	cmp	r3, #0
 800599a:	d101      	bne.n	80059a0 <can_allocate_tx_frame_and_append_I+0x34>
        return NULL;
 800599c:	2300      	movs	r3, #0
 800599e:	e011      	b.n	80059c4 <can_allocate_tx_frame_and_append_I+0x58>
    }
    
    LINKED_LIST_APPEND(struct can_tx_frame_s, *frame_list, new_frame);
 80059a0:	68bb      	ldr	r3, [r7, #8]
 80059a2:	2200      	movs	r2, #0
 80059a4:	619a      	str	r2, [r3, #24]
 80059a6:	683b      	ldr	r3, [r7, #0]
 80059a8:	60fb      	str	r3, [r7, #12]
 80059aa:	e003      	b.n	80059b4 <can_allocate_tx_frame_and_append_I+0x48>
 80059ac:	68fb      	ldr	r3, [r7, #12]
 80059ae:	681b      	ldr	r3, [r3, #0]
 80059b0:	3318      	adds	r3, #24
 80059b2:	60fb      	str	r3, [r7, #12]
 80059b4:	68fb      	ldr	r3, [r7, #12]
 80059b6:	681b      	ldr	r3, [r3, #0]
 80059b8:	2b00      	cmp	r3, #0
 80059ba:	d1f7      	bne.n	80059ac <can_allocate_tx_frame_and_append_I+0x40>
 80059bc:	68fb      	ldr	r3, [r7, #12]
 80059be:	68ba      	ldr	r2, [r7, #8]
 80059c0:	601a      	str	r2, [r3, #0]

    return new_frame;
 80059c2:	68bb      	ldr	r3, [r7, #8]
}
 80059c4:	4618      	mov	r0, r3
 80059c6:	3710      	adds	r7, #16
 80059c8:	46bd      	mov	sp, r7
 80059ca:	bd80      	pop	{r7, pc}

080059cc <can_allocate_tx_frame_and_append>:

struct can_tx_frame_s* can_allocate_tx_frame_and_append(struct can_instance_s* instance, struct can_tx_frame_s** frame_list) {
 80059cc:	b580      	push	{r7, lr}
 80059ce:	b084      	sub	sp, #16
 80059d0:	af00      	add	r7, sp, #0
 80059d2:	6078      	str	r0, [r7, #4]
 80059d4:	6039      	str	r1, [r7, #0]
    chSysLock();
 80059d6:	f001 ff87 	bl	80078e8 <chSysLock.lto_priv.102>
    struct can_tx_frame_s* ret = can_allocate_tx_frame_and_append_I(instance, frame_list);
 80059da:	6878      	ldr	r0, [r7, #4]
 80059dc:	6839      	ldr	r1, [r7, #0]
 80059de:	f7ff ffc5 	bl	800596c <can_allocate_tx_frame_and_append_I>
 80059e2:	60f8      	str	r0, [r7, #12]
    chSysUnlock();
 80059e4:	f001 ff88 	bl	80078f8 <chSysUnlock.lto_priv.101>
    return ret;
 80059e8:	68fb      	ldr	r3, [r7, #12]
}
 80059ea:	4618      	mov	r0, r3
 80059ec:	3710      	adds	r7, #16
 80059ee:	46bd      	mov	sp, r7
 80059f0:	bd80      	pop	{r7, pc}
 80059f2:	bf00      	nop

080059f4 <can_enqueue_tx_frames>:
        }
    }
    return ret;
}

void can_enqueue_tx_frames(struct can_instance_s* instance, struct can_tx_frame_s** frame_list, systime_t tx_timeout, struct pubsub_topic_s* completion_topic) {
 80059f4:	b580      	push	{r7, lr}
 80059f6:	b088      	sub	sp, #32
 80059f8:	af00      	add	r7, sp, #0
 80059fa:	60f8      	str	r0, [r7, #12]
 80059fc:	60b9      	str	r1, [r7, #8]
 80059fe:	603b      	str	r3, [r7, #0]
 8005a00:	4613      	mov	r3, r2
 8005a02:	80fb      	strh	r3, [r7, #6]
    if (!instance) {
 8005a04:	68fb      	ldr	r3, [r7, #12]
 8005a06:	2b00      	cmp	r3, #0
 8005a08:	d02f      	beq.n	8005a6a <can_enqueue_tx_frames+0x76>
        return;
    }
    
    systime_t t_now = chVTGetSystemTimeX();
 8005a0a:	f001 ff91 	bl	8007930 <chVTGetSystemTimeX.lto_priv.100>
 8005a0e:	4603      	mov	r3, r0
 8005a10:	837b      	strh	r3, [r7, #26]

    struct can_tx_frame_s* frame = *frame_list;
 8005a12:	68bb      	ldr	r3, [r7, #8]
 8005a14:	681b      	ldr	r3, [r3, #0]
 8005a16:	61fb      	str	r3, [r7, #28]
 8005a18:	e01b      	b.n	8005a52 <can_enqueue_tx_frames+0x5e>
    while (frame != NULL) {
        struct can_tx_frame_s* next_frame = frame->next;
 8005a1a:	69fb      	ldr	r3, [r7, #28]
 8005a1c:	699b      	ldr	r3, [r3, #24]
 8005a1e:	617b      	str	r3, [r7, #20]

        frame->creation_systime = t_now;
 8005a20:	69fb      	ldr	r3, [r7, #28]
 8005a22:	8b7a      	ldrh	r2, [r7, #26]
 8005a24:	821a      	strh	r2, [r3, #16]
        frame->tx_timeout = tx_timeout;
 8005a26:	69fb      	ldr	r3, [r7, #28]
 8005a28:	88fa      	ldrh	r2, [r7, #6]
 8005a2a:	825a      	strh	r2, [r3, #18]
        if (!frame->next) {
 8005a2c:	69fb      	ldr	r3, [r7, #28]
 8005a2e:	699b      	ldr	r3, [r3, #24]
 8005a30:	2b00      	cmp	r3, #0
 8005a32:	d103      	bne.n	8005a3c <can_enqueue_tx_frames+0x48>
            frame->completion_topic = completion_topic;
 8005a34:	69fb      	ldr	r3, [r7, #28]
 8005a36:	683a      	ldr	r2, [r7, #0]
 8005a38:	615a      	str	r2, [r3, #20]
 8005a3a:	e002      	b.n	8005a42 <can_enqueue_tx_frames+0x4e>
        } else {
            frame->completion_topic = NULL;
 8005a3c:	69fb      	ldr	r3, [r7, #28]
 8005a3e:	2200      	movs	r2, #0
 8005a40:	615a      	str	r2, [r3, #20]
        }
        can_tx_queue_push(&instance->tx_queue, frame);
 8005a42:	68fb      	ldr	r3, [r7, #12]
 8005a44:	333c      	adds	r3, #60	; 0x3c
 8005a46:	4618      	mov	r0, r3
 8005a48:	69f9      	ldr	r1, [r7, #28]
 8005a4a:	f001 fdad 	bl	80075a8 <can_tx_queue_push>

        frame = next_frame;
 8005a4e:	697b      	ldr	r3, [r7, #20]
 8005a50:	61fb      	str	r3, [r7, #28]
    }
    
    systime_t t_now = chVTGetSystemTimeX();

    struct can_tx_frame_s* frame = *frame_list;
    while (frame != NULL) {
 8005a52:	69fb      	ldr	r3, [r7, #28]
 8005a54:	2b00      	cmp	r3, #0
 8005a56:	d1e0      	bne.n	8005a1a <can_enqueue_tx_frames+0x26>
        can_tx_queue_push(&instance->tx_queue, frame);

        frame = next_frame;
    }

    *frame_list = NULL;
 8005a58:	68bb      	ldr	r3, [r7, #8]
 8005a5a:	2200      	movs	r2, #0
 8005a5c:	601a      	str	r2, [r3, #0]

    can_try_enqueue_waiting_frame(instance);
 8005a5e:	68f8      	ldr	r0, [r7, #12]
 8005a60:	f000 f960 	bl	8005d24 <can_try_enqueue_waiting_frame>
    can_reschedule_expire_timer(instance);
 8005a64:	68f8      	ldr	r0, [r7, #12]
 8005a66:	f000 f9cb 	bl	8005e00 <can_reschedule_expire_timer>
}
 8005a6a:	3720      	adds	r7, #32
 8005a6c:	46bd      	mov	sp, r7
 8005a6e:	bd80      	pop	{r7, pc}

08005a70 <can_free_tx_frames>:

void can_free_tx_frames(struct can_instance_s* instance, struct can_tx_frame_s** frame_list) {
 8005a70:	b580      	push	{r7, lr}
 8005a72:	b084      	sub	sp, #16
 8005a74:	af00      	add	r7, sp, #0
 8005a76:	6078      	str	r0, [r7, #4]
 8005a78:	6039      	str	r1, [r7, #0]
    if (!instance) {
 8005a7a:	687b      	ldr	r3, [r7, #4]
 8005a7c:	2b00      	cmp	r3, #0
 8005a7e:	d012      	beq.n	8005aa6 <can_free_tx_frames+0x36>
        return;
    }
    
    for (struct can_tx_frame_s* frame = *frame_list; frame != NULL; frame = frame->next) {
 8005a80:	683b      	ldr	r3, [r7, #0]
 8005a82:	681b      	ldr	r3, [r3, #0]
 8005a84:	60fb      	str	r3, [r7, #12]
 8005a86:	e008      	b.n	8005a9a <can_free_tx_frames+0x2a>
        chPoolFree(&instance->frame_pool, frame);
 8005a88:	687b      	ldr	r3, [r7, #4]
 8005a8a:	3330      	adds	r3, #48	; 0x30
 8005a8c:	4618      	mov	r0, r3
 8005a8e:	68f9      	ldr	r1, [r7, #12]
 8005a90:	f004 fad0 	bl	800a034 <chPoolFree>
void can_free_tx_frames(struct can_instance_s* instance, struct can_tx_frame_s** frame_list) {
    if (!instance) {
        return;
    }
    
    for (struct can_tx_frame_s* frame = *frame_list; frame != NULL; frame = frame->next) {
 8005a94:	68fb      	ldr	r3, [r7, #12]
 8005a96:	699b      	ldr	r3, [r3, #24]
 8005a98:	60fb      	str	r3, [r7, #12]
 8005a9a:	68fb      	ldr	r3, [r7, #12]
 8005a9c:	2b00      	cmp	r3, #0
 8005a9e:	d1f3      	bne.n	8005a88 <can_free_tx_frames+0x18>
        chPoolFree(&instance->frame_pool, frame);
    }
    
    *frame_list = NULL;
 8005aa0:	683b      	ldr	r3, [r7, #0]
 8005aa2:	2200      	movs	r2, #0
 8005aa4:	601a      	str	r2, [r3, #0]
}
 8005aa6:	3710      	adds	r7, #16
 8005aa8:	46bd      	mov	sp, r7
 8005aaa:	bd80      	pop	{r7, pc}

08005aac <can_driver_register>:

struct can_instance_s* can_driver_register(uint8_t can_idx, void* driver_ctx, const struct can_driver_iface_s* driver_iface, uint8_t num_tx_mailboxes, uint8_t num_rx_mailboxes, uint8_t rx_fifo_depth) {
 8005aac:	b580      	push	{r7, lr}
 8005aae:	b08a      	sub	sp, #40	; 0x28
 8005ab0:	af02      	add	r7, sp, #8
 8005ab2:	60b9      	str	r1, [r7, #8]
 8005ab4:	607a      	str	r2, [r7, #4]
 8005ab6:	461a      	mov	r2, r3
 8005ab8:	4603      	mov	r3, r0
 8005aba:	73fb      	strb	r3, [r7, #15]
 8005abc:	4613      	mov	r3, r2
 8005abe:	73bb      	strb	r3, [r7, #14]
    if (can_get_instance(can_idx) != NULL) {
 8005ac0:	7bfb      	ldrb	r3, [r7, #15]
 8005ac2:	4618      	mov	r0, r3
 8005ac4:	f001 ff82 	bl	80079cc <can_get_instance>
 8005ac8:	4603      	mov	r3, r0
 8005aca:	2b00      	cmp	r3, #0
 8005acc:	d001      	beq.n	8005ad2 <can_driver_register+0x26>
        return NULL;
 8005ace:	2300      	movs	r3, #0
 8005ad0:	e093      	b.n	8005bfa <can_driver_register+0x14e>
    }

    struct can_instance_s* instance = chPoolAlloc(&can_instance_pool);
 8005ad2:	484c      	ldr	r0, [pc, #304]	; (8005c04 <can_driver_register+0x158>)
 8005ad4:	f004 fa7e 	bl	8009fd4 <chPoolAlloc>
 8005ad8:	6178      	str	r0, [r7, #20]

    if (!instance) {
 8005ada:	697b      	ldr	r3, [r7, #20]
 8005adc:	2b00      	cmp	r3, #0
 8005ade:	d101      	bne.n	8005ae4 <can_driver_register+0x38>
        return NULL;
 8005ae0:	2300      	movs	r3, #0
 8005ae2:	e08a      	b.n	8005bfa <can_driver_register+0x14e>
    }
    
    void* tx_queue_mem = chCoreAlloc(CAN_TX_QUEUE_LEN*sizeof(struct can_tx_frame_s));
 8005ae4:	f44f 60e0 	mov.w	r0, #1792	; 0x700
 8005ae8:	f001 ff3a 	bl	8007960 <chCoreAlloc.lto_priv.84>
 8005aec:	6138      	str	r0, [r7, #16]
    
    if (!tx_queue_mem) {
 8005aee:	693b      	ldr	r3, [r7, #16]
 8005af0:	2b00      	cmp	r3, #0
 8005af2:	d101      	bne.n	8005af8 <can_driver_register+0x4c>
        return NULL;
 8005af4:	2300      	movs	r3, #0
 8005af6:	e080      	b.n	8005bfa <can_driver_register+0x14e>
    }

    if (num_tx_mailboxes > MAX_NUM_TX_MAILBOXES) {
 8005af8:	7bbb      	ldrb	r3, [r7, #14]
 8005afa:	2b03      	cmp	r3, #3
 8005afc:	d901      	bls.n	8005b02 <can_driver_register+0x56>
        num_tx_mailboxes = MAX_NUM_TX_MAILBOXES;
 8005afe:	2303      	movs	r3, #3
 8005b00:	73bb      	strb	r3, [r7, #14]
    }

    instance->idx = can_idx;
 8005b02:	697b      	ldr	r3, [r7, #20]
 8005b04:	7bfa      	ldrb	r2, [r7, #15]
 8005b06:	701a      	strb	r2, [r3, #0]

    instance->started = false;
 8005b08:	697b      	ldr	r3, [r7, #20]
 8005b0a:	2200      	movs	r2, #0
 8005b0c:	705a      	strb	r2, [r3, #1]
    instance->silent = false;
 8005b0e:	697b      	ldr	r3, [r7, #20]
 8005b10:	2200      	movs	r2, #0
 8005b12:	709a      	strb	r2, [r3, #2]
    instance->auto_retransmit = false;
 8005b14:	697b      	ldr	r3, [r7, #20]
 8005b16:	2200      	movs	r2, #0
 8005b18:	70da      	strb	r2, [r3, #3]
    instance->baudrate = 0;
 8005b1a:	697b      	ldr	r3, [r7, #20]
 8005b1c:	2200      	movs	r2, #0
 8005b1e:	605a      	str	r2, [r3, #4]
    instance->baudrate_confirmed = false;
 8005b20:	697b      	ldr	r3, [r7, #20]
 8005b22:	2200      	movs	r2, #0
 8005b24:	721a      	strb	r2, [r3, #8]

    instance->driver_ctx = driver_ctx;
 8005b26:	697b      	ldr	r3, [r7, #20]
 8005b28:	68ba      	ldr	r2, [r7, #8]
 8005b2a:	60da      	str	r2, [r3, #12]
    instance->driver_iface = driver_iface;
 8005b2c:	697b      	ldr	r3, [r7, #20]
 8005b2e:	687a      	ldr	r2, [r7, #4]
 8005b30:	611a      	str	r2, [r3, #16]

    for (uint8_t i=0; i<MAX_NUM_TX_MAILBOXES; i++) {
 8005b32:	2300      	movs	r3, #0
 8005b34:	77fb      	strb	r3, [r7, #31]
 8005b36:	e009      	b.n	8005b4c <can_driver_register+0xa0>
        instance->tx_mailbox[i].state = CAN_TX_MAILBOX_EMPTY;
 8005b38:	7ffb      	ldrb	r3, [r7, #31]
 8005b3a:	697a      	ldr	r2, [r7, #20]
 8005b3c:	3302      	adds	r3, #2
 8005b3e:	00db      	lsls	r3, r3, #3
 8005b40:	4413      	add	r3, r2
 8005b42:	2200      	movs	r2, #0
 8005b44:	721a      	strb	r2, [r3, #8]
    instance->baudrate_confirmed = false;

    instance->driver_ctx = driver_ctx;
    instance->driver_iface = driver_iface;

    for (uint8_t i=0; i<MAX_NUM_TX_MAILBOXES; i++) {
 8005b46:	7ffb      	ldrb	r3, [r7, #31]
 8005b48:	3301      	adds	r3, #1
 8005b4a:	77fb      	strb	r3, [r7, #31]
 8005b4c:	7ffb      	ldrb	r3, [r7, #31]
 8005b4e:	2b02      	cmp	r3, #2
 8005b50:	d9f2      	bls.n	8005b38 <can_driver_register+0x8c>
        instance->tx_mailbox[i].state = CAN_TX_MAILBOX_EMPTY;
    }
    instance->num_tx_mailboxes = num_tx_mailboxes;
 8005b52:	697b      	ldr	r3, [r7, #20]
 8005b54:	7bba      	ldrb	r2, [r7, #14]
 8005b56:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    
    chPoolObjectInit(&instance->frame_pool, sizeof(struct can_tx_frame_s), NULL);
 8005b5a:	697b      	ldr	r3, [r7, #20]
 8005b5c:	3330      	adds	r3, #48	; 0x30
 8005b5e:	4618      	mov	r0, r3
 8005b60:	211c      	movs	r1, #28
 8005b62:	2200      	movs	r2, #0
 8005b64:	f004 f9c8 	bl	8009ef8 <chPoolObjectInit>
    chPoolLoadArray(&instance->frame_pool, tx_queue_mem, CAN_TX_QUEUE_LEN);
 8005b68:	697b      	ldr	r3, [r7, #20]
 8005b6a:	3330      	adds	r3, #48	; 0x30
 8005b6c:	4618      	mov	r0, r3
 8005b6e:	6939      	ldr	r1, [r7, #16]
 8005b70:	2240      	movs	r2, #64	; 0x40
 8005b72:	f004 f9df 	bl	8009f34 <chPoolLoadArray>

    can_tx_queue_init(&instance->tx_queue);
 8005b76:	697b      	ldr	r3, [r7, #20]
 8005b78:	333c      	adds	r3, #60	; 0x3c
 8005b7a:	4618      	mov	r0, r3
 8005b7c:	f001 fcd0 	bl	8007520 <can_tx_queue_init>

    pubsub_init_topic(&instance->rx_topic, NULL); // TODO specific/configurable topic group
 8005b80:	697b      	ldr	r3, [r7, #20]
 8005b82:	3340      	adds	r3, #64	; 0x40
 8005b84:	4618      	mov	r0, r3
 8005b86:	2100      	movs	r1, #0
 8005b88:	f002 fb52 	bl	8008230 <pubsub_init_topic>
    worker_thread_add_publisher_task(&WT_TRX, &instance->rx_publisher_task, sizeof(struct can_rx_frame_s), num_rx_mailboxes*rx_fifo_depth);
 8005b8c:	697b      	ldr	r3, [r7, #20]
 8005b8e:	f103 014c 	add.w	r1, r3, #76	; 0x4c
 8005b92:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8005b96:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
 8005b9a:	fb02 f303 	mul.w	r3, r2, r3
 8005b9e:	481a      	ldr	r0, [pc, #104]	; (8005c08 <can_driver_register+0x15c>)
 8005ba0:	2214      	movs	r2, #20
 8005ba2:	f000 feaf 	bl	8006904 <worker_thread_add_publisher_task>

    worker_thread_add_publisher_task(&WT_TRX, &instance->tx_publisher_task, sizeof(struct can_transmit_completion_msg_s), num_tx_mailboxes);
 8005ba6:	697b      	ldr	r3, [r7, #20]
 8005ba8:	f103 028c 	add.w	r2, r3, #140	; 0x8c
 8005bac:	7bbb      	ldrb	r3, [r7, #14]
 8005bae:	4816      	ldr	r0, [pc, #88]	; (8005c08 <can_driver_register+0x15c>)
 8005bb0:	4611      	mov	r1, r2
 8005bb2:	2204      	movs	r2, #4
 8005bb4:	f000 fea6 	bl	8006904 <worker_thread_add_publisher_task>

    worker_thread_add_timer_task(&WT_EXPIRE, &instance->expire_timer_task, can_expire_handler, instance, TIME_INFINITE, false);
 8005bb8:	697b      	ldr	r3, [r7, #20]
 8005bba:	f103 02cc 	add.w	r2, r3, #204	; 0xcc
 8005bbe:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8005bc2:	9300      	str	r3, [sp, #0]
 8005bc4:	2300      	movs	r3, #0
 8005bc6:	9301      	str	r3, [sp, #4]
 8005bc8:	480f      	ldr	r0, [pc, #60]	; (8005c08 <can_driver_register+0x15c>)
 8005bca:	4611      	mov	r1, r2
 8005bcc:	4a0f      	ldr	r2, [pc, #60]	; (8005c0c <can_driver_register+0x160>)
 8005bce:	697b      	ldr	r3, [r7, #20]
 8005bd0:	f002 fed0 	bl	8008974 <worker_thread_add_timer_task>

    LINKED_LIST_APPEND(struct can_instance_s, can_instance_list_head, instance);
 8005bd4:	697b      	ldr	r3, [r7, #20]
 8005bd6:	2200      	movs	r2, #0
 8005bd8:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 8005bdc:	4b0c      	ldr	r3, [pc, #48]	; (8005c10 <can_driver_register+0x164>)
 8005bde:	61bb      	str	r3, [r7, #24]
 8005be0:	e003      	b.n	8005bea <can_driver_register+0x13e>
 8005be2:	69bb      	ldr	r3, [r7, #24]
 8005be4:	681b      	ldr	r3, [r3, #0]
 8005be6:	33e0      	adds	r3, #224	; 0xe0
 8005be8:	61bb      	str	r3, [r7, #24]
 8005bea:	69bb      	ldr	r3, [r7, #24]
 8005bec:	681b      	ldr	r3, [r3, #0]
 8005bee:	2b00      	cmp	r3, #0
 8005bf0:	d1f7      	bne.n	8005be2 <can_driver_register+0x136>
 8005bf2:	69bb      	ldr	r3, [r7, #24]
 8005bf4:	697a      	ldr	r2, [r7, #20]
 8005bf6:	601a      	str	r2, [r3, #0]

    return instance;
 8005bf8:	697b      	ldr	r3, [r7, #20]
}
 8005bfa:	4618      	mov	r0, r3
 8005bfc:	3720      	adds	r7, #32
 8005bfe:	46bd      	mov	sp, r7
 8005c00:	bd80      	pop	{r7, pc}
 8005c02:	bf00      	nop
 8005c04:	20000a00 	.word	0x20000a00
 8005c08:	20000a3c 	.word	0x20000a3c
 8005c0c:	08005ee5 	.word	0x08005ee5
 8005c10:	2000146c 	.word	0x2000146c

08005c14 <can_try_enqueue_waiting_frame_I>:

static void can_try_enqueue_waiting_frame_I(struct can_instance_s* instance) {
 8005c14:	b580      	push	{r7, lr}
 8005c16:	b088      	sub	sp, #32
 8005c18:	af00      	add	r7, sp, #0
 8005c1a:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
 8005c1c:	f005 f9ce 	bl	800afbc <chDbgCheckClassI>
    
    // Enqueue the next frame if it will be the highest priority
    bool have_empty_mailbox = false;
 8005c20:	2300      	movs	r3, #0
 8005c22:	77fb      	strb	r3, [r7, #31]
    uint8_t empty_mailbox_idx;
    bool have_pending_mailbox = false;
 8005c24:	2300      	movs	r3, #0
 8005c26:	777b      	strb	r3, [r7, #29]
    can_frame_priority_t highest_prio_pending = 0;
 8005c28:	2300      	movs	r3, #0
 8005c2a:	61bb      	str	r3, [r7, #24]
    
    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8005c2c:	2300      	movs	r3, #0
 8005c2e:	75fb      	strb	r3, [r7, #23]
 8005c30:	e037      	b.n	8005ca2 <can_try_enqueue_waiting_frame_I+0x8e>
        if (instance->tx_mailbox[i].state == CAN_TX_MAILBOX_EMPTY) {
 8005c32:	7dfb      	ldrb	r3, [r7, #23]
 8005c34:	687a      	ldr	r2, [r7, #4]
 8005c36:	3302      	adds	r3, #2
 8005c38:	00db      	lsls	r3, r3, #3
 8005c3a:	4413      	add	r3, r2
 8005c3c:	7a1b      	ldrb	r3, [r3, #8]
 8005c3e:	2b00      	cmp	r3, #0
 8005c40:	d104      	bne.n	8005c4c <can_try_enqueue_waiting_frame_I+0x38>
            have_empty_mailbox = true;
 8005c42:	2301      	movs	r3, #1
 8005c44:	77fb      	strb	r3, [r7, #31]
            empty_mailbox_idx = i;
 8005c46:	7dfb      	ldrb	r3, [r7, #23]
 8005c48:	77bb      	strb	r3, [r7, #30]
 8005c4a:	e027      	b.n	8005c9c <can_try_enqueue_waiting_frame_I+0x88>
        } else if (instance->tx_mailbox[i].state == CAN_TX_MAILBOX_PENDING || instance->tx_mailbox[i].state == CAN_TX_MAILBOX_ABORTING) {
 8005c4c:	7dfb      	ldrb	r3, [r7, #23]
 8005c4e:	687a      	ldr	r2, [r7, #4]
 8005c50:	3302      	adds	r3, #2
 8005c52:	00db      	lsls	r3, r3, #3
 8005c54:	4413      	add	r3, r2
 8005c56:	7a1b      	ldrb	r3, [r3, #8]
 8005c58:	2b01      	cmp	r3, #1
 8005c5a:	d007      	beq.n	8005c6c <can_try_enqueue_waiting_frame_I+0x58>
 8005c5c:	7dfb      	ldrb	r3, [r7, #23]
 8005c5e:	687a      	ldr	r2, [r7, #4]
 8005c60:	3302      	adds	r3, #2
 8005c62:	00db      	lsls	r3, r3, #3
 8005c64:	4413      	add	r3, r2
 8005c66:	7a1b      	ldrb	r3, [r3, #8]
 8005c68:	2b02      	cmp	r3, #2
 8005c6a:	d117      	bne.n	8005c9c <can_try_enqueue_waiting_frame_I+0x88>
            can_frame_priority_t prio = can_get_tx_frame_priority_X(instance->tx_mailbox[i].frame);
 8005c6c:	7dfb      	ldrb	r3, [r7, #23]
 8005c6e:	687a      	ldr	r2, [r7, #4]
 8005c70:	3302      	adds	r3, #2
 8005c72:	00db      	lsls	r3, r3, #3
 8005c74:	4413      	add	r3, r2
 8005c76:	685b      	ldr	r3, [r3, #4]
 8005c78:	4618      	mov	r0, r3
 8005c7a:	f001 fdf7 	bl	800786c <can_get_tx_frame_priority_X>
 8005c7e:	6138      	str	r0, [r7, #16]
            if (!have_pending_mailbox || prio > highest_prio_pending) {
 8005c80:	7f7b      	ldrb	r3, [r7, #29]
 8005c82:	f083 0301 	eor.w	r3, r3, #1
 8005c86:	b2db      	uxtb	r3, r3
 8005c88:	2b00      	cmp	r3, #0
 8005c8a:	d103      	bne.n	8005c94 <can_try_enqueue_waiting_frame_I+0x80>
 8005c8c:	693a      	ldr	r2, [r7, #16]
 8005c8e:	69bb      	ldr	r3, [r7, #24]
 8005c90:	429a      	cmp	r2, r3
 8005c92:	d901      	bls.n	8005c98 <can_try_enqueue_waiting_frame_I+0x84>
                highest_prio_pending = prio;
 8005c94:	693b      	ldr	r3, [r7, #16]
 8005c96:	61bb      	str	r3, [r7, #24]
            }
            have_pending_mailbox = true;
 8005c98:	2301      	movs	r3, #1
 8005c9a:	777b      	strb	r3, [r7, #29]
    bool have_empty_mailbox = false;
    uint8_t empty_mailbox_idx;
    bool have_pending_mailbox = false;
    can_frame_priority_t highest_prio_pending = 0;
    
    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8005c9c:	7dfb      	ldrb	r3, [r7, #23]
 8005c9e:	3301      	adds	r3, #1
 8005ca0:	75fb      	strb	r3, [r7, #23]
 8005ca2:	687b      	ldr	r3, [r7, #4]
 8005ca4:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8005ca8:	7dfa      	ldrb	r2, [r7, #23]
 8005caa:	429a      	cmp	r2, r3
 8005cac:	d3c1      	bcc.n	8005c32 <can_try_enqueue_waiting_frame_I+0x1e>
            }
            have_pending_mailbox = true;
        }
    }
    
    if (!have_empty_mailbox) {
 8005cae:	7ffb      	ldrb	r3, [r7, #31]
 8005cb0:	f083 0301 	eor.w	r3, r3, #1
 8005cb4:	b2db      	uxtb	r3, r3
 8005cb6:	2b00      	cmp	r3, #0
 8005cb8:	d130      	bne.n	8005d1c <can_try_enqueue_waiting_frame_I+0x108>
        return;
    }
    
    struct can_tx_frame_s* frame = can_tx_queue_peek_I(&instance->tx_queue);
 8005cba:	687b      	ldr	r3, [r7, #4]
 8005cbc:	333c      	adds	r3, #60	; 0x3c
 8005cbe:	4618      	mov	r0, r3
 8005cc0:	f001 fcb0 	bl	8007624 <can_tx_queue_peek_I>
 8005cc4:	60f8      	str	r0, [r7, #12]
    if (frame && (!have_pending_mailbox || can_get_tx_frame_priority_X(frame) > highest_prio_pending)) {
 8005cc6:	68fb      	ldr	r3, [r7, #12]
 8005cc8:	2b00      	cmp	r3, #0
 8005cca:	d027      	beq.n	8005d1c <can_try_enqueue_waiting_frame_I+0x108>
 8005ccc:	7f7b      	ldrb	r3, [r7, #29]
 8005cce:	f083 0301 	eor.w	r3, r3, #1
 8005cd2:	b2db      	uxtb	r3, r3
 8005cd4:	2b00      	cmp	r3, #0
 8005cd6:	d106      	bne.n	8005ce6 <can_try_enqueue_waiting_frame_I+0xd2>
 8005cd8:	68f8      	ldr	r0, [r7, #12]
 8005cda:	f001 fdc7 	bl	800786c <can_get_tx_frame_priority_X>
 8005cde:	4602      	mov	r2, r0
 8005ce0:	69bb      	ldr	r3, [r7, #24]
 8005ce2:	429a      	cmp	r2, r3
 8005ce4:	d91a      	bls.n	8005d1c <can_try_enqueue_waiting_frame_I+0x108>
        can_tx_queue_pop_I(&instance->tx_queue);
 8005ce6:	687b      	ldr	r3, [r7, #4]
 8005ce8:	333c      	adds	r3, #60	; 0x3c
 8005cea:	4618      	mov	r0, r3
 8005cec:	f001 fca6 	bl	800763c <can_tx_queue_pop_I>
        instance->tx_mailbox[empty_mailbox_idx].frame = frame;
 8005cf0:	7fbb      	ldrb	r3, [r7, #30]
 8005cf2:	687a      	ldr	r2, [r7, #4]
 8005cf4:	3302      	adds	r3, #2
 8005cf6:	00db      	lsls	r3, r3, #3
 8005cf8:	4413      	add	r3, r2
 8005cfa:	68fa      	ldr	r2, [r7, #12]
 8005cfc:	605a      	str	r2, [r3, #4]
        instance->tx_mailbox[empty_mailbox_idx].state = CAN_TX_MAILBOX_PENDING;
 8005cfe:	7fbb      	ldrb	r3, [r7, #30]
 8005d00:	687a      	ldr	r2, [r7, #4]
 8005d02:	3302      	adds	r3, #2
 8005d04:	00db      	lsls	r3, r3, #3
 8005d06:	4413      	add	r3, r2
 8005d08:	2201      	movs	r2, #1
 8005d0a:	721a      	strb	r2, [r3, #8]
        instance->driver_iface->load_tx_mailbox_I(instance->driver_ctx, empty_mailbox_idx, &frame->content);
 8005d0c:	687b      	ldr	r3, [r7, #4]
 8005d0e:	691b      	ldr	r3, [r3, #16]
 8005d10:	68db      	ldr	r3, [r3, #12]
 8005d12:	687a      	ldr	r2, [r7, #4]
 8005d14:	68d0      	ldr	r0, [r2, #12]
 8005d16:	68fa      	ldr	r2, [r7, #12]
 8005d18:	7fb9      	ldrb	r1, [r7, #30]
 8005d1a:	4798      	blx	r3
    }
}
 8005d1c:	3720      	adds	r7, #32
 8005d1e:	46bd      	mov	sp, r7
 8005d20:	bd80      	pop	{r7, pc}
 8005d22:	bf00      	nop

08005d24 <can_try_enqueue_waiting_frame>:

static void can_try_enqueue_waiting_frame(struct can_instance_s* instance) {
 8005d24:	b580      	push	{r7, lr}
 8005d26:	b082      	sub	sp, #8
 8005d28:	af00      	add	r7, sp, #0
 8005d2a:	6078      	str	r0, [r7, #4]
    chSysLock();
 8005d2c:	f001 fddc 	bl	80078e8 <chSysLock.lto_priv.102>
    can_try_enqueue_waiting_frame_I(instance);
 8005d30:	6878      	ldr	r0, [r7, #4]
 8005d32:	f7ff ff6f 	bl	8005c14 <can_try_enqueue_waiting_frame_I>
    chSysUnlock();
 8005d36:	f001 fddf 	bl	80078f8 <chSysUnlock.lto_priv.101>
}
 8005d3a:	3708      	adds	r7, #8
 8005d3c:	46bd      	mov	sp, r7
 8005d3e:	bd80      	pop	{r7, pc}

08005d40 <can_reschedule_expire_timer_I>:

static void can_reschedule_expire_timer_I(struct can_instance_s* instance) {
 8005d40:	b580      	push	{r7, lr}
 8005d42:	b086      	sub	sp, #24
 8005d44:	af00      	add	r7, sp, #0
 8005d46:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
 8005d48:	f005 f938 	bl	800afbc <chDbgCheckClassI>

    // Find frame that expires soonest in mailboxes and queue, schedule expire handler for that time
    systime_t t_now = chVTGetSystemTimeX();
 8005d4c:	f001 fdf0 	bl	8007930 <chVTGetSystemTimeX.lto_priv.100>
 8005d50:	4603      	mov	r3, r0
 8005d52:	827b      	strh	r3, [r7, #18]
    systime_t min_ticks_to_expire = TIME_INFINITE;
 8005d54:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8005d58:	82fb      	strh	r3, [r7, #22]

    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8005d5a:	2300      	movs	r3, #0
 8005d5c:	757b      	strb	r3, [r7, #21]
 8005d5e:	e01d      	b.n	8005d9c <can_reschedule_expire_timer_I+0x5c>
        if (instance->tx_mailbox[i].state == CAN_TX_MAILBOX_PENDING) {
 8005d60:	7d7b      	ldrb	r3, [r7, #21]
 8005d62:	687a      	ldr	r2, [r7, #4]
 8005d64:	3302      	adds	r3, #2
 8005d66:	00db      	lsls	r3, r3, #3
 8005d68:	4413      	add	r3, r2
 8005d6a:	7a1b      	ldrb	r3, [r3, #8]
 8005d6c:	2b01      	cmp	r3, #1
 8005d6e:	d112      	bne.n	8005d96 <can_reschedule_expire_timer_I+0x56>
            systime_t ticks_to_expire = can_tx_frame_time_until_expire_X(instance->tx_mailbox[i].frame, t_now);
 8005d70:	7d7b      	ldrb	r3, [r7, #21]
 8005d72:	687a      	ldr	r2, [r7, #4]
 8005d74:	3302      	adds	r3, #2
 8005d76:	00db      	lsls	r3, r3, #3
 8005d78:	4413      	add	r3, r2
 8005d7a:	685a      	ldr	r2, [r3, #4]
 8005d7c:	8a7b      	ldrh	r3, [r7, #18]
 8005d7e:	4610      	mov	r0, r2
 8005d80:	4619      	mov	r1, r3
 8005d82:	f001 fcfd 	bl	8007780 <can_tx_frame_time_until_expire_X>
 8005d86:	4603      	mov	r3, r0
 8005d88:	823b      	strh	r3, [r7, #16]
            if (ticks_to_expire < min_ticks_to_expire) {
 8005d8a:	8a3a      	ldrh	r2, [r7, #16]
 8005d8c:	8afb      	ldrh	r3, [r7, #22]
 8005d8e:	429a      	cmp	r2, r3
 8005d90:	d201      	bcs.n	8005d96 <can_reschedule_expire_timer_I+0x56>
                min_ticks_to_expire = ticks_to_expire;
 8005d92:	8a3b      	ldrh	r3, [r7, #16]
 8005d94:	82fb      	strh	r3, [r7, #22]

    // Find frame that expires soonest in mailboxes and queue, schedule expire handler for that time
    systime_t t_now = chVTGetSystemTimeX();
    systime_t min_ticks_to_expire = TIME_INFINITE;

    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8005d96:	7d7b      	ldrb	r3, [r7, #21]
 8005d98:	3301      	adds	r3, #1
 8005d9a:	757b      	strb	r3, [r7, #21]
 8005d9c:	687b      	ldr	r3, [r7, #4]
 8005d9e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8005da2:	7d7a      	ldrb	r2, [r7, #21]
 8005da4:	429a      	cmp	r2, r3
 8005da6:	d3db      	bcc.n	8005d60 <can_reschedule_expire_timer_I+0x20>
                min_ticks_to_expire = ticks_to_expire;
            }
        }
    }

    struct can_tx_frame_s* frame = NULL;
 8005da8:	2300      	movs	r3, #0
 8005daa:	60bb      	str	r3, [r7, #8]
 8005dac:	e00d      	b.n	8005dca <can_reschedule_expire_timer_I+0x8a>
    while (can_tx_queue_iterate_I(&instance->tx_queue, &frame)) {
        systime_t ticks_to_expire = can_tx_frame_time_until_expire_X(frame, t_now);
 8005dae:	68ba      	ldr	r2, [r7, #8]
 8005db0:	8a7b      	ldrh	r3, [r7, #18]
 8005db2:	4610      	mov	r0, r2
 8005db4:	4619      	mov	r1, r3
 8005db6:	f001 fce3 	bl	8007780 <can_tx_frame_time_until_expire_X>
 8005dba:	4603      	mov	r3, r0
 8005dbc:	81fb      	strh	r3, [r7, #14]
        if (ticks_to_expire < min_ticks_to_expire) {
 8005dbe:	89fa      	ldrh	r2, [r7, #14]
 8005dc0:	8afb      	ldrh	r3, [r7, #22]
 8005dc2:	429a      	cmp	r2, r3
 8005dc4:	d201      	bcs.n	8005dca <can_reschedule_expire_timer_I+0x8a>
            min_ticks_to_expire = ticks_to_expire;
 8005dc6:	89fb      	ldrh	r3, [r7, #14]
 8005dc8:	82fb      	strh	r3, [r7, #22]
            }
        }
    }

    struct can_tx_frame_s* frame = NULL;
    while (can_tx_queue_iterate_I(&instance->tx_queue, &frame)) {
 8005dca:	687b      	ldr	r3, [r7, #4]
 8005dcc:	f103 023c 	add.w	r2, r3, #60	; 0x3c
 8005dd0:	f107 0308 	add.w	r3, r7, #8
 8005dd4:	4610      	mov	r0, r2
 8005dd6:	4619      	mov	r1, r3
 8005dd8:	f001 fbf6 	bl	80075c8 <can_tx_queue_iterate_I>
 8005ddc:	4603      	mov	r3, r0
 8005dde:	2b00      	cmp	r3, #0
 8005de0:	d1e5      	bne.n	8005dae <can_reschedule_expire_timer_I+0x6e>
        if (ticks_to_expire < min_ticks_to_expire) {
            min_ticks_to_expire = ticks_to_expire;
        }
    }

    worker_thread_timer_task_reschedule_I(&WT_EXPIRE, &instance->expire_timer_task, min_ticks_to_expire);
 8005de2:	687b      	ldr	r3, [r7, #4]
 8005de4:	f103 02cc 	add.w	r2, r3, #204	; 0xcc
 8005de8:	8afb      	ldrh	r3, [r7, #22]
 8005dea:	4804      	ldr	r0, [pc, #16]	; (8005dfc <can_reschedule_expire_timer_I+0xbc>)
 8005dec:	4611      	mov	r1, r2
 8005dee:	461a      	mov	r2, r3
 8005df0:	f002 fdfa 	bl	80089e8 <worker_thread_timer_task_reschedule_I>
}
 8005df4:	3718      	adds	r7, #24
 8005df6:	46bd      	mov	sp, r7
 8005df8:	bd80      	pop	{r7, pc}
 8005dfa:	bf00      	nop
 8005dfc:	20000a3c 	.word	0x20000a3c

08005e00 <can_reschedule_expire_timer>:

static void can_reschedule_expire_timer(struct can_instance_s* instance) {
 8005e00:	b580      	push	{r7, lr}
 8005e02:	b082      	sub	sp, #8
 8005e04:	af00      	add	r7, sp, #0
 8005e06:	6078      	str	r0, [r7, #4]
    chSysLock();
 8005e08:	f001 fd6e 	bl	80078e8 <chSysLock.lto_priv.102>
    can_reschedule_expire_timer_I(instance);
 8005e0c:	6878      	ldr	r0, [r7, #4]
 8005e0e:	f7ff ff97 	bl	8005d40 <can_reschedule_expire_timer_I>
    chSchRescheduleS();
 8005e12:	f005 fcd5 	bl	800b7c0 <chSchRescheduleS>
    chSysUnlock();
 8005e16:	f001 fd6f 	bl	80078f8 <chSysUnlock.lto_priv.101>
}
 8005e1a:	3708      	adds	r7, #8
 8005e1c:	46bd      	mov	sp, r7
 8005e1e:	bd80      	pop	{r7, pc}

08005e20 <can_tx_frame_completed_I>:

static void can_tx_frame_completed_I(struct can_instance_s* instance, struct can_tx_frame_s* frame, bool success, systime_t completion_systime) {
 8005e20:	b580      	push	{r7, lr}
 8005e22:	b088      	sub	sp, #32
 8005e24:	af02      	add	r7, sp, #8
 8005e26:	60f8      	str	r0, [r7, #12]
 8005e28:	60b9      	str	r1, [r7, #8]
 8005e2a:	4611      	mov	r1, r2
 8005e2c:	461a      	mov	r2, r3
 8005e2e:	460b      	mov	r3, r1
 8005e30:	71fb      	strb	r3, [r7, #7]
 8005e32:	4613      	mov	r3, r2
 8005e34:	80bb      	strh	r3, [r7, #4]
    chDbgCheckClassI();
 8005e36:	f005 f8c1 	bl	800afbc <chDbgCheckClassI>

    if (frame->completion_topic) {
 8005e3a:	68bb      	ldr	r3, [r7, #8]
 8005e3c:	695b      	ldr	r3, [r3, #20]
 8005e3e:	2b00      	cmp	r3, #0
 8005e40:	d017      	beq.n	8005e72 <can_tx_frame_completed_I+0x52>
        struct can_transmit_completion_msg_s msg = { success, completion_systime };
 8005e42:	79fb      	ldrb	r3, [r7, #7]
 8005e44:	b29b      	uxth	r3, r3
 8005e46:	82bb      	strh	r3, [r7, #20]
 8005e48:	88bb      	ldrh	r3, [r7, #4]
 8005e4a:	2b00      	cmp	r3, #0
 8005e4c:	bf14      	ite	ne
 8005e4e:	2301      	movne	r3, #1
 8005e50:	2300      	moveq	r3, #0
 8005e52:	b2db      	uxtb	r3, r3
 8005e54:	75bb      	strb	r3, [r7, #22]
        worker_thread_publisher_task_publish_I(&instance->tx_publisher_task, frame->completion_topic, sizeof(struct can_transmit_completion_msg_s), pubsub_copy_writer_func, &msg);
 8005e56:	68fb      	ldr	r3, [r7, #12]
 8005e58:	f103 018c 	add.w	r1, r3, #140	; 0x8c
 8005e5c:	68bb      	ldr	r3, [r7, #8]
 8005e5e:	695a      	ldr	r2, [r3, #20]
 8005e60:	f107 0314 	add.w	r3, r7, #20
 8005e64:	9300      	str	r3, [sp, #0]
 8005e66:	4608      	mov	r0, r1
 8005e68:	4611      	mov	r1, r2
 8005e6a:	2204      	movs	r2, #4
 8005e6c:	4b05      	ldr	r3, [pc, #20]	; (8005e84 <can_tx_frame_completed_I+0x64>)
 8005e6e:	f000 fd5d 	bl	800692c <worker_thread_publisher_task_publish_I>
    }
    chPoolFreeI(&instance->frame_pool, frame);
 8005e72:	68fb      	ldr	r3, [r7, #12]
 8005e74:	3330      	adds	r3, #48	; 0x30
 8005e76:	4618      	mov	r0, r3
 8005e78:	68b9      	ldr	r1, [r7, #8]
 8005e7a:	f004 f8bd 	bl	8009ff8 <chPoolFreeI>
}
 8005e7e:	3718      	adds	r7, #24
 8005e80:	46bd      	mov	sp, r7
 8005e82:	bd80      	pop	{r7, pc}
 8005e84:	0800836d 	.word	0x0800836d

08005e88 <can_tx_frame_completed>:

static void can_tx_frame_completed(struct can_instance_s* instance, struct can_tx_frame_s* frame, bool success, systime_t completion_systime) {
 8005e88:	b580      	push	{r7, lr}
 8005e8a:	b086      	sub	sp, #24
 8005e8c:	af00      	add	r7, sp, #0
 8005e8e:	60f8      	str	r0, [r7, #12]
 8005e90:	60b9      	str	r1, [r7, #8]
 8005e92:	4611      	mov	r1, r2
 8005e94:	461a      	mov	r2, r3
 8005e96:	460b      	mov	r3, r1
 8005e98:	71fb      	strb	r3, [r7, #7]
 8005e9a:	4613      	mov	r3, r2
 8005e9c:	80bb      	strh	r3, [r7, #4]
    if (frame->completion_topic) {
 8005e9e:	68bb      	ldr	r3, [r7, #8]
 8005ea0:	695b      	ldr	r3, [r3, #20]
 8005ea2:	2b00      	cmp	r3, #0
 8005ea4:	d012      	beq.n	8005ecc <can_tx_frame_completed+0x44>
        struct can_transmit_completion_msg_s msg = { success, completion_systime };
 8005ea6:	79fb      	ldrb	r3, [r7, #7]
 8005ea8:	b29b      	uxth	r3, r3
 8005eaa:	82bb      	strh	r3, [r7, #20]
 8005eac:	88bb      	ldrh	r3, [r7, #4]
 8005eae:	2b00      	cmp	r3, #0
 8005eb0:	bf14      	ite	ne
 8005eb2:	2301      	movne	r3, #1
 8005eb4:	2300      	moveq	r3, #0
 8005eb6:	b2db      	uxtb	r3, r3
 8005eb8:	75bb      	strb	r3, [r7, #22]
        pubsub_publish_message(frame->completion_topic, sizeof(struct can_transmit_completion_msg_s), pubsub_copy_writer_func, &msg);
 8005eba:	68bb      	ldr	r3, [r7, #8]
 8005ebc:	695a      	ldr	r2, [r3, #20]
 8005ebe:	f107 0314 	add.w	r3, r7, #20
 8005ec2:	4610      	mov	r0, r2
 8005ec4:	2104      	movs	r1, #4
 8005ec6:	4a06      	ldr	r2, [pc, #24]	; (8005ee0 <can_tx_frame_completed+0x58>)
 8005ec8:	f002 fa98 	bl	80083fc <pubsub_publish_message>
    }
    chPoolFree(&instance->frame_pool, frame);
 8005ecc:	68fb      	ldr	r3, [r7, #12]
 8005ece:	3330      	adds	r3, #48	; 0x30
 8005ed0:	4618      	mov	r0, r3
 8005ed2:	68b9      	ldr	r1, [r7, #8]
 8005ed4:	f004 f8ae 	bl	800a034 <chPoolFree>
}
 8005ed8:	3718      	adds	r7, #24
 8005eda:	46bd      	mov	sp, r7
 8005edc:	bd80      	pop	{r7, pc}
 8005ede:	bf00      	nop
 8005ee0:	0800836d 	.word	0x0800836d

08005ee4 <can_expire_handler>:

static void can_expire_handler(struct worker_thread_timer_task_s* task) {
 8005ee4:	b580      	push	{r7, lr}
 8005ee6:	b086      	sub	sp, #24
 8005ee8:	af00      	add	r7, sp, #0
 8005eea:	6078      	str	r0, [r7, #4]
    struct can_instance_s* instance = worker_thread_task_get_user_context(task);
 8005eec:	6878      	ldr	r0, [r7, #4]
 8005eee:	f002 fddd 	bl	8008aac <worker_thread_task_get_user_context>
 8005ef2:	6138      	str	r0, [r7, #16]

    // Abort expired mailboxes
    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8005ef4:	2300      	movs	r3, #0
 8005ef6:	75fb      	strb	r3, [r7, #23]
 8005ef8:	e02d      	b.n	8005f56 <can_expire_handler+0x72>
        chSysLock();
 8005efa:	f001 fcf5 	bl	80078e8 <chSysLock.lto_priv.102>
        if (instance->tx_mailbox[i].state == CAN_TX_MAILBOX_PENDING && can_tx_frame_expired_X(instance->tx_mailbox[i].frame)) {
 8005efe:	7dfb      	ldrb	r3, [r7, #23]
 8005f00:	693a      	ldr	r2, [r7, #16]
 8005f02:	3302      	adds	r3, #2
 8005f04:	00db      	lsls	r3, r3, #3
 8005f06:	4413      	add	r3, r2
 8005f08:	7a1b      	ldrb	r3, [r3, #8]
 8005f0a:	2b01      	cmp	r3, #1
 8005f0c:	d11e      	bne.n	8005f4c <can_expire_handler+0x68>
 8005f0e:	7dfb      	ldrb	r3, [r7, #23]
 8005f10:	693a      	ldr	r2, [r7, #16]
 8005f12:	3302      	adds	r3, #2
 8005f14:	00db      	lsls	r3, r3, #3
 8005f16:	4413      	add	r3, r2
 8005f18:	685b      	ldr	r3, [r3, #4]
 8005f1a:	4618      	mov	r0, r3
 8005f1c:	f001 fc1a 	bl	8007754 <can_tx_frame_expired_X>
 8005f20:	4603      	mov	r3, r0
 8005f22:	2b00      	cmp	r3, #0
 8005f24:	d012      	beq.n	8005f4c <can_expire_handler+0x68>
            if (instance->driver_iface->abort_tx_mailbox_I(instance->driver_ctx, i)) {
 8005f26:	693b      	ldr	r3, [r7, #16]
 8005f28:	691b      	ldr	r3, [r3, #16]
 8005f2a:	689b      	ldr	r3, [r3, #8]
 8005f2c:	693a      	ldr	r2, [r7, #16]
 8005f2e:	68d1      	ldr	r1, [r2, #12]
 8005f30:	7dfa      	ldrb	r2, [r7, #23]
 8005f32:	4608      	mov	r0, r1
 8005f34:	4611      	mov	r1, r2
 8005f36:	4798      	blx	r3
 8005f38:	4603      	mov	r3, r0
 8005f3a:	2b00      	cmp	r3, #0
 8005f3c:	d006      	beq.n	8005f4c <can_expire_handler+0x68>
                instance->tx_mailbox[i].state = CAN_TX_MAILBOX_ABORTING;
 8005f3e:	7dfb      	ldrb	r3, [r7, #23]
 8005f40:	693a      	ldr	r2, [r7, #16]
 8005f42:	3302      	adds	r3, #2
 8005f44:	00db      	lsls	r3, r3, #3
 8005f46:	4413      	add	r3, r2
 8005f48:	2202      	movs	r2, #2
 8005f4a:	721a      	strb	r2, [r3, #8]
            }
        }
        chSysUnlock();
 8005f4c:	f001 fcd4 	bl	80078f8 <chSysUnlock.lto_priv.101>

static void can_expire_handler(struct worker_thread_timer_task_s* task) {
    struct can_instance_s* instance = worker_thread_task_get_user_context(task);

    // Abort expired mailboxes
    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8005f50:	7dfb      	ldrb	r3, [r7, #23]
 8005f52:	3301      	adds	r3, #1
 8005f54:	75fb      	strb	r3, [r7, #23]
 8005f56:	693b      	ldr	r3, [r7, #16]
 8005f58:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8005f5c:	7dfa      	ldrb	r2, [r7, #23]
 8005f5e:	429a      	cmp	r2, r3
 8005f60:	d3cb      	bcc.n	8005efa <can_expire_handler+0x16>
 8005f62:	e007      	b.n	8005f74 <can_expire_handler+0x90>
    }

    // Abort expired queue items
    struct can_tx_frame_s* frame;
    while ((frame = can_tx_queue_pop_expired(&instance->tx_queue)) != NULL) {
        can_tx_frame_completed(instance, frame, false, chVTGetSystemTimeX());
 8005f64:	f001 fce4 	bl	8007930 <chVTGetSystemTimeX.lto_priv.100>
 8005f68:	4603      	mov	r3, r0
 8005f6a:	6938      	ldr	r0, [r7, #16]
 8005f6c:	68f9      	ldr	r1, [r7, #12]
 8005f6e:	2200      	movs	r2, #0
 8005f70:	f7ff ff8a 	bl	8005e88 <can_tx_frame_completed>
        chSysUnlock();
    }

    // Abort expired queue items
    struct can_tx_frame_s* frame;
    while ((frame = can_tx_queue_pop_expired(&instance->tx_queue)) != NULL) {
 8005f74:	693b      	ldr	r3, [r7, #16]
 8005f76:	333c      	adds	r3, #60	; 0x3c
 8005f78:	4618      	mov	r0, r3
 8005f7a:	f001 fba1 	bl	80076c0 <can_tx_queue_pop_expired>
 8005f7e:	60f8      	str	r0, [r7, #12]
 8005f80:	68fb      	ldr	r3, [r7, #12]
 8005f82:	2b00      	cmp	r3, #0
 8005f84:	d1ee      	bne.n	8005f64 <can_expire_handler+0x80>
        can_tx_frame_completed(instance, frame, false, chVTGetSystemTimeX());
    }

    can_try_enqueue_waiting_frame(instance);
 8005f86:	6938      	ldr	r0, [r7, #16]
 8005f88:	f7ff fecc 	bl	8005d24 <can_try_enqueue_waiting_frame>

    can_reschedule_expire_timer(instance);
 8005f8c:	6938      	ldr	r0, [r7, #16]
 8005f8e:	f7ff ff37 	bl	8005e00 <can_reschedule_expire_timer>
}
 8005f92:	3718      	adds	r7, #24
 8005f94:	46bd      	mov	sp, r7
 8005f96:	bd80      	pop	{r7, pc}

08005f98 <can_driver_tx_request_complete_I>:

void can_driver_tx_request_complete_I(struct can_instance_s* instance, uint8_t mb_idx, bool transmit_success, systime_t completion_systime) {
 8005f98:	b580      	push	{r7, lr}
 8005f9a:	b082      	sub	sp, #8
 8005f9c:	af00      	add	r7, sp, #0
 8005f9e:	6078      	str	r0, [r7, #4]
 8005fa0:	4608      	mov	r0, r1
 8005fa2:	4611      	mov	r1, r2
 8005fa4:	461a      	mov	r2, r3
 8005fa6:	4603      	mov	r3, r0
 8005fa8:	70fb      	strb	r3, [r7, #3]
 8005faa:	460b      	mov	r3, r1
 8005fac:	70bb      	strb	r3, [r7, #2]
 8005fae:	4613      	mov	r3, r2
 8005fb0:	803b      	strh	r3, [r7, #0]
    chDbgCheckClassI();
 8005fb2:	f005 f803 	bl	800afbc <chDbgCheckClassI>
    chDbgCheck(instance->tx_mailbox[mb_idx].state == CAN_TX_MAILBOX_PENDING || instance->tx_mailbox[mb_idx].state == CAN_TX_MAILBOX_ABORTING);
 8005fb6:	78fb      	ldrb	r3, [r7, #3]
 8005fb8:	687a      	ldr	r2, [r7, #4]
 8005fba:	3302      	adds	r3, #2
 8005fbc:	00db      	lsls	r3, r3, #3
 8005fbe:	4413      	add	r3, r2
 8005fc0:	7a1b      	ldrb	r3, [r3, #8]
 8005fc2:	2b01      	cmp	r3, #1
 8005fc4:	d00a      	beq.n	8005fdc <can_driver_tx_request_complete_I+0x44>
 8005fc6:	78fb      	ldrb	r3, [r7, #3]
 8005fc8:	687a      	ldr	r2, [r7, #4]
 8005fca:	3302      	adds	r3, #2
 8005fcc:	00db      	lsls	r3, r3, #3
 8005fce:	4413      	add	r3, r2
 8005fd0:	7a1b      	ldrb	r3, [r3, #8]
 8005fd2:	2b02      	cmp	r3, #2
 8005fd4:	d002      	beq.n	8005fdc <can_driver_tx_request_complete_I+0x44>
 8005fd6:	480d      	ldr	r0, [pc, #52]	; (800600c <can_driver_tx_request_complete_I+0x74>)
 8005fd8:	f004 ff12 	bl	800ae00 <chSysHalt>

    can_tx_frame_completed_I(instance, instance->tx_mailbox[mb_idx].frame, transmit_success, completion_systime);
 8005fdc:	78fb      	ldrb	r3, [r7, #3]
 8005fde:	687a      	ldr	r2, [r7, #4]
 8005fe0:	3302      	adds	r3, #2
 8005fe2:	00db      	lsls	r3, r3, #3
 8005fe4:	4413      	add	r3, r2
 8005fe6:	6859      	ldr	r1, [r3, #4]
 8005fe8:	78ba      	ldrb	r2, [r7, #2]
 8005fea:	883b      	ldrh	r3, [r7, #0]
 8005fec:	6878      	ldr	r0, [r7, #4]
 8005fee:	f7ff ff17 	bl	8005e20 <can_tx_frame_completed_I>
    instance->tx_mailbox[mb_idx].state = CAN_TX_MAILBOX_EMPTY;
 8005ff2:	78fb      	ldrb	r3, [r7, #3]
 8005ff4:	687a      	ldr	r2, [r7, #4]
 8005ff6:	3302      	adds	r3, #2
 8005ff8:	00db      	lsls	r3, r3, #3
 8005ffa:	4413      	add	r3, r2
 8005ffc:	2200      	movs	r2, #0
 8005ffe:	721a      	strb	r2, [r3, #8]

    can_try_enqueue_waiting_frame_I(instance);
 8006000:	6878      	ldr	r0, [r7, #4]
 8006002:	f7ff fe07 	bl	8005c14 <can_try_enqueue_waiting_frame_I>
}
 8006006:	3708      	adds	r7, #8
 8006008:	46bd      	mov	sp, r7
 800600a:	bd80      	pop	{r7, pc}
 800600c:	0800ec74 	.word	0x0800ec74

08006010 <can_fill_rx_frame_I>:
struct can_fill_rx_frame_params_s {
    systime_t rx_systime;
    struct can_frame_s* frame;
};

static void can_fill_rx_frame_I(size_t msg_size, void* msg, void* ctx) {
 8006010:	b590      	push	{r4, r7, lr}
 8006012:	b087      	sub	sp, #28
 8006014:	af00      	add	r7, sp, #0
 8006016:	60f8      	str	r0, [r7, #12]
 8006018:	60b9      	str	r1, [r7, #8]
 800601a:	607a      	str	r2, [r7, #4]
    (void)msg_size;

    chDbgCheckClassI();
 800601c:	f004 ffce 	bl	800afbc <chDbgCheckClassI>

    struct can_fill_rx_frame_params_s* params = ctx;
 8006020:	687b      	ldr	r3, [r7, #4]
 8006022:	617b      	str	r3, [r7, #20]
    struct can_rx_frame_s* frame = msg;
 8006024:	68bb      	ldr	r3, [r7, #8]
 8006026:	613b      	str	r3, [r7, #16]

    frame->content = *params->frame;
 8006028:	697b      	ldr	r3, [r7, #20]
 800602a:	685b      	ldr	r3, [r3, #4]
 800602c:	693a      	ldr	r2, [r7, #16]
 800602e:	4614      	mov	r4, r2
 8006030:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8006032:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    frame->rx_systime = params->rx_systime;
 8006036:	697b      	ldr	r3, [r7, #20]
 8006038:	881a      	ldrh	r2, [r3, #0]
 800603a:	693b      	ldr	r3, [r7, #16]
 800603c:	821a      	strh	r2, [r3, #16]
}
 800603e:	371c      	adds	r7, #28
 8006040:	46bd      	mov	sp, r7
 8006042:	bd90      	pop	{r4, r7, pc}

08006044 <can_driver_rx_frame_received_I>:

void can_driver_rx_frame_received_I(struct can_instance_s* instance, uint8_t mb_idx, systime_t rx_systime, struct can_frame_s* frame) {
 8006044:	b580      	push	{r7, lr}
 8006046:	b088      	sub	sp, #32
 8006048:	af02      	add	r7, sp, #8
 800604a:	60f8      	str	r0, [r7, #12]
 800604c:	607b      	str	r3, [r7, #4]
 800604e:	460b      	mov	r3, r1
 8006050:	72fb      	strb	r3, [r7, #11]
 8006052:	4613      	mov	r3, r2
 8006054:	813b      	strh	r3, [r7, #8]
    (void)mb_idx;

    chDbgCheckClassI();
 8006056:	f004 ffb1 	bl	800afbc <chDbgCheckClassI>

    struct can_fill_rx_frame_params_s can_fill_rx_frame_params = {rx_systime, frame};
 800605a:	893b      	ldrh	r3, [r7, #8]
 800605c:	823b      	strh	r3, [r7, #16]
 800605e:	687b      	ldr	r3, [r7, #4]
 8006060:	617b      	str	r3, [r7, #20]
    worker_thread_publisher_task_publish_I(&instance->rx_publisher_task, &instance->rx_topic, sizeof(struct can_rx_frame_s), can_fill_rx_frame_I, &can_fill_rx_frame_params);
 8006062:	68fb      	ldr	r3, [r7, #12]
 8006064:	f103 014c 	add.w	r1, r3, #76	; 0x4c
 8006068:	68fb      	ldr	r3, [r7, #12]
 800606a:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800606e:	f107 0310 	add.w	r3, r7, #16
 8006072:	9300      	str	r3, [sp, #0]
 8006074:	4608      	mov	r0, r1
 8006076:	4611      	mov	r1, r2
 8006078:	2214      	movs	r2, #20
 800607a:	4b04      	ldr	r3, [pc, #16]	; (800608c <can_driver_rx_frame_received_I+0x48>)
 800607c:	f000 fc56 	bl	800692c <worker_thread_publisher_task_publish_I>
    instance->baudrate_confirmed = true;
 8006080:	68fb      	ldr	r3, [r7, #12]
 8006082:	2201      	movs	r2, #1
 8006084:	721a      	strb	r2, [r3, #8]
}
 8006086:	3718      	adds	r7, #24
 8006088:	46bd      	mov	sp, r7
 800608a:	bd80      	pop	{r7, pc}
 800608c:	08006011 	.word	0x08006011

08006090 <LL_US2ST.lto_priv.86>:
 * @param[in] usec      number of microseconds
 * @return              The number of ticks.
 *
 * @api
 */
static inline systime_t LL_US2ST(unsigned int usec) {
 8006090:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8006094:	b086      	sub	sp, #24
 8006096:	af00      	add	r7, sp, #0
 8006098:	60f8      	str	r0, [r7, #12]
  uint64_t ticks = (((uint64_t)usec * (uint64_t)CH_CFG_ST_FREQUENCY) + 999999ULL)
 800609a:	68f9      	ldr	r1, [r7, #12]
 800609c:	460c      	mov	r4, r1
 800609e:	f04f 0500 	mov.w	r5, #0
 80060a2:	4620      	mov	r0, r4
 80060a4:	4629      	mov	r1, r5
 80060a6:	ea4f 0b81 	mov.w	fp, r1, lsl #2
 80060aa:	ea4b 7b90 	orr.w	fp, fp, r0, lsr #30
 80060ae:	ea4f 0a80 	mov.w	sl, r0, lsl #2
 80060b2:	4650      	mov	r0, sl
 80060b4:	4659      	mov	r1, fp
 80060b6:	014b      	lsls	r3, r1, #5
 80060b8:	ea43 63d0 	orr.w	r3, r3, r0, lsr #27
 80060bc:	0142      	lsls	r2, r0, #5
 80060be:	1a12      	subs	r2, r2, r0
 80060c0:	eb63 0301 	sbc.w	r3, r3, r1
 80060c4:	18a4      	adds	r4, r4, r2
 80060c6:	eb45 0503 	adc.w	r5, r5, r3
 80060ca:	4622      	mov	r2, r4
 80060cc:	462b      	mov	r3, r5
 80060ce:	0099      	lsls	r1, r3, #2
 80060d0:	6079      	str	r1, [r7, #4]
 80060d2:	6879      	ldr	r1, [r7, #4]
 80060d4:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
 80060d8:	6079      	str	r1, [r7, #4]
 80060da:	0091      	lsls	r1, r2, #2
 80060dc:	6039      	str	r1, [r7, #0]
 80060de:	e9d7 0100 	ldrd	r0, r1, [r7]
 80060e2:	1880      	adds	r0, r0, r2
 80060e4:	eb41 0103 	adc.w	r1, r1, r3
 80060e8:	4602      	mov	r2, r0
 80060ea:	460b      	mov	r3, r1
 80060ec:	ea4f 1903 	mov.w	r9, r3, lsl #4
 80060f0:	ea49 7912 	orr.w	r9, r9, r2, lsr #28
 80060f4:	ea4f 1802 	mov.w	r8, r2, lsl #4
 80060f8:	4642      	mov	r2, r8
 80060fa:	464b      	mov	r3, r9
 80060fc:	4610      	mov	r0, r2
 80060fe:	4619      	mov	r1, r3
 8006100:	4a11      	ldr	r2, [pc, #68]	; (8006148 <LL_US2ST.lto_priv.86+0xb8>)
 8006102:	f04f 0300 	mov.w	r3, #0
 8006106:	1812      	adds	r2, r2, r0
 8006108:	eb43 0301 	adc.w	r3, r3, r1
 800610c:	4610      	mov	r0, r2
 800610e:	4619      	mov	r1, r3
 8006110:	4a0e      	ldr	r2, [pc, #56]	; (800614c <LL_US2ST.lto_priv.86+0xbc>)
 8006112:	f04f 0300 	mov.w	r3, #0
 8006116:	f7fd f8ff 	bl	8003318 <__aeabi_uldivmod>
 800611a:	4602      	mov	r2, r0
 800611c:	460b      	mov	r3, r1
 800611e:	e9c7 2304 	strd	r2, r3, [r7, #16]
                   / 1000000ULL;

  chDbgAssert(ticks <= (uint64_t)TIME_MAXIMUM, "conversion overflow");
 8006122:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8006126:	f64f 70fe 	movw	r0, #65534	; 0xfffe
 800612a:	f04f 0100 	mov.w	r1, #0
 800612e:	4299      	cmp	r1, r3
 8006130:	bf08      	it	eq
 8006132:	4290      	cmpeq	r0, r2
 8006134:	d202      	bcs.n	800613c <LL_US2ST.lto_priv.86+0xac>
 8006136:	4806      	ldr	r0, [pc, #24]	; (8006150 <LL_US2ST.lto_priv.86+0xc0>)
 8006138:	f004 fe62 	bl	800ae00 <chSysHalt>

  return (systime_t)ticks;
 800613c:	8a3b      	ldrh	r3, [r7, #16]
}
 800613e:	4618      	mov	r0, r3
 8006140:	3718      	adds	r7, #24
 8006142:	46bd      	mov	sp, r7
 8006144:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8006148:	000f423f 	.word	0x000f423f
 800614c:	000f4240 	.word	0x000f4240
 8006150:	0800eca8 	.word	0x0800eca8

08006154 <is_baudrate_valid>:

static uint8_t baudrate_idx = 0;
static void autobaud_timer_task_func(struct worker_thread_timer_task_s* task);
static struct worker_thread_timer_task_s autobaud_timer_task;

static bool is_baudrate_valid(uint32_t baudrate) {
 8006154:	b480      	push	{r7}
 8006156:	b085      	sub	sp, #20
 8006158:	af00      	add	r7, sp, #0
 800615a:	6078      	str	r0, [r7, #4]
    for (uint8_t i=0; i<LEN(valid_baudrates); i++) {
 800615c:	2300      	movs	r3, #0
 800615e:	73fb      	strb	r3, [r7, #15]
 8006160:	e00b      	b.n	800617a <is_baudrate_valid+0x26>
        if (baudrate == valid_baudrates[i]) {
 8006162:	7bfb      	ldrb	r3, [r7, #15]
 8006164:	4a0a      	ldr	r2, [pc, #40]	; (8006190 <is_baudrate_valid+0x3c>)
 8006166:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800616a:	687b      	ldr	r3, [r7, #4]
 800616c:	429a      	cmp	r2, r3
 800616e:	d101      	bne.n	8006174 <is_baudrate_valid+0x20>
            return true;
 8006170:	2301      	movs	r3, #1
 8006172:	e006      	b.n	8006182 <is_baudrate_valid+0x2e>
static uint8_t baudrate_idx = 0;
static void autobaud_timer_task_func(struct worker_thread_timer_task_s* task);
static struct worker_thread_timer_task_s autobaud_timer_task;

static bool is_baudrate_valid(uint32_t baudrate) {
    for (uint8_t i=0; i<LEN(valid_baudrates); i++) {
 8006174:	7bfb      	ldrb	r3, [r7, #15]
 8006176:	3301      	adds	r3, #1
 8006178:	73fb      	strb	r3, [r7, #15]
 800617a:	7bfb      	ldrb	r3, [r7, #15]
 800617c:	2b03      	cmp	r3, #3
 800617e:	d9f0      	bls.n	8006162 <is_baudrate_valid+0xe>
        if (baudrate == valid_baudrates[i]) {
            return true;
        }
    }
    return false;
 8006180:	2300      	movs	r3, #0
}
 8006182:	4618      	mov	r0, r3
 8006184:	3714      	adds	r7, #20
 8006186:	46bd      	mov	sp, r7
 8006188:	f85d 7b04 	ldr.w	r7, [sp], #4
 800618c:	4770      	bx	lr
 800618e:	bf00      	nop
 8006190:	0800ec98 	.word	0x0800ec98

08006194 <_local_ctor_37>:

RUN_AFTER(CAN_INIT) {
 8006194:	b580      	push	{r7, lr}
 8006196:	b086      	sub	sp, #24
 8006198:	af02      	add	r7, sp, #8
    uint32_t canbus_baud = 1000000;
 800619a:	4b38      	ldr	r3, [pc, #224]	; (800627c <_local_ctor_37+0xe8>)
 800619c:	60fb      	str	r3, [r7, #12]
    bool canbus_autobaud_enable = true;
 800619e:	2301      	movs	r3, #1
 80061a0:	72fb      	strb	r3, [r7, #11]

#ifdef MODULE_APP_DESCRIPTOR_ENABLED
    if (is_baudrate_valid(shared_get_parameters(&shared_app_descriptor)->canbus_baudrate)) {
 80061a2:	4837      	ldr	r0, [pc, #220]	; (8006280 <_local_ctor_37+0xec>)
 80061a4:	f003 fce4 	bl	8009b70 <shared_get_parameters>
 80061a8:	4603      	mov	r3, r0
 80061aa:	789a      	ldrb	r2, [r3, #2]
 80061ac:	0852      	lsrs	r2, r2, #1
 80061ae:	b2d2      	uxtb	r2, r2
 80061b0:	78d9      	ldrb	r1, [r3, #3]
 80061b2:	01c9      	lsls	r1, r1, #7
 80061b4:	430a      	orrs	r2, r1
 80061b6:	7919      	ldrb	r1, [r3, #4]
 80061b8:	03c9      	lsls	r1, r1, #15
 80061ba:	430a      	orrs	r2, r1
 80061bc:	795b      	ldrb	r3, [r3, #5]
 80061be:	05db      	lsls	r3, r3, #23
 80061c0:	4313      	orrs	r3, r2
 80061c2:	4618      	mov	r0, r3
 80061c4:	f7ff ffc6 	bl	8006154 <is_baudrate_valid>
 80061c8:	4603      	mov	r3, r0
 80061ca:	2b00      	cmp	r3, #0
 80061cc:	d010      	beq.n	80061f0 <_local_ctor_37+0x5c>
        canbus_baud = shared_get_parameters(&shared_app_descriptor)->canbus_baudrate;
 80061ce:	482c      	ldr	r0, [pc, #176]	; (8006280 <_local_ctor_37+0xec>)
 80061d0:	f003 fcce 	bl	8009b70 <shared_get_parameters>
 80061d4:	4603      	mov	r3, r0
 80061d6:	789a      	ldrb	r2, [r3, #2]
 80061d8:	0852      	lsrs	r2, r2, #1
 80061da:	b2d2      	uxtb	r2, r2
 80061dc:	78d9      	ldrb	r1, [r3, #3]
 80061de:	01c9      	lsls	r1, r1, #7
 80061e0:	430a      	orrs	r2, r1
 80061e2:	7919      	ldrb	r1, [r3, #4]
 80061e4:	03c9      	lsls	r1, r1, #15
 80061e6:	430a      	orrs	r2, r1
 80061e8:	795b      	ldrb	r3, [r3, #5]
 80061ea:	05db      	lsls	r3, r3, #23
 80061ec:	4313      	orrs	r3, r2
 80061ee:	60fb      	str	r3, [r7, #12]
    }

    if (shared_get_parameters(&shared_app_descriptor)->canbus_disable_auto_baud) {
 80061f0:	4823      	ldr	r0, [pc, #140]	; (8006280 <_local_ctor_37+0xec>)
 80061f2:	f003 fcbd 	bl	8009b70 <shared_get_parameters>
 80061f6:	4603      	mov	r3, r0
 80061f8:	789b      	ldrb	r3, [r3, #2]
 80061fa:	f003 0301 	and.w	r3, r3, #1
 80061fe:	b2db      	uxtb	r3, r3
 8006200:	2b00      	cmp	r3, #0
 8006202:	d001      	beq.n	8006208 <_local_ctor_37+0x74>
        canbus_autobaud_enable = false;
 8006204:	2300      	movs	r3, #0
 8006206:	72fb      	strb	r3, [r7, #11]
        canbus_baud = boot_msg.canbus_info.baudrate;
        canbus_autobaud_enable = false;
    }
#endif

    for (uint8_t i=0; i<LEN(valid_baudrates); i++) {
 8006208:	2300      	movs	r3, #0
 800620a:	72bb      	strb	r3, [r7, #10]
 800620c:	e00d      	b.n	800622a <_local_ctor_37+0x96>
        if (canbus_baud == valid_baudrates[i]) {
 800620e:	7abb      	ldrb	r3, [r7, #10]
 8006210:	4a1c      	ldr	r2, [pc, #112]	; (8006284 <_local_ctor_37+0xf0>)
 8006212:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8006216:	68fb      	ldr	r3, [r7, #12]
 8006218:	429a      	cmp	r2, r3
 800621a:	d103      	bne.n	8006224 <_local_ctor_37+0x90>
            baudrate_idx = i;
 800621c:	4a1a      	ldr	r2, [pc, #104]	; (8006288 <_local_ctor_37+0xf4>)
 800621e:	7abb      	ldrb	r3, [r7, #10]
 8006220:	7013      	strb	r3, [r2, #0]
 8006222:	e005      	b.n	8006230 <_local_ctor_37+0x9c>
        canbus_baud = boot_msg.canbus_info.baudrate;
        canbus_autobaud_enable = false;
    }
#endif

    for (uint8_t i=0; i<LEN(valid_baudrates); i++) {
 8006224:	7abb      	ldrb	r3, [r7, #10]
 8006226:	3301      	adds	r3, #1
 8006228:	72bb      	strb	r3, [r7, #10]
 800622a:	7abb      	ldrb	r3, [r7, #10]
 800622c:	2b03      	cmp	r3, #3
 800622e:	d9ee      	bls.n	800620e <_local_ctor_37+0x7a>
            baudrate_idx = i;
            break;
        }
    }

    struct can_instance_s* can_instance = NULL;
 8006230:	2300      	movs	r3, #0
 8006232:	607b      	str	r3, [r7, #4]
 8006234:	e007      	b.n	8006246 <_local_ctor_37+0xb2>
    while (can_iterate_instances(&can_instance)) {
        can_start(can_instance, canbus_autobaud_enable, true, canbus_baud);
 8006236:	687a      	ldr	r2, [r7, #4]
 8006238:	7afb      	ldrb	r3, [r7, #11]
 800623a:	4610      	mov	r0, r2
 800623c:	4619      	mov	r1, r3
 800623e:	2201      	movs	r2, #1
 8006240:	68fb      	ldr	r3, [r7, #12]
 8006242:	f7ff fb63 	bl	800590c <can_start>
            break;
        }
    }

    struct can_instance_s* can_instance = NULL;
    while (can_iterate_instances(&can_instance)) {
 8006246:	1d3b      	adds	r3, r7, #4
 8006248:	4618      	mov	r0, r3
 800624a:	f001 fb97 	bl	800797c <can_iterate_instances>
 800624e:	4603      	mov	r3, r0
 8006250:	2b00      	cmp	r3, #0
 8006252:	d1f0      	bne.n	8006236 <_local_ctor_37+0xa2>
        can_start(can_instance, canbus_autobaud_enable, true, canbus_baud);
    }

    if (canbus_autobaud_enable) {
 8006254:	7afb      	ldrb	r3, [r7, #11]
 8006256:	2b00      	cmp	r3, #0
 8006258:	d00c      	beq.n	8006274 <_local_ctor_37+0xe0>
        worker_thread_add_timer_task(&WT, &autobaud_timer_task, autobaud_timer_task_func, NULL, LL_US2ST(CAN_AUTOBAUD_SWITCH_INTERVAL_US), false);
 800625a:	4808      	ldr	r0, [pc, #32]	; (800627c <_local_ctor_37+0xe8>)
 800625c:	f7ff ff18 	bl	8006090 <LL_US2ST.lto_priv.86>
 8006260:	4603      	mov	r3, r0
 8006262:	9300      	str	r3, [sp, #0]
 8006264:	2300      	movs	r3, #0
 8006266:	9301      	str	r3, [sp, #4]
 8006268:	4808      	ldr	r0, [pc, #32]	; (800628c <_local_ctor_37+0xf8>)
 800626a:	4909      	ldr	r1, [pc, #36]	; (8006290 <_local_ctor_37+0xfc>)
 800626c:	4a09      	ldr	r2, [pc, #36]	; (8006294 <_local_ctor_37+0x100>)
 800626e:	2300      	movs	r3, #0
 8006270:	f002 fb80 	bl	8008974 <worker_thread_add_timer_task>
    }
}
 8006274:	3710      	adds	r7, #16
 8006276:	46bd      	mov	sp, r7
 8006278:	bd80      	pop	{r7, pc}
 800627a:	bf00      	nop
 800627c:	000f4240 	.word	0x000f4240
 8006280:	08003160 	.word	0x08003160
 8006284:	0800ec98 	.word	0x0800ec98
 8006288:	20001470 	.word	0x20001470
 800628c:	20000a20 	.word	0x20000a20
 8006290:	20001474 	.word	0x20001474
 8006294:	08006299 	.word	0x08006299

08006298 <autobaud_timer_task_func>:

static void autobaud_timer_task_func(struct worker_thread_timer_task_s* task) {
 8006298:	b580      	push	{r7, lr}
 800629a:	b084      	sub	sp, #16
 800629c:	af00      	add	r7, sp, #0
 800629e:	6078      	str	r0, [r7, #4]
    baudrate_idx = (baudrate_idx + 1) % LEN(valid_baudrates);
 80062a0:	4b20      	ldr	r3, [pc, #128]	; (8006324 <autobaud_timer_task_func+0x8c>)
 80062a2:	781b      	ldrb	r3, [r3, #0]
 80062a4:	3301      	adds	r3, #1
 80062a6:	b2db      	uxtb	r3, r3
 80062a8:	f003 0303 	and.w	r3, r3, #3
 80062ac:	b2da      	uxtb	r2, r3
 80062ae:	4b1d      	ldr	r3, [pc, #116]	; (8006324 <autobaud_timer_task_func+0x8c>)
 80062b0:	701a      	strb	r2, [r3, #0]

    bool autobaud_complete = true;
 80062b2:	2301      	movs	r3, #1
 80062b4:	73fb      	strb	r3, [r7, #15]
    struct can_instance_s* can_instance = NULL;
 80062b6:	2300      	movs	r3, #0
 80062b8:	60bb      	str	r3, [r7, #8]
 80062ba:	e019      	b.n	80062f0 <autobaud_timer_task_func+0x58>
    while (can_iterate_instances(&can_instance)) {
        if (can_get_baudrate_confirmed(can_instance)) {
 80062bc:	68bb      	ldr	r3, [r7, #8]
 80062be:	4618      	mov	r0, r3
 80062c0:	f001 fc22 	bl	8007b08 <can_get_baudrate_confirmed>
 80062c4:	4603      	mov	r3, r0
 80062c6:	2b00      	cmp	r3, #0
 80062c8:	d005      	beq.n	80062d6 <autobaud_timer_task_func+0x3e>
            can_set_silent_mode(can_instance, false);
 80062ca:	68bb      	ldr	r3, [r7, #8]
 80062cc:	4618      	mov	r0, r3
 80062ce:	2100      	movs	r1, #0
 80062d0:	f001 fbb4 	bl	8007a3c <can_set_silent_mode>
 80062d4:	e00c      	b.n	80062f0 <autobaud_timer_task_func+0x58>
        } else {
            can_set_baudrate(can_instance, valid_baudrates[baudrate_idx]);
 80062d6:	68ba      	ldr	r2, [r7, #8]
 80062d8:	4b12      	ldr	r3, [pc, #72]	; (8006324 <autobaud_timer_task_func+0x8c>)
 80062da:	781b      	ldrb	r3, [r3, #0]
 80062dc:	4619      	mov	r1, r3
 80062de:	4b12      	ldr	r3, [pc, #72]	; (8006328 <autobaud_timer_task_func+0x90>)
 80062e0:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80062e4:	4610      	mov	r0, r2
 80062e6:	4619      	mov	r1, r3
 80062e8:	f001 fbec 	bl	8007ac4 <can_set_baudrate>
            autobaud_complete = false;
 80062ec:	2300      	movs	r3, #0
 80062ee:	73fb      	strb	r3, [r7, #15]
static void autobaud_timer_task_func(struct worker_thread_timer_task_s* task) {
    baudrate_idx = (baudrate_idx + 1) % LEN(valid_baudrates);

    bool autobaud_complete = true;
    struct can_instance_s* can_instance = NULL;
    while (can_iterate_instances(&can_instance)) {
 80062f0:	f107 0308 	add.w	r3, r7, #8
 80062f4:	4618      	mov	r0, r3
 80062f6:	f001 fb41 	bl	800797c <can_iterate_instances>
 80062fa:	4603      	mov	r3, r0
 80062fc:	2b00      	cmp	r3, #0
 80062fe:	d1dd      	bne.n	80062bc <autobaud_timer_task_func+0x24>
            can_set_baudrate(can_instance, valid_baudrates[baudrate_idx]);
            autobaud_complete = false;
        }
    }

    if (!autobaud_complete) {
 8006300:	7bfb      	ldrb	r3, [r7, #15]
 8006302:	f083 0301 	eor.w	r3, r3, #1
 8006306:	b2db      	uxtb	r3, r3
 8006308:	2b00      	cmp	r3, #0
 800630a:	d008      	beq.n	800631e <autobaud_timer_task_func+0x86>
        worker_thread_timer_task_reschedule(&WT, task, LL_US2ST(CAN_AUTOBAUD_SWITCH_INTERVAL_US));
 800630c:	4807      	ldr	r0, [pc, #28]	; (800632c <autobaud_timer_task_func+0x94>)
 800630e:	f7ff febf 	bl	8006090 <LL_US2ST.lto_priv.86>
 8006312:	4603      	mov	r3, r0
 8006314:	4806      	ldr	r0, [pc, #24]	; (8006330 <autobaud_timer_task_func+0x98>)
 8006316:	6879      	ldr	r1, [r7, #4]
 8006318:	461a      	mov	r2, r3
 800631a:	f002 fb7b 	bl	8008a14 <worker_thread_timer_task_reschedule>
    }
}
 800631e:	3710      	adds	r7, #16
 8006320:	46bd      	mov	sp, r7
 8006322:	bd80      	pop	{r7, pc}
 8006324:	20001470 	.word	0x20001470
 8006328:	0800ec98 	.word	0x0800ec98
 800632c:	000f4240 	.word	0x000f4240
 8006330:	20000a20 	.word	0x20000a20

08006334 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006334:	b480      	push	{r7}
 8006336:	b083      	sub	sp, #12
 8006338:	af00      	add	r7, sp, #0
 800633a:	2320      	movs	r3, #32
 800633c:	607b      	str	r3, [r7, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800633e:	687b      	ldr	r3, [r7, #4]
 8006340:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006344:	370c      	adds	r7, #12
 8006346:	46bd      	mov	sp, r7
 8006348:	f85d 7b04 	ldr.w	r7, [sp], #4
 800634c:	4770      	bx	lr
 800634e:	bf00      	nop

08006350 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006350:	b480      	push	{r7}
 8006352:	b083      	sub	sp, #12
 8006354:	af00      	add	r7, sp, #0
 8006356:	2300      	movs	r3, #0
 8006358:	607b      	str	r3, [r7, #4]
 800635a:	687b      	ldr	r3, [r7, #4]
 800635c:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006360:	370c      	adds	r7, #12
 8006362:	46bd      	mov	sp, r7
 8006364:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006368:	4770      	bx	lr
 800636a:	bf00      	nop

0800636c <chSysLock.lto_priv.77>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800636c:	b580      	push	{r7, lr}
 800636e:	af00      	add	r7, sp, #0

  port_lock();
 8006370:	f7ff ffe0 	bl	8006334 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006374:	f004 fd92 	bl	800ae9c <_dbg_check_lock>
}
 8006378:	bd80      	pop	{r7, pc}
 800637a:	bf00      	nop

0800637c <chSysUnlock.lto_priv.76>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800637c:	b580      	push	{r7, lr}
 800637e:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8006380:	f004 fda2 	bl	800aec8 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8006384:	4b09      	ldr	r3, [pc, #36]	; (80063ac <chSysUnlock.lto_priv.76+0x30>)
 8006386:	681b      	ldr	r3, [r3, #0]
 8006388:	4a08      	ldr	r2, [pc, #32]	; (80063ac <chSysUnlock.lto_priv.76+0x30>)
 800638a:	4293      	cmp	r3, r2
 800638c:	d00a      	beq.n	80063a4 <chSysUnlock.lto_priv.76+0x28>
 800638e:	4b07      	ldr	r3, [pc, #28]	; (80063ac <chSysUnlock.lto_priv.76+0x30>)
 8006390:	699b      	ldr	r3, [r3, #24]
 8006392:	689a      	ldr	r2, [r3, #8]
 8006394:	4b05      	ldr	r3, [pc, #20]	; (80063ac <chSysUnlock.lto_priv.76+0x30>)
 8006396:	681b      	ldr	r3, [r3, #0]
 8006398:	689b      	ldr	r3, [r3, #8]
 800639a:	429a      	cmp	r2, r3
 800639c:	d202      	bcs.n	80063a4 <chSysUnlock.lto_priv.76+0x28>
 800639e:	4804      	ldr	r0, [pc, #16]	; (80063b0 <chSysUnlock.lto_priv.76+0x34>)
 80063a0:	f004 fd2e 	bl	800ae00 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 80063a4:	f7ff ffd4 	bl	8006350 <port_unlock>
}
 80063a8:	bd80      	pop	{r7, pc}
 80063aa:	bf00      	nop
 80063ac:	20001338 	.word	0x20001338
 80063b0:	0800ecc0 	.word	0x0800ecc0

080063b4 <LL_US2ST.lto_priv.87>:
 * @param[in] usec      number of microseconds
 * @return              The number of ticks.
 *
 * @api
 */
static inline systime_t LL_US2ST(unsigned int usec) {
 80063b4:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80063b8:	b086      	sub	sp, #24
 80063ba:	af00      	add	r7, sp, #0
 80063bc:	60f8      	str	r0, [r7, #12]
  uint64_t ticks = (((uint64_t)usec * (uint64_t)CH_CFG_ST_FREQUENCY) + 999999ULL)
 80063be:	68f9      	ldr	r1, [r7, #12]
 80063c0:	460c      	mov	r4, r1
 80063c2:	f04f 0500 	mov.w	r5, #0
 80063c6:	4620      	mov	r0, r4
 80063c8:	4629      	mov	r1, r5
 80063ca:	ea4f 0b81 	mov.w	fp, r1, lsl #2
 80063ce:	ea4b 7b90 	orr.w	fp, fp, r0, lsr #30
 80063d2:	ea4f 0a80 	mov.w	sl, r0, lsl #2
 80063d6:	4650      	mov	r0, sl
 80063d8:	4659      	mov	r1, fp
 80063da:	014b      	lsls	r3, r1, #5
 80063dc:	ea43 63d0 	orr.w	r3, r3, r0, lsr #27
 80063e0:	0142      	lsls	r2, r0, #5
 80063e2:	1a12      	subs	r2, r2, r0
 80063e4:	eb63 0301 	sbc.w	r3, r3, r1
 80063e8:	18a4      	adds	r4, r4, r2
 80063ea:	eb45 0503 	adc.w	r5, r5, r3
 80063ee:	4622      	mov	r2, r4
 80063f0:	462b      	mov	r3, r5
 80063f2:	0099      	lsls	r1, r3, #2
 80063f4:	6079      	str	r1, [r7, #4]
 80063f6:	6879      	ldr	r1, [r7, #4]
 80063f8:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
 80063fc:	6079      	str	r1, [r7, #4]
 80063fe:	0091      	lsls	r1, r2, #2
 8006400:	6039      	str	r1, [r7, #0]
 8006402:	e9d7 0100 	ldrd	r0, r1, [r7]
 8006406:	1880      	adds	r0, r0, r2
 8006408:	eb41 0103 	adc.w	r1, r1, r3
 800640c:	4602      	mov	r2, r0
 800640e:	460b      	mov	r3, r1
 8006410:	ea4f 1903 	mov.w	r9, r3, lsl #4
 8006414:	ea49 7912 	orr.w	r9, r9, r2, lsr #28
 8006418:	ea4f 1802 	mov.w	r8, r2, lsl #4
 800641c:	4642      	mov	r2, r8
 800641e:	464b      	mov	r3, r9
 8006420:	4610      	mov	r0, r2
 8006422:	4619      	mov	r1, r3
 8006424:	4a11      	ldr	r2, [pc, #68]	; (800646c <LL_US2ST.lto_priv.87+0xb8>)
 8006426:	f04f 0300 	mov.w	r3, #0
 800642a:	1812      	adds	r2, r2, r0
 800642c:	eb43 0301 	adc.w	r3, r3, r1
 8006430:	4610      	mov	r0, r2
 8006432:	4619      	mov	r1, r3
 8006434:	4a0e      	ldr	r2, [pc, #56]	; (8006470 <LL_US2ST.lto_priv.87+0xbc>)
 8006436:	f04f 0300 	mov.w	r3, #0
 800643a:	f7fc ff6d 	bl	8003318 <__aeabi_uldivmod>
 800643e:	4602      	mov	r2, r0
 8006440:	460b      	mov	r3, r1
 8006442:	e9c7 2304 	strd	r2, r3, [r7, #16]
                   / 1000000ULL;

  chDbgAssert(ticks <= (uint64_t)TIME_MAXIMUM, "conversion overflow");
 8006446:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800644a:	f64f 70fe 	movw	r0, #65534	; 0xfffe
 800644e:	f04f 0100 	mov.w	r1, #0
 8006452:	4299      	cmp	r1, r3
 8006454:	bf08      	it	eq
 8006456:	4290      	cmpeq	r0, r2
 8006458:	d202      	bcs.n	8006460 <LL_US2ST.lto_priv.87+0xac>
 800645a:	4806      	ldr	r0, [pc, #24]	; (8006474 <LL_US2ST.lto_priv.87+0xc0>)
 800645c:	f004 fcd0 	bl	800ae00 <chSysHalt>

  return (systime_t)ticks;
 8006460:	8a3b      	ldrh	r3, [r7, #16]
}
 8006462:	4618      	mov	r0, r3
 8006464:	3718      	adds	r7, #24
 8006466:	46bd      	mov	sp, r7
 8006468:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 800646c:	000f423f 	.word	0x000f423f
 8006470:	000f4240 	.word	0x000f4240
 8006474:	0800ecb4 	.word	0x0800ecb4

08006478 <chCoreAllocAlignedI.lto_priv.9>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8006478:	b580      	push	{r7, lr}
 800647a:	b082      	sub	sp, #8
 800647c:	af00      	add	r7, sp, #0
 800647e:	6078      	str	r0, [r7, #4]
 8006480:	6039      	str	r1, [r7, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8006482:	6878      	ldr	r0, [r7, #4]
 8006484:	6839      	ldr	r1, [r7, #0]
 8006486:	2200      	movs	r2, #0
 8006488:	f003 fc80 	bl	8009d8c <chCoreAllocAlignedWithOffsetI>
 800648c:	4603      	mov	r3, r0
}
 800648e:	4618      	mov	r0, r3
 8006490:	3708      	adds	r7, #8
 8006492:	46bd      	mov	sp, r7
 8006494:	bd80      	pop	{r7, pc}
 8006496:	bf00      	nop

08006498 <chCoreAlloc.lto_priv.85>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
static inline void *chCoreAlloc(size_t size) {
 8006498:	b580      	push	{r7, lr}
 800649a:	b082      	sub	sp, #8
 800649c:	af00      	add	r7, sp, #0
 800649e:	6078      	str	r0, [r7, #4]

  return chCoreAllocAlignedWithOffset(size, PORT_NATURAL_ALIGN, 0U);
 80064a0:	6878      	ldr	r0, [r7, #4]
 80064a2:	2104      	movs	r1, #4
 80064a4:	2200      	movs	r2, #0
 80064a6:	f003 fcb5 	bl	8009e14 <chCoreAllocAlignedWithOffset>
 80064aa:	4603      	mov	r3, r0
}
 80064ac:	4618      	mov	r0, r3
 80064ae:	3708      	adds	r7, #8
 80064b0:	46bd      	mov	sp, r7
 80064b2:	bd80      	pop	{r7, pc}

080064b4 <_local_ctor_100>:
#ifdef MODULE_PARAM_ENABLED
#include <modules/param/param.h>
PARAM_DEFINE_UINT8_PARAM_STATIC(node_id_param, "uavcan.node_id", 0, 0, 125)
#endif

RUN_ON(UAVCAN_INIT) {
 80064b4:	b580      	push	{r7, lr}
 80064b6:	b082      	sub	sp, #8
 80064b8:	af02      	add	r7, sp, #8
    uavcan_init(0);
 80064ba:	2000      	movs	r0, #0
 80064bc:	f000 f818 	bl	80064f0 <uavcan_init>

    worker_thread_add_timer_task(&WT_RX, &stale_transfer_cleanup_task, stale_transfer_cleanup_task_func, NULL, LL_US2ST(CANARD_RECOMMENDED_STALE_TRANSFER_CLEANUP_INTERVAL_USEC), true);
 80064c0:	4807      	ldr	r0, [pc, #28]	; (80064e0 <_local_ctor_100+0x2c>)
 80064c2:	f7ff ff77 	bl	80063b4 <LL_US2ST.lto_priv.87>
 80064c6:	4603      	mov	r3, r0
 80064c8:	9300      	str	r3, [sp, #0]
 80064ca:	2301      	movs	r3, #1
 80064cc:	9301      	str	r3, [sp, #4]
 80064ce:	4805      	ldr	r0, [pc, #20]	; (80064e4 <_local_ctor_100+0x30>)
 80064d0:	4905      	ldr	r1, [pc, #20]	; (80064e8 <_local_ctor_100+0x34>)
 80064d2:	4a06      	ldr	r2, [pc, #24]	; (80064ec <_local_ctor_100+0x38>)
 80064d4:	2300      	movs	r3, #0
 80064d6:	f002 fa4d 	bl	8008974 <worker_thread_add_timer_task>
}
 80064da:	46bd      	mov	sp, r7
 80064dc:	bd80      	pop	{r7, pc}
 80064de:	bf00      	nop
 80064e0:	000f4240 	.word	0x000f4240
 80064e4:	20000a3c 	.word	0x20000a3c
 80064e8:	20001488 	.word	0x20001488
 80064ec:	08005089 	.word	0x08005089

080064f0 <uavcan_init>:

static void uavcan_init(uint8_t can_dev_idx) {
 80064f0:	b580      	push	{r7, lr}
 80064f2:	b08c      	sub	sp, #48	; 0x30
 80064f4:	af02      	add	r7, sp, #8
 80064f6:	4603      	mov	r3, r0
 80064f8:	71fb      	strb	r3, [r7, #7]
    struct uavcan_instance_s* instance;
    struct can_instance_s* can_instance;
    void* transfer_id_map_working_area;

    if (!(can_instance = can_get_instance(can_dev_idx))) { goto fail; }
 80064fa:	79fb      	ldrb	r3, [r7, #7]
 80064fc:	4618      	mov	r0, r3
 80064fe:	f001 fa65 	bl	80079cc <can_get_instance>
 8006502:	61f8      	str	r0, [r7, #28]
 8006504:	69fb      	ldr	r3, [r7, #28]
 8006506:	2b00      	cmp	r3, #0
 8006508:	f000 8091 	beq.w	800662e <uavcan_init+0x13e>
    if (!(instance = chCoreAlloc(sizeof(struct uavcan_instance_s)))) { goto fail; }
 800650c:	2074      	movs	r0, #116	; 0x74
 800650e:	f7ff ffc3 	bl	8006498 <chCoreAlloc.lto_priv.85>
 8006512:	61b8      	str	r0, [r7, #24]
 8006514:	69bb      	ldr	r3, [r7, #24]
 8006516:	2b00      	cmp	r3, #0
 8006518:	f000 8089 	beq.w	800662e <uavcan_init+0x13e>
    memset(instance, 0, sizeof(struct uavcan_instance_s));
 800651c:	69b8      	ldr	r0, [r7, #24]
 800651e:	2100      	movs	r1, #0
 8006520:	2274      	movs	r2, #116	; 0x74
 8006522:	f008 f853 	bl	800e5cc <memset>
    instance->can_instance = can_instance;
 8006526:	69bb      	ldr	r3, [r7, #24]
 8006528:	69fa      	ldr	r2, [r7, #28]
 800652a:	605a      	str	r2, [r3, #4]
    if (!(transfer_id_map_working_area = chCoreAlloc(UAVCAN_TRANSFER_ID_MAP_WORKING_AREA_SIZE))) { goto fail; }
 800652c:	2080      	movs	r0, #128	; 0x80
 800652e:	f7ff ffb3 	bl	8006498 <chCoreAlloc.lto_priv.85>
 8006532:	6178      	str	r0, [r7, #20]
 8006534:	697b      	ldr	r3, [r7, #20]
 8006536:	2b00      	cmp	r3, #0
 8006538:	d079      	beq.n	800662e <uavcan_init+0x13e>
    uavcan_transfer_id_map_init(&instance->transfer_id_map, UAVCAN_TRANSFER_ID_MAP_WORKING_AREA_SIZE, transfer_id_map_working_area);
 800653a:	69bb      	ldr	r3, [r7, #24]
 800653c:	3330      	adds	r3, #48	; 0x30
 800653e:	4618      	mov	r0, r3
 8006540:	2180      	movs	r1, #128	; 0x80
 8006542:	697a      	ldr	r2, [r7, #20]
 8006544:	f7fe ff24 	bl	8005390 <uavcan_transfer_id_map_init.lto_priv.99>
    if(!(instance->canard_memory_pool = chCoreAlloc(UAVCAN_CANARD_MEMORY_POOL_SIZE))) { goto fail; }
 8006548:	f44f 7040 	mov.w	r0, #768	; 0x300
 800654c:	f7ff ffa4 	bl	8006498 <chCoreAlloc.lto_priv.85>
 8006550:	4602      	mov	r2, r0
 8006552:	69bb      	ldr	r3, [r7, #24]
 8006554:	62da      	str	r2, [r3, #44]	; 0x2c
 8006556:	69bb      	ldr	r3, [r7, #24]
 8006558:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800655a:	2b00      	cmp	r3, #0
 800655c:	d067      	beq.n	800662e <uavcan_init+0x13e>
    canardInit(&instance->canard, instance->canard_memory_pool, UAVCAN_CANARD_MEMORY_POOL_SIZE, uavcan_on_transfer_rx, uavcan_should_accept_transfer, instance);
 800655e:	69bb      	ldr	r3, [r7, #24]
 8006560:	f103 0108 	add.w	r1, r3, #8
 8006564:	69bb      	ldr	r3, [r7, #24]
 8006566:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8006568:	4b34      	ldr	r3, [pc, #208]	; (800663c <uavcan_init+0x14c>)
 800656a:	9300      	str	r3, [sp, #0]
 800656c:	69bb      	ldr	r3, [r7, #24]
 800656e:	9301      	str	r3, [sp, #4]
 8006570:	4608      	mov	r0, r1
 8006572:	4611      	mov	r1, r2
 8006574:	f44f 7240 	mov.w	r2, #768	; 0x300
 8006578:	4b31      	ldr	r3, [pc, #196]	; (8006640 <uavcan_init+0x150>)
 800657a:	f006 fa4b 	bl	800ca14 <canardInit>
    struct pubsub_topic_s* can_rx_topic = can_get_rx_topic(instance->can_instance);
 800657e:	69bb      	ldr	r3, [r7, #24]
 8006580:	685b      	ldr	r3, [r3, #4]
 8006582:	4618      	mov	r0, r3
 8006584:	f001 fa42 	bl	8007a0c <can_get_rx_topic>
 8006588:	6138      	str	r0, [r7, #16]
    if (!can_rx_topic) { goto fail; }
 800658a:	693b      	ldr	r3, [r7, #16]
 800658c:	2b00      	cmp	r3, #0
 800658e:	d04e      	beq.n	800662e <uavcan_init+0x13e>
    worker_thread_add_listener_task(&WT_RX, &instance->rx_listener_task, can_rx_topic, uavcan_can_rx_handler, instance); // TODO configurable thread
 8006590:	69bb      	ldr	r3, [r7, #24]
 8006592:	f103 0238 	add.w	r2, r3, #56	; 0x38
 8006596:	69bb      	ldr	r3, [r7, #24]
 8006598:	9300      	str	r3, [sp, #0]
 800659a:	482a      	ldr	r0, [pc, #168]	; (8006644 <uavcan_init+0x154>)
 800659c:	4611      	mov	r1, r2
 800659e:	693a      	ldr	r2, [r7, #16]
 80065a0:	4b29      	ldr	r3, [pc, #164]	; (8006648 <uavcan_init+0x158>)
 80065a2:	f002 fa95 	bl	8008ad0 <worker_thread_add_listener_task>

    can_set_auto_retransmit_mode(instance->can_instance, false);
 80065a6:	69bb      	ldr	r3, [r7, #24]
 80065a8:	685b      	ldr	r3, [r3, #4]
 80065aa:	4618      	mov	r0, r3
 80065ac:	2100      	movs	r1, #0
 80065ae:	f001 fa67 	bl	8007a80 <can_set_auto_retransmit_mode>

    LINKED_LIST_APPEND(struct uavcan_instance_s, uavcan_instance_list_head, instance);
 80065b2:	69bb      	ldr	r3, [r7, #24]
 80065b4:	2200      	movs	r2, #0
 80065b6:	671a      	str	r2, [r3, #112]	; 0x70
 80065b8:	4b24      	ldr	r3, [pc, #144]	; (800664c <uavcan_init+0x15c>)
 80065ba:	627b      	str	r3, [r7, #36]	; 0x24
 80065bc:	e003      	b.n	80065c6 <uavcan_init+0xd6>
 80065be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80065c0:	681b      	ldr	r3, [r3, #0]
 80065c2:	3370      	adds	r3, #112	; 0x70
 80065c4:	627b      	str	r3, [r7, #36]	; 0x24
 80065c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80065c8:	681b      	ldr	r3, [r3, #0]
 80065ca:	2b00      	cmp	r3, #0
 80065cc:	d1f7      	bne.n	80065be <uavcan_init+0xce>
 80065ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80065d0:	69ba      	ldr	r2, [r7, #24]
 80065d2:	601a      	str	r2, [r3, #0]

    instance->idx = uavcan_get_idx(instance);
 80065d4:	69b8      	ldr	r0, [r7, #24]
 80065d6:	f7fe fdb3 	bl	8005140 <uavcan_get_idx.lto_priv.98>
 80065da:	4603      	mov	r3, r0
 80065dc:	461a      	mov	r2, r3
 80065de:	69bb      	ldr	r3, [r7, #24]
 80065e0:	701a      	strb	r2, [r3, #0]

    uint8_t node_id = 0;
 80065e2:	2300      	movs	r3, #0
 80065e4:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

#ifdef MODULE_APP_DESCRIPTOR_ENABLED
    {
        const struct shared_app_parameters_s* shared_parameters = shared_get_parameters(&shared_app_descriptor);
 80065e8:	4819      	ldr	r0, [pc, #100]	; (8006650 <uavcan_init+0x160>)
 80065ea:	f003 fac1 	bl	8009b70 <shared_get_parameters>
 80065ee:	60f8      	str	r0, [r7, #12]
        if (shared_parameters && shared_parameters->canbus_local_node_id > 0 && shared_parameters->canbus_local_node_id <= 127) {
 80065f0:	68fb      	ldr	r3, [r7, #12]
 80065f2:	2b00      	cmp	r3, #0
 80065f4:	d00d      	beq.n	8006612 <uavcan_init+0x122>
 80065f6:	68fb      	ldr	r3, [r7, #12]
 80065f8:	799b      	ldrb	r3, [r3, #6]
 80065fa:	2b00      	cmp	r3, #0
 80065fc:	d009      	beq.n	8006612 <uavcan_init+0x122>
 80065fe:	68fb      	ldr	r3, [r7, #12]
 8006600:	799b      	ldrb	r3, [r3, #6]
 8006602:	b2db      	uxtb	r3, r3
 8006604:	b25b      	sxtb	r3, r3
 8006606:	2b00      	cmp	r3, #0
 8006608:	db03      	blt.n	8006612 <uavcan_init+0x122>
            node_id = shared_parameters->canbus_local_node_id;
 800660a:	68fb      	ldr	r3, [r7, #12]
 800660c:	799b      	ldrb	r3, [r3, #6]
 800660e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    if (node_id_param != 0) {
        node_id = node_id_param;
    }
#endif

    _uavcan_set_node_id(instance, node_id);
 8006612:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8006616:	69b8      	ldr	r0, [r7, #24]
 8006618:	4619      	mov	r1, r3
 800661a:	f7fe fa01 	bl	8004a20 <_uavcan_set_node_id.lto_priv.97>

    /* debug message */
    chnWrite(&SD1, (const uint8_t *)"uavcan_init complete\n", 24);
 800661e:	4b0d      	ldr	r3, [pc, #52]	; (8006654 <uavcan_init+0x164>)
 8006620:	681b      	ldr	r3, [r3, #0]
 8006622:	681b      	ldr	r3, [r3, #0]
 8006624:	480b      	ldr	r0, [pc, #44]	; (8006654 <uavcan_init+0x164>)
 8006626:	490c      	ldr	r1, [pc, #48]	; (8006658 <uavcan_init+0x168>)
 8006628:	2218      	movs	r2, #24
 800662a:	4798      	blx	r3
 800662c:	e002      	b.n	8006634 <uavcan_init+0x144>

    return;

fail:
    chSysHalt(NULL);
 800662e:	2000      	movs	r0, #0
 8006630:	f004 fbe6 	bl	800ae00 <chSysHalt>
}
 8006634:	3728      	adds	r7, #40	; 0x28
 8006636:	46bd      	mov	sp, r7
 8006638:	bd80      	pop	{r7, pc}
 800663a:	bf00      	nop
 800663c:	08005305 	.word	0x08005305
 8006640:	08005271 	.word	0x08005271
 8006644:	20000a3c 	.word	0x20000a3c
 8006648:	08005039 	.word	0x08005039
 800664c:	2000149c 	.word	0x2000149c
 8006650:	08003160 	.word	0x08003160
 8006654:	200013ac 	.word	0x200013ac
 8006658:	0800e644 	.word	0x0800e644

0800665c <uavcan_iterate_instances.lto_priv.75>:

static bool uavcan_iterate_instances(struct uavcan_instance_s** instance_ptr) {
 800665c:	b480      	push	{r7}
 800665e:	b083      	sub	sp, #12
 8006660:	af00      	add	r7, sp, #0
 8006662:	6078      	str	r0, [r7, #4]
    if (!instance_ptr) {
 8006664:	687b      	ldr	r3, [r7, #4]
 8006666:	2b00      	cmp	r3, #0
 8006668:	d101      	bne.n	800666e <uavcan_iterate_instances.lto_priv.75+0x12>
        return false;
 800666a:	2300      	movs	r3, #0
 800666c:	e014      	b.n	8006698 <uavcan_iterate_instances.lto_priv.75+0x3c>
    }

    if (!(*instance_ptr)) {
 800666e:	687b      	ldr	r3, [r7, #4]
 8006670:	681b      	ldr	r3, [r3, #0]
 8006672:	2b00      	cmp	r3, #0
 8006674:	d104      	bne.n	8006680 <uavcan_iterate_instances.lto_priv.75+0x24>
        *instance_ptr = uavcan_instance_list_head;
 8006676:	4b0b      	ldr	r3, [pc, #44]	; (80066a4 <uavcan_iterate_instances.lto_priv.75+0x48>)
 8006678:	681a      	ldr	r2, [r3, #0]
 800667a:	687b      	ldr	r3, [r7, #4]
 800667c:	601a      	str	r2, [r3, #0]
 800667e:	e004      	b.n	800668a <uavcan_iterate_instances.lto_priv.75+0x2e>
    } else {
        *instance_ptr = (*instance_ptr)->next;
 8006680:	687b      	ldr	r3, [r7, #4]
 8006682:	681b      	ldr	r3, [r3, #0]
 8006684:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8006686:	687b      	ldr	r3, [r7, #4]
 8006688:	601a      	str	r2, [r3, #0]
    }

    return *instance_ptr != NULL;
 800668a:	687b      	ldr	r3, [r7, #4]
 800668c:	681b      	ldr	r3, [r3, #0]
 800668e:	2b00      	cmp	r3, #0
 8006690:	bf14      	ite	ne
 8006692:	2301      	movne	r3, #1
 8006694:	2300      	moveq	r3, #0
 8006696:	b2db      	uxtb	r3, r3
}
 8006698:	4618      	mov	r0, r3
 800669a:	370c      	adds	r7, #12
 800669c:	46bd      	mov	sp, r7
 800669e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80066a2:	4770      	bx	lr
 80066a4:	2000149c 	.word	0x2000149c

080066a8 <_uavcan_get_message_topic>:

static struct pubsub_topic_s* _uavcan_get_message_topic(struct uavcan_instance_s* instance, const struct uavcan_message_descriptor_s* msg_descriptor) {
 80066a8:	b580      	push	{r7, lr}
 80066aa:	b084      	sub	sp, #16
 80066ac:	af00      	add	r7, sp, #0
 80066ae:	6078      	str	r0, [r7, #4]
 80066b0:	6039      	str	r1, [r7, #0]
    if (!instance) {
 80066b2:	687b      	ldr	r3, [r7, #4]
 80066b4:	2b00      	cmp	r3, #0
 80066b6:	d101      	bne.n	80066bc <_uavcan_get_message_topic+0x14>
        return NULL;
 80066b8:	2300      	movs	r3, #0
 80066ba:	e042      	b.n	8006742 <_uavcan_get_message_topic+0x9a>
    }

    chSysLock();
 80066bc:	f7ff fe56 	bl	800636c <chSysLock.lto_priv.77>

    // attempt to find existing item in receive list
    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
 80066c0:	687b      	ldr	r3, [r7, #4]
 80066c2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80066c4:	60fb      	str	r3, [r7, #12]
 80066c6:	e002      	b.n	80066ce <_uavcan_get_message_topic+0x26>
    while (rx_list_item && rx_list_item->msg_descriptor != msg_descriptor) {
        rx_list_item = rx_list_item->next;
 80066c8:	68fb      	ldr	r3, [r7, #12]
 80066ca:	691b      	ldr	r3, [r3, #16]
 80066cc:	60fb      	str	r3, [r7, #12]

    chSysLock();

    // attempt to find existing item in receive list
    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
    while (rx_list_item && rx_list_item->msg_descriptor != msg_descriptor) {
 80066ce:	68fb      	ldr	r3, [r7, #12]
 80066d0:	2b00      	cmp	r3, #0
 80066d2:	d004      	beq.n	80066de <_uavcan_get_message_topic+0x36>
 80066d4:	68fb      	ldr	r3, [r7, #12]
 80066d6:	681a      	ldr	r2, [r3, #0]
 80066d8:	683b      	ldr	r3, [r7, #0]
 80066da:	429a      	cmp	r2, r3
 80066dc:	d1f4      	bne.n	80066c8 <_uavcan_get_message_topic+0x20>
        rx_list_item = rx_list_item->next;
    }

    if (rx_list_item) {
 80066de:	68fb      	ldr	r3, [r7, #12]
 80066e0:	2b00      	cmp	r3, #0
 80066e2:	d004      	beq.n	80066ee <_uavcan_get_message_topic+0x46>
        chSysUnlock();
 80066e4:	f7ff fe4a 	bl	800637c <chSysUnlock.lto_priv.76>
        return &rx_list_item->topic;
 80066e8:	68fb      	ldr	r3, [r7, #12]
 80066ea:	3304      	adds	r3, #4
 80066ec:	e029      	b.n	8006742 <_uavcan_get_message_topic+0x9a>
    }

    // create new item in receive list
    rx_list_item = chPoolAllocI(&rx_list_pool);
 80066ee:	4817      	ldr	r0, [pc, #92]	; (800674c <_uavcan_get_message_topic+0xa4>)
 80066f0:	f003 fc44 	bl	8009f7c <chPoolAllocI>
 80066f4:	60f8      	str	r0, [r7, #12]
    if (!rx_list_item) {
 80066f6:	68fb      	ldr	r3, [r7, #12]
 80066f8:	2b00      	cmp	r3, #0
 80066fa:	d103      	bne.n	8006704 <_uavcan_get_message_topic+0x5c>
        chSysUnlock();
 80066fc:	f7ff fe3e 	bl	800637c <chSysUnlock.lto_priv.76>
        return NULL;
 8006700:	2300      	movs	r3, #0
 8006702:	e01e      	b.n	8006742 <_uavcan_get_message_topic+0x9a>
    }

    // populate it
    rx_list_item->msg_descriptor = msg_descriptor;
 8006704:	68fb      	ldr	r3, [r7, #12]
 8006706:	683a      	ldr	r2, [r7, #0]
 8006708:	601a      	str	r2, [r3, #0]
    pubsub_init_topic(&rx_list_item->topic, NULL);
 800670a:	68fb      	ldr	r3, [r7, #12]
 800670c:	3304      	adds	r3, #4
 800670e:	4618      	mov	r0, r3
 8006710:	2100      	movs	r1, #0
 8006712:	f001 fd8d 	bl	8008230 <pubsub_init_topic>

    // append it
    LINKED_LIST_APPEND(struct uavcan_rx_list_item_s, instance->rx_list_head, rx_list_item);
 8006716:	68fb      	ldr	r3, [r7, #12]
 8006718:	2200      	movs	r2, #0
 800671a:	611a      	str	r2, [r3, #16]
 800671c:	687b      	ldr	r3, [r7, #4]
 800671e:	336c      	adds	r3, #108	; 0x6c
 8006720:	60bb      	str	r3, [r7, #8]
 8006722:	e003      	b.n	800672c <_uavcan_get_message_topic+0x84>
 8006724:	68bb      	ldr	r3, [r7, #8]
 8006726:	681b      	ldr	r3, [r3, #0]
 8006728:	3310      	adds	r3, #16
 800672a:	60bb      	str	r3, [r7, #8]
 800672c:	68bb      	ldr	r3, [r7, #8]
 800672e:	681b      	ldr	r3, [r3, #0]
 8006730:	2b00      	cmp	r3, #0
 8006732:	d1f7      	bne.n	8006724 <_uavcan_get_message_topic+0x7c>
 8006734:	68bb      	ldr	r3, [r7, #8]
 8006736:	68fa      	ldr	r2, [r7, #12]
 8006738:	601a      	str	r2, [r3, #0]

    chSysUnlock();
 800673a:	f7ff fe1f 	bl	800637c <chSysUnlock.lto_priv.76>

    return &rx_list_item->topic;
 800673e:	68fb      	ldr	r3, [r7, #12]
 8006740:	3304      	adds	r3, #4
}
 8006742:	4618      	mov	r0, r3
 8006744:	3710      	adds	r7, #16
 8006746:	46bd      	mov	sp, r7
 8006748:	bd80      	pop	{r7, pc}
 800674a:	bf00      	nop
 800674c:	20000a0c 	.word	0x20000a0c

08006750 <uavcan_get_message_topic>:

struct pubsub_topic_s* uavcan_get_message_topic(uint8_t uavcan_idx, const struct uavcan_message_descriptor_s* msg_descriptor) {
 8006750:	b580      	push	{r7, lr}
 8006752:	b082      	sub	sp, #8
 8006754:	af00      	add	r7, sp, #0
 8006756:	4603      	mov	r3, r0
 8006758:	6039      	str	r1, [r7, #0]
 800675a:	71fb      	strb	r3, [r7, #7]
    return _uavcan_get_message_topic(uavcan_get_instance(uavcan_idx), msg_descriptor);
 800675c:	79fb      	ldrb	r3, [r7, #7]
 800675e:	4618      	mov	r0, r3
 8006760:	f7fe fcae 	bl	80050c0 <uavcan_get_instance.lto_priv.96>
 8006764:	4603      	mov	r3, r0
 8006766:	4618      	mov	r0, r3
 8006768:	6839      	ldr	r1, [r7, #0]
 800676a:	f7ff ff9d 	bl	80066a8 <_uavcan_get_message_topic>
 800676e:	4603      	mov	r3, r0
}
 8006770:	4618      	mov	r0, r3
 8006772:	3708      	adds	r7, #8
 8006774:	46bd      	mov	sp, r7
 8006776:	bd80      	pop	{r7, pc}

08006778 <_uavcan_get_message_data_type_id.lto_priv.74>:

static uint16_t _uavcan_get_message_data_type_id(struct uavcan_instance_s* instance, const struct uavcan_message_descriptor_s* msg_descriptor) {
 8006778:	b480      	push	{r7}
 800677a:	b083      	sub	sp, #12
 800677c:	af00      	add	r7, sp, #0
 800677e:	6078      	str	r0, [r7, #4]
 8006780:	6039      	str	r1, [r7, #0]
    (void)instance;

    if (msg_descriptor) {
 8006782:	683b      	ldr	r3, [r7, #0]
 8006784:	2b00      	cmp	r3, #0
 8006786:	d002      	beq.n	800678e <_uavcan_get_message_data_type_id.lto_priv.74+0x16>
        return msg_descriptor->default_data_type_id;
 8006788:	683b      	ldr	r3, [r7, #0]
 800678a:	891b      	ldrh	r3, [r3, #8]
 800678c:	e000      	b.n	8006790 <_uavcan_get_message_data_type_id.lto_priv.74+0x18>
    } else {
        return 0;
 800678e:	2300      	movs	r3, #0
    }
}
 8006790:	4618      	mov	r0, r3
 8006792:	370c      	adds	r7, #12
 8006794:	46bd      	mov	sp, r7
 8006796:	f85d 7b04 	ldr.w	r7, [sp], #4
 800679a:	4770      	bx	lr

0800679c <_uavcan_get_node_id.lto_priv.78>:

uint16_t uavcan_get_message_data_type_id(uint8_t uavcan_idx, const struct uavcan_message_descriptor_s* msg_descriptor) {
    return _uavcan_get_message_data_type_id(uavcan_get_instance(uavcan_idx), msg_descriptor);
}

static uint8_t _uavcan_get_node_id(struct uavcan_instance_s* instance) {
 800679c:	b580      	push	{r7, lr}
 800679e:	b084      	sub	sp, #16
 80067a0:	af00      	add	r7, sp, #0
 80067a2:	6078      	str	r0, [r7, #4]
    if (!instance) {
 80067a4:	687b      	ldr	r3, [r7, #4]
 80067a6:	2b00      	cmp	r3, #0
 80067a8:	d101      	bne.n	80067ae <_uavcan_get_node_id.lto_priv.78+0x12>
        return 0;
 80067aa:	2300      	movs	r3, #0
 80067ac:	e00b      	b.n	80067c6 <_uavcan_get_node_id.lto_priv.78+0x2a>
    }

    chSysLock();
 80067ae:	f7ff fddd 	bl	800636c <chSysLock.lto_priv.77>
    uint8_t ret = canardGetLocalNodeID(&instance->canard);
 80067b2:	687b      	ldr	r3, [r7, #4]
 80067b4:	3308      	adds	r3, #8
 80067b6:	4618      	mov	r0, r3
 80067b8:	f006 f988 	bl	800cacc <canardGetLocalNodeID>
 80067bc:	4603      	mov	r3, r0
 80067be:	73fb      	strb	r3, [r7, #15]
    chSysUnlock();
 80067c0:	f7ff fddc 	bl	800637c <chSysUnlock.lto_priv.76>
    return ret;
 80067c4:	7bfb      	ldrb	r3, [r7, #15]
}
 80067c6:	4618      	mov	r0, r3
 80067c8:	3710      	adds	r7, #16
 80067ca:	46bd      	mov	sp, r7
 80067cc:	bd80      	pop	{r7, pc}
 80067ce:	bf00      	nop

080067d0 <uavcan_get_node_id>:

uint8_t uavcan_get_node_id(uint8_t uavcan_idx) {
 80067d0:	b580      	push	{r7, lr}
 80067d2:	b082      	sub	sp, #8
 80067d4:	af00      	add	r7, sp, #0
 80067d6:	4603      	mov	r3, r0
 80067d8:	71fb      	strb	r3, [r7, #7]
    return _uavcan_get_node_id(uavcan_get_instance(uavcan_idx));
 80067da:	79fb      	ldrb	r3, [r7, #7]
 80067dc:	4618      	mov	r0, r3
 80067de:	f7fe fc6f 	bl	80050c0 <uavcan_get_instance.lto_priv.96>
 80067e2:	4603      	mov	r3, r0
 80067e4:	4618      	mov	r0, r3
 80067e6:	f7ff ffd9 	bl	800679c <_uavcan_get_node_id.lto_priv.78>
 80067ea:	4603      	mov	r3, r0
}
 80067ec:	4618      	mov	r0, r3
 80067ee:	3708      	adds	r7, #8
 80067f0:	46bd      	mov	sp, r7
 80067f2:	bd80      	pop	{r7, pc}

080067f4 <worker_thread_remove_listener_task>:

    // Wake worker thread to process tasks
    worker_thread_wake(worker_thread);
}

void worker_thread_remove_listener_task(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* task) {
 80067f4:	b580      	push	{r7, lr}
 80067f6:	b084      	sub	sp, #16
 80067f8:	af00      	add	r7, sp, #0
 80067fa:	6078      	str	r0, [r7, #4]
 80067fc:	6039      	str	r1, [r7, #0]
    pubsub_listener_unregister(&task->listener);
 80067fe:	683b      	ldr	r3, [r7, #0]
 8006800:	4618      	mov	r0, r3
 8006802:	f001 fd77 	bl	80082f4 <pubsub_listener_unregister>

    chSysLock();
 8006806:	f001 ffad 	bl	8008764 <chSysLock.lto_priv.125>
    LINKED_LIST_REMOVE(struct worker_thread_listener_task_s, worker_thread->listener_task_list_head, task);
 800680a:	687b      	ldr	r3, [r7, #4]
 800680c:	3314      	adds	r3, #20
 800680e:	60fb      	str	r3, [r7, #12]
 8006810:	e003      	b.n	800681a <worker_thread_remove_listener_task+0x26>
 8006812:	68fb      	ldr	r3, [r7, #12]
 8006814:	681b      	ldr	r3, [r3, #0]
 8006816:	3330      	adds	r3, #48	; 0x30
 8006818:	60fb      	str	r3, [r7, #12]
 800681a:	68fb      	ldr	r3, [r7, #12]
 800681c:	681b      	ldr	r3, [r3, #0]
 800681e:	2b00      	cmp	r3, #0
 8006820:	d004      	beq.n	800682c <worker_thread_remove_listener_task+0x38>
 8006822:	68fb      	ldr	r3, [r7, #12]
 8006824:	681a      	ldr	r2, [r3, #0]
 8006826:	683b      	ldr	r3, [r7, #0]
 8006828:	429a      	cmp	r2, r3
 800682a:	d1f2      	bne.n	8006812 <worker_thread_remove_listener_task+0x1e>
 800682c:	68fb      	ldr	r3, [r7, #12]
 800682e:	681b      	ldr	r3, [r3, #0]
 8006830:	2b00      	cmp	r3, #0
 8006832:	d004      	beq.n	800683e <worker_thread_remove_listener_task+0x4a>
 8006834:	68fb      	ldr	r3, [r7, #12]
 8006836:	681b      	ldr	r3, [r3, #0]
 8006838:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800683a:	68fb      	ldr	r3, [r7, #12]
 800683c:	601a      	str	r2, [r3, #0]
    chSysUnlock();
 800683e:	f001 ff99 	bl	8008774 <chSysUnlock.lto_priv.123>
}
 8006842:	3710      	adds	r7, #16
 8006844:	46bd      	mov	sp, r7
 8006846:	bd80      	pop	{r7, pc}

08006848 <worker_thread_add_publisher_task_I>:

void worker_thread_add_publisher_task_I(struct worker_thread_s* worker_thread, struct worker_thread_publisher_task_s* task, size_t msg_max_size, size_t msg_queue_depth) {
 8006848:	b590      	push	{r4, r7, lr}
 800684a:	b089      	sub	sp, #36	; 0x24
 800684c:	af00      	add	r7, sp, #0
 800684e:	60f8      	str	r0, [r7, #12]
 8006850:	60b9      	str	r1, [r7, #8]
 8006852:	607a      	str	r2, [r7, #4]
 8006854:	603b      	str	r3, [r7, #0]
    chDbgCheckClassI();
 8006856:	f004 fbb1 	bl	800afbc <chDbgCheckClassI>
    chDbgCheck(!worker_thread_publisher_task_is_registered_I(worker_thread, task));
 800685a:	68f8      	ldr	r0, [r7, #12]
 800685c:	68b9      	ldr	r1, [r7, #8]
 800685e:	f000 fa33 	bl	8006cc8 <worker_thread_publisher_task_is_registered_I>
 8006862:	4603      	mov	r3, r0
 8006864:	2b00      	cmp	r3, #0
 8006866:	d002      	beq.n	800686e <worker_thread_add_publisher_task_I+0x26>
 8006868:	4825      	ldr	r0, [pc, #148]	; (8006900 <worker_thread_add_publisher_task_I+0xb8>)
 800686a:	f004 fac9 	bl	800ae00 <chSysHalt>

    size_t mem_block_size = sizeof(struct worker_thread_publisher_msg_s)+msg_max_size;
 800686e:	687b      	ldr	r3, [r7, #4]
 8006870:	3308      	adds	r3, #8
 8006872:	617b      	str	r3, [r7, #20]

    task->msg_max_size = msg_max_size;
 8006874:	68bb      	ldr	r3, [r7, #8]
 8006876:	687a      	ldr	r2, [r7, #4]
 8006878:	601a      	str	r2, [r3, #0]
    chPoolObjectInit(&task->pool, mem_block_size, NULL);
 800687a:	68bb      	ldr	r3, [r7, #8]
 800687c:	3304      	adds	r3, #4
 800687e:	4618      	mov	r0, r3
 8006880:	6979      	ldr	r1, [r7, #20]
 8006882:	2200      	movs	r2, #0
 8006884:	f003 fb38 	bl	8009ef8 <chPoolObjectInit>
    chMBObjectInit(&task->mailbox, chCoreAllocI(sizeof(msg_t)*msg_queue_depth), msg_queue_depth);
 8006888:	68bb      	ldr	r3, [r7, #8]
 800688a:	f103 0410 	add.w	r4, r3, #16
 800688e:	683b      	ldr	r3, [r7, #0]
 8006890:	009b      	lsls	r3, r3, #2
 8006892:	4618      	mov	r0, r3
 8006894:	f001 ffce 	bl	8008834 <chCoreAllocI.lto_priv.135>
 8006898:	4602      	mov	r2, r0
 800689a:	683b      	ldr	r3, [r7, #0]
 800689c:	4620      	mov	r0, r4
 800689e:	4611      	mov	r1, r2
 80068a0:	461a      	mov	r2, r3
 80068a2:	f004 fa37 	bl	800ad14 <chMBObjectInit>
    task->worker_thread = worker_thread;
 80068a6:	68bb      	ldr	r3, [r7, #8]
 80068a8:	68fa      	ldr	r2, [r7, #12]
 80068aa:	639a      	str	r2, [r3, #56]	; 0x38

    for (size_t i = 0; i < msg_queue_depth; i++) {
 80068ac:	2300      	movs	r3, #0
 80068ae:	61fb      	str	r3, [r7, #28]
 80068b0:	e00c      	b.n	80068cc <worker_thread_add_publisher_task_I+0x84>
        chPoolAddI(&task->pool, chCoreAllocI(mem_block_size));
 80068b2:	68bb      	ldr	r3, [r7, #8]
 80068b4:	1d1c      	adds	r4, r3, #4
 80068b6:	6978      	ldr	r0, [r7, #20]
 80068b8:	f001 ffbc 	bl	8008834 <chCoreAllocI.lto_priv.135>
 80068bc:	4603      	mov	r3, r0
 80068be:	4620      	mov	r0, r4
 80068c0:	4619      	mov	r1, r3
 80068c2:	f001 ffc5 	bl	8008850 <chPoolAddI.lto_priv.134>
    task->msg_max_size = msg_max_size;
    chPoolObjectInit(&task->pool, mem_block_size, NULL);
    chMBObjectInit(&task->mailbox, chCoreAllocI(sizeof(msg_t)*msg_queue_depth), msg_queue_depth);
    task->worker_thread = worker_thread;

    for (size_t i = 0; i < msg_queue_depth; i++) {
 80068c6:	69fb      	ldr	r3, [r7, #28]
 80068c8:	3301      	adds	r3, #1
 80068ca:	61fb      	str	r3, [r7, #28]
 80068cc:	69fa      	ldr	r2, [r7, #28]
 80068ce:	683b      	ldr	r3, [r7, #0]
 80068d0:	429a      	cmp	r2, r3
 80068d2:	d3ee      	bcc.n	80068b2 <worker_thread_add_publisher_task_I+0x6a>
        chPoolAddI(&task->pool, chCoreAllocI(mem_block_size));
    }

    LINKED_LIST_APPEND(struct worker_thread_publisher_task_s, worker_thread->publisher_task_list_head, task);
 80068d4:	68bb      	ldr	r3, [r7, #8]
 80068d6:	2200      	movs	r2, #0
 80068d8:	63da      	str	r2, [r3, #60]	; 0x3c
 80068da:	68fb      	ldr	r3, [r7, #12]
 80068dc:	3318      	adds	r3, #24
 80068de:	61bb      	str	r3, [r7, #24]
 80068e0:	e003      	b.n	80068ea <worker_thread_add_publisher_task_I+0xa2>
 80068e2:	69bb      	ldr	r3, [r7, #24]
 80068e4:	681b      	ldr	r3, [r3, #0]
 80068e6:	333c      	adds	r3, #60	; 0x3c
 80068e8:	61bb      	str	r3, [r7, #24]
 80068ea:	69bb      	ldr	r3, [r7, #24]
 80068ec:	681b      	ldr	r3, [r3, #0]
 80068ee:	2b00      	cmp	r3, #0
 80068f0:	d1f7      	bne.n	80068e2 <worker_thread_add_publisher_task_I+0x9a>
 80068f2:	69bb      	ldr	r3, [r7, #24]
 80068f4:	68ba      	ldr	r2, [r7, #8]
 80068f6:	601a      	str	r2, [r3, #0]
}
 80068f8:	3724      	adds	r7, #36	; 0x24
 80068fa:	46bd      	mov	sp, r7
 80068fc:	bd90      	pop	{r4, r7, pc}
 80068fe:	bf00      	nop
 8006900:	0800ebc4 	.word	0x0800ebc4

08006904 <worker_thread_add_publisher_task>:

void worker_thread_add_publisher_task(struct worker_thread_s* worker_thread, struct worker_thread_publisher_task_s* task, size_t msg_max_size, size_t msg_queue_depth) {
 8006904:	b580      	push	{r7, lr}
 8006906:	b084      	sub	sp, #16
 8006908:	af00      	add	r7, sp, #0
 800690a:	60f8      	str	r0, [r7, #12]
 800690c:	60b9      	str	r1, [r7, #8]
 800690e:	607a      	str	r2, [r7, #4]
 8006910:	603b      	str	r3, [r7, #0]
    chSysLock();
 8006912:	f001 ff27 	bl	8008764 <chSysLock.lto_priv.125>
    worker_thread_add_publisher_task_I(worker_thread, task, msg_max_size, msg_queue_depth);
 8006916:	68f8      	ldr	r0, [r7, #12]
 8006918:	68b9      	ldr	r1, [r7, #8]
 800691a:	687a      	ldr	r2, [r7, #4]
 800691c:	683b      	ldr	r3, [r7, #0]
 800691e:	f7ff ff93 	bl	8006848 <worker_thread_add_publisher_task_I>
    chSysUnlock();
 8006922:	f001 ff27 	bl	8008774 <chSysUnlock.lto_priv.123>
}
 8006926:	3710      	adds	r7, #16
 8006928:	46bd      	mov	sp, r7
 800692a:	bd80      	pop	{r7, pc}

0800692c <worker_thread_publisher_task_publish_I>:
    chSysLock();
    LINKED_LIST_REMOVE(struct worker_thread_publisher_task_s, worker_thread->publisher_task_list_head, task);
    chSysUnlock();
}

bool worker_thread_publisher_task_publish_I(struct worker_thread_publisher_task_s* task, struct pubsub_topic_s* topic, size_t size, pubsub_message_writer_func_ptr writer_cb, void* ctx) {
 800692c:	b580      	push	{r7, lr}
 800692e:	b086      	sub	sp, #24
 8006930:	af00      	add	r7, sp, #0
 8006932:	60f8      	str	r0, [r7, #12]
 8006934:	60b9      	str	r1, [r7, #8]
 8006936:	607a      	str	r2, [r7, #4]
 8006938:	603b      	str	r3, [r7, #0]
    chDbgCheckClassI();
 800693a:	f004 fb3f 	bl	800afbc <chDbgCheckClassI>

    if (size > task->msg_max_size) {
 800693e:	68fb      	ldr	r3, [r7, #12]
 8006940:	681a      	ldr	r2, [r3, #0]
 8006942:	687b      	ldr	r3, [r7, #4]
 8006944:	429a      	cmp	r2, r3
 8006946:	d201      	bcs.n	800694c <worker_thread_publisher_task_publish_I+0x20>
        return false;
 8006948:	2300      	movs	r3, #0
 800694a:	e02c      	b.n	80069a6 <worker_thread_publisher_task_publish_I+0x7a>
    }

    struct worker_thread_publisher_msg_s* msg = chPoolAllocI(&task->pool);
 800694c:	68fb      	ldr	r3, [r7, #12]
 800694e:	3304      	adds	r3, #4
 8006950:	4618      	mov	r0, r3
 8006952:	f003 fb13 	bl	8009f7c <chPoolAllocI>
 8006956:	6178      	str	r0, [r7, #20]

    if (!msg || !topic) {
 8006958:	697b      	ldr	r3, [r7, #20]
 800695a:	2b00      	cmp	r3, #0
 800695c:	d002      	beq.n	8006964 <worker_thread_publisher_task_publish_I+0x38>
 800695e:	68bb      	ldr	r3, [r7, #8]
 8006960:	2b00      	cmp	r3, #0
 8006962:	d101      	bne.n	8006968 <worker_thread_publisher_task_publish_I+0x3c>
        return false;
 8006964:	2300      	movs	r3, #0
 8006966:	e01e      	b.n	80069a6 <worker_thread_publisher_task_publish_I+0x7a>
    }

    msg->topic = topic;
 8006968:	697b      	ldr	r3, [r7, #20]
 800696a:	68ba      	ldr	r2, [r7, #8]
 800696c:	601a      	str	r2, [r3, #0]
    msg->size = size;
 800696e:	697b      	ldr	r3, [r7, #20]
 8006970:	687a      	ldr	r2, [r7, #4]
 8006972:	605a      	str	r2, [r3, #4]

    if (writer_cb) {
 8006974:	683b      	ldr	r3, [r7, #0]
 8006976:	2b00      	cmp	r3, #0
 8006978:	d007      	beq.n	800698a <worker_thread_publisher_task_publish_I+0x5e>
        writer_cb(size, msg->data, ctx);
 800697a:	697b      	ldr	r3, [r7, #20]
 800697c:	f103 0208 	add.w	r2, r3, #8
 8006980:	683b      	ldr	r3, [r7, #0]
 8006982:	6878      	ldr	r0, [r7, #4]
 8006984:	4611      	mov	r1, r2
 8006986:	6a3a      	ldr	r2, [r7, #32]
 8006988:	4798      	blx	r3
    }

    chMBPostI(&task->mailbox, (msg_t)msg);
 800698a:	68fb      	ldr	r3, [r7, #12]
 800698c:	f103 0210 	add.w	r2, r3, #16
 8006990:	697b      	ldr	r3, [r7, #20]
 8006992:	4610      	mov	r0, r2
 8006994:	4619      	mov	r1, r3
 8006996:	f004 f9f3 	bl	800ad80 <chMBPostI>

    worker_thread_wake_I(task->worker_thread);
 800699a:	68fb      	ldr	r3, [r7, #12]
 800699c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800699e:	4618      	mov	r0, r3
 80069a0:	f000 f8cc 	bl	8006b3c <worker_thread_wake_I.lto_priv.162>
    return true;
 80069a4:	2301      	movs	r3, #1
}
 80069a6:	4618      	mov	r0, r3
 80069a8:	3718      	adds	r7, #24
 80069aa:	46bd      	mov	sp, r7
 80069ac:	bd80      	pop	{r7, pc}
 80069ae:	bf00      	nop

080069b0 <worker_thread_takeover>:
#endif

void worker_thread_takeover(struct worker_thread_s* worker_thread) {
 80069b0:	b580      	push	{r7, lr}
 80069b2:	b088      	sub	sp, #32
 80069b4:	af00      	add	r7, sp, #0
 80069b6:	6078      	str	r0, [r7, #4]
    chRegSetThreadName(worker_thread->name);
 80069b8:	687b      	ldr	r3, [r7, #4]
 80069ba:	681b      	ldr	r3, [r3, #0]
 80069bc:	4618      	mov	r0, r3
 80069be:	f001 ff09 	bl	80087d4 <chRegSetThreadName.lto_priv.133>
    chThdSetPriority(worker_thread->priority);
 80069c2:	687b      	ldr	r3, [r7, #4]
 80069c4:	685b      	ldr	r3, [r3, #4]
 80069c6:	4618      	mov	r0, r3
 80069c8:	f003 fd60 	bl	800a48c <chThdSetPriority>
    worker_thread->thread = chThdGetSelfX();
 80069cc:	f001 fef6 	bl	80087bc <chThdGetSelfX.lto_priv.132>
 80069d0:	4602      	mov	r2, r0
 80069d2:	687b      	ldr	r3, [r7, #4]
 80069d4:	609a      	str	r2, [r3, #8]

    while (true) {
#ifdef MODULE_PUBSUB_ENABLED
        // Handle publisher tasks
        {
            chSysLock();
 80069d6:	f001 fec5 	bl	8008764 <chSysLock.lto_priv.125>
            struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
 80069da:	687b      	ldr	r3, [r7, #4]
 80069dc:	699b      	ldr	r3, [r3, #24]
 80069de:	61fb      	str	r3, [r7, #28]
            chSysUnlock();
 80069e0:	f001 fec8 	bl	8008774 <chSysUnlock.lto_priv.123>
 80069e4:	e025      	b.n	8006a32 <worker_thread_takeover+0x82>
            while (task) {
                struct worker_thread_publisher_msg_s* msg;
                while (chMBFetch(&task->mailbox, (msg_t*)&msg, TIME_IMMEDIATE) == MSG_OK) {
                    pubsub_publish_message(msg->topic, msg->size, pubsub_copy_writer_func, msg->data);
 80069e6:	68fb      	ldr	r3, [r7, #12]
 80069e8:	6819      	ldr	r1, [r3, #0]
 80069ea:	68fb      	ldr	r3, [r7, #12]
 80069ec:	685a      	ldr	r2, [r3, #4]
 80069ee:	68fb      	ldr	r3, [r7, #12]
 80069f0:	3308      	adds	r3, #8
 80069f2:	4608      	mov	r0, r1
 80069f4:	4611      	mov	r1, r2
 80069f6:	4a48      	ldr	r2, [pc, #288]	; (8006b18 <worker_thread_takeover+0x168>)
 80069f8:	f001 fd00 	bl	80083fc <pubsub_publish_message>
                    chPoolFree(&task->pool, msg);
 80069fc:	69fb      	ldr	r3, [r7, #28]
 80069fe:	1d1a      	adds	r2, r3, #4
 8006a00:	68fb      	ldr	r3, [r7, #12]
 8006a02:	4610      	mov	r0, r2
 8006a04:	4619      	mov	r1, r3
 8006a06:	f003 fb15 	bl	800a034 <chPoolFree>
            chSysLock();
            struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
            chSysUnlock();
            while (task) {
                struct worker_thread_publisher_msg_s* msg;
                while (chMBFetch(&task->mailbox, (msg_t*)&msg, TIME_IMMEDIATE) == MSG_OK) {
 8006a0a:	69fb      	ldr	r3, [r7, #28]
 8006a0c:	f103 0210 	add.w	r2, r3, #16
 8006a10:	f107 030c 	add.w	r3, r7, #12
 8006a14:	4610      	mov	r0, r2
 8006a16:	4619      	mov	r1, r3
 8006a18:	2200      	movs	r2, #0
 8006a1a:	f003 f8f9 	bl	8009c10 <chMBFetch>
 8006a1e:	4603      	mov	r3, r0
 8006a20:	2b00      	cmp	r3, #0
 8006a22:	d0e0      	beq.n	80069e6 <worker_thread_takeover+0x36>
                    pubsub_publish_message(msg->topic, msg->size, pubsub_copy_writer_func, msg->data);
                    chPoolFree(&task->pool, msg);
                }
                chSysLock();
 8006a24:	f001 fe9e 	bl	8008764 <chSysLock.lto_priv.125>
                task = task->next;
 8006a28:	69fb      	ldr	r3, [r7, #28]
 8006a2a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006a2c:	61fb      	str	r3, [r7, #28]
                chSysUnlock();
 8006a2e:	f001 fea1 	bl	8008774 <chSysUnlock.lto_priv.123>
        // Handle publisher tasks
        {
            chSysLock();
            struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
            chSysUnlock();
            while (task) {
 8006a32:	69fb      	ldr	r3, [r7, #28]
 8006a34:	2b00      	cmp	r3, #0
 8006a36:	d1e8      	bne.n	8006a0a <worker_thread_takeover+0x5a>
            }
        }

        // Check for immediately available messages on listener tasks, handle one
        {
            chSysLock();
 8006a38:	f001 fe94 	bl	8008764 <chSysLock.lto_priv.125>
            struct worker_thread_listener_task_s* listener_task = worker_thread->listener_task_list_head;
 8006a3c:	687b      	ldr	r3, [r7, #4]
 8006a3e:	695b      	ldr	r3, [r3, #20]
 8006a40:	61bb      	str	r3, [r7, #24]
            chSysUnlock();
 8006a42:	f001 fe97 	bl	8008774 <chSysUnlock.lto_priv.123>
 8006a46:	e00e      	b.n	8006a66 <worker_thread_takeover+0xb6>
            while (listener_task) {
                if (pubsub_listener_handle_one_timeout(&listener_task->listener, TIME_IMMEDIATE)) {
 8006a48:	69bb      	ldr	r3, [r7, #24]
 8006a4a:	4618      	mov	r0, r3
 8006a4c:	2100      	movs	r1, #0
 8006a4e:	f001 fd61 	bl	8008514 <pubsub_listener_handle_one_timeout>
 8006a52:	4603      	mov	r3, r0
 8006a54:	2b00      	cmp	r3, #0
 8006a56:	d109      	bne.n	8006a6c <worker_thread_takeover+0xbc>
                    break;
                }
                chSysLock();
 8006a58:	f001 fe84 	bl	8008764 <chSysLock.lto_priv.125>
                listener_task = listener_task->next;
 8006a5c:	69bb      	ldr	r3, [r7, #24]
 8006a5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006a60:	61bb      	str	r3, [r7, #24]
                chSysUnlock();
 8006a62:	f001 fe87 	bl	8008774 <chSysUnlock.lto_priv.123>
        // Check for immediately available messages on listener tasks, handle one
        {
            chSysLock();
            struct worker_thread_listener_task_s* listener_task = worker_thread->listener_task_list_head;
            chSysUnlock();
            while (listener_task) {
 8006a66:	69bb      	ldr	r3, [r7, #24]
 8006a68:	2b00      	cmp	r3, #0
 8006a6a:	d1ed      	bne.n	8006a48 <worker_thread_takeover+0x98>
                listener_task = listener_task->next;
                chSysUnlock();
            }
        }
#endif
        chSysLock();
 8006a6c:	f001 fe7a 	bl	8008764 <chSysLock.lto_priv.125>
        systime_t tnow_ticks = chVTGetSystemTimeX();
 8006a70:	f001 fe9c 	bl	80087ac <chVTGetSystemTimeX.lto_priv.116>
 8006a74:	4603      	mov	r3, r0
 8006a76:	82fb      	strh	r3, [r7, #22]
        systime_t ticks_to_next_timer_task = worker_thread_get_ticks_to_timer_task_I(worker_thread->timer_task_list_head, tnow_ticks);
 8006a78:	687b      	ldr	r3, [r7, #4]
 8006a7a:	691a      	ldr	r2, [r3, #16]
 8006a7c:	8afb      	ldrh	r3, [r7, #22]
 8006a7e:	4610      	mov	r0, r2
 8006a80:	4619      	mov	r1, r3
 8006a82:	f000 f8f7 	bl	8006c74 <worker_thread_get_ticks_to_timer_task_I>
 8006a86:	4603      	mov	r3, r0
 8006a88:	82bb      	strh	r3, [r7, #20]

        chSysUnlock();
 8006a8a:	f001 fe73 	bl	8008774 <chSysUnlock.lto_priv.123>
        uavcan_send_debug_msg(UAVCAN_PROTOCOL_DEBUG_LOGLEVEL_INFO, "", "rem_ticks: %u", ticks_to_next_timer_task);
 8006a8e:	8abb      	ldrh	r3, [r7, #20]
 8006a90:	2001      	movs	r0, #1
 8006a92:	4922      	ldr	r1, [pc, #136]	; (8006b1c <worker_thread_takeover+0x16c>)
 8006a94:	4a22      	ldr	r2, [pc, #136]	; (8006b20 <worker_thread_takeover+0x170>)
 8006a96:	f7fd fb41 	bl	800411c <uavcan_send_debug_msg>
        chSysLock();
 8006a9a:	f001 fe63 	bl	8008764 <chSysLock.lto_priv.125>

        if (ticks_to_next_timer_task == TIME_IMMEDIATE) {
 8006a9e:	8abb      	ldrh	r3, [r7, #20]
 8006aa0:	2b00      	cmp	r3, #0
 8006aa2:	d11c      	bne.n	8006ade <worker_thread_takeover+0x12e>
            // Task is due - pop the task off the task list, run it, reschedule if task is auto-repeat
            struct worker_thread_timer_task_s* next_timer_task = worker_thread->timer_task_list_head;
 8006aa4:	687b      	ldr	r3, [r7, #4]
 8006aa6:	691b      	ldr	r3, [r3, #16]
 8006aa8:	613b      	str	r3, [r7, #16]
            worker_thread->timer_task_list_head = next_timer_task->next;
 8006aaa:	693b      	ldr	r3, [r7, #16]
 8006aac:	691a      	ldr	r2, [r3, #16]
 8006aae:	687b      	ldr	r3, [r7, #4]
 8006ab0:	611a      	str	r2, [r3, #16]

            chSysUnlock();
 8006ab2:	f001 fe5f 	bl	8008774 <chSysUnlock.lto_priv.123>

            // Perform task
            next_timer_task->task_func(next_timer_task);
 8006ab6:	693b      	ldr	r3, [r7, #16]
 8006ab8:	681b      	ldr	r3, [r3, #0]
 8006aba:	6938      	ldr	r0, [r7, #16]
 8006abc:	4798      	blx	r3
            next_timer_task->timer_begin_systime = tnow_ticks;
 8006abe:	693b      	ldr	r3, [r7, #16]
 8006ac0:	8afa      	ldrh	r2, [r7, #22]
 8006ac2:	815a      	strh	r2, [r3, #10]

            if (next_timer_task->auto_repeat) {
 8006ac4:	693b      	ldr	r3, [r7, #16]
 8006ac6:	7b1b      	ldrb	r3, [r3, #12]
 8006ac8:	2b00      	cmp	r3, #0
 8006aca:	d084      	beq.n	80069d6 <worker_thread_takeover+0x26>
                // Re-insert task
                chSysLock();
 8006acc:	f001 fe4a 	bl	8008764 <chSysLock.lto_priv.125>
                worker_thread_insert_timer_task_I(worker_thread, next_timer_task);
 8006ad0:	6878      	ldr	r0, [r7, #4]
 8006ad2:	6939      	ldr	r1, [r7, #16]
 8006ad4:	f000 f88e 	bl	8006bf4 <worker_thread_insert_timer_task_I.lto_priv.163>
                chSysUnlock();
 8006ad8:	f001 fe4c 	bl	8008774 <chSysUnlock.lto_priv.123>
 8006adc:	e77b      	b.n	80069d6 <worker_thread_takeover+0x26>
            }
        } else {
#ifdef MODULE_PUBSUB_ENABLED
            // If a listener task is due, we should not sleep until we've handled it
            if (worker_thread_get_any_listener_task_due_I(worker_thread)) {
 8006ade:	6878      	ldr	r0, [r7, #4]
 8006ae0:	f000 f95e 	bl	8006da0 <worker_thread_get_any_listener_task_due_I>
 8006ae4:	4603      	mov	r3, r0
 8006ae6:	2b00      	cmp	r3, #0
 8006ae8:	d002      	beq.n	8006af0 <worker_thread_takeover+0x140>
                chSysUnlock();
 8006aea:	f001 fe43 	bl	8008774 <chSysUnlock.lto_priv.123>
 8006aee:	e772      	b.n	80069d6 <worker_thread_takeover+0x26>
                continue;
            }

            // If a publisher task is due, we should not sleep until we've handled it
            if (worker_thread_get_any_publisher_task_due_I(worker_thread)) {
 8006af0:	6878      	ldr	r0, [r7, #4]
 8006af2:	f000 f905 	bl	8006d00 <worker_thread_get_any_publisher_task_due_I>
 8006af6:	4603      	mov	r3, r0
 8006af8:	2b00      	cmp	r3, #0
 8006afa:	d002      	beq.n	8006b02 <worker_thread_takeover+0x152>
                chSysUnlock();
 8006afc:	f001 fe3a 	bl	8008774 <chSysUnlock.lto_priv.123>
 8006b00:	e769      	b.n	80069d6 <worker_thread_takeover+0x26>
                continue;
            }
#endif

            // No task due - go to sleep until there is a task
            chThdSuspendTimeoutS(&worker_thread->suspend_trp, ticks_to_next_timer_task);
 8006b02:	687b      	ldr	r3, [r7, #4]
 8006b04:	f103 020c 	add.w	r2, r3, #12
 8006b08:	8abb      	ldrh	r3, [r7, #20]
 8006b0a:	4610      	mov	r0, r2
 8006b0c:	4619      	mov	r1, r3
 8006b0e:	f003 fcf1 	bl	800a4f4 <chThdSuspendTimeoutS>

            chSysUnlock();
 8006b12:	f001 fe2f 	bl	8008774 <chSysUnlock.lto_priv.123>
 8006b16:	e75e      	b.n	80069d6 <worker_thread_takeover+0x26>
 8006b18:	0800836d 	.word	0x0800836d
 8006b1c:	0800e65c 	.word	0x0800e65c
 8006b20:	0800e660 	.word	0x0800e660

08006b24 <worker_thread_func.lto_priv.138>:
        }
    }
}

static THD_FUNCTION(worker_thread_func, arg) {
 8006b24:	b580      	push	{r7, lr}
 8006b26:	b084      	sub	sp, #16
 8006b28:	af00      	add	r7, sp, #0
 8006b2a:	6078      	str	r0, [r7, #4]
    struct worker_thread_s* worker_thread = arg;
 8006b2c:	687b      	ldr	r3, [r7, #4]
 8006b2e:	60fb      	str	r3, [r7, #12]
    worker_thread_takeover(worker_thread);
 8006b30:	68f8      	ldr	r0, [r7, #12]
 8006b32:	f7ff ff3d 	bl	80069b0 <worker_thread_takeover>
}
 8006b36:	3710      	adds	r7, #16
 8006b38:	46bd      	mov	sp, r7
 8006b3a:	bd80      	pop	{r7, pc}

08006b3c <worker_thread_wake_I.lto_priv.162>:

static void worker_thread_wake_I(struct worker_thread_s* worker_thread) {
 8006b3c:	b580      	push	{r7, lr}
 8006b3e:	b082      	sub	sp, #8
 8006b40:	af00      	add	r7, sp, #0
 8006b42:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
 8006b44:	f004 fa3a 	bl	800afbc <chDbgCheckClassI>

    chThdResumeI(&worker_thread->suspend_trp, MSG_TIMEOUT);
 8006b48:	687b      	ldr	r3, [r7, #4]
 8006b4a:	330c      	adds	r3, #12
 8006b4c:	4618      	mov	r0, r3
 8006b4e:	f04f 31ff 	mov.w	r1, #4294967295
 8006b52:	f003 fcf7 	bl	800a544 <chThdResumeI>
}
 8006b56:	3708      	adds	r7, #8
 8006b58:	46bd      	mov	sp, r7
 8006b5a:	bd80      	pop	{r7, pc}

08006b5c <worker_thread_wake.lto_priv.160>:

static void worker_thread_wake(struct worker_thread_s* worker_thread) {
 8006b5c:	b580      	push	{r7, lr}
 8006b5e:	b082      	sub	sp, #8
 8006b60:	af00      	add	r7, sp, #0
 8006b62:	6078      	str	r0, [r7, #4]
    chThdResume(&worker_thread->suspend_trp, MSG_TIMEOUT);
 8006b64:	687b      	ldr	r3, [r7, #4]
 8006b66:	330c      	adds	r3, #12
 8006b68:	4618      	mov	r0, r3
 8006b6a:	f04f 31ff 	mov.w	r1, #4294967295
 8006b6e:	f003 fd2b 	bl	800a5c8 <chThdResume>
}
 8006b72:	3708      	adds	r7, #8
 8006b74:	46bd      	mov	sp, r7
 8006b76:	bd80      	pop	{r7, pc}

08006b78 <worker_thread_init_timer_task.lto_priv.164>:

static void worker_thread_init_timer_task(struct worker_thread_timer_task_s* task, systime_t timer_begin_systime, systime_t timer_expiration_ticks, bool auto_repeat, timer_task_handler_func_ptr task_func, void* ctx) {
 8006b78:	b480      	push	{r7}
 8006b7a:	b085      	sub	sp, #20
 8006b7c:	af00      	add	r7, sp, #0
 8006b7e:	60f8      	str	r0, [r7, #12]
 8006b80:	4608      	mov	r0, r1
 8006b82:	4611      	mov	r1, r2
 8006b84:	461a      	mov	r2, r3
 8006b86:	4603      	mov	r3, r0
 8006b88:	817b      	strh	r3, [r7, #10]
 8006b8a:	460b      	mov	r3, r1
 8006b8c:	813b      	strh	r3, [r7, #8]
 8006b8e:	4613      	mov	r3, r2
 8006b90:	71fb      	strb	r3, [r7, #7]
    task->task_func = task_func;
 8006b92:	68fb      	ldr	r3, [r7, #12]
 8006b94:	69ba      	ldr	r2, [r7, #24]
 8006b96:	601a      	str	r2, [r3, #0]
    task->ctx = ctx;
 8006b98:	68fb      	ldr	r3, [r7, #12]
 8006b9a:	69fa      	ldr	r2, [r7, #28]
 8006b9c:	605a      	str	r2, [r3, #4]
    task->timer_expiration_ticks = timer_expiration_ticks;
 8006b9e:	68fb      	ldr	r3, [r7, #12]
 8006ba0:	893a      	ldrh	r2, [r7, #8]
 8006ba2:	811a      	strh	r2, [r3, #8]
    task->auto_repeat = auto_repeat;
 8006ba4:	68fb      	ldr	r3, [r7, #12]
 8006ba6:	79fa      	ldrb	r2, [r7, #7]
 8006ba8:	731a      	strb	r2, [r3, #12]
    task->timer_begin_systime = timer_begin_systime;
 8006baa:	68fb      	ldr	r3, [r7, #12]
 8006bac:	897a      	ldrh	r2, [r7, #10]
 8006bae:	815a      	strh	r2, [r3, #10]
}
 8006bb0:	3714      	adds	r7, #20
 8006bb2:	46bd      	mov	sp, r7
 8006bb4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006bb8:	4770      	bx	lr
 8006bba:	bf00      	nop

08006bbc <worker_thread_timer_task_is_registered_I>:

static bool worker_thread_timer_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* check_task) {
 8006bbc:	b580      	push	{r7, lr}
 8006bbe:	b084      	sub	sp, #16
 8006bc0:	af00      	add	r7, sp, #0
 8006bc2:	6078      	str	r0, [r7, #4]
 8006bc4:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 8006bc6:	f004 f9f9 	bl	800afbc <chDbgCheckClassI>

    struct worker_thread_timer_task_s* task = worker_thread->timer_task_list_head;
 8006bca:	687b      	ldr	r3, [r7, #4]
 8006bcc:	691b      	ldr	r3, [r3, #16]
 8006bce:	60fb      	str	r3, [r7, #12]
 8006bd0:	e008      	b.n	8006be4 <worker_thread_timer_task_is_registered_I+0x28>
    while (task) {
        if (task == check_task) {
 8006bd2:	68fa      	ldr	r2, [r7, #12]
 8006bd4:	683b      	ldr	r3, [r7, #0]
 8006bd6:	429a      	cmp	r2, r3
 8006bd8:	d101      	bne.n	8006bde <worker_thread_timer_task_is_registered_I+0x22>
            return true;
 8006bda:	2301      	movs	r3, #1
 8006bdc:	e006      	b.n	8006bec <worker_thread_timer_task_is_registered_I+0x30>
        }
        task = task->next;
 8006bde:	68fb      	ldr	r3, [r7, #12]
 8006be0:	691b      	ldr	r3, [r3, #16]
 8006be2:	60fb      	str	r3, [r7, #12]

static bool worker_thread_timer_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* check_task) {
    chDbgCheckClassI();

    struct worker_thread_timer_task_s* task = worker_thread->timer_task_list_head;
    while (task) {
 8006be4:	68fb      	ldr	r3, [r7, #12]
 8006be6:	2b00      	cmp	r3, #0
 8006be8:	d1f3      	bne.n	8006bd2 <worker_thread_timer_task_is_registered_I+0x16>
        if (task == check_task) {
            return true;
        }
        task = task->next;
    }
    return false;
 8006bea:	2300      	movs	r3, #0
}
 8006bec:	4618      	mov	r0, r3
 8006bee:	3710      	adds	r7, #16
 8006bf0:	46bd      	mov	sp, r7
 8006bf2:	bd80      	pop	{r7, pc}

08006bf4 <worker_thread_insert_timer_task_I.lto_priv.163>:

static void worker_thread_insert_timer_task_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task) {
 8006bf4:	b580      	push	{r7, lr}
 8006bf6:	b084      	sub	sp, #16
 8006bf8:	af00      	add	r7, sp, #0
 8006bfa:	6078      	str	r0, [r7, #4]
 8006bfc:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 8006bfe:	f004 f9dd 	bl	800afbc <chDbgCheckClassI>
    chDbgCheck(!worker_thread_timer_task_is_registered_I(worker_thread, task));
 8006c02:	6878      	ldr	r0, [r7, #4]
 8006c04:	6839      	ldr	r1, [r7, #0]
 8006c06:	f7ff ffd9 	bl	8006bbc <worker_thread_timer_task_is_registered_I>
 8006c0a:	4603      	mov	r3, r0
 8006c0c:	2b00      	cmp	r3, #0
 8006c0e:	d002      	beq.n	8006c16 <worker_thread_insert_timer_task_I.lto_priv.163+0x22>
 8006c10:	4817      	ldr	r0, [pc, #92]	; (8006c70 <worker_thread_insert_timer_task_I.lto_priv.163+0x7c>)
 8006c12:	f004 f8f5 	bl	800ae00 <chSysHalt>

    if (task->timer_expiration_ticks == TIME_INFINITE) {
 8006c16:	683b      	ldr	r3, [r7, #0]
 8006c18:	891b      	ldrh	r3, [r3, #8]
 8006c1a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006c1e:	4293      	cmp	r3, r2
 8006c20:	d023      	beq.n	8006c6a <worker_thread_insert_timer_task_I.lto_priv.163+0x76>
        return;
    }

    systime_t task_run_time = task->timer_begin_systime + task->timer_expiration_ticks;
 8006c22:	683b      	ldr	r3, [r7, #0]
 8006c24:	895a      	ldrh	r2, [r3, #10]
 8006c26:	683b      	ldr	r3, [r7, #0]
 8006c28:	891b      	ldrh	r3, [r3, #8]
 8006c2a:	4413      	add	r3, r2
 8006c2c:	817b      	strh	r3, [r7, #10]
    struct worker_thread_timer_task_s** insert_ptr = &worker_thread->timer_task_list_head;
 8006c2e:	687b      	ldr	r3, [r7, #4]
 8006c30:	3310      	adds	r3, #16
 8006c32:	60fb      	str	r3, [r7, #12]
 8006c34:	e003      	b.n	8006c3e <worker_thread_insert_timer_task_I.lto_priv.163+0x4a>
//        insert_ptr = &(*insert_ptr)->next;
//    } while (*insert_ptr && (time_till_run >= period));

    while (*insert_ptr &&
           (systime_t)(task_run_time - (*insert_ptr)->timer_begin_systime) >= (*insert_ptr)->timer_expiration_ticks) {
        insert_ptr = &(*insert_ptr)->next;
 8006c36:	68fb      	ldr	r3, [r7, #12]
 8006c38:	681b      	ldr	r3, [r3, #0]
 8006c3a:	3310      	adds	r3, #16
 8006c3c:	60fb      	str	r3, [r7, #12]
//        time_till_run = (systime_t)(task_run_time - (*insert_ptr)->timer_begin_systime);
//        period = (*insert_ptr)->timer_expiration_ticks;
//        insert_ptr = &(*insert_ptr)->next;
//    } while (*insert_ptr && (time_till_run >= period));

    while (*insert_ptr &&
 8006c3e:	68fb      	ldr	r3, [r7, #12]
 8006c40:	681b      	ldr	r3, [r3, #0]
 8006c42:	2b00      	cmp	r3, #0
 8006c44:	d00a      	beq.n	8006c5c <worker_thread_insert_timer_task_I.lto_priv.163+0x68>
           (systime_t)(task_run_time - (*insert_ptr)->timer_begin_systime) >= (*insert_ptr)->timer_expiration_ticks) {
 8006c46:	68fb      	ldr	r3, [r7, #12]
 8006c48:	681b      	ldr	r3, [r3, #0]
 8006c4a:	895b      	ldrh	r3, [r3, #10]
 8006c4c:	897a      	ldrh	r2, [r7, #10]
 8006c4e:	1ad3      	subs	r3, r2, r3
 8006c50:	b29a      	uxth	r2, r3
 8006c52:	68fb      	ldr	r3, [r7, #12]
 8006c54:	681b      	ldr	r3, [r3, #0]
 8006c56:	891b      	ldrh	r3, [r3, #8]
//        time_till_run = (systime_t)(task_run_time - (*insert_ptr)->timer_begin_systime);
//        period = (*insert_ptr)->timer_expiration_ticks;
//        insert_ptr = &(*insert_ptr)->next;
//    } while (*insert_ptr && (time_till_run >= period));

    while (*insert_ptr &&
 8006c58:	429a      	cmp	r2, r3
 8006c5a:	d2ec      	bcs.n	8006c36 <worker_thread_insert_timer_task_I.lto_priv.163+0x42>
           (systime_t)(task_run_time - (*insert_ptr)->timer_begin_systime) >= (*insert_ptr)->timer_expiration_ticks) {
        insert_ptr = &(*insert_ptr)->next;
    }

    task->next = *insert_ptr;
 8006c5c:	68fb      	ldr	r3, [r7, #12]
 8006c5e:	681a      	ldr	r2, [r3, #0]
 8006c60:	683b      	ldr	r3, [r7, #0]
 8006c62:	611a      	str	r2, [r3, #16]
    *insert_ptr = task;
 8006c64:	68fb      	ldr	r3, [r7, #12]
 8006c66:	683a      	ldr	r2, [r7, #0]
 8006c68:	601a      	str	r2, [r3, #0]
}
 8006c6a:	3710      	adds	r7, #16
 8006c6c:	46bd      	mov	sp, r7
 8006c6e:	bd80      	pop	{r7, pc}
 8006c70:	0800ebe8 	.word	0x0800ebe8

08006c74 <worker_thread_get_ticks_to_timer_task_I>:

static systime_t worker_thread_get_ticks_to_timer_task_I(struct worker_thread_timer_task_s* task, systime_t tnow_ticks) {
 8006c74:	b580      	push	{r7, lr}
 8006c76:	b084      	sub	sp, #16
 8006c78:	af00      	add	r7, sp, #0
 8006c7a:	6078      	str	r0, [r7, #4]
 8006c7c:	460b      	mov	r3, r1
 8006c7e:	807b      	strh	r3, [r7, #2]
    chDbgCheckClassI();
 8006c80:	f004 f99c 	bl	800afbc <chDbgCheckClassI>

    if (task && task->timer_expiration_ticks != TIME_INFINITE) {
 8006c84:	687b      	ldr	r3, [r7, #4]
 8006c86:	2b00      	cmp	r3, #0
 8006c88:	d017      	beq.n	8006cba <worker_thread_get_ticks_to_timer_task_I+0x46>
 8006c8a:	687b      	ldr	r3, [r7, #4]
 8006c8c:	891b      	ldrh	r3, [r3, #8]
 8006c8e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006c92:	4293      	cmp	r3, r2
 8006c94:	d011      	beq.n	8006cba <worker_thread_get_ticks_to_timer_task_I+0x46>
        systime_t elapsed = tnow_ticks - task->timer_begin_systime;
 8006c96:	687b      	ldr	r3, [r7, #4]
 8006c98:	895b      	ldrh	r3, [r3, #10]
 8006c9a:	887a      	ldrh	r2, [r7, #2]
 8006c9c:	1ad3      	subs	r3, r2, r3
 8006c9e:	81fb      	strh	r3, [r7, #14]
        if (elapsed >= task->timer_expiration_ticks) {
 8006ca0:	687b      	ldr	r3, [r7, #4]
 8006ca2:	891b      	ldrh	r3, [r3, #8]
 8006ca4:	89fa      	ldrh	r2, [r7, #14]
 8006ca6:	429a      	cmp	r2, r3
 8006ca8:	d301      	bcc.n	8006cae <worker_thread_get_ticks_to_timer_task_I+0x3a>
            return TIME_IMMEDIATE;
 8006caa:	2300      	movs	r3, #0
 8006cac:	e007      	b.n	8006cbe <worker_thread_get_ticks_to_timer_task_I+0x4a>
        } else {
            return task->timer_expiration_ticks - elapsed;
 8006cae:	687b      	ldr	r3, [r7, #4]
 8006cb0:	891a      	ldrh	r2, [r3, #8]
 8006cb2:	89fb      	ldrh	r3, [r7, #14]
 8006cb4:	1ad3      	subs	r3, r2, r3
 8006cb6:	b29b      	uxth	r3, r3
 8006cb8:	e001      	b.n	8006cbe <worker_thread_get_ticks_to_timer_task_I+0x4a>
        }
    } else {
        return TIME_INFINITE;
 8006cba:	f64f 73ff 	movw	r3, #65535	; 0xffff
    }
}
 8006cbe:	4618      	mov	r0, r3
 8006cc0:	3710      	adds	r7, #16
 8006cc2:	46bd      	mov	sp, r7
 8006cc4:	bd80      	pop	{r7, pc}
 8006cc6:	bf00      	nop

08006cc8 <worker_thread_publisher_task_is_registered_I>:

#ifdef MODULE_PUBSUB_ENABLED
static bool worker_thread_publisher_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_publisher_task_s* check_task) {
 8006cc8:	b580      	push	{r7, lr}
 8006cca:	b084      	sub	sp, #16
 8006ccc:	af00      	add	r7, sp, #0
 8006cce:	6078      	str	r0, [r7, #4]
 8006cd0:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 8006cd2:	f004 f973 	bl	800afbc <chDbgCheckClassI>

    struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
 8006cd6:	687b      	ldr	r3, [r7, #4]
 8006cd8:	699b      	ldr	r3, [r3, #24]
 8006cda:	60fb      	str	r3, [r7, #12]
 8006cdc:	e008      	b.n	8006cf0 <worker_thread_publisher_task_is_registered_I+0x28>
    while (task) {
        if (task == check_task) {
 8006cde:	68fa      	ldr	r2, [r7, #12]
 8006ce0:	683b      	ldr	r3, [r7, #0]
 8006ce2:	429a      	cmp	r2, r3
 8006ce4:	d101      	bne.n	8006cea <worker_thread_publisher_task_is_registered_I+0x22>
            return true;
 8006ce6:	2301      	movs	r3, #1
 8006ce8:	e006      	b.n	8006cf8 <worker_thread_publisher_task_is_registered_I+0x30>
        }
        task = task->next;
 8006cea:	68fb      	ldr	r3, [r7, #12]
 8006cec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006cee:	60fb      	str	r3, [r7, #12]
#ifdef MODULE_PUBSUB_ENABLED
static bool worker_thread_publisher_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_publisher_task_s* check_task) {
    chDbgCheckClassI();

    struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
    while (task) {
 8006cf0:	68fb      	ldr	r3, [r7, #12]
 8006cf2:	2b00      	cmp	r3, #0
 8006cf4:	d1f3      	bne.n	8006cde <worker_thread_publisher_task_is_registered_I+0x16>
        if (task == check_task) {
            return true;
        }
        task = task->next;
    }
    return false;
 8006cf6:	2300      	movs	r3, #0
}
 8006cf8:	4618      	mov	r0, r3
 8006cfa:	3710      	adds	r7, #16
 8006cfc:	46bd      	mov	sp, r7
 8006cfe:	bd80      	pop	{r7, pc}

08006d00 <worker_thread_get_any_publisher_task_due_I>:

static bool worker_thread_get_any_publisher_task_due_I(struct worker_thread_s* worker_thread) {
 8006d00:	b580      	push	{r7, lr}
 8006d02:	b084      	sub	sp, #16
 8006d04:	af00      	add	r7, sp, #0
 8006d06:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
 8006d08:	f004 f958 	bl	800afbc <chDbgCheckClassI>

    struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
 8006d0c:	687b      	ldr	r3, [r7, #4]
 8006d0e:	699b      	ldr	r3, [r3, #24]
 8006d10:	60fb      	str	r3, [r7, #12]
 8006d12:	e00c      	b.n	8006d2e <worker_thread_get_any_publisher_task_due_I+0x2e>
    while (task) {
        if (chMBGetUsedCountI(&task->mailbox) != 0) {
 8006d14:	68fb      	ldr	r3, [r7, #12]
 8006d16:	3310      	adds	r3, #16
 8006d18:	4618      	mov	r0, r3
 8006d1a:	f001 fd6b 	bl	80087f4 <chMBGetUsedCountI.lto_priv.131>
 8006d1e:	4603      	mov	r3, r0
 8006d20:	2b00      	cmp	r3, #0
 8006d22:	d001      	beq.n	8006d28 <worker_thread_get_any_publisher_task_due_I+0x28>
            return true;
 8006d24:	2301      	movs	r3, #1
 8006d26:	e006      	b.n	8006d36 <worker_thread_get_any_publisher_task_due_I+0x36>
        }
        task = task->next;
 8006d28:	68fb      	ldr	r3, [r7, #12]
 8006d2a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006d2c:	60fb      	str	r3, [r7, #12]

static bool worker_thread_get_any_publisher_task_due_I(struct worker_thread_s* worker_thread) {
    chDbgCheckClassI();

    struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
    while (task) {
 8006d2e:	68fb      	ldr	r3, [r7, #12]
 8006d30:	2b00      	cmp	r3, #0
 8006d32:	d1ef      	bne.n	8006d14 <worker_thread_get_any_publisher_task_due_I+0x14>
        if (chMBGetUsedCountI(&task->mailbox) != 0) {
            return true;
        }
        task = task->next;
    }
    return false;
 8006d34:	2300      	movs	r3, #0
}
 8006d36:	4618      	mov	r0, r3
 8006d38:	3710      	adds	r7, #16
 8006d3a:	46bd      	mov	sp, r7
 8006d3c:	bd80      	pop	{r7, pc}
 8006d3e:	bf00      	nop

08006d40 <worker_thread_listener_task_is_registered_I>:

static bool worker_thread_listener_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* check_task) {
 8006d40:	b580      	push	{r7, lr}
 8006d42:	b084      	sub	sp, #16
 8006d44:	af00      	add	r7, sp, #0
 8006d46:	6078      	str	r0, [r7, #4]
 8006d48:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 8006d4a:	f004 f937 	bl	800afbc <chDbgCheckClassI>

    struct worker_thread_listener_task_s* task = worker_thread->listener_task_list_head;
 8006d4e:	687b      	ldr	r3, [r7, #4]
 8006d50:	695b      	ldr	r3, [r3, #20]
 8006d52:	60fb      	str	r3, [r7, #12]
 8006d54:	e008      	b.n	8006d68 <worker_thread_listener_task_is_registered_I+0x28>
    while (task) {
        if (task == check_task) {
 8006d56:	68fa      	ldr	r2, [r7, #12]
 8006d58:	683b      	ldr	r3, [r7, #0]
 8006d5a:	429a      	cmp	r2, r3
 8006d5c:	d101      	bne.n	8006d62 <worker_thread_listener_task_is_registered_I+0x22>
            return true;
 8006d5e:	2301      	movs	r3, #1
 8006d60:	e006      	b.n	8006d70 <worker_thread_listener_task_is_registered_I+0x30>
        }
        task = task->next;
 8006d62:	68fb      	ldr	r3, [r7, #12]
 8006d64:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006d66:	60fb      	str	r3, [r7, #12]

static bool worker_thread_listener_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* check_task) {
    chDbgCheckClassI();

    struct worker_thread_listener_task_s* task = worker_thread->listener_task_list_head;
    while (task) {
 8006d68:	68fb      	ldr	r3, [r7, #12]
 8006d6a:	2b00      	cmp	r3, #0
 8006d6c:	d1f3      	bne.n	8006d56 <worker_thread_listener_task_is_registered_I+0x16>
        if (task == check_task) {
            return true;
        }
        task = task->next;
    }
    return false;
 8006d6e:	2300      	movs	r3, #0
}
 8006d70:	4618      	mov	r0, r3
 8006d72:	3710      	adds	r7, #16
 8006d74:	46bd      	mov	sp, r7
 8006d76:	bd80      	pop	{r7, pc}

08006d78 <worker_thread_listener_task_is_registered.lto_priv.161>:

static bool worker_thread_listener_task_is_registered(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* check_task) {
 8006d78:	b580      	push	{r7, lr}
 8006d7a:	b084      	sub	sp, #16
 8006d7c:	af00      	add	r7, sp, #0
 8006d7e:	6078      	str	r0, [r7, #4]
 8006d80:	6039      	str	r1, [r7, #0]
    chSysLock();
 8006d82:	f001 fcef 	bl	8008764 <chSysLock.lto_priv.125>
    bool ret = worker_thread_listener_task_is_registered_I(worker_thread, check_task);
 8006d86:	6878      	ldr	r0, [r7, #4]
 8006d88:	6839      	ldr	r1, [r7, #0]
 8006d8a:	f7ff ffd9 	bl	8006d40 <worker_thread_listener_task_is_registered_I>
 8006d8e:	4603      	mov	r3, r0
 8006d90:	73fb      	strb	r3, [r7, #15]
    chSysUnlock();
 8006d92:	f001 fcef 	bl	8008774 <chSysUnlock.lto_priv.123>
    return ret;
 8006d96:	7bfb      	ldrb	r3, [r7, #15]
}
 8006d98:	4618      	mov	r0, r3
 8006d9a:	3710      	adds	r7, #16
 8006d9c:	46bd      	mov	sp, r7
 8006d9e:	bd80      	pop	{r7, pc}

08006da0 <worker_thread_get_any_listener_task_due_I>:

static bool worker_thread_get_any_listener_task_due_I(struct worker_thread_s* worker_thread) {
 8006da0:	b580      	push	{r7, lr}
 8006da2:	b084      	sub	sp, #16
 8006da4:	af00      	add	r7, sp, #0
 8006da6:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
 8006da8:	f004 f908 	bl	800afbc <chDbgCheckClassI>

    struct worker_thread_listener_task_s* listener_task = worker_thread->listener_task_list_head;
 8006dac:	687b      	ldr	r3, [r7, #4]
 8006dae:	695b      	ldr	r3, [r3, #20]
 8006db0:	60fb      	str	r3, [r7, #12]
 8006db2:	e00b      	b.n	8006dcc <worker_thread_get_any_listener_task_due_I+0x2c>
    while (listener_task) {
        if (pubsub_listener_has_message(&listener_task->listener)) {
 8006db4:	68fb      	ldr	r3, [r7, #12]
 8006db6:	4618      	mov	r0, r3
 8006db8:	f001 fac6 	bl	8008348 <pubsub_listener_has_message>
 8006dbc:	4603      	mov	r3, r0
 8006dbe:	2b00      	cmp	r3, #0
 8006dc0:	d001      	beq.n	8006dc6 <worker_thread_get_any_listener_task_due_I+0x26>
            return true;
 8006dc2:	2301      	movs	r3, #1
 8006dc4:	e006      	b.n	8006dd4 <worker_thread_get_any_listener_task_due_I+0x34>
        }
        listener_task = listener_task->next;
 8006dc6:	68fb      	ldr	r3, [r7, #12]
 8006dc8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006dca:	60fb      	str	r3, [r7, #12]

static bool worker_thread_get_any_listener_task_due_I(struct worker_thread_s* worker_thread) {
    chDbgCheckClassI();

    struct worker_thread_listener_task_s* listener_task = worker_thread->listener_task_list_head;
    while (listener_task) {
 8006dcc:	68fb      	ldr	r3, [r7, #12]
 8006dce:	2b00      	cmp	r3, #0
 8006dd0:	d1f0      	bne.n	8006db4 <worker_thread_get_any_listener_task_due_I+0x14>
        if (pubsub_listener_has_message(&listener_task->listener)) {
            return true;
        }
        listener_task = listener_task->next;
    }
    return false;
 8006dd2:	2300      	movs	r3, #0
}
 8006dd4:	4618      	mov	r0, r3
 8006dd6:	3710      	adds	r7, #16
 8006dd8:	46bd      	mov	sp, r7
 8006dda:	bd80      	pop	{r7, pc}

08006ddc <port_lock.lto_priv.113>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006ddc:	b480      	push	{r7}
 8006dde:	b083      	sub	sp, #12
 8006de0:	af00      	add	r7, sp, #0
 8006de2:	2320      	movs	r3, #32
 8006de4:	607b      	str	r3, [r7, #4]
 8006de6:	687b      	ldr	r3, [r7, #4]
 8006de8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006dec:	370c      	adds	r7, #12
 8006dee:	46bd      	mov	sp, r7
 8006df0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006df4:	4770      	bx	lr
 8006df6:	bf00      	nop

08006df8 <port_unlock.lto_priv.110>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006df8:	b480      	push	{r7}
 8006dfa:	b083      	sub	sp, #12
 8006dfc:	af00      	add	r7, sp, #0
 8006dfe:	2300      	movs	r3, #0
 8006e00:	607b      	str	r3, [r7, #4]
 8006e02:	687b      	ldr	r3, [r7, #4]
 8006e04:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006e08:	370c      	adds	r7, #12
 8006e0a:	46bd      	mov	sp, r7
 8006e0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e10:	4770      	bx	lr
 8006e12:	bf00      	nop

08006e14 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8006e14:	b580      	push	{r7, lr}
 8006e16:	af00      	add	r7, sp, #0

  port_lock();
 8006e18:	f7ff ffe0 	bl	8006ddc <port_lock.lto_priv.113>
}
 8006e1c:	bd80      	pop	{r7, pc}
 8006e1e:	bf00      	nop

08006e20 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8006e20:	b580      	push	{r7, lr}
 8006e22:	af00      	add	r7, sp, #0

  port_unlock();
 8006e24:	f7ff ffe8 	bl	8006df8 <port_unlock.lto_priv.110>
}
 8006e28:	bd80      	pop	{r7, pc}
 8006e2a:	bf00      	nop

08006e2c <st_lld_get_counter.lto_priv.107>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 8006e2c:	b480      	push	{r7}
 8006e2e:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 8006e30:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006e34:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006e36:	b29b      	uxth	r3, r3
}
 8006e38:	4618      	mov	r0, r3
 8006e3a:	46bd      	mov	sp, r7
 8006e3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e40:	4770      	bx	lr
 8006e42:	bf00      	nop

08006e44 <port_timer_get_time.lto_priv.104>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8006e44:	b580      	push	{r7, lr}
 8006e46:	af00      	add	r7, sp, #0

  return stGetCounter();
 8006e48:	f7ff fff0 	bl	8006e2c <st_lld_get_counter.lto_priv.107>
 8006e4c:	4603      	mov	r3, r0
}
 8006e4e:	4618      	mov	r0, r3
 8006e50:	bd80      	pop	{r7, pc}
 8006e52:	bf00      	nop

08006e54 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8006e54:	b580      	push	{r7, lr}
 8006e56:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 8006e58:	f7ff ffdc 	bl	8006e14 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8006e5c:	f004 f84a 	bl	800aef4 <_dbg_check_lock_from_isr>
}
 8006e60:	bd80      	pop	{r7, pc}
 8006e62:	bf00      	nop

08006e64 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8006e64:	b580      	push	{r7, lr}
 8006e66:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
 8006e68:	f004 f85a 	bl	800af20 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8006e6c:	f7ff ffd8 	bl	8006e20 <port_unlock_from_isr>
}
 8006e70:	bd80      	pop	{r7, pc}
 8006e72:	bf00      	nop

08006e74 <chVTGetSystemTimeX.lto_priv.117>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8006e74:	b580      	push	{r7, lr}
 8006e76:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8006e78:	f7ff ffe4 	bl	8006e44 <port_timer_get_time.lto_priv.104>
 8006e7c:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8006e7e:	4618      	mov	r0, r3
 8006e80:	bd80      	pop	{r7, pc}
 8006e82:	bf00      	nop

08006e84 <_local_ctor_41>:
    CAN_TypeDef* can;
};

static struct can_driver_stm32_instance_s can1_instance;

RUN_ON(CAN_INIT) {
 8006e84:	b580      	push	{r7, lr}
 8006e86:	b082      	sub	sp, #8
 8006e88:	af02      	add	r7, sp, #8
    // TODO make this index configurable and enable multiple instances
    can1_instance.can = CAN1;
 8006e8a:	4b09      	ldr	r3, [pc, #36]	; (8006eb0 <_local_ctor_41+0x2c>)
 8006e8c:	4a09      	ldr	r2, [pc, #36]	; (8006eb4 <_local_ctor_41+0x30>)
 8006e8e:	605a      	str	r2, [r3, #4]
    can1_instance.frontend = can_driver_register(0, &can1_instance, &can_driver_stm32_iface, NUM_TX_MAILBOXES, NUM_RX_MAILBOXES, RX_FIFO_DEPTH);
 8006e90:	2302      	movs	r3, #2
 8006e92:	9300      	str	r3, [sp, #0]
 8006e94:	2303      	movs	r3, #3
 8006e96:	9301      	str	r3, [sp, #4]
 8006e98:	2000      	movs	r0, #0
 8006e9a:	4905      	ldr	r1, [pc, #20]	; (8006eb0 <_local_ctor_41+0x2c>)
 8006e9c:	4a06      	ldr	r2, [pc, #24]	; (8006eb8 <_local_ctor_41+0x34>)
 8006e9e:	2303      	movs	r3, #3
 8006ea0:	f7fe fe04 	bl	8005aac <can_driver_register>
 8006ea4:	4602      	mov	r2, r0
 8006ea6:	4b02      	ldr	r3, [pc, #8]	; (8006eb0 <_local_ctor_41+0x2c>)
 8006ea8:	601a      	str	r2, [r3, #0]
}
 8006eaa:	46bd      	mov	sp, r7
 8006eac:	bd80      	pop	{r7, pc}
 8006eae:	bf00      	nop
 8006eb0:	20001464 	.word	0x20001464
 8006eb4:	40006400 	.word	0x40006400
 8006eb8:	0800ec0c 	.word	0x0800ec0c

08006ebc <can_driver_stm32_start.lto_priv.22>:

static void can_driver_stm32_start(void* ctx, bool silent, bool auto_retransmit, uint32_t baudrate) {
 8006ebc:	b580      	push	{r7, lr}
 8006ebe:	b08c      	sub	sp, #48	; 0x30
 8006ec0:	af00      	add	r7, sp, #0
 8006ec2:	60f8      	str	r0, [r7, #12]
 8006ec4:	607b      	str	r3, [r7, #4]
 8006ec6:	460b      	mov	r3, r1
 8006ec8:	72fb      	strb	r3, [r7, #11]
 8006eca:	4613      	mov	r3, r2
 8006ecc:	72bb      	strb	r3, [r7, #10]
    struct can_driver_stm32_instance_s* instance = ctx;
 8006ece:	68fb      	ldr	r3, [r7, #12]
 8006ed0:	62bb      	str	r3, [r7, #40]	; 0x28

    rccEnableCAN1(FALSE);
 8006ed2:	4a84      	ldr	r2, [pc, #528]	; (80070e4 <can_driver_stm32_start.lto_priv.22+0x228>)
 8006ed4:	4b83      	ldr	r3, [pc, #524]	; (80070e4 <can_driver_stm32_start.lto_priv.22+0x228>)
 8006ed6:	69db      	ldr	r3, [r3, #28]
 8006ed8:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8006edc:	61d3      	str	r3, [r2, #28]

    instance->can->FMR = (instance->can->FMR & 0xFFFF0000) | CAN_FMR_FINIT;
 8006ede:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006ee0:	685a      	ldr	r2, [r3, #4]
 8006ee2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006ee4:	685b      	ldr	r3, [r3, #4]
 8006ee6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8006eea:	0c1b      	lsrs	r3, r3, #16
 8006eec:	041b      	lsls	r3, r3, #16
 8006eee:	f043 0301 	orr.w	r3, r3, #1
 8006ef2:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    instance->can->sFilterRegister[0].FR1 = 0;
 8006ef6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006ef8:	685b      	ldr	r3, [r3, #4]
 8006efa:	2200      	movs	r2, #0
 8006efc:	f8c3 2240 	str.w	r2, [r3, #576]	; 0x240
    instance->can->sFilterRegister[0].FR2 = 0;
 8006f00:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f02:	685b      	ldr	r3, [r3, #4]
 8006f04:	2200      	movs	r2, #0
 8006f06:	f8c3 2244 	str.w	r2, [r3, #580]	; 0x244
    instance->can->FM1R = 0;
 8006f0a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f0c:	685b      	ldr	r3, [r3, #4]
 8006f0e:	2200      	movs	r2, #0
 8006f10:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
    instance->can->FFA1R = 0;
 8006f14:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f16:	685b      	ldr	r3, [r3, #4]
 8006f18:	2200      	movs	r2, #0
 8006f1a:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
    instance->can->FS1R = 1;
 8006f1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f20:	685b      	ldr	r3, [r3, #4]
 8006f22:	2201      	movs	r2, #1
 8006f24:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
    instance->can->FA1R = 1;
 8006f28:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f2a:	685b      	ldr	r3, [r3, #4]
 8006f2c:	2201      	movs	r2, #1
 8006f2e:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c

    instance->can->FMR &= ~CAN_FMR_FINIT;
 8006f32:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f34:	685b      	ldr	r3, [r3, #4]
 8006f36:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8006f38:	6852      	ldr	r2, [r2, #4]
 8006f3a:	f8d2 2200 	ldr.w	r2, [r2, #512]	; 0x200
 8006f3e:	f022 0201 	bic.w	r2, r2, #1
 8006f42:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200

    nvicEnableVector(STM32_CAN1_TX_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 8006f46:	2013      	movs	r0, #19
 8006f48:	210b      	movs	r1, #11
 8006f4a:	f002 fa3d 	bl	80093c8 <nvicEnableVector>
    nvicEnableVector(STM32_CAN1_RX0_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 8006f4e:	2014      	movs	r0, #20
 8006f50:	210b      	movs	r1, #11
 8006f52:	f002 fa39 	bl	80093c8 <nvicEnableVector>
    nvicEnableVector(STM32_CAN1_SCE_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 8006f56:	2016      	movs	r0, #22
 8006f58:	210b      	movs	r1, #11
 8006f5a:	f002 fa35 	bl	80093c8 <nvicEnableVector>

    instance->can->MCR = CAN_MCR_INRQ;
 8006f5e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f60:	685b      	ldr	r3, [r3, #4]
 8006f62:	2201      	movs	r2, #1
 8006f64:	601a      	str	r2, [r3, #0]
 8006f66:	e000      	b.n	8006f6a <can_driver_stm32_start.lto_priv.22+0xae>
    while((instance->can->MSR & CAN_MSR_INAK) == 0) {
        __asm__("nop");
 8006f68:	bf00      	nop
    nvicEnableVector(STM32_CAN1_TX_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_RX0_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_SCE_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);

    instance->can->MCR = CAN_MCR_INRQ;
    while((instance->can->MSR & CAN_MSR_INAK) == 0) {
 8006f6a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f6c:	685b      	ldr	r3, [r3, #4]
 8006f6e:	685b      	ldr	r3, [r3, #4]
 8006f70:	f003 0301 	and.w	r3, r3, #1
 8006f74:	2b00      	cmp	r3, #0
 8006f76:	d0f7      	beq.n	8006f68 <can_driver_stm32_start.lto_priv.22+0xac>
    uint8_t bs1;
    uint8_t bs2;
    uint32_t prescaler;

    {
        const uint8_t max_quanta_per_bit = (baudrate >= 1000000) ? 10 : 17;
 8006f78:	687b      	ldr	r3, [r7, #4]
 8006f7a:	4a5b      	ldr	r2, [pc, #364]	; (80070e8 <can_driver_stm32_start.lto_priv.22+0x22c>)
 8006f7c:	4293      	cmp	r3, r2
 8006f7e:	d901      	bls.n	8006f84 <can_driver_stm32_start.lto_priv.22+0xc8>
 8006f80:	230a      	movs	r3, #10
 8006f82:	e000      	b.n	8006f86 <can_driver_stm32_start.lto_priv.22+0xca>
 8006f84:	2311      	movs	r3, #17
 8006f86:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        const uint32_t prescaler_bs = STM32_PCLK1 / baudrate;
 8006f8a:	4a58      	ldr	r2, [pc, #352]	; (80070ec <can_driver_stm32_start.lto_priv.22+0x230>)
 8006f8c:	687b      	ldr	r3, [r7, #4]
 8006f8e:	fbb2 f3f3 	udiv	r3, r2, r3
 8006f92:	623b      	str	r3, [r7, #32]

        uint8_t bs1_bs2_sum = (uint8_t)(max_quanta_per_bit - 1);
 8006f94:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8006f98:	3b01      	subs	r3, #1
 8006f9a:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
 8006f9e:	e009      	b.n	8006fb4 <can_driver_stm32_start.lto_priv.22+0xf8>

        // Search for the highest valid prescalar value
        while ((prescaler_bs % (1 + bs1_bs2_sum)) != 0) {
            if (bs1_bs2_sum <= 2) {
 8006fa0:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8006fa4:	2b02      	cmp	r3, #2
 8006fa6:	f240 8099 	bls.w	80070dc <can_driver_stm32_start.lto_priv.22+0x220>
                return;
            }
            bs1_bs2_sum--;
 8006faa:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8006fae:	3b01      	subs	r3, #1
 8006fb0:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
        const uint32_t prescaler_bs = STM32_PCLK1 / baudrate;

        uint8_t bs1_bs2_sum = (uint8_t)(max_quanta_per_bit - 1);

        // Search for the highest valid prescalar value
        while ((prescaler_bs % (1 + bs1_bs2_sum)) != 0) {
 8006fb4:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8006fb8:	3301      	adds	r3, #1
 8006fba:	461a      	mov	r2, r3
 8006fbc:	6a3b      	ldr	r3, [r7, #32]
 8006fbe:	fbb3 f1f2 	udiv	r1, r3, r2
 8006fc2:	fb02 f201 	mul.w	r2, r2, r1
 8006fc6:	1a9b      	subs	r3, r3, r2
 8006fc8:	2b00      	cmp	r3, #0
 8006fca:	d1e9      	bne.n	8006fa0 <can_driver_stm32_start.lto_priv.22+0xe4>
                return;
            }
            bs1_bs2_sum--;
        }

        prescaler = prescaler_bs / (1 + bs1_bs2_sum);
 8006fcc:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8006fd0:	3301      	adds	r3, #1
 8006fd2:	461a      	mov	r2, r3
 8006fd4:	6a3b      	ldr	r3, [r7, #32]
 8006fd6:	fbb3 f3f2 	udiv	r3, r3, r2
 8006fda:	61fb      	str	r3, [r7, #28]
        if (prescaler < 1 || prescaler > 1024) {
 8006fdc:	69fb      	ldr	r3, [r7, #28]
 8006fde:	2b00      	cmp	r3, #0
 8006fe0:	d07c      	beq.n	80070dc <can_driver_stm32_start.lto_priv.22+0x220>
 8006fe2:	69fb      	ldr	r3, [r7, #28]
 8006fe4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8006fe8:	d878      	bhi.n	80070dc <can_driver_stm32_start.lto_priv.22+0x220>
            return;
        }

        // The recommended sample point location is 87.5% or 7/8. Compute the values of BS1 and BS2 that satisfy BS1+BS2 == bs1_bs2_sum and minimize ((1+BS1)/(1+BS1/BS2) - 7/8)
        bs1 = ((7 * bs1_bs2_sum - 1) + 4) / 8;
 8006fea:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
 8006fee:	4613      	mov	r3, r2
 8006ff0:	00db      	lsls	r3, r3, #3
 8006ff2:	1a9b      	subs	r3, r3, r2
 8006ff4:	3303      	adds	r3, #3
 8006ff6:	2b00      	cmp	r3, #0
 8006ff8:	da00      	bge.n	8006ffc <can_driver_stm32_start.lto_priv.22+0x140>
 8006ffa:	3307      	adds	r3, #7
 8006ffc:	10db      	asrs	r3, r3, #3
 8006ffe:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

        // Check sample point constraints
        const uint16_t max_sample_point_per_mille = 900;
 8007002:	f44f 7361 	mov.w	r3, #900	; 0x384
 8007006:	837b      	strh	r3, [r7, #26]
        const uint16_t min_sample_point_per_mille = (baudrate >= 1000000) ? 750 : 850;
 8007008:	687b      	ldr	r3, [r7, #4]
 800700a:	4a37      	ldr	r2, [pc, #220]	; (80070e8 <can_driver_stm32_start.lto_priv.22+0x22c>)
 800700c:	4293      	cmp	r3, r2
 800700e:	d902      	bls.n	8007016 <can_driver_stm32_start.lto_priv.22+0x15a>
 8007010:	f240 23ee 	movw	r3, #750	; 0x2ee
 8007014:	e001      	b.n	800701a <can_driver_stm32_start.lto_priv.22+0x15e>
 8007016:	f240 3352 	movw	r3, #850	; 0x352
 800701a:	833b      	strh	r3, [r7, #24]

        if (1000 * (1 + bs1) / (1 + bs1_bs2_sum) >= max_sample_point_per_mille) {
 800701c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8007020:	3301      	adds	r3, #1
 8007022:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8007026:	fb02 f203 	mul.w	r2, r2, r3
 800702a:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 800702e:	3301      	adds	r3, #1
 8007030:	fb92 f2f3 	sdiv	r2, r2, r3
 8007034:	8b7b      	ldrh	r3, [r7, #26]
 8007036:	429a      	cmp	r2, r3
 8007038:	db04      	blt.n	8007044 <can_driver_stm32_start.lto_priv.22+0x188>
            bs1--;
 800703a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800703e:	3b01      	subs	r3, #1
 8007040:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        }

        if (1000 * (1 + bs1) / (1 + bs1_bs2_sum) < min_sample_point_per_mille) {
 8007044:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8007048:	3301      	adds	r3, #1
 800704a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800704e:	fb02 f203 	mul.w	r2, r2, r3
 8007052:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8007056:	3301      	adds	r3, #1
 8007058:	fb92 f2f3 	sdiv	r2, r2, r3
 800705c:	8b3b      	ldrh	r3, [r7, #24]
 800705e:	429a      	cmp	r2, r3
 8007060:	da04      	bge.n	800706c <can_driver_stm32_start.lto_priv.22+0x1b0>
            bs1++;
 8007062:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8007066:	3301      	adds	r3, #1
 8007068:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        }

        if (1000 * (1 + bs1) / (1 + bs1_bs2_sum) >= max_sample_point_per_mille) {
 800706c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8007070:	3301      	adds	r3, #1
 8007072:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8007076:	fb02 f203 	mul.w	r2, r2, r3
 800707a:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 800707e:	3301      	adds	r3, #1
 8007080:	fb92 f2f3 	sdiv	r2, r2, r3
 8007084:	8b7b      	ldrh	r3, [r7, #26]
 8007086:	429a      	cmp	r2, r3
 8007088:	da28      	bge.n	80070dc <can_driver_stm32_start.lto_priv.22+0x220>
            return;
        }

        bs2 = bs1_bs2_sum-bs1;
 800708a:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
 800708e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8007092:	1ad3      	subs	r3, r2, r3
 8007094:	75fb      	strb	r3, [r7, #23]
    }

    instance->can->BTR = (silent?CAN_BTR_SILM:0) | CAN_BTR_SJW(0) | CAN_BTR_TS1(bs1-1) | CAN_BTR_TS2(bs2-1) | CAN_BTR_BRP(prescaler - 1);
 8007096:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007098:	685b      	ldr	r3, [r3, #4]
 800709a:	7afa      	ldrb	r2, [r7, #11]
 800709c:	2a00      	cmp	r2, #0
 800709e:	d002      	beq.n	80070a6 <can_driver_stm32_start.lto_priv.22+0x1ea>
 80070a0:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 80070a4:	e000      	b.n	80070a8 <can_driver_stm32_start.lto_priv.22+0x1ec>
 80070a6:	2200      	movs	r2, #0
 80070a8:	f897 102f 	ldrb.w	r1, [r7, #47]	; 0x2f
 80070ac:	3901      	subs	r1, #1
 80070ae:	0409      	lsls	r1, r1, #16
 80070b0:	430a      	orrs	r2, r1
 80070b2:	7df9      	ldrb	r1, [r7, #23]
 80070b4:	3901      	subs	r1, #1
 80070b6:	0509      	lsls	r1, r1, #20
 80070b8:	4311      	orrs	r1, r2
 80070ba:	69fa      	ldr	r2, [r7, #28]
 80070bc:	3a01      	subs	r2, #1
 80070be:	430a      	orrs	r2, r1
 80070c0:	61da      	str	r2, [r3, #28]

    instance->can->MCR = CAN_MCR_ABOM | CAN_MCR_AWUM | (auto_retransmit?0:CAN_MCR_NART);
 80070c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80070c4:	685b      	ldr	r3, [r3, #4]
 80070c6:	7aba      	ldrb	r2, [r7, #10]
 80070c8:	2a00      	cmp	r2, #0
 80070ca:	d001      	beq.n	80070d0 <can_driver_stm32_start.lto_priv.22+0x214>
 80070cc:	2260      	movs	r2, #96	; 0x60
 80070ce:	e000      	b.n	80070d2 <can_driver_stm32_start.lto_priv.22+0x216>
 80070d0:	2270      	movs	r2, #112	; 0x70
 80070d2:	601a      	str	r2, [r3, #0]

    instance->can->IER = CAN_IER_TMEIE | CAN_IER_FMPIE0; // TODO: review reference manual for other interrupt flags needed
 80070d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80070d6:	685b      	ldr	r3, [r3, #4]
 80070d8:	2203      	movs	r2, #3
 80070da:	615a      	str	r2, [r3, #20]
}
 80070dc:	3730      	adds	r7, #48	; 0x30
 80070de:	46bd      	mov	sp, r7
 80070e0:	bd80      	pop	{r7, pc}
 80070e2:	bf00      	nop
 80070e4:	40021000 	.word	0x40021000
 80070e8:	000f423f 	.word	0x000f423f
 80070ec:	02255100 	.word	0x02255100

080070f0 <can_driver_stm32_stop.lto_priv.23>:

static void can_driver_stm32_stop(void* ctx) {
 80070f0:	b580      	push	{r7, lr}
 80070f2:	b084      	sub	sp, #16
 80070f4:	af00      	add	r7, sp, #0
 80070f6:	6078      	str	r0, [r7, #4]
    struct can_driver_stm32_instance_s* instance = ctx;
 80070f8:	687b      	ldr	r3, [r7, #4]
 80070fa:	60fb      	str	r3, [r7, #12]

    instance->can->MCR = 0x00010002;
 80070fc:	68fb      	ldr	r3, [r7, #12]
 80070fe:	685b      	ldr	r3, [r3, #4]
 8007100:	4a0b      	ldr	r2, [pc, #44]	; (8007130 <can_driver_stm32_stop.lto_priv.23+0x40>)
 8007102:	601a      	str	r2, [r3, #0]
    instance->can->IER = 0x00000000;
 8007104:	68fb      	ldr	r3, [r7, #12]
 8007106:	685b      	ldr	r3, [r3, #4]
 8007108:	2200      	movs	r2, #0
 800710a:	615a      	str	r2, [r3, #20]

    nvicDisableVector(STM32_CAN1_TX_NUMBER);
 800710c:	2013      	movs	r0, #19
 800710e:	f002 f989 	bl	8009424 <nvicDisableVector>
    nvicDisableVector(STM32_CAN1_RX0_NUMBER);
 8007112:	2014      	movs	r0, #20
 8007114:	f002 f986 	bl	8009424 <nvicDisableVector>
    nvicDisableVector(STM32_CAN1_SCE_NUMBER);
 8007118:	2016      	movs	r0, #22
 800711a:	f002 f983 	bl	8009424 <nvicDisableVector>

    rccDisableCAN1(FALSE);
 800711e:	4a05      	ldr	r2, [pc, #20]	; (8007134 <can_driver_stm32_stop.lto_priv.23+0x44>)
 8007120:	4b04      	ldr	r3, [pc, #16]	; (8007134 <can_driver_stm32_stop.lto_priv.23+0x44>)
 8007122:	69db      	ldr	r3, [r3, #28]
 8007124:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8007128:	61d3      	str	r3, [r2, #28]
}
 800712a:	3710      	adds	r7, #16
 800712c:	46bd      	mov	sp, r7
 800712e:	bd80      	pop	{r7, pc}
 8007130:	00010002 	.word	0x00010002
 8007134:	40021000 	.word	0x40021000

08007138 <can_driver_stm32_abort_tx_mailbox_I>:

bool can_driver_stm32_abort_tx_mailbox_I(void* ctx, uint8_t mb_idx) {
 8007138:	b580      	push	{r7, lr}
 800713a:	b084      	sub	sp, #16
 800713c:	af00      	add	r7, sp, #0
 800713e:	6078      	str	r0, [r7, #4]
 8007140:	460b      	mov	r3, r1
 8007142:	70fb      	strb	r3, [r7, #3]
    struct can_driver_stm32_instance_s* instance = ctx;
 8007144:	687b      	ldr	r3, [r7, #4]
 8007146:	60fb      	str	r3, [r7, #12]

    chDbgCheckClassI();
 8007148:	f003 ff38 	bl	800afbc <chDbgCheckClassI>

    switch(mb_idx) {
 800714c:	78fb      	ldrb	r3, [r7, #3]
 800714e:	2b01      	cmp	r3, #1
 8007150:	d009      	beq.n	8007166 <can_driver_stm32_abort_tx_mailbox_I+0x2e>
 8007152:	2b02      	cmp	r3, #2
 8007154:	d00e      	beq.n	8007174 <can_driver_stm32_abort_tx_mailbox_I+0x3c>
 8007156:	2b00      	cmp	r3, #0
 8007158:	d113      	bne.n	8007182 <can_driver_stm32_abort_tx_mailbox_I+0x4a>
        case 0:
            instance->can->TSR = CAN_TSR_ABRQ0;
 800715a:	68fb      	ldr	r3, [r7, #12]
 800715c:	685b      	ldr	r3, [r3, #4]
 800715e:	2280      	movs	r2, #128	; 0x80
 8007160:	609a      	str	r2, [r3, #8]
            return true;
 8007162:	2301      	movs	r3, #1
 8007164:	e00e      	b.n	8007184 <can_driver_stm32_abort_tx_mailbox_I+0x4c>
        case 1:
            instance->can->TSR = CAN_TSR_ABRQ1;
 8007166:	68fb      	ldr	r3, [r7, #12]
 8007168:	685b      	ldr	r3, [r3, #4]
 800716a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 800716e:	609a      	str	r2, [r3, #8]
            return true;
 8007170:	2301      	movs	r3, #1
 8007172:	e007      	b.n	8007184 <can_driver_stm32_abort_tx_mailbox_I+0x4c>
        case 2:
            instance->can->TSR = CAN_TSR_ABRQ2;
 8007174:	68fb      	ldr	r3, [r7, #12]
 8007176:	685b      	ldr	r3, [r3, #4]
 8007178:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 800717c:	609a      	str	r2, [r3, #8]
            return true;
 800717e:	2301      	movs	r3, #1
 8007180:	e000      	b.n	8007184 <can_driver_stm32_abort_tx_mailbox_I+0x4c>
    }
    return false;
 8007182:	2300      	movs	r3, #0
}
 8007184:	4618      	mov	r0, r3
 8007186:	3710      	adds	r7, #16
 8007188:	46bd      	mov	sp, r7
 800718a:	bd80      	pop	{r7, pc}

0800718c <can_driver_stm32_load_tx_mailbox_I>:

bool can_driver_stm32_load_tx_mailbox_I(void* ctx, uint8_t mb_idx, struct can_frame_s* frame) {
 800718c:	b580      	push	{r7, lr}
 800718e:	b086      	sub	sp, #24
 8007190:	af00      	add	r7, sp, #0
 8007192:	60f8      	str	r0, [r7, #12]
 8007194:	460b      	mov	r3, r1
 8007196:	607a      	str	r2, [r7, #4]
 8007198:	72fb      	strb	r3, [r7, #11]
    struct can_driver_stm32_instance_s* instance = ctx;
 800719a:	68fb      	ldr	r3, [r7, #12]
 800719c:	617b      	str	r3, [r7, #20]

    chDbgCheckClassI();
 800719e:	f003 ff0d 	bl	800afbc <chDbgCheckClassI>

    CAN_TxMailBox_TypeDef* mailbox = &instance->can->sTxMailBox[mb_idx];
 80071a2:	697b      	ldr	r3, [r7, #20]
 80071a4:	685a      	ldr	r2, [r3, #4]
 80071a6:	7afb      	ldrb	r3, [r7, #11]
 80071a8:	3318      	adds	r3, #24
 80071aa:	011b      	lsls	r3, r3, #4
 80071ac:	4413      	add	r3, r2
 80071ae:	613b      	str	r3, [r7, #16]

    mailbox->TDTR = frame->DLC;
 80071b0:	687b      	ldr	r3, [r7, #4]
 80071b2:	781b      	ldrb	r3, [r3, #0]
 80071b4:	f3c3 0383 	ubfx	r3, r3, #2, #4
 80071b8:	b2db      	uxtb	r3, r3
 80071ba:	461a      	mov	r2, r3
 80071bc:	693b      	ldr	r3, [r7, #16]
 80071be:	605a      	str	r2, [r3, #4]
    mailbox->TDLR = frame->data32[0];
 80071c0:	687b      	ldr	r3, [r7, #4]
 80071c2:	689a      	ldr	r2, [r3, #8]
 80071c4:	693b      	ldr	r3, [r7, #16]
 80071c6:	609a      	str	r2, [r3, #8]
    mailbox->TDHR = frame->data32[1];
 80071c8:	687b      	ldr	r3, [r7, #4]
 80071ca:	68da      	ldr	r2, [r3, #12]
 80071cc:	693b      	ldr	r3, [r7, #16]
 80071ce:	60da      	str	r2, [r3, #12]

    if (frame->IDE) {
 80071d0:	687b      	ldr	r3, [r7, #4]
 80071d2:	781b      	ldrb	r3, [r3, #0]
 80071d4:	f003 0302 	and.w	r3, r3, #2
 80071d8:	b2db      	uxtb	r3, r3
 80071da:	2b00      	cmp	r3, #0
 80071dc:	d014      	beq.n	8007208 <can_driver_stm32_load_tx_mailbox_I+0x7c>
        mailbox->TIR = ((uint32_t)frame->EID << 3) | (frame->RTR ? CAN_TI0R_RTR : 0) | CAN_TI0R_IDE | CAN_TI0R_TXRQ;
 80071de:	687b      	ldr	r3, [r7, #4]
 80071e0:	685b      	ldr	r3, [r3, #4]
 80071e2:	f3c3 031c 	ubfx	r3, r3, #0, #29
 80071e6:	00da      	lsls	r2, r3, #3
 80071e8:	687b      	ldr	r3, [r7, #4]
 80071ea:	781b      	ldrb	r3, [r3, #0]
 80071ec:	f003 0301 	and.w	r3, r3, #1
 80071f0:	b2db      	uxtb	r3, r3
 80071f2:	2b00      	cmp	r3, #0
 80071f4:	d001      	beq.n	80071fa <can_driver_stm32_load_tx_mailbox_I+0x6e>
 80071f6:	2302      	movs	r3, #2
 80071f8:	e000      	b.n	80071fc <can_driver_stm32_load_tx_mailbox_I+0x70>
 80071fa:	2300      	movs	r3, #0
 80071fc:	4313      	orrs	r3, r2
 80071fe:	f043 0205 	orr.w	r2, r3, #5
 8007202:	693b      	ldr	r3, [r7, #16]
 8007204:	601a      	str	r2, [r3, #0]
 8007206:	e014      	b.n	8007232 <can_driver_stm32_load_tx_mailbox_I+0xa6>
    } else {
        mailbox->TIR = ((uint32_t)frame->SID << 21) | (frame->RTR ? CAN_TI0R_RTR : 0) | CAN_TI0R_TXRQ;
 8007208:	687b      	ldr	r3, [r7, #4]
 800720a:	889b      	ldrh	r3, [r3, #4]
 800720c:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8007210:	b29b      	uxth	r3, r3
 8007212:	055a      	lsls	r2, r3, #21
 8007214:	687b      	ldr	r3, [r7, #4]
 8007216:	781b      	ldrb	r3, [r3, #0]
 8007218:	f003 0301 	and.w	r3, r3, #1
 800721c:	b2db      	uxtb	r3, r3
 800721e:	2b00      	cmp	r3, #0
 8007220:	d001      	beq.n	8007226 <can_driver_stm32_load_tx_mailbox_I+0x9a>
 8007222:	2302      	movs	r3, #2
 8007224:	e000      	b.n	8007228 <can_driver_stm32_load_tx_mailbox_I+0x9c>
 8007226:	2300      	movs	r3, #0
 8007228:	4313      	orrs	r3, r2
 800722a:	f043 0201 	orr.w	r2, r3, #1
 800722e:	693b      	ldr	r3, [r7, #16]
 8007230:	601a      	str	r2, [r3, #0]
    }

    return true;
 8007232:	2301      	movs	r3, #1
}
 8007234:	4618      	mov	r0, r3
 8007236:	3718      	adds	r7, #24
 8007238:	46bd      	mov	sp, r7
 800723a:	bd80      	pop	{r7, pc}

0800723c <can_driver_stm32_retreive_rx_frame_I>:

static void can_driver_stm32_retreive_rx_frame_I(struct can_frame_s* frame, CAN_FIFOMailBox_TypeDef* mailbox) {
 800723c:	b480      	push	{r7}
 800723e:	b083      	sub	sp, #12
 8007240:	af00      	add	r7, sp, #0
 8007242:	6078      	str	r0, [r7, #4]
 8007244:	6039      	str	r1, [r7, #0]
    frame->data32[0] = mailbox->RDLR;
 8007246:	683b      	ldr	r3, [r7, #0]
 8007248:	689a      	ldr	r2, [r3, #8]
 800724a:	687b      	ldr	r3, [r7, #4]
 800724c:	609a      	str	r2, [r3, #8]
    frame->data32[1] = mailbox->RDHR;
 800724e:	683b      	ldr	r3, [r7, #0]
 8007250:	68da      	ldr	r2, [r3, #12]
 8007252:	687b      	ldr	r3, [r7, #4]
 8007254:	60da      	str	r2, [r3, #12]
    frame->RTR = (mailbox->RIR & CAN_RI0R_RTR) != 0;
 8007256:	683b      	ldr	r3, [r7, #0]
 8007258:	681b      	ldr	r3, [r3, #0]
 800725a:	f003 0302 	and.w	r3, r3, #2
 800725e:	2b00      	cmp	r3, #0
 8007260:	bf14      	ite	ne
 8007262:	2301      	movne	r3, #1
 8007264:	2300      	moveq	r3, #0
 8007266:	b2d9      	uxtb	r1, r3
 8007268:	687a      	ldr	r2, [r7, #4]
 800726a:	7813      	ldrb	r3, [r2, #0]
 800726c:	f361 0300 	bfi	r3, r1, #0, #1
 8007270:	7013      	strb	r3, [r2, #0]
    frame->IDE = (mailbox->RIR & CAN_RI0R_IDE) != 0;
 8007272:	683b      	ldr	r3, [r7, #0]
 8007274:	681b      	ldr	r3, [r3, #0]
 8007276:	f003 0304 	and.w	r3, r3, #4
 800727a:	2b00      	cmp	r3, #0
 800727c:	bf14      	ite	ne
 800727e:	2301      	movne	r3, #1
 8007280:	2300      	moveq	r3, #0
 8007282:	b2d9      	uxtb	r1, r3
 8007284:	687a      	ldr	r2, [r7, #4]
 8007286:	7813      	ldrb	r3, [r2, #0]
 8007288:	f361 0341 	bfi	r3, r1, #1, #1
 800728c:	7013      	strb	r3, [r2, #0]
    if (frame->IDE) {
 800728e:	687b      	ldr	r3, [r7, #4]
 8007290:	781b      	ldrb	r3, [r3, #0]
 8007292:	f003 0302 	and.w	r3, r3, #2
 8007296:	b2db      	uxtb	r3, r3
 8007298:	2b00      	cmp	r3, #0
 800729a:	d00a      	beq.n	80072b2 <can_driver_stm32_retreive_rx_frame_I+0x76>
        frame->EID = (mailbox->RIR & (CAN_RI0R_STID|CAN_RI0R_EXID)) >> 3;
 800729c:	683b      	ldr	r3, [r7, #0]
 800729e:	681b      	ldr	r3, [r3, #0]
 80072a0:	08db      	lsrs	r3, r3, #3
 80072a2:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 80072a6:	687a      	ldr	r2, [r7, #4]
 80072a8:	6853      	ldr	r3, [r2, #4]
 80072aa:	f361 031c 	bfi	r3, r1, #0, #29
 80072ae:	6053      	str	r3, [r2, #4]
 80072b0:	e00b      	b.n	80072ca <can_driver_stm32_retreive_rx_frame_I+0x8e>
    } else {
        frame->SID = (mailbox->RIR & CAN_RI0R_STID) >> 21;
 80072b2:	683b      	ldr	r3, [r7, #0]
 80072b4:	681b      	ldr	r3, [r3, #0]
 80072b6:	0d5b      	lsrs	r3, r3, #21
 80072b8:	b29b      	uxth	r3, r3
 80072ba:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80072be:	b299      	uxth	r1, r3
 80072c0:	687a      	ldr	r2, [r7, #4]
 80072c2:	8893      	ldrh	r3, [r2, #4]
 80072c4:	f361 030a 	bfi	r3, r1, #0, #11
 80072c8:	8093      	strh	r3, [r2, #4]
    }
    frame->DLC = mailbox->RDTR & CAN_RDT0R_DLC;
 80072ca:	683b      	ldr	r3, [r7, #0]
 80072cc:	685b      	ldr	r3, [r3, #4]
 80072ce:	b2db      	uxtb	r3, r3
 80072d0:	f003 030f 	and.w	r3, r3, #15
 80072d4:	b2d9      	uxtb	r1, r3
 80072d6:	687a      	ldr	r2, [r7, #4]
 80072d8:	7813      	ldrb	r3, [r2, #0]
 80072da:	f361 0385 	bfi	r3, r1, #2, #4
 80072de:	7013      	strb	r3, [r2, #0]
}
 80072e0:	370c      	adds	r7, #12
 80072e2:	46bd      	mov	sp, r7
 80072e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80072e8:	4770      	bx	lr
 80072ea:	bf00      	nop

080072ec <stm32_can_rx_handler>:

static void stm32_can_rx_handler(struct can_driver_stm32_instance_s* instance) {
 80072ec:	b580      	push	{r7, lr}
 80072ee:	b08c      	sub	sp, #48	; 0x30
 80072f0:	af00      	add	r7, sp, #0
 80072f2:	6078      	str	r0, [r7, #4]
    systime_t rx_systime = chVTGetSystemTimeX();
 80072f4:	f7ff fdbe 	bl	8006e74 <chVTGetSystemTimeX.lto_priv.117>
 80072f8:	4603      	mov	r3, r0
 80072fa:	85fb      	strh	r3, [r7, #46]	; 0x2e
    while (true) {
        chSysLockFromISR();
 80072fc:	f7ff fdaa 	bl	8006e54 <chSysLockFromISR>
        if ((instance->can->RF0R & CAN_RF0R_FMP0) == 0) {
 8007300:	687b      	ldr	r3, [r7, #4]
 8007302:	685b      	ldr	r3, [r3, #4]
 8007304:	68db      	ldr	r3, [r3, #12]
 8007306:	f003 0303 	and.w	r3, r3, #3
 800730a:	2b00      	cmp	r3, #0
 800730c:	d102      	bne.n	8007314 <stm32_can_rx_handler+0x28>
            chSysUnlockFromISR();
 800730e:	f7ff fda9 	bl	8006e64 <chSysUnlockFromISR>
 8007312:	e019      	b.n	8007348 <stm32_can_rx_handler+0x5c>
            break;
        }
        struct can_frame_s frame;
        can_driver_stm32_retreive_rx_frame_I(&frame, &instance->can->sFIFOMailBox[0]);
 8007314:	687b      	ldr	r3, [r7, #4]
 8007316:	685b      	ldr	r3, [r3, #4]
 8007318:	f503 73d8 	add.w	r3, r3, #432	; 0x1b0
 800731c:	f107 020c 	add.w	r2, r7, #12
 8007320:	4610      	mov	r0, r2
 8007322:	4619      	mov	r1, r3
 8007324:	f7ff ff8a 	bl	800723c <can_driver_stm32_retreive_rx_frame_I>
        can_driver_rx_frame_received_I(instance->frontend, 0, rx_systime, &frame);
 8007328:	687b      	ldr	r3, [r7, #4]
 800732a:	6819      	ldr	r1, [r3, #0]
 800732c:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800732e:	f107 030c 	add.w	r3, r7, #12
 8007332:	4608      	mov	r0, r1
 8007334:	2100      	movs	r1, #0
 8007336:	f7fe fe85 	bl	8006044 <can_driver_rx_frame_received_I>
        instance->can->RF0R = CAN_RF0R_RFOM0;
 800733a:	687b      	ldr	r3, [r7, #4]
 800733c:	685b      	ldr	r3, [r3, #4]
 800733e:	2220      	movs	r2, #32
 8007340:	60da      	str	r2, [r3, #12]
        chSysUnlockFromISR();
 8007342:	f7ff fd8f 	bl	8006e64 <chSysUnlockFromISR>
 8007346:	e7d9      	b.n	80072fc <stm32_can_rx_handler+0x10>
    }

    while (true) {
        chSysLockFromISR();
 8007348:	f7ff fd84 	bl	8006e54 <chSysLockFromISR>
        if ((instance->can->RF1R & CAN_RF1R_FMP1) == 0) {
 800734c:	687b      	ldr	r3, [r7, #4]
 800734e:	685b      	ldr	r3, [r3, #4]
 8007350:	691b      	ldr	r3, [r3, #16]
 8007352:	f003 0303 	and.w	r3, r3, #3
 8007356:	2b00      	cmp	r3, #0
 8007358:	d102      	bne.n	8007360 <stm32_can_rx_handler+0x74>
            chSysUnlockFromISR();
 800735a:	f7ff fd83 	bl	8006e64 <chSysUnlockFromISR>
 800735e:	e019      	b.n	8007394 <stm32_can_rx_handler+0xa8>
            break;
        }
        struct can_frame_s frame;
        can_driver_stm32_retreive_rx_frame_I(&frame, &instance->can->sFIFOMailBox[1]);
 8007360:	687b      	ldr	r3, [r7, #4]
 8007362:	685b      	ldr	r3, [r3, #4]
 8007364:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
 8007368:	f107 021c 	add.w	r2, r7, #28
 800736c:	4610      	mov	r0, r2
 800736e:	4619      	mov	r1, r3
 8007370:	f7ff ff64 	bl	800723c <can_driver_stm32_retreive_rx_frame_I>
        can_driver_rx_frame_received_I(instance->frontend, 1, rx_systime, &frame);
 8007374:	687b      	ldr	r3, [r7, #4]
 8007376:	6819      	ldr	r1, [r3, #0]
 8007378:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800737a:	f107 031c 	add.w	r3, r7, #28
 800737e:	4608      	mov	r0, r1
 8007380:	2101      	movs	r1, #1
 8007382:	f7fe fe5f 	bl	8006044 <can_driver_rx_frame_received_I>
        instance->can->RF1R = CAN_RF1R_RFOM1;
 8007386:	687b      	ldr	r3, [r7, #4]
 8007388:	685b      	ldr	r3, [r3, #4]
 800738a:	2220      	movs	r2, #32
 800738c:	611a      	str	r2, [r3, #16]
        chSysUnlockFromISR();
 800738e:	f7ff fd69 	bl	8006e64 <chSysUnlockFromISR>
 8007392:	e7d9      	b.n	8007348 <stm32_can_rx_handler+0x5c>
    }
}
 8007394:	3730      	adds	r7, #48	; 0x30
 8007396:	46bd      	mov	sp, r7
 8007398:	bd80      	pop	{r7, pc}
 800739a:	bf00      	nop

0800739c <stm32_can_tx_handler>:

static void stm32_can_tx_handler(struct can_driver_stm32_instance_s* instance) {
 800739c:	b580      	push	{r7, lr}
 800739e:	b084      	sub	sp, #16
 80073a0:	af00      	add	r7, sp, #0
 80073a2:	6078      	str	r0, [r7, #4]
    systime_t t_now = chVTGetSystemTimeX();
 80073a4:	f7ff fd66 	bl	8006e74 <chVTGetSystemTimeX.lto_priv.117>
 80073a8:	4603      	mov	r3, r0
 80073aa:	81fb      	strh	r3, [r7, #14]

    chSysLockFromISR();
 80073ac:	f7ff fd52 	bl	8006e54 <chSysLockFromISR>
    if ((instance->can->TSR & CAN_TSR_RQCP0) != 0) {
 80073b0:	687b      	ldr	r3, [r7, #4]
 80073b2:	685b      	ldr	r3, [r3, #4]
 80073b4:	689b      	ldr	r3, [r3, #8]
 80073b6:	f003 0301 	and.w	r3, r3, #1
 80073ba:	2b00      	cmp	r3, #0
 80073bc:	d014      	beq.n	80073e8 <stm32_can_tx_handler+0x4c>
        can_driver_tx_request_complete_I(instance->frontend, 0, (instance->can->TSR & CAN_TSR_TXOK0) != 0, t_now);
 80073be:	687b      	ldr	r3, [r7, #4]
 80073c0:	6819      	ldr	r1, [r3, #0]
 80073c2:	687b      	ldr	r3, [r7, #4]
 80073c4:	685b      	ldr	r3, [r3, #4]
 80073c6:	689b      	ldr	r3, [r3, #8]
 80073c8:	f003 0302 	and.w	r3, r3, #2
 80073cc:	2b00      	cmp	r3, #0
 80073ce:	bf14      	ite	ne
 80073d0:	2301      	movne	r3, #1
 80073d2:	2300      	moveq	r3, #0
 80073d4:	b2da      	uxtb	r2, r3
 80073d6:	89fb      	ldrh	r3, [r7, #14]
 80073d8:	4608      	mov	r0, r1
 80073da:	2100      	movs	r1, #0
 80073dc:	f7fe fddc 	bl	8005f98 <can_driver_tx_request_complete_I>
        instance->can->TSR = CAN_TSR_RQCP0;
 80073e0:	687b      	ldr	r3, [r7, #4]
 80073e2:	685b      	ldr	r3, [r3, #4]
 80073e4:	2201      	movs	r2, #1
 80073e6:	609a      	str	r2, [r3, #8]
    }

    if ((instance->can->TSR & CAN_TSR_RQCP1) != 0) {
 80073e8:	687b      	ldr	r3, [r7, #4]
 80073ea:	685b      	ldr	r3, [r3, #4]
 80073ec:	689b      	ldr	r3, [r3, #8]
 80073ee:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80073f2:	2b00      	cmp	r3, #0
 80073f4:	d015      	beq.n	8007422 <stm32_can_tx_handler+0x86>
        can_driver_tx_request_complete_I(instance->frontend, 1, (instance->can->TSR & CAN_TSR_TXOK1) != 0, t_now);
 80073f6:	687b      	ldr	r3, [r7, #4]
 80073f8:	6819      	ldr	r1, [r3, #0]
 80073fa:	687b      	ldr	r3, [r7, #4]
 80073fc:	685b      	ldr	r3, [r3, #4]
 80073fe:	689b      	ldr	r3, [r3, #8]
 8007400:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8007404:	2b00      	cmp	r3, #0
 8007406:	bf14      	ite	ne
 8007408:	2301      	movne	r3, #1
 800740a:	2300      	moveq	r3, #0
 800740c:	b2da      	uxtb	r2, r3
 800740e:	89fb      	ldrh	r3, [r7, #14]
 8007410:	4608      	mov	r0, r1
 8007412:	2101      	movs	r1, #1
 8007414:	f7fe fdc0 	bl	8005f98 <can_driver_tx_request_complete_I>
        instance->can->TSR = CAN_TSR_RQCP1;
 8007418:	687b      	ldr	r3, [r7, #4]
 800741a:	685b      	ldr	r3, [r3, #4]
 800741c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007420:	609a      	str	r2, [r3, #8]
    }

    if ((instance->can->TSR & CAN_TSR_RQCP2) != 0) {
 8007422:	687b      	ldr	r3, [r7, #4]
 8007424:	685b      	ldr	r3, [r3, #4]
 8007426:	689b      	ldr	r3, [r3, #8]
 8007428:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800742c:	2b00      	cmp	r3, #0
 800742e:	d015      	beq.n	800745c <stm32_can_tx_handler+0xc0>
        can_driver_tx_request_complete_I(instance->frontend, 2, (instance->can->TSR & CAN_TSR_TXOK2) != 0, t_now);
 8007430:	687b      	ldr	r3, [r7, #4]
 8007432:	6819      	ldr	r1, [r3, #0]
 8007434:	687b      	ldr	r3, [r7, #4]
 8007436:	685b      	ldr	r3, [r3, #4]
 8007438:	689b      	ldr	r3, [r3, #8]
 800743a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800743e:	2b00      	cmp	r3, #0
 8007440:	bf14      	ite	ne
 8007442:	2301      	movne	r3, #1
 8007444:	2300      	moveq	r3, #0
 8007446:	b2da      	uxtb	r2, r3
 8007448:	89fb      	ldrh	r3, [r7, #14]
 800744a:	4608      	mov	r0, r1
 800744c:	2102      	movs	r1, #2
 800744e:	f7fe fda3 	bl	8005f98 <can_driver_tx_request_complete_I>
        instance->can->TSR = CAN_TSR_RQCP2;
 8007452:	687b      	ldr	r3, [r7, #4]
 8007454:	685b      	ldr	r3, [r3, #4]
 8007456:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800745a:	609a      	str	r2, [r3, #8]
    }
    chSysUnlockFromISR();
 800745c:	f7ff fd02 	bl	8006e64 <chSysUnlockFromISR>
}
 8007460:	3710      	adds	r7, #16
 8007462:	46bd      	mov	sp, r7
 8007464:	bd80      	pop	{r7, pc}
 8007466:	bf00      	nop

08007468 <Vector8C>:

OSAL_IRQ_HANDLER(STM32_CAN1_TX_HANDLER) {
 8007468:	b580      	push	{r7, lr}
 800746a:	af00      	add	r7, sp, #0
    OSAL_IRQ_PROLOGUE();
 800746c:	f003 fd6e 	bl	800af4c <_dbg_check_enter_isr>

    stm32_can_tx_handler(&can1_instance);
 8007470:	4803      	ldr	r0, [pc, #12]	; (8007480 <Vector8C+0x18>)
 8007472:	f7ff ff93 	bl	800739c <stm32_can_tx_handler>

    OSAL_IRQ_EPILOGUE();
 8007476:	f003 fd85 	bl	800af84 <_dbg_check_leave_isr>
 800747a:	f002 fe29 	bl	800a0d0 <_port_irq_epilogue>
}
 800747e:	bd80      	pop	{r7, pc}
 8007480:	20001464 	.word	0x20001464

08007484 <Vector90>:

OSAL_IRQ_HANDLER(STM32_CAN1_RX0_HANDLER) {
 8007484:	b580      	push	{r7, lr}
 8007486:	af00      	add	r7, sp, #0
    OSAL_IRQ_PROLOGUE();
 8007488:	f003 fd60 	bl	800af4c <_dbg_check_enter_isr>

    stm32_can_rx_handler(&can1_instance);
 800748c:	4803      	ldr	r0, [pc, #12]	; (800749c <Vector90+0x18>)
 800748e:	f7ff ff2d 	bl	80072ec <stm32_can_rx_handler>

    OSAL_IRQ_EPILOGUE();
 8007492:	f003 fd77 	bl	800af84 <_dbg_check_leave_isr>
 8007496:	f002 fe1b 	bl	800a0d0 <_port_irq_epilogue>
}
 800749a:	bd80      	pop	{r7, pc}
 800749c:	20001464 	.word	0x20001464

080074a0 <port_lock.lto_priv.114>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80074a0:	b480      	push	{r7}
 80074a2:	b083      	sub	sp, #12
 80074a4:	af00      	add	r7, sp, #0
 80074a6:	2320      	movs	r3, #32
 80074a8:	607b      	str	r3, [r7, #4]
 80074aa:	687b      	ldr	r3, [r7, #4]
 80074ac:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80074b0:	370c      	adds	r7, #12
 80074b2:	46bd      	mov	sp, r7
 80074b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80074b8:	4770      	bx	lr
 80074ba:	bf00      	nop

080074bc <port_unlock.lto_priv.111>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80074bc:	b480      	push	{r7}
 80074be:	b083      	sub	sp, #12
 80074c0:	af00      	add	r7, sp, #0
 80074c2:	2300      	movs	r3, #0
 80074c4:	607b      	str	r3, [r7, #4]
 80074c6:	687b      	ldr	r3, [r7, #4]
 80074c8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80074cc:	370c      	adds	r7, #12
 80074ce:	46bd      	mov	sp, r7
 80074d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80074d4:	4770      	bx	lr
 80074d6:	bf00      	nop

080074d8 <chSysLock.lto_priv.126>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80074d8:	b580      	push	{r7, lr}
 80074da:	af00      	add	r7, sp, #0

  port_lock();
 80074dc:	f7ff ffe0 	bl	80074a0 <port_lock.lto_priv.114>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80074e0:	f003 fcdc 	bl	800ae9c <_dbg_check_lock>
}
 80074e4:	bd80      	pop	{r7, pc}
 80074e6:	bf00      	nop

080074e8 <chSysUnlock.lto_priv.124>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80074e8:	b580      	push	{r7, lr}
 80074ea:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 80074ec:	f003 fcec 	bl	800aec8 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80074f0:	4b09      	ldr	r3, [pc, #36]	; (8007518 <chSysUnlock.lto_priv.124+0x30>)
 80074f2:	681b      	ldr	r3, [r3, #0]
 80074f4:	4a08      	ldr	r2, [pc, #32]	; (8007518 <chSysUnlock.lto_priv.124+0x30>)
 80074f6:	4293      	cmp	r3, r2
 80074f8:	d00a      	beq.n	8007510 <chSysUnlock.lto_priv.124+0x28>
 80074fa:	4b07      	ldr	r3, [pc, #28]	; (8007518 <chSysUnlock.lto_priv.124+0x30>)
 80074fc:	699b      	ldr	r3, [r3, #24]
 80074fe:	689a      	ldr	r2, [r3, #8]
 8007500:	4b05      	ldr	r3, [pc, #20]	; (8007518 <chSysUnlock.lto_priv.124+0x30>)
 8007502:	681b      	ldr	r3, [r3, #0]
 8007504:	689b      	ldr	r3, [r3, #8]
 8007506:	429a      	cmp	r2, r3
 8007508:	d202      	bcs.n	8007510 <chSysUnlock.lto_priv.124+0x28>
 800750a:	4804      	ldr	r0, [pc, #16]	; (800751c <chSysUnlock.lto_priv.124+0x34>)
 800750c:	f003 fc78 	bl	800ae00 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8007510:	f7ff ffd4 	bl	80074bc <port_unlock.lto_priv.111>
}
 8007514:	bd80      	pop	{r7, pc}
 8007516:	bf00      	nop
 8007518:	20001338 	.word	0x20001338
 800751c:	0800ec30 	.word	0x0800ec30

08007520 <can_tx_queue_init>:

#if CH_DBG_ENABLE_CHECKS
static bool can_tx_queue_frame_exists_in_queue(struct can_tx_queue_s* instance, struct can_tx_frame_s* check_frame);
#endif

bool can_tx_queue_init(struct can_tx_queue_s* instance) {
 8007520:	b480      	push	{r7}
 8007522:	b083      	sub	sp, #12
 8007524:	af00      	add	r7, sp, #0
 8007526:	6078      	str	r0, [r7, #4]
    instance->head = NULL;
 8007528:	687b      	ldr	r3, [r7, #4]
 800752a:	2200      	movs	r2, #0
 800752c:	601a      	str	r2, [r3, #0]
    return true;
 800752e:	2301      	movs	r3, #1
}
 8007530:	4618      	mov	r0, r3
 8007532:	370c      	adds	r7, #12
 8007534:	46bd      	mov	sp, r7
 8007536:	f85d 7b04 	ldr.w	r7, [sp], #4
 800753a:	4770      	bx	lr

0800753c <can_tx_queue_push_I>:

void can_tx_queue_push_I(struct can_tx_queue_s* instance, struct can_tx_frame_s* push_frame) {
 800753c:	b580      	push	{r7, lr}
 800753e:	b084      	sub	sp, #16
 8007540:	af00      	add	r7, sp, #0
 8007542:	6078      	str	r0, [r7, #4]
 8007544:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 8007546:	f003 fd39 	bl	800afbc <chDbgCheckClassI>
    
#if CH_DBG_ENABLE_CHECKS
    chDbgCheck(!can_tx_queue_frame_exists_in_queue(instance, push_frame));
 800754a:	6878      	ldr	r0, [r7, #4]
 800754c:	6839      	ldr	r1, [r7, #0]
 800754e:	f000 f8c9 	bl	80076e4 <can_tx_queue_frame_exists_in_queue>
 8007552:	4603      	mov	r3, r0
 8007554:	2b00      	cmp	r3, #0
 8007556:	d002      	beq.n	800755e <can_tx_queue_push_I+0x22>
 8007558:	4812      	ldr	r0, [pc, #72]	; (80075a4 <can_tx_queue_push_I+0x68>)
 800755a:	f003 fc51 	bl	800ae00 <chSysHalt>
#endif

    can_frame_priority_t push_frame_prio = can_get_tx_frame_priority_X(push_frame);
 800755e:	6838      	ldr	r0, [r7, #0]
 8007560:	f000 f984 	bl	800786c <can_get_tx_frame_priority_X>
 8007564:	60b8      	str	r0, [r7, #8]

    struct can_tx_frame_s** insert_ptr = &instance->head;
 8007566:	687b      	ldr	r3, [r7, #4]
 8007568:	60fb      	str	r3, [r7, #12]
 800756a:	e003      	b.n	8007574 <can_tx_queue_push_I+0x38>
    while(*insert_ptr != NULL && push_frame_prio <= can_get_tx_frame_priority_X(*insert_ptr)) {
        insert_ptr = &(*insert_ptr)->next;
 800756c:	68fb      	ldr	r3, [r7, #12]
 800756e:	681b      	ldr	r3, [r3, #0]
 8007570:	3318      	adds	r3, #24
 8007572:	60fb      	str	r3, [r7, #12]
#endif

    can_frame_priority_t push_frame_prio = can_get_tx_frame_priority_X(push_frame);

    struct can_tx_frame_s** insert_ptr = &instance->head;
    while(*insert_ptr != NULL && push_frame_prio <= can_get_tx_frame_priority_X(*insert_ptr)) {
 8007574:	68fb      	ldr	r3, [r7, #12]
 8007576:	681b      	ldr	r3, [r3, #0]
 8007578:	2b00      	cmp	r3, #0
 800757a:	d008      	beq.n	800758e <can_tx_queue_push_I+0x52>
 800757c:	68fb      	ldr	r3, [r7, #12]
 800757e:	681b      	ldr	r3, [r3, #0]
 8007580:	4618      	mov	r0, r3
 8007582:	f000 f973 	bl	800786c <can_get_tx_frame_priority_X>
 8007586:	4602      	mov	r2, r0
 8007588:	68bb      	ldr	r3, [r7, #8]
 800758a:	429a      	cmp	r2, r3
 800758c:	d2ee      	bcs.n	800756c <can_tx_queue_push_I+0x30>
        insert_ptr = &(*insert_ptr)->next;
    }

    push_frame->next = *insert_ptr;
 800758e:	68fb      	ldr	r3, [r7, #12]
 8007590:	681a      	ldr	r2, [r3, #0]
 8007592:	683b      	ldr	r3, [r7, #0]
 8007594:	619a      	str	r2, [r3, #24]
    *insert_ptr = push_frame;
 8007596:	68fb      	ldr	r3, [r7, #12]
 8007598:	683a      	ldr	r2, [r7, #0]
 800759a:	601a      	str	r2, [r3, #0]
}
 800759c:	3710      	adds	r7, #16
 800759e:	46bd      	mov	sp, r7
 80075a0:	bd80      	pop	{r7, pc}
 80075a2:	bf00      	nop
 80075a4:	0800ec1c 	.word	0x0800ec1c

080075a8 <can_tx_queue_push>:

void can_tx_queue_push(struct can_tx_queue_s* instance, struct can_tx_frame_s* push_frame) {
 80075a8:	b580      	push	{r7, lr}
 80075aa:	b082      	sub	sp, #8
 80075ac:	af00      	add	r7, sp, #0
 80075ae:	6078      	str	r0, [r7, #4]
 80075b0:	6039      	str	r1, [r7, #0]
    chSysLock();
 80075b2:	f7ff ff91 	bl	80074d8 <chSysLock.lto_priv.126>
    can_tx_queue_push_I(instance, push_frame);
 80075b6:	6878      	ldr	r0, [r7, #4]
 80075b8:	6839      	ldr	r1, [r7, #0]
 80075ba:	f7ff ffbf 	bl	800753c <can_tx_queue_push_I>
    chSysUnlock();
 80075be:	f7ff ff93 	bl	80074e8 <chSysUnlock.lto_priv.124>
}
 80075c2:	3708      	adds	r7, #8
 80075c4:	46bd      	mov	sp, r7
 80075c6:	bd80      	pop	{r7, pc}

080075c8 <can_tx_queue_iterate_I>:
    chSysLock();
    can_tx_queue_push_ahead_I(instance, push_frame);
    chSysUnlock();
}

bool can_tx_queue_iterate_I(struct can_tx_queue_s* instance, struct can_tx_frame_s** frame_ptr) {
 80075c8:	b580      	push	{r7, lr}
 80075ca:	b082      	sub	sp, #8
 80075cc:	af00      	add	r7, sp, #0
 80075ce:	6078      	str	r0, [r7, #4]
 80075d0:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 80075d2:	f003 fcf3 	bl	800afbc <chDbgCheckClassI>
    chDbgCheck(frame_ptr != NULL);
 80075d6:	683b      	ldr	r3, [r7, #0]
 80075d8:	2b00      	cmp	r3, #0
 80075da:	d102      	bne.n	80075e2 <can_tx_queue_iterate_I+0x1a>
 80075dc:	4810      	ldr	r0, [pc, #64]	; (8007620 <can_tx_queue_iterate_I+0x58>)
 80075de:	f003 fc0f 	bl	800ae00 <chSysHalt>

    if (frame_ptr == NULL) {
 80075e2:	683b      	ldr	r3, [r7, #0]
 80075e4:	2b00      	cmp	r3, #0
 80075e6:	d101      	bne.n	80075ec <can_tx_queue_iterate_I+0x24>
        return false;
 80075e8:	2300      	movs	r3, #0
 80075ea:	e014      	b.n	8007616 <can_tx_queue_iterate_I+0x4e>
    }

    if (*frame_ptr == NULL) {
 80075ec:	683b      	ldr	r3, [r7, #0]
 80075ee:	681b      	ldr	r3, [r3, #0]
 80075f0:	2b00      	cmp	r3, #0
 80075f2:	d104      	bne.n	80075fe <can_tx_queue_iterate_I+0x36>
        *frame_ptr = instance->head;
 80075f4:	687b      	ldr	r3, [r7, #4]
 80075f6:	681a      	ldr	r2, [r3, #0]
 80075f8:	683b      	ldr	r3, [r7, #0]
 80075fa:	601a      	str	r2, [r3, #0]
 80075fc:	e004      	b.n	8007608 <can_tx_queue_iterate_I+0x40>
    } else {
        *frame_ptr = (*frame_ptr)->next;
 80075fe:	683b      	ldr	r3, [r7, #0]
 8007600:	681b      	ldr	r3, [r3, #0]
 8007602:	699a      	ldr	r2, [r3, #24]
 8007604:	683b      	ldr	r3, [r7, #0]
 8007606:	601a      	str	r2, [r3, #0]
    }

    return *frame_ptr != NULL;
 8007608:	683b      	ldr	r3, [r7, #0]
 800760a:	681b      	ldr	r3, [r3, #0]
 800760c:	2b00      	cmp	r3, #0
 800760e:	bf14      	ite	ne
 8007610:	2301      	movne	r3, #1
 8007612:	2300      	moveq	r3, #0
 8007614:	b2db      	uxtb	r3, r3
}
 8007616:	4618      	mov	r0, r3
 8007618:	3708      	adds	r7, #8
 800761a:	46bd      	mov	sp, r7
 800761c:	bd80      	pop	{r7, pc}
 800761e:	bf00      	nop
 8007620:	0800ec3c 	.word	0x0800ec3c

08007624 <can_tx_queue_peek_I>:
#endif

    LINKED_LIST_REMOVE(struct can_tx_frame_s, instance->head, frame);
}

struct can_tx_frame_s* can_tx_queue_peek_I(struct can_tx_queue_s* instance) {
 8007624:	b580      	push	{r7, lr}
 8007626:	b082      	sub	sp, #8
 8007628:	af00      	add	r7, sp, #0
 800762a:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
 800762c:	f003 fcc6 	bl	800afbc <chDbgCheckClassI>
    
    return instance->head;
 8007630:	687b      	ldr	r3, [r7, #4]
 8007632:	681b      	ldr	r3, [r3, #0]
}
 8007634:	4618      	mov	r0, r3
 8007636:	3708      	adds	r7, #8
 8007638:	46bd      	mov	sp, r7
 800763a:	bd80      	pop	{r7, pc}

0800763c <can_tx_queue_pop_I>:
    struct can_tx_frame_s* ret = can_tx_queue_peek_I(instance);
    chSysUnlock();
    return ret;
}

void can_tx_queue_pop_I(struct can_tx_queue_s* instance) {
 800763c:	b580      	push	{r7, lr}
 800763e:	b082      	sub	sp, #8
 8007640:	af00      	add	r7, sp, #0
 8007642:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
 8007644:	f003 fcba 	bl	800afbc <chDbgCheckClassI>

    if (instance->head) {
 8007648:	687b      	ldr	r3, [r7, #4]
 800764a:	681b      	ldr	r3, [r3, #0]
 800764c:	2b00      	cmp	r3, #0
 800764e:	d004      	beq.n	800765a <can_tx_queue_pop_I+0x1e>
        instance->head = instance->head->next;
 8007650:	687b      	ldr	r3, [r7, #4]
 8007652:	681b      	ldr	r3, [r3, #0]
 8007654:	699a      	ldr	r2, [r3, #24]
 8007656:	687b      	ldr	r3, [r7, #4]
 8007658:	601a      	str	r2, [r3, #0]
    }
}
 800765a:	3708      	adds	r7, #8
 800765c:	46bd      	mov	sp, r7
 800765e:	bd80      	pop	{r7, pc}

08007660 <can_tx_queue_pop_expired_I>:
    chSysLock();
    can_tx_queue_pop_I(instance);
    chSysUnlock();
}

struct can_tx_frame_s* can_tx_queue_pop_expired_I(struct can_tx_queue_s* instance) {
 8007660:	b580      	push	{r7, lr}
 8007662:	b084      	sub	sp, #16
 8007664:	af00      	add	r7, sp, #0
 8007666:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
 8007668:	f003 fca8 	bl	800afbc <chDbgCheckClassI>
    
    struct can_tx_frame_s* ret = NULL;
 800766c:	2300      	movs	r3, #0
 800766e:	60fb      	str	r3, [r7, #12]
    struct can_tx_frame_s** expired_ptr = &instance->head;
 8007670:	687b      	ldr	r3, [r7, #4]
 8007672:	60bb      	str	r3, [r7, #8]
 8007674:	e003      	b.n	800767e <can_tx_queue_pop_expired_I+0x1e>
    while (*expired_ptr && !can_tx_frame_expired_X(*expired_ptr)) {
        expired_ptr = &(*expired_ptr)->next;
 8007676:	68bb      	ldr	r3, [r7, #8]
 8007678:	681b      	ldr	r3, [r3, #0]
 800767a:	3318      	adds	r3, #24
 800767c:	60bb      	str	r3, [r7, #8]
struct can_tx_frame_s* can_tx_queue_pop_expired_I(struct can_tx_queue_s* instance) {
    chDbgCheckClassI();
    
    struct can_tx_frame_s* ret = NULL;
    struct can_tx_frame_s** expired_ptr = &instance->head;
    while (*expired_ptr && !can_tx_frame_expired_X(*expired_ptr)) {
 800767e:	68bb      	ldr	r3, [r7, #8]
 8007680:	681b      	ldr	r3, [r3, #0]
 8007682:	2b00      	cmp	r3, #0
 8007684:	d00a      	beq.n	800769c <can_tx_queue_pop_expired_I+0x3c>
 8007686:	68bb      	ldr	r3, [r7, #8]
 8007688:	681b      	ldr	r3, [r3, #0]
 800768a:	4618      	mov	r0, r3
 800768c:	f000 f862 	bl	8007754 <can_tx_frame_expired_X>
 8007690:	4603      	mov	r3, r0
 8007692:	f083 0301 	eor.w	r3, r3, #1
 8007696:	b2db      	uxtb	r3, r3
 8007698:	2b00      	cmp	r3, #0
 800769a:	d1ec      	bne.n	8007676 <can_tx_queue_pop_expired_I+0x16>
        expired_ptr = &(*expired_ptr)->next;
    }
    
    if (*expired_ptr) {
 800769c:	68bb      	ldr	r3, [r7, #8]
 800769e:	681b      	ldr	r3, [r3, #0]
 80076a0:	2b00      	cmp	r3, #0
 80076a2:	d007      	beq.n	80076b4 <can_tx_queue_pop_expired_I+0x54>
        ret = *expired_ptr;
 80076a4:	68bb      	ldr	r3, [r7, #8]
 80076a6:	681b      	ldr	r3, [r3, #0]
 80076a8:	60fb      	str	r3, [r7, #12]
        *expired_ptr = (*expired_ptr)->next;
 80076aa:	68bb      	ldr	r3, [r7, #8]
 80076ac:	681b      	ldr	r3, [r3, #0]
 80076ae:	699a      	ldr	r2, [r3, #24]
 80076b0:	68bb      	ldr	r3, [r7, #8]
 80076b2:	601a      	str	r2, [r3, #0]
    }
    
    return ret;
 80076b4:	68fb      	ldr	r3, [r7, #12]
}
 80076b6:	4618      	mov	r0, r3
 80076b8:	3710      	adds	r7, #16
 80076ba:	46bd      	mov	sp, r7
 80076bc:	bd80      	pop	{r7, pc}
 80076be:	bf00      	nop

080076c0 <can_tx_queue_pop_expired>:

struct can_tx_frame_s* can_tx_queue_pop_expired(struct can_tx_queue_s* instance) {
 80076c0:	b580      	push	{r7, lr}
 80076c2:	b084      	sub	sp, #16
 80076c4:	af00      	add	r7, sp, #0
 80076c6:	6078      	str	r0, [r7, #4]
    struct can_tx_frame_s* ret;
    chSysLock();
 80076c8:	f7ff ff06 	bl	80074d8 <chSysLock.lto_priv.126>
    ret = can_tx_queue_pop_expired_I(instance);
 80076cc:	6878      	ldr	r0, [r7, #4]
 80076ce:	f7ff ffc7 	bl	8007660 <can_tx_queue_pop_expired_I>
 80076d2:	60f8      	str	r0, [r7, #12]
    chSysUnlock();
 80076d4:	f7ff ff08 	bl	80074e8 <chSysUnlock.lto_priv.124>
    return ret;
 80076d8:	68fb      	ldr	r3, [r7, #12]
}
 80076da:	4618      	mov	r0, r3
 80076dc:	3710      	adds	r7, #16
 80076de:	46bd      	mov	sp, r7
 80076e0:	bd80      	pop	{r7, pc}
 80076e2:	bf00      	nop

080076e4 <can_tx_queue_frame_exists_in_queue>:

#if CH_DBG_ENABLE_CHECKS
static bool can_tx_queue_frame_exists_in_queue(struct can_tx_queue_s* instance, struct can_tx_frame_s* check_frame) {
 80076e4:	b580      	push	{r7, lr}
 80076e6:	b084      	sub	sp, #16
 80076e8:	af00      	add	r7, sp, #0
 80076ea:	6078      	str	r0, [r7, #4]
 80076ec:	6039      	str	r1, [r7, #0]
    struct can_tx_frame_s* frame = NULL;
 80076ee:	2300      	movs	r3, #0
 80076f0:	60fb      	str	r3, [r7, #12]
 80076f2:	e005      	b.n	8007700 <can_tx_queue_frame_exists_in_queue+0x1c>
    while (can_tx_queue_iterate_I(instance, &frame)) {
        if (check_frame == frame) {
 80076f4:	68fb      	ldr	r3, [r7, #12]
 80076f6:	683a      	ldr	r2, [r7, #0]
 80076f8:	429a      	cmp	r2, r3
 80076fa:	d101      	bne.n	8007700 <can_tx_queue_frame_exists_in_queue+0x1c>
            return true;
 80076fc:	2301      	movs	r3, #1
 80076fe:	e009      	b.n	8007714 <can_tx_queue_frame_exists_in_queue+0x30>
}

#if CH_DBG_ENABLE_CHECKS
static bool can_tx_queue_frame_exists_in_queue(struct can_tx_queue_s* instance, struct can_tx_frame_s* check_frame) {
    struct can_tx_frame_s* frame = NULL;
    while (can_tx_queue_iterate_I(instance, &frame)) {
 8007700:	f107 030c 	add.w	r3, r7, #12
 8007704:	6878      	ldr	r0, [r7, #4]
 8007706:	4619      	mov	r1, r3
 8007708:	f7ff ff5e 	bl	80075c8 <can_tx_queue_iterate_I>
 800770c:	4603      	mov	r3, r0
 800770e:	2b00      	cmp	r3, #0
 8007710:	d1f0      	bne.n	80076f4 <can_tx_queue_frame_exists_in_queue+0x10>
        if (check_frame == frame) {
            return true;
        }
    }
    return false;
 8007712:	2300      	movs	r3, #0
}
 8007714:	4618      	mov	r0, r3
 8007716:	3710      	adds	r7, #16
 8007718:	46bd      	mov	sp, r7
 800771a:	bd80      	pop	{r7, pc}

0800771c <st_lld_get_counter.lto_priv.108>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 800771c:	b480      	push	{r7}
 800771e:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 8007720:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8007724:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007726:	b29b      	uxth	r3, r3
}
 8007728:	4618      	mov	r0, r3
 800772a:	46bd      	mov	sp, r7
 800772c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007730:	4770      	bx	lr
 8007732:	bf00      	nop

08007734 <port_timer_get_time.lto_priv.105>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8007734:	b580      	push	{r7, lr}
 8007736:	af00      	add	r7, sp, #0

  return stGetCounter();
 8007738:	f7ff fff0 	bl	800771c <st_lld_get_counter.lto_priv.108>
 800773c:	4603      	mov	r3, r0
}
 800773e:	4618      	mov	r0, r3
 8007740:	bd80      	pop	{r7, pc}
 8007742:	bf00      	nop

08007744 <chVTGetSystemTimeX.lto_priv.118>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8007744:	b580      	push	{r7, lr}
 8007746:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8007748:	f7ff fff4 	bl	8007734 <port_timer_get_time.lto_priv.105>
 800774c:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800774e:	4618      	mov	r0, r3
 8007750:	bd80      	pop	{r7, pc}
 8007752:	bf00      	nop

08007754 <can_tx_frame_expired_X>:
#include "can_helpers.h"

bool can_tx_frame_expired_X(struct can_tx_frame_s* frame) {
 8007754:	b580      	push	{r7, lr}
 8007756:	b082      	sub	sp, #8
 8007758:	af00      	add	r7, sp, #0
 800775a:	6078      	str	r0, [r7, #4]
    return chVTGetSystemTimeX() - frame->creation_systime > frame->tx_timeout;
 800775c:	f7ff fff2 	bl	8007744 <chVTGetSystemTimeX.lto_priv.118>
 8007760:	4603      	mov	r3, r0
 8007762:	461a      	mov	r2, r3
 8007764:	687b      	ldr	r3, [r7, #4]
 8007766:	8a1b      	ldrh	r3, [r3, #16]
 8007768:	1ad3      	subs	r3, r2, r3
 800776a:	687a      	ldr	r2, [r7, #4]
 800776c:	8a52      	ldrh	r2, [r2, #18]
 800776e:	4293      	cmp	r3, r2
 8007770:	bfcc      	ite	gt
 8007772:	2301      	movgt	r3, #1
 8007774:	2300      	movle	r3, #0
 8007776:	b2db      	uxtb	r3, r3
}
 8007778:	4618      	mov	r0, r3
 800777a:	3708      	adds	r7, #8
 800777c:	46bd      	mov	sp, r7
 800777e:	bd80      	pop	{r7, pc}

08007780 <can_tx_frame_time_until_expire_X>:

systime_t can_tx_frame_time_until_expire_X(struct can_tx_frame_s* frame, systime_t t_now) {
 8007780:	b480      	push	{r7}
 8007782:	b085      	sub	sp, #20
 8007784:	af00      	add	r7, sp, #0
 8007786:	6078      	str	r0, [r7, #4]
 8007788:	460b      	mov	r3, r1
 800778a:	807b      	strh	r3, [r7, #2]
    if (frame->tx_timeout == TIME_INFINITE) {
 800778c:	687b      	ldr	r3, [r7, #4]
 800778e:	8a5b      	ldrh	r3, [r3, #18]
 8007790:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8007794:	4293      	cmp	r3, r2
 8007796:	d102      	bne.n	800779e <can_tx_frame_time_until_expire_X+0x1e>
        return TIME_INFINITE;
 8007798:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800779c:	e010      	b.n	80077c0 <can_tx_frame_time_until_expire_X+0x40>
    }

    systime_t time_elapsed = t_now - frame->creation_systime;
 800779e:	687b      	ldr	r3, [r7, #4]
 80077a0:	8a1b      	ldrh	r3, [r3, #16]
 80077a2:	887a      	ldrh	r2, [r7, #2]
 80077a4:	1ad3      	subs	r3, r2, r3
 80077a6:	81fb      	strh	r3, [r7, #14]
    if (time_elapsed > frame->tx_timeout) {
 80077a8:	687b      	ldr	r3, [r7, #4]
 80077aa:	8a5b      	ldrh	r3, [r3, #18]
 80077ac:	89fa      	ldrh	r2, [r7, #14]
 80077ae:	429a      	cmp	r2, r3
 80077b0:	d901      	bls.n	80077b6 <can_tx_frame_time_until_expire_X+0x36>
        return TIME_IMMEDIATE;
 80077b2:	2300      	movs	r3, #0
 80077b4:	e004      	b.n	80077c0 <can_tx_frame_time_until_expire_X+0x40>
    }

    return frame->tx_timeout - time_elapsed;
 80077b6:	687b      	ldr	r3, [r7, #4]
 80077b8:	8a5a      	ldrh	r2, [r3, #18]
 80077ba:	89fb      	ldrh	r3, [r7, #14]
 80077bc:	1ad3      	subs	r3, r2, r3
 80077be:	b29b      	uxth	r3, r3
}
 80077c0:	4618      	mov	r0, r3
 80077c2:	3714      	adds	r7, #20
 80077c4:	46bd      	mov	sp, r7
 80077c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80077ca:	4770      	bx	lr

080077cc <can_get_frame_priority_X>:

can_frame_priority_t can_get_frame_priority_X(const struct can_frame_s* frame) {
 80077cc:	b480      	push	{r7}
 80077ce:	b085      	sub	sp, #20
 80077d0:	af00      	add	r7, sp, #0
 80077d2:	6078      	str	r0, [r7, #4]
    can_frame_priority_t ret = 0;
 80077d4:	2300      	movs	r3, #0
 80077d6:	60fb      	str	r3, [r7, #12]

    if (frame->IDE) {
 80077d8:	687b      	ldr	r3, [r7, #4]
 80077da:	781b      	ldrb	r3, [r3, #0]
 80077dc:	f003 0302 	and.w	r3, r3, #2
 80077e0:	b2db      	uxtb	r3, r3
 80077e2:	2b00      	cmp	r3, #0
 80077e4:	d026      	beq.n	8007834 <can_get_frame_priority_X+0x68>
        ret |= ((frame->EID >> 18) & 0x7ff) << 21; // Identifier A
 80077e6:	687b      	ldr	r3, [r7, #4]
 80077e8:	685b      	ldr	r3, [r3, #4]
 80077ea:	f3c3 031c 	ubfx	r3, r3, #0, #29
 80077ee:	149b      	asrs	r3, r3, #18
 80077f0:	055b      	lsls	r3, r3, #21
 80077f2:	461a      	mov	r2, r3
 80077f4:	68fb      	ldr	r3, [r7, #12]
 80077f6:	4313      	orrs	r3, r2
 80077f8:	60fb      	str	r3, [r7, #12]
        ret |= 1<<20; // SRR
 80077fa:	68fb      	ldr	r3, [r7, #12]
 80077fc:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8007800:	60fb      	str	r3, [r7, #12]
        ret |= 1<<19; // EID
 8007802:	68fb      	ldr	r3, [r7, #12]
 8007804:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8007808:	60fb      	str	r3, [r7, #12]
        ret |= (frame->EID & 0x3ffff) << 1; // Identifier B
 800780a:	687b      	ldr	r3, [r7, #4]
 800780c:	685b      	ldr	r3, [r3, #4]
 800780e:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8007812:	f3c3 0311 	ubfx	r3, r3, #0, #18
 8007816:	005b      	lsls	r3, r3, #1
 8007818:	461a      	mov	r2, r3
 800781a:	68fb      	ldr	r3, [r7, #12]
 800781c:	4313      	orrs	r3, r2
 800781e:	60fb      	str	r3, [r7, #12]
        ret |= frame->RTR; // RTR
 8007820:	687b      	ldr	r3, [r7, #4]
 8007822:	781b      	ldrb	r3, [r3, #0]
 8007824:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8007828:	b2db      	uxtb	r3, r3
 800782a:	461a      	mov	r2, r3
 800782c:	68fb      	ldr	r3, [r7, #12]
 800782e:	4313      	orrs	r3, r2
 8007830:	60fb      	str	r3, [r7, #12]
 8007832:	e013      	b.n	800785c <can_get_frame_priority_X+0x90>
    } else {
        ret |= frame->SID << 21; // Identifier
 8007834:	687b      	ldr	r3, [r7, #4]
 8007836:	889b      	ldrh	r3, [r3, #4]
 8007838:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800783c:	b29b      	uxth	r3, r3
 800783e:	055b      	lsls	r3, r3, #21
 8007840:	461a      	mov	r2, r3
 8007842:	68fb      	ldr	r3, [r7, #12]
 8007844:	4313      	orrs	r3, r2
 8007846:	60fb      	str	r3, [r7, #12]
        ret |= frame->RTR << 20; // RTR
 8007848:	687b      	ldr	r3, [r7, #4]
 800784a:	781b      	ldrb	r3, [r3, #0]
 800784c:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8007850:	b2db      	uxtb	r3, r3
 8007852:	051b      	lsls	r3, r3, #20
 8007854:	461a      	mov	r2, r3
 8007856:	68fb      	ldr	r3, [r7, #12]
 8007858:	4313      	orrs	r3, r2
 800785a:	60fb      	str	r3, [r7, #12]
    }

    return ~ret;
 800785c:	68fb      	ldr	r3, [r7, #12]
 800785e:	43db      	mvns	r3, r3
}
 8007860:	4618      	mov	r0, r3
 8007862:	3714      	adds	r7, #20
 8007864:	46bd      	mov	sp, r7
 8007866:	f85d 7b04 	ldr.w	r7, [sp], #4
 800786a:	4770      	bx	lr

0800786c <can_get_tx_frame_priority_X>:

can_frame_priority_t can_get_tx_frame_priority_X(const struct can_tx_frame_s* frame) {
 800786c:	b580      	push	{r7, lr}
 800786e:	b082      	sub	sp, #8
 8007870:	af00      	add	r7, sp, #0
 8007872:	6078      	str	r0, [r7, #4]
    return can_get_frame_priority_X(&frame->content);
 8007874:	687b      	ldr	r3, [r7, #4]
 8007876:	4618      	mov	r0, r3
 8007878:	f7ff ffa8 	bl	80077cc <can_get_frame_priority_X>
 800787c:	4603      	mov	r3, r0
}
 800787e:	4618      	mov	r0, r3
 8007880:	3708      	adds	r7, #8
 8007882:	46bd      	mov	sp, r7
 8007884:	bd80      	pop	{r7, pc}
 8007886:	bf00      	nop

08007888 <port_lock.lto_priv.115>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8007888:	b480      	push	{r7}
 800788a:	b083      	sub	sp, #12
 800788c:	af00      	add	r7, sp, #0
 800788e:	2320      	movs	r3, #32
 8007890:	607b      	str	r3, [r7, #4]
 8007892:	687b      	ldr	r3, [r7, #4]
 8007894:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8007898:	370c      	adds	r7, #12
 800789a:	46bd      	mov	sp, r7
 800789c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80078a0:	4770      	bx	lr
 80078a2:	bf00      	nop

080078a4 <port_unlock.lto_priv.112>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80078a4:	b480      	push	{r7}
 80078a6:	b083      	sub	sp, #12
 80078a8:	af00      	add	r7, sp, #0
 80078aa:	2300      	movs	r3, #0
 80078ac:	607b      	str	r3, [r7, #4]
 80078ae:	687b      	ldr	r3, [r7, #4]
 80078b0:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80078b4:	370c      	adds	r7, #12
 80078b6:	46bd      	mov	sp, r7
 80078b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80078bc:	4770      	bx	lr
 80078be:	bf00      	nop

080078c0 <st_lld_get_counter.lto_priv.109>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 80078c0:	b480      	push	{r7}
 80078c2:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 80078c4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80078c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80078ca:	b29b      	uxth	r3, r3
}
 80078cc:	4618      	mov	r0, r3
 80078ce:	46bd      	mov	sp, r7
 80078d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80078d4:	4770      	bx	lr
 80078d6:	bf00      	nop

080078d8 <port_timer_get_time.lto_priv.106>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 80078d8:	b580      	push	{r7, lr}
 80078da:	af00      	add	r7, sp, #0

  return stGetCounter();
 80078dc:	f7ff fff0 	bl	80078c0 <st_lld_get_counter.lto_priv.109>
 80078e0:	4603      	mov	r3, r0
}
 80078e2:	4618      	mov	r0, r3
 80078e4:	bd80      	pop	{r7, pc}
 80078e6:	bf00      	nop

080078e8 <chSysLock.lto_priv.102>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80078e8:	b580      	push	{r7, lr}
 80078ea:	af00      	add	r7, sp, #0

  port_lock();
 80078ec:	f7ff ffcc 	bl	8007888 <port_lock.lto_priv.115>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80078f0:	f003 fad4 	bl	800ae9c <_dbg_check_lock>
}
 80078f4:	bd80      	pop	{r7, pc}
 80078f6:	bf00      	nop

080078f8 <chSysUnlock.lto_priv.101>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80078f8:	b580      	push	{r7, lr}
 80078fa:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 80078fc:	f003 fae4 	bl	800aec8 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007900:	4b09      	ldr	r3, [pc, #36]	; (8007928 <chSysUnlock.lto_priv.101+0x30>)
 8007902:	681b      	ldr	r3, [r3, #0]
 8007904:	4a08      	ldr	r2, [pc, #32]	; (8007928 <chSysUnlock.lto_priv.101+0x30>)
 8007906:	4293      	cmp	r3, r2
 8007908:	d00a      	beq.n	8007920 <chSysUnlock.lto_priv.101+0x28>
 800790a:	4b07      	ldr	r3, [pc, #28]	; (8007928 <chSysUnlock.lto_priv.101+0x30>)
 800790c:	699b      	ldr	r3, [r3, #24]
 800790e:	689a      	ldr	r2, [r3, #8]
 8007910:	4b05      	ldr	r3, [pc, #20]	; (8007928 <chSysUnlock.lto_priv.101+0x30>)
 8007912:	681b      	ldr	r3, [r3, #0]
 8007914:	689b      	ldr	r3, [r3, #8]
 8007916:	429a      	cmp	r2, r3
 8007918:	d202      	bcs.n	8007920 <chSysUnlock.lto_priv.101+0x28>
 800791a:	4804      	ldr	r0, [pc, #16]	; (800792c <chSysUnlock.lto_priv.101+0x34>)
 800791c:	f003 fa70 	bl	800ae00 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8007920:	f7ff ffc0 	bl	80078a4 <port_unlock.lto_priv.112>
}
 8007924:	bd80      	pop	{r7, pc}
 8007926:	bf00      	nop
 8007928:	20001338 	.word	0x20001338
 800792c:	0800ec68 	.word	0x0800ec68

08007930 <chVTGetSystemTimeX.lto_priv.100>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8007930:	b580      	push	{r7, lr}
 8007932:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8007934:	f7ff ffd0 	bl	80078d8 <port_timer_get_time.lto_priv.106>
 8007938:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800793a:	4618      	mov	r0, r3
 800793c:	bd80      	pop	{r7, pc}
 800793e:	bf00      	nop

08007940 <chCoreAllocAlignedI.lto_priv.8>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8007940:	b580      	push	{r7, lr}
 8007942:	b082      	sub	sp, #8
 8007944:	af00      	add	r7, sp, #0
 8007946:	6078      	str	r0, [r7, #4]
 8007948:	6039      	str	r1, [r7, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 800794a:	6878      	ldr	r0, [r7, #4]
 800794c:	6839      	ldr	r1, [r7, #0]
 800794e:	2200      	movs	r2, #0
 8007950:	f002 fa1c 	bl	8009d8c <chCoreAllocAlignedWithOffsetI>
 8007954:	4603      	mov	r3, r0
}
 8007956:	4618      	mov	r0, r3
 8007958:	3708      	adds	r7, #8
 800795a:	46bd      	mov	sp, r7
 800795c:	bd80      	pop	{r7, pc}
 800795e:	bf00      	nop

08007960 <chCoreAlloc.lto_priv.84>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
static inline void *chCoreAlloc(size_t size) {
 8007960:	b580      	push	{r7, lr}
 8007962:	b082      	sub	sp, #8
 8007964:	af00      	add	r7, sp, #0
 8007966:	6078      	str	r0, [r7, #4]

  return chCoreAllocAlignedWithOffset(size, PORT_NATURAL_ALIGN, 0U);
 8007968:	6878      	ldr	r0, [r7, #4]
 800796a:	2104      	movs	r1, #4
 800796c:	2200      	movs	r2, #0
 800796e:	f002 fa51 	bl	8009e14 <chCoreAllocAlignedWithOffset>
 8007972:	4603      	mov	r3, r0
}
 8007974:	4618      	mov	r0, r3
 8007976:	3708      	adds	r7, #8
 8007978:	46bd      	mov	sp, r7
 800797a:	bd80      	pop	{r7, pc}

0800797c <can_iterate_instances>:
static void can_reschedule_expire_timer_I(struct can_instance_s* instance);
static void can_reschedule_expire_timer(struct can_instance_s* instance);
static void can_try_enqueue_waiting_frame_I(struct can_instance_s* instance);
static void can_try_enqueue_waiting_frame(struct can_instance_s* instance);

bool can_iterate_instances(struct can_instance_s** instance_ptr) {
 800797c:	b480      	push	{r7}
 800797e:	b083      	sub	sp, #12
 8007980:	af00      	add	r7, sp, #0
 8007982:	6078      	str	r0, [r7, #4]
    if (!instance_ptr) {
 8007984:	687b      	ldr	r3, [r7, #4]
 8007986:	2b00      	cmp	r3, #0
 8007988:	d101      	bne.n	800798e <can_iterate_instances+0x12>
        return false;
 800798a:	2300      	movs	r3, #0
 800798c:	e015      	b.n	80079ba <can_iterate_instances+0x3e>
    }

    if (!(*instance_ptr)) {
 800798e:	687b      	ldr	r3, [r7, #4]
 8007990:	681b      	ldr	r3, [r3, #0]
 8007992:	2b00      	cmp	r3, #0
 8007994:	d104      	bne.n	80079a0 <can_iterate_instances+0x24>
        *instance_ptr = can_instance_list_head;
 8007996:	4b0c      	ldr	r3, [pc, #48]	; (80079c8 <can_iterate_instances+0x4c>)
 8007998:	681a      	ldr	r2, [r3, #0]
 800799a:	687b      	ldr	r3, [r7, #4]
 800799c:	601a      	str	r2, [r3, #0]
 800799e:	e005      	b.n	80079ac <can_iterate_instances+0x30>
    } else {
        *instance_ptr = (*instance_ptr)->next;
 80079a0:	687b      	ldr	r3, [r7, #4]
 80079a2:	681b      	ldr	r3, [r3, #0]
 80079a4:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80079a8:	687b      	ldr	r3, [r7, #4]
 80079aa:	601a      	str	r2, [r3, #0]
    }

    return *instance_ptr != NULL;
 80079ac:	687b      	ldr	r3, [r7, #4]
 80079ae:	681b      	ldr	r3, [r3, #0]
 80079b0:	2b00      	cmp	r3, #0
 80079b2:	bf14      	ite	ne
 80079b4:	2301      	movne	r3, #1
 80079b6:	2300      	moveq	r3, #0
 80079b8:	b2db      	uxtb	r3, r3
}
 80079ba:	4618      	mov	r0, r3
 80079bc:	370c      	adds	r7, #12
 80079be:	46bd      	mov	sp, r7
 80079c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80079c4:	4770      	bx	lr
 80079c6:	bf00      	nop
 80079c8:	2000146c 	.word	0x2000146c

080079cc <can_get_instance>:

struct can_instance_s* can_get_instance(uint8_t can_idx) {
 80079cc:	b480      	push	{r7}
 80079ce:	b085      	sub	sp, #20
 80079d0:	af00      	add	r7, sp, #0
 80079d2:	4603      	mov	r3, r0
 80079d4:	71fb      	strb	r3, [r7, #7]
    for (struct can_instance_s* instance = can_instance_list_head; instance != NULL; instance = instance->next) {
 80079d6:	4b0c      	ldr	r3, [pc, #48]	; (8007a08 <can_get_instance+0x3c>)
 80079d8:	681b      	ldr	r3, [r3, #0]
 80079da:	60fb      	str	r3, [r7, #12]
 80079dc:	e00a      	b.n	80079f4 <can_get_instance+0x28>
        if (instance->idx == can_idx) {
 80079de:	68fb      	ldr	r3, [r7, #12]
 80079e0:	781b      	ldrb	r3, [r3, #0]
 80079e2:	79fa      	ldrb	r2, [r7, #7]
 80079e4:	429a      	cmp	r2, r3
 80079e6:	d101      	bne.n	80079ec <can_get_instance+0x20>
            return instance;
 80079e8:	68fb      	ldr	r3, [r7, #12]
 80079ea:	e007      	b.n	80079fc <can_get_instance+0x30>

    return *instance_ptr != NULL;
}

struct can_instance_s* can_get_instance(uint8_t can_idx) {
    for (struct can_instance_s* instance = can_instance_list_head; instance != NULL; instance = instance->next) {
 80079ec:	68fb      	ldr	r3, [r7, #12]
 80079ee:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80079f2:	60fb      	str	r3, [r7, #12]
 80079f4:	68fb      	ldr	r3, [r7, #12]
 80079f6:	2b00      	cmp	r3, #0
 80079f8:	d1f1      	bne.n	80079de <can_get_instance+0x12>
        if (instance->idx == can_idx) {
            return instance;
        }
    }

    return NULL;
 80079fa:	2300      	movs	r3, #0
}
 80079fc:	4618      	mov	r0, r3
 80079fe:	3714      	adds	r7, #20
 8007a00:	46bd      	mov	sp, r7
 8007a02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007a06:	4770      	bx	lr
 8007a08:	2000146c 	.word	0x2000146c

08007a0c <can_get_rx_topic>:

struct pubsub_topic_s* can_get_rx_topic(struct can_instance_s* instance) {
 8007a0c:	b580      	push	{r7, lr}
 8007a0e:	b082      	sub	sp, #8
 8007a10:	af00      	add	r7, sp, #0
 8007a12:	6078      	str	r0, [r7, #4]
    chDbgCheck(instance != NULL);
 8007a14:	687b      	ldr	r3, [r7, #4]
 8007a16:	2b00      	cmp	r3, #0
 8007a18:	d102      	bne.n	8007a20 <can_get_rx_topic+0x14>
 8007a1a:	4807      	ldr	r0, [pc, #28]	; (8007a38 <can_get_rx_topic+0x2c>)
 8007a1c:	f003 f9f0 	bl	800ae00 <chSysHalt>
    if (!instance) {
 8007a20:	687b      	ldr	r3, [r7, #4]
 8007a22:	2b00      	cmp	r3, #0
 8007a24:	d101      	bne.n	8007a2a <can_get_rx_topic+0x1e>
        return NULL;
 8007a26:	2300      	movs	r3, #0
 8007a28:	e001      	b.n	8007a2e <can_get_rx_topic+0x22>
    }

    return &instance->rx_topic;
 8007a2a:	687b      	ldr	r3, [r7, #4]
 8007a2c:	3340      	adds	r3, #64	; 0x40
}
 8007a2e:	4618      	mov	r0, r3
 8007a30:	3708      	adds	r7, #8
 8007a32:	46bd      	mov	sp, r7
 8007a34:	bd80      	pop	{r7, pc}
 8007a36:	bf00      	nop
 8007a38:	0800ec54 	.word	0x0800ec54

08007a3c <can_set_silent_mode>:
    }

    return instance->baudrate;
}

void can_set_silent_mode(struct can_instance_s* instance, bool silent) {
 8007a3c:	b580      	push	{r7, lr}
 8007a3e:	b082      	sub	sp, #8
 8007a40:	af00      	add	r7, sp, #0
 8007a42:	6078      	str	r0, [r7, #4]
 8007a44:	460b      	mov	r3, r1
 8007a46:	70fb      	strb	r3, [r7, #3]
    if (!instance) {
 8007a48:	687b      	ldr	r3, [r7, #4]
 8007a4a:	2b00      	cmp	r3, #0
 8007a4c:	d014      	beq.n	8007a78 <can_set_silent_mode+0x3c>
        return;
    }

    chSysLock();
 8007a4e:	f7ff ff4b 	bl	80078e8 <chSysLock.lto_priv.102>
    if (instance->started && instance->silent != silent) {
 8007a52:	687b      	ldr	r3, [r7, #4]
 8007a54:	785b      	ldrb	r3, [r3, #1]
 8007a56:	2b00      	cmp	r3, #0
 8007a58:	d00c      	beq.n	8007a74 <can_set_silent_mode+0x38>
 8007a5a:	687b      	ldr	r3, [r7, #4]
 8007a5c:	789b      	ldrb	r3, [r3, #2]
 8007a5e:	78fa      	ldrb	r2, [r7, #3]
 8007a60:	429a      	cmp	r2, r3
 8007a62:	d007      	beq.n	8007a74 <can_set_silent_mode+0x38>
        can_start_I(instance, silent, instance->auto_retransmit, instance->baudrate);
 8007a64:	687b      	ldr	r3, [r7, #4]
 8007a66:	78da      	ldrb	r2, [r3, #3]
 8007a68:	687b      	ldr	r3, [r7, #4]
 8007a6a:	685b      	ldr	r3, [r3, #4]
 8007a6c:	78f9      	ldrb	r1, [r7, #3]
 8007a6e:	6878      	ldr	r0, [r7, #4]
 8007a70:	f000 f85c 	bl	8007b2c <can_start_I>
    }
    chSysUnlock();
 8007a74:	f7ff ff40 	bl	80078f8 <chSysUnlock.lto_priv.101>
}
 8007a78:	3708      	adds	r7, #8
 8007a7a:	46bd      	mov	sp, r7
 8007a7c:	bd80      	pop	{r7, pc}
 8007a7e:	bf00      	nop

08007a80 <can_set_auto_retransmit_mode>:

void can_set_auto_retransmit_mode(struct can_instance_s* instance, bool auto_retransmit) {
 8007a80:	b580      	push	{r7, lr}
 8007a82:	b082      	sub	sp, #8
 8007a84:	af00      	add	r7, sp, #0
 8007a86:	6078      	str	r0, [r7, #4]
 8007a88:	460b      	mov	r3, r1
 8007a8a:	70fb      	strb	r3, [r7, #3]
    if (!instance) {
 8007a8c:	687b      	ldr	r3, [r7, #4]
 8007a8e:	2b00      	cmp	r3, #0
 8007a90:	d014      	beq.n	8007abc <can_set_auto_retransmit_mode+0x3c>
        return;
    }

    chSysLock();
 8007a92:	f7ff ff29 	bl	80078e8 <chSysLock.lto_priv.102>
    if (instance->started && instance->auto_retransmit != auto_retransmit) {
 8007a96:	687b      	ldr	r3, [r7, #4]
 8007a98:	785b      	ldrb	r3, [r3, #1]
 8007a9a:	2b00      	cmp	r3, #0
 8007a9c:	d00c      	beq.n	8007ab8 <can_set_auto_retransmit_mode+0x38>
 8007a9e:	687b      	ldr	r3, [r7, #4]
 8007aa0:	78db      	ldrb	r3, [r3, #3]
 8007aa2:	78fa      	ldrb	r2, [r7, #3]
 8007aa4:	429a      	cmp	r2, r3
 8007aa6:	d007      	beq.n	8007ab8 <can_set_auto_retransmit_mode+0x38>
        can_start_I(instance, instance->silent, auto_retransmit, instance->baudrate);
 8007aa8:	687b      	ldr	r3, [r7, #4]
 8007aaa:	7899      	ldrb	r1, [r3, #2]
 8007aac:	687b      	ldr	r3, [r7, #4]
 8007aae:	685b      	ldr	r3, [r3, #4]
 8007ab0:	78fa      	ldrb	r2, [r7, #3]
 8007ab2:	6878      	ldr	r0, [r7, #4]
 8007ab4:	f000 f83a 	bl	8007b2c <can_start_I>
    }
    chSysUnlock();
 8007ab8:	f7ff ff1e 	bl	80078f8 <chSysUnlock.lto_priv.101>
}
 8007abc:	3708      	adds	r7, #8
 8007abe:	46bd      	mov	sp, r7
 8007ac0:	bd80      	pop	{r7, pc}
 8007ac2:	bf00      	nop

08007ac4 <can_set_baudrate>:

void can_set_baudrate(struct can_instance_s* instance, uint32_t baudrate) {
 8007ac4:	b580      	push	{r7, lr}
 8007ac6:	b082      	sub	sp, #8
 8007ac8:	af00      	add	r7, sp, #0
 8007aca:	6078      	str	r0, [r7, #4]
 8007acc:	6039      	str	r1, [r7, #0]
    if (!instance) {
 8007ace:	687b      	ldr	r3, [r7, #4]
 8007ad0:	2b00      	cmp	r3, #0
 8007ad2:	d016      	beq.n	8007b02 <can_set_baudrate+0x3e>
        return;
    }

    chSysLock();
 8007ad4:	f7ff ff08 	bl	80078e8 <chSysLock.lto_priv.102>
    if (instance->started && instance->baudrate != baudrate) {
 8007ad8:	687b      	ldr	r3, [r7, #4]
 8007ada:	785b      	ldrb	r3, [r3, #1]
 8007adc:	2b00      	cmp	r3, #0
 8007ade:	d00e      	beq.n	8007afe <can_set_baudrate+0x3a>
 8007ae0:	687b      	ldr	r3, [r7, #4]
 8007ae2:	685a      	ldr	r2, [r3, #4]
 8007ae4:	683b      	ldr	r3, [r7, #0]
 8007ae6:	429a      	cmp	r2, r3
 8007ae8:	d009      	beq.n	8007afe <can_set_baudrate+0x3a>
        can_start_I(instance, instance->silent, instance->auto_retransmit, baudrate);
 8007aea:	687b      	ldr	r3, [r7, #4]
 8007aec:	789a      	ldrb	r2, [r3, #2]
 8007aee:	687b      	ldr	r3, [r7, #4]
 8007af0:	78db      	ldrb	r3, [r3, #3]
 8007af2:	6878      	ldr	r0, [r7, #4]
 8007af4:	4611      	mov	r1, r2
 8007af6:	461a      	mov	r2, r3
 8007af8:	683b      	ldr	r3, [r7, #0]
 8007afa:	f000 f817 	bl	8007b2c <can_start_I>
    }
    chSysUnlock();
 8007afe:	f7ff fefb 	bl	80078f8 <chSysUnlock.lto_priv.101>
}
 8007b02:	3708      	adds	r7, #8
 8007b04:	46bd      	mov	sp, r7
 8007b06:	bd80      	pop	{r7, pc}

08007b08 <can_get_baudrate_confirmed>:

bool can_get_baudrate_confirmed(struct can_instance_s* instance) {
 8007b08:	b480      	push	{r7}
 8007b0a:	b083      	sub	sp, #12
 8007b0c:	af00      	add	r7, sp, #0
 8007b0e:	6078      	str	r0, [r7, #4]
    if (!instance) {
 8007b10:	687b      	ldr	r3, [r7, #4]
 8007b12:	2b00      	cmp	r3, #0
 8007b14:	d101      	bne.n	8007b1a <can_get_baudrate_confirmed+0x12>
        return false;
 8007b16:	2300      	movs	r3, #0
 8007b18:	e001      	b.n	8007b1e <can_get_baudrate_confirmed+0x16>
    }

    return instance->baudrate_confirmed;
 8007b1a:	687b      	ldr	r3, [r7, #4]
 8007b1c:	7a1b      	ldrb	r3, [r3, #8]
}
 8007b1e:	4618      	mov	r0, r3
 8007b20:	370c      	adds	r7, #12
 8007b22:	46bd      	mov	sp, r7
 8007b24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007b28:	4770      	bx	lr
 8007b2a:	bf00      	nop

08007b2c <can_start_I>:

void can_start_I(struct can_instance_s* instance, bool silent, bool auto_retransmit, uint32_t baudrate) {
 8007b2c:	b590      	push	{r4, r7, lr}
 8007b2e:	b085      	sub	sp, #20
 8007b30:	af00      	add	r7, sp, #0
 8007b32:	60f8      	str	r0, [r7, #12]
 8007b34:	607b      	str	r3, [r7, #4]
 8007b36:	460b      	mov	r3, r1
 8007b38:	72fb      	strb	r3, [r7, #11]
 8007b3a:	4613      	mov	r3, r2
 8007b3c:	72bb      	strb	r3, [r7, #10]
    chDbgCheckClassI();
 8007b3e:	f003 fa3d 	bl	800afbc <chDbgCheckClassI>
    if (!instance) {
 8007b42:	68fb      	ldr	r3, [r7, #12]
 8007b44:	2b00      	cmp	r3, #0
 8007b46:	d026      	beq.n	8007b96 <can_start_I+0x6a>
        return;
    }

    if (instance->started) {
 8007b48:	68fb      	ldr	r3, [r7, #12]
 8007b4a:	785b      	ldrb	r3, [r3, #1]
 8007b4c:	2b00      	cmp	r3, #0
 8007b4e:	d002      	beq.n	8007b56 <can_start_I+0x2a>
        // TODO prevent dropped frames when re-starting CAN driver
        can_stop_I(instance);
 8007b50:	68f8      	ldr	r0, [r7, #12]
 8007b52:	f7fd fef3 	bl	800593c <can_stop_I>
    }

    instance->driver_iface->start(instance->driver_ctx, silent, auto_retransmit, baudrate);
 8007b56:	68fb      	ldr	r3, [r7, #12]
 8007b58:	691b      	ldr	r3, [r3, #16]
 8007b5a:	681c      	ldr	r4, [r3, #0]
 8007b5c:	68fb      	ldr	r3, [r7, #12]
 8007b5e:	68d9      	ldr	r1, [r3, #12]
 8007b60:	7afa      	ldrb	r2, [r7, #11]
 8007b62:	7abb      	ldrb	r3, [r7, #10]
 8007b64:	4608      	mov	r0, r1
 8007b66:	4611      	mov	r1, r2
 8007b68:	461a      	mov	r2, r3
 8007b6a:	687b      	ldr	r3, [r7, #4]
 8007b6c:	47a0      	blx	r4
    instance->started = true;
 8007b6e:	68fb      	ldr	r3, [r7, #12]
 8007b70:	2201      	movs	r2, #1
 8007b72:	705a      	strb	r2, [r3, #1]
    instance->silent = silent;
 8007b74:	68fb      	ldr	r3, [r7, #12]
 8007b76:	7afa      	ldrb	r2, [r7, #11]
 8007b78:	709a      	strb	r2, [r3, #2]
    instance->auto_retransmit = auto_retransmit;
 8007b7a:	68fb      	ldr	r3, [r7, #12]
 8007b7c:	7aba      	ldrb	r2, [r7, #10]
 8007b7e:	70da      	strb	r2, [r3, #3]
    if (baudrate != instance->baudrate) {
 8007b80:	68fb      	ldr	r3, [r7, #12]
 8007b82:	685a      	ldr	r2, [r3, #4]
 8007b84:	687b      	ldr	r3, [r7, #4]
 8007b86:	429a      	cmp	r2, r3
 8007b88:	d002      	beq.n	8007b90 <can_start_I+0x64>
        instance->baudrate_confirmed = false;
 8007b8a:	68fb      	ldr	r3, [r7, #12]
 8007b8c:	2200      	movs	r2, #0
 8007b8e:	721a      	strb	r2, [r3, #8]
    }
    instance->baudrate = baudrate;
 8007b90:	68fb      	ldr	r3, [r7, #12]
 8007b92:	687a      	ldr	r2, [r7, #4]
 8007b94:	605a      	str	r2, [r3, #4]
}
 8007b96:	3714      	adds	r7, #20
 8007b98:	46bd      	mov	sp, r7
 8007b9a:	bd90      	pop	{r4, r7, pc}
 8007b9c:	0000      	movs	r0, r0
	...

08007ba0 <crc64_we>:
#include <common/crc64_we.h>

uint64_t crc64_we(const uint8_t *buf, uint32_t len, uint64_t crc)
{
 8007ba0:	b4b0      	push	{r4, r5, r7}
 8007ba2:	b087      	sub	sp, #28
 8007ba4:	af00      	add	r7, sp, #0
 8007ba6:	60f8      	str	r0, [r7, #12]
 8007ba8:	60b9      	str	r1, [r7, #8]
 8007baa:	e9c7 2300 	strd	r2, r3, [r7]
    uint32_t i;
    uint8_t j;

    crc = ~crc;
 8007bae:	e9d7 2300 	ldrd	r2, r3, [r7]
 8007bb2:	ea6f 0202 	mvn.w	r2, r2
 8007bb6:	ea6f 0303 	mvn.w	r3, r3
 8007bba:	e9c7 2300 	strd	r2, r3, [r7]

    for (i = 0; i < len; i++) {
 8007bbe:	2300      	movs	r3, #0
 8007bc0:	617b      	str	r3, [r7, #20]
 8007bc2:	e036      	b.n	8007c32 <crc64_we+0x92>
        crc ^= ((uint64_t)buf[i]) << 56;
 8007bc4:	68fa      	ldr	r2, [r7, #12]
 8007bc6:	697b      	ldr	r3, [r7, #20]
 8007bc8:	4413      	add	r3, r2
 8007bca:	781b      	ldrb	r3, [r3, #0]
 8007bcc:	b2da      	uxtb	r2, r3
 8007bce:	f04f 0300 	mov.w	r3, #0
 8007bd2:	0615      	lsls	r5, r2, #24
 8007bd4:	2400      	movs	r4, #0
 8007bd6:	e9d7 2300 	ldrd	r2, r3, [r7]
 8007bda:	ea82 0204 	eor.w	r2, r2, r4
 8007bde:	ea83 0305 	eor.w	r3, r3, r5
 8007be2:	e9c7 2300 	strd	r2, r3, [r7]
        for (j = 0; j < 8; j++) {
 8007be6:	2300      	movs	r3, #0
 8007be8:	74fb      	strb	r3, [r7, #19]
 8007bea:	e01c      	b.n	8007c26 <crc64_we+0x86>
            crc = (crc & (1ULL<<63)) ? (crc<<1)^0x42F0E1EBA9EA3693ULL : (crc<<1);
 8007bec:	e9d7 2300 	ldrd	r2, r3, [r7]
 8007bf0:	2a00      	cmp	r2, #0
 8007bf2:	f173 0300 	sbcs.w	r3, r3, #0
 8007bf6:	da0c      	bge.n	8007c12 <crc64_we+0x72>
 8007bf8:	e9d7 2300 	ldrd	r2, r3, [r7]
 8007bfc:	1892      	adds	r2, r2, r2
 8007bfe:	eb43 0303 	adc.w	r3, r3, r3
 8007c02:	a115      	add	r1, pc, #84	; (adr r1, 8007c58 <crc64_we+0xb8>)
 8007c04:	e9d1 0100 	ldrd	r0, r1, [r1]
 8007c08:	ea82 0200 	eor.w	r2, r2, r0
 8007c0c:	ea83 0301 	eor.w	r3, r3, r1
 8007c10:	e004      	b.n	8007c1c <crc64_we+0x7c>
 8007c12:	e9d7 2300 	ldrd	r2, r3, [r7]
 8007c16:	1892      	adds	r2, r2, r2
 8007c18:	eb43 0303 	adc.w	r3, r3, r3
 8007c1c:	e9c7 2300 	strd	r2, r3, [r7]

    crc = ~crc;

    for (i = 0; i < len; i++) {
        crc ^= ((uint64_t)buf[i]) << 56;
        for (j = 0; j < 8; j++) {
 8007c20:	7cfb      	ldrb	r3, [r7, #19]
 8007c22:	3301      	adds	r3, #1
 8007c24:	74fb      	strb	r3, [r7, #19]
 8007c26:	7cfb      	ldrb	r3, [r7, #19]
 8007c28:	2b07      	cmp	r3, #7
 8007c2a:	d9df      	bls.n	8007bec <crc64_we+0x4c>
    uint32_t i;
    uint8_t j;

    crc = ~crc;

    for (i = 0; i < len; i++) {
 8007c2c:	697b      	ldr	r3, [r7, #20]
 8007c2e:	3301      	adds	r3, #1
 8007c30:	617b      	str	r3, [r7, #20]
 8007c32:	697a      	ldr	r2, [r7, #20]
 8007c34:	68bb      	ldr	r3, [r7, #8]
 8007c36:	429a      	cmp	r2, r3
 8007c38:	d3c4      	bcc.n	8007bc4 <crc64_we+0x24>
        for (j = 0; j < 8; j++) {
            crc = (crc & (1ULL<<63)) ? (crc<<1)^0x42F0E1EBA9EA3693ULL : (crc<<1);
        }
    }

    return ~crc;
 8007c3a:	e9d7 2300 	ldrd	r2, r3, [r7]
 8007c3e:	ea6f 0202 	mvn.w	r2, r2
 8007c42:	ea6f 0303 	mvn.w	r3, r3
}
 8007c46:	4610      	mov	r0, r2
 8007c48:	4619      	mov	r1, r3
 8007c4a:	371c      	adds	r7, #28
 8007c4c:	46bd      	mov	sp, r7
 8007c4e:	bcb0      	pop	{r4, r5, r7}
 8007c50:	4770      	bx	lr
 8007c52:	bf00      	nop
 8007c54:	f3af 8000 	nop.w
 8007c58:	a9ea3693 	.word	0xa9ea3693
 8007c5c:	42f0e1eb 	.word	0x42f0e1eb

08007c60 <crc16_ccitt>:
        *hash ^= (uint64_t)buf[i];
        *hash *= FNV_1_PRIME_64;
    }
}

uint16_t crc16_ccitt(const void *buf, size_t len, uint16_t crc) {
 8007c60:	b480      	push	{r7}
 8007c62:	b087      	sub	sp, #28
 8007c64:	af00      	add	r7, sp, #0
 8007c66:	60f8      	str	r0, [r7, #12]
 8007c68:	60b9      	str	r1, [r7, #8]
 8007c6a:	4613      	mov	r3, r2
 8007c6c:	80fb      	strh	r3, [r7, #6]
    for (size_t i = 0; i < len; i++) {
 8007c6e:	2300      	movs	r3, #0
 8007c70:	617b      	str	r3, [r7, #20]
 8007c72:	e026      	b.n	8007cc2 <crc16_ccitt+0x62>
        crc = crc ^ (((uint8_t*)buf)[i] << 8);
 8007c74:	68fa      	ldr	r2, [r7, #12]
 8007c76:	697b      	ldr	r3, [r7, #20]
 8007c78:	4413      	add	r3, r2
 8007c7a:	781b      	ldrb	r3, [r3, #0]
 8007c7c:	021b      	lsls	r3, r3, #8
 8007c7e:	b29a      	uxth	r2, r3
 8007c80:	88fb      	ldrh	r3, [r7, #6]
 8007c82:	4053      	eors	r3, r2
 8007c84:	b29b      	uxth	r3, r3
 8007c86:	80fb      	strh	r3, [r7, #6]
        for (int j = 0; j < 8; j++) {
 8007c88:	2300      	movs	r3, #0
 8007c8a:	613b      	str	r3, [r7, #16]
 8007c8c:	e013      	b.n	8007cb6 <crc16_ccitt+0x56>
            if (crc & 0x8000) {
 8007c8e:	88fb      	ldrh	r3, [r7, #6]
 8007c90:	b21b      	sxth	r3, r3
 8007c92:	2b00      	cmp	r3, #0
 8007c94:	da09      	bge.n	8007caa <crc16_ccitt+0x4a>
                crc = (crc << 1) ^ 0x1021;
 8007c96:	88fb      	ldrh	r3, [r7, #6]
 8007c98:	005b      	lsls	r3, r3, #1
 8007c9a:	b29b      	uxth	r3, r3
 8007c9c:	f483 5381 	eor.w	r3, r3, #4128	; 0x1020
 8007ca0:	f083 0301 	eor.w	r3, r3, #1
 8007ca4:	b29b      	uxth	r3, r3
 8007ca6:	80fb      	strh	r3, [r7, #6]
 8007ca8:	e002      	b.n	8007cb0 <crc16_ccitt+0x50>
            } else {
                crc = (crc << 1);
 8007caa:	88fb      	ldrh	r3, [r7, #6]
 8007cac:	005b      	lsls	r3, r3, #1
 8007cae:	80fb      	strh	r3, [r7, #6]
}

uint16_t crc16_ccitt(const void *buf, size_t len, uint16_t crc) {
    for (size_t i = 0; i < len; i++) {
        crc = crc ^ (((uint8_t*)buf)[i] << 8);
        for (int j = 0; j < 8; j++) {
 8007cb0:	693b      	ldr	r3, [r7, #16]
 8007cb2:	3301      	adds	r3, #1
 8007cb4:	613b      	str	r3, [r7, #16]
 8007cb6:	693b      	ldr	r3, [r7, #16]
 8007cb8:	2b07      	cmp	r3, #7
 8007cba:	dde8      	ble.n	8007c8e <crc16_ccitt+0x2e>
        *hash *= FNV_1_PRIME_64;
    }
}

uint16_t crc16_ccitt(const void *buf, size_t len, uint16_t crc) {
    for (size_t i = 0; i < len; i++) {
 8007cbc:	697b      	ldr	r3, [r7, #20]
 8007cbe:	3301      	adds	r3, #1
 8007cc0:	617b      	str	r3, [r7, #20]
 8007cc2:	697a      	ldr	r2, [r7, #20]
 8007cc4:	68bb      	ldr	r3, [r7, #8]
 8007cc6:	429a      	cmp	r2, r3
 8007cc8:	d3d4      	bcc.n	8007c74 <crc16_ccitt+0x14>
                crc = (crc << 1);
            }
        }
    }

    return crc;
 8007cca:	88fb      	ldrh	r3, [r7, #6]
}
 8007ccc:	4618      	mov	r0, r3
 8007cce:	371c      	adds	r7, #28
 8007cd0:	46bd      	mov	sp, r7
 8007cd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007cd6:	4770      	bx	lr

08007cd8 <_local_ctor_5.lto_priv.158>:
#include <common/ctor.h>

#include <ch.h>

RUN_ON(CH_SYS_INIT) {
 8007cd8:	b580      	push	{r7, lr}
 8007cda:	af00      	add	r7, sp, #0
    chSysInit();
 8007cdc:	f004 fe32 	bl	800c944 <chSysInit>
}
 8007ce0:	bd80      	pop	{r7, pc}
 8007ce2:	bf00      	nop

08007ce4 <_local_ctor_5.lto_priv.159>:
#include <common/ctor.h>

#include <hal.h>

RUN_ON(CH_HAL_INIT) {
 8007ce4:	b580      	push	{r7, lr}
 8007ce6:	af00      	add	r7, sp, #0
    halInit();
 8007ce8:	f002 fa2c 	bl	800a144 <halInit>
}
 8007cec:	bd80      	pop	{r7, pc}
 8007cee:	bf00      	nop

08007cf0 <st_lld_get_counter.lto_priv.143>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 8007cf0:	b480      	push	{r7}
 8007cf2:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 8007cf4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8007cf8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007cfa:	b29b      	uxth	r3, r3
}
 8007cfc:	4618      	mov	r0, r3
 8007cfe:	46bd      	mov	sp, r7
 8007d00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007d04:	4770      	bx	lr
 8007d06:	bf00      	nop

08007d08 <port_timer_get_time.lto_priv.140>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8007d08:	b580      	push	{r7, lr}
 8007d0a:	af00      	add	r7, sp, #0

  return stGetCounter();
 8007d0c:	f7ff fff0 	bl	8007cf0 <st_lld_get_counter.lto_priv.143>
 8007d10:	4603      	mov	r3, r0
}
 8007d12:	4618      	mov	r0, r3
 8007d14:	bd80      	pop	{r7, pc}
 8007d16:	bf00      	nop

08007d18 <chVTGetSystemTimeX.lto_priv.151>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8007d18:	b580      	push	{r7, lr}
 8007d1a:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8007d1c:	f7ff fff4 	bl	8007d08 <port_timer_get_time.lto_priv.140>
 8007d20:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8007d22:	4618      	mov	r0, r3
 8007d24:	bd80      	pop	{r7, pc}
 8007d26:	bf00      	nop

08007d28 <_local_ctor_39>:

static struct worker_thread_timer_task_s timing_state_update_task;

static void timing_state_update_task_func(struct worker_thread_timer_task_s* task);

RUN_AFTER(WORKER_THREADS_INIT) {
 8007d28:	b580      	push	{r7, lr}
 8007d2a:	b082      	sub	sp, #8
 8007d2c:	af02      	add	r7, sp, #8
    worker_thread_add_timer_task(&WT, &timing_state_update_task, timing_state_update_task_func, NULL, S2ST(10), true);
 8007d2e:	f248 63a0 	movw	r3, #34464	; 0x86a0
 8007d32:	9300      	str	r3, [sp, #0]
 8007d34:	2301      	movs	r3, #1
 8007d36:	9301      	str	r3, [sp, #4]
 8007d38:	4803      	ldr	r0, [pc, #12]	; (8007d48 <_local_ctor_39+0x20>)
 8007d3a:	4904      	ldr	r1, [pc, #16]	; (8007d4c <_local_ctor_39+0x24>)
 8007d3c:	4a04      	ldr	r2, [pc, #16]	; (8007d50 <_local_ctor_39+0x28>)
 8007d3e:	2300      	movs	r3, #0
 8007d40:	f000 fe18 	bl	8008974 <worker_thread_add_timer_task>
}
 8007d44:	46bd      	mov	sp, r7
 8007d46:	bd80      	pop	{r7, pc}
 8007d48:	20000a20 	.word	0x20000a20
 8007d4c:	2000144c 	.word	0x2000144c
 8007d50:	08007e81 	.word	0x08007e81

08007d54 <micros>:
    uint32_t delta_ticks = systime_now-timing_state[idx].update_systime;
    uint32_t delta_ms = delta_ticks / (CH_CFG_ST_FREQUENCY/1000);
    return ((uint32_t)timing_state[idx].update_seconds*1000) + delta_ms;
}

uint32_t micros(void) {
 8007d54:	b580      	push	{r7, lr}
 8007d56:	b084      	sub	sp, #16
 8007d58:	af00      	add	r7, sp, #0
    uint8_t idx = timing_state_idx;
 8007d5a:	4b16      	ldr	r3, [pc, #88]	; (8007db4 <micros+0x60>)
 8007d5c:	781b      	ldrb	r3, [r3, #0]
 8007d5e:	73fb      	strb	r3, [r7, #15]
    systime_t systime_now = chVTGetSystemTimeX();
 8007d60:	f7ff ffda 	bl	8007d18 <chVTGetSystemTimeX.lto_priv.151>
 8007d64:	4603      	mov	r3, r0
 8007d66:	81bb      	strh	r3, [r7, #12]
    uint32_t delta_ticks = systime_now-timing_state[idx].update_systime;
 8007d68:	89bb      	ldrh	r3, [r7, #12]
 8007d6a:	7bfa      	ldrb	r2, [r7, #15]
 8007d6c:	4912      	ldr	r1, [pc, #72]	; (8007db8 <micros+0x64>)
 8007d6e:	0112      	lsls	r2, r2, #4
 8007d70:	440a      	add	r2, r1
 8007d72:	3208      	adds	r2, #8
 8007d74:	8812      	ldrh	r2, [r2, #0]
 8007d76:	1a9b      	subs	r3, r3, r2
 8007d78:	60bb      	str	r3, [r7, #8]
    uint32_t delta_us = delta_ticks * (1000000.0f / CH_CFG_ST_FREQUENCY);
 8007d7a:	68b8      	ldr	r0, [r7, #8]
 8007d7c:	f7fb fe5a 	bl	8003a34 <__aeabi_ui2f>
 8007d80:	4603      	mov	r3, r0
 8007d82:	4618      	mov	r0, r3
 8007d84:	490d      	ldr	r1, [pc, #52]	; (8007dbc <micros+0x68>)
 8007d86:	f7fb fead 	bl	8003ae4 <__aeabi_fmul>
 8007d8a:	4603      	mov	r3, r0
 8007d8c:	4618      	mov	r0, r3
 8007d8e:	f7fb faa3 	bl	80032d8 <__aeabi_f2uiz>
 8007d92:	4603      	mov	r3, r0
 8007d94:	607b      	str	r3, [r7, #4]
    return ((uint32_t)timing_state[idx].update_seconds*1000000) + delta_us;
 8007d96:	7bfb      	ldrb	r3, [r7, #15]
 8007d98:	4a07      	ldr	r2, [pc, #28]	; (8007db8 <micros+0x64>)
 8007d9a:	011b      	lsls	r3, r3, #4
 8007d9c:	4413      	add	r3, r2
 8007d9e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007da2:	4b07      	ldr	r3, [pc, #28]	; (8007dc0 <micros+0x6c>)
 8007da4:	fb03 f202 	mul.w	r2, r3, r2
 8007da8:	687b      	ldr	r3, [r7, #4]
 8007daa:	4413      	add	r3, r2
}
 8007dac:	4618      	mov	r0, r3
 8007dae:	3710      	adds	r7, #16
 8007db0:	46bd      	mov	sp, r7
 8007db2:	bd80      	pop	{r7, pc}
 8007db4:	20001448 	.word	0x20001448
 8007db8:	20001428 	.word	0x20001428
 8007dbc:	42c80000 	.word	0x42c80000
 8007dc0:	000f4240 	.word	0x000f4240

08007dc4 <micros64>:

uint64_t micros64(void) {
 8007dc4:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8007dc8:	b084      	sub	sp, #16
 8007dca:	af00      	add	r7, sp, #0
    uint8_t idx = timing_state_idx;
 8007dcc:	4b29      	ldr	r3, [pc, #164]	; (8007e74 <micros64+0xb0>)
 8007dce:	781b      	ldrb	r3, [r3, #0]
 8007dd0:	73fb      	strb	r3, [r7, #15]
    systime_t systime_now = chVTGetSystemTimeX();
 8007dd2:	f7ff ffa1 	bl	8007d18 <chVTGetSystemTimeX.lto_priv.151>
 8007dd6:	4603      	mov	r3, r0
 8007dd8:	81bb      	strh	r3, [r7, #12]
    uint32_t delta_ticks = systime_now-timing_state[idx].update_systime;
 8007dda:	89bb      	ldrh	r3, [r7, #12]
 8007ddc:	7bfa      	ldrb	r2, [r7, #15]
 8007dde:	4926      	ldr	r1, [pc, #152]	; (8007e78 <micros64+0xb4>)
 8007de0:	0112      	lsls	r2, r2, #4
 8007de2:	440a      	add	r2, r1
 8007de4:	3208      	adds	r2, #8
 8007de6:	8812      	ldrh	r2, [r2, #0]
 8007de8:	1a9b      	subs	r3, r3, r2
 8007dea:	60bb      	str	r3, [r7, #8]
    uint32_t delta_us = delta_ticks * (1000000.0f / CH_CFG_ST_FREQUENCY);
 8007dec:	68b8      	ldr	r0, [r7, #8]
 8007dee:	f7fb fe21 	bl	8003a34 <__aeabi_ui2f>
 8007df2:	4603      	mov	r3, r0
 8007df4:	4618      	mov	r0, r3
 8007df6:	4921      	ldr	r1, [pc, #132]	; (8007e7c <micros64+0xb8>)
 8007df8:	f7fb fe74 	bl	8003ae4 <__aeabi_fmul>
 8007dfc:	4603      	mov	r3, r0
 8007dfe:	4618      	mov	r0, r3
 8007e00:	f7fb fa6a 	bl	80032d8 <__aeabi_f2uiz>
 8007e04:	4603      	mov	r3, r0
 8007e06:	607b      	str	r3, [r7, #4]
    return (timing_state[idx].update_seconds*1000000) + delta_us;
 8007e08:	7bfb      	ldrb	r3, [r7, #15]
 8007e0a:	4a1b      	ldr	r2, [pc, #108]	; (8007e78 <micros64+0xb4>)
 8007e0c:	011b      	lsls	r3, r3, #4
 8007e0e:	4413      	add	r3, r2
 8007e10:	e9d3 0100 	ldrd	r0, r1, [r3]
 8007e14:	4602      	mov	r2, r0
 8007e16:	460b      	mov	r3, r1
 8007e18:	ea4f 2b43 	mov.w	fp, r3, lsl #9
 8007e1c:	ea4b 5bd2 	orr.w	fp, fp, r2, lsr #23
 8007e20:	ea4f 2a42 	mov.w	sl, r2, lsl #9
 8007e24:	4652      	mov	r2, sl
 8007e26:	465b      	mov	r3, fp
 8007e28:	015d      	lsls	r5, r3, #5
 8007e2a:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 8007e2e:	0154      	lsls	r4, r2, #5
 8007e30:	1aa4      	subs	r4, r4, r2
 8007e32:	eb65 0503 	sbc.w	r5, r5, r3
 8007e36:	1824      	adds	r4, r4, r0
 8007e38:	eb45 0501 	adc.w	r5, r5, r1
 8007e3c:	ea4f 1985 	mov.w	r9, r5, lsl #6
 8007e40:	ea49 6994 	orr.w	r9, r9, r4, lsr #26
 8007e44:	ea4f 1884 	mov.w	r8, r4, lsl #6
 8007e48:	ebb8 0804 	subs.w	r8, r8, r4
 8007e4c:	eb69 0905 	sbc.w	r9, r9, r5
 8007e50:	eb10 0008 	adds.w	r0, r0, r8
 8007e54:	eb41 0109 	adc.w	r1, r1, r9
 8007e58:	687b      	ldr	r3, [r7, #4]
 8007e5a:	461a      	mov	r2, r3
 8007e5c:	f04f 0300 	mov.w	r3, #0
 8007e60:	1812      	adds	r2, r2, r0
 8007e62:	eb43 0301 	adc.w	r3, r3, r1
}
 8007e66:	4610      	mov	r0, r2
 8007e68:	4619      	mov	r1, r3
 8007e6a:	3710      	adds	r7, #16
 8007e6c:	46bd      	mov	sp, r7
 8007e6e:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8007e72:	bf00      	nop
 8007e74:	20001448 	.word	0x20001448
 8007e78:	20001428 	.word	0x20001428
 8007e7c:	42c80000 	.word	0x42c80000

08007e80 <timing_state_update_task_func>:
void usleep(uint32_t delay) {
    uint32_t tbegin = micros();
    while (micros()-tbegin < delay);
}

static void timing_state_update_task_func(struct worker_thread_timer_task_s* task) {
 8007e80:	b590      	push	{r4, r7, lr}
 8007e82:	b085      	sub	sp, #20
 8007e84:	af00      	add	r7, sp, #0
 8007e86:	6078      	str	r0, [r7, #4]
    (void)task;
    uint8_t next_timing_state_idx = (timing_state_idx+1) % 2;
 8007e88:	4b27      	ldr	r3, [pc, #156]	; (8007f28 <timing_state_update_task_func+0xa8>)
 8007e8a:	781b      	ldrb	r3, [r3, #0]
 8007e8c:	b2db      	uxtb	r3, r3
 8007e8e:	1c5a      	adds	r2, r3, #1
 8007e90:	4b26      	ldr	r3, [pc, #152]	; (8007f2c <timing_state_update_task_func+0xac>)
 8007e92:	4013      	ands	r3, r2
 8007e94:	2b00      	cmp	r3, #0
 8007e96:	da03      	bge.n	8007ea0 <timing_state_update_task_func+0x20>
 8007e98:	3b01      	subs	r3, #1
 8007e9a:	f063 0301 	orn	r3, r3, #1
 8007e9e:	3301      	adds	r3, #1
 8007ea0:	73fb      	strb	r3, [r7, #15]

    systime_t systime_now = chVTGetSystemTimeX();
 8007ea2:	f7ff ff39 	bl	8007d18 <chVTGetSystemTimeX.lto_priv.151>
 8007ea6:	4603      	mov	r3, r0
 8007ea8:	81bb      	strh	r3, [r7, #12]
    uint32_t delta_ticks = systime_now-timing_state[timing_state_idx].update_systime;
 8007eaa:	89bb      	ldrh	r3, [r7, #12]
 8007eac:	4a1e      	ldr	r2, [pc, #120]	; (8007f28 <timing_state_update_task_func+0xa8>)
 8007eae:	7812      	ldrb	r2, [r2, #0]
 8007eb0:	b2d2      	uxtb	r2, r2
 8007eb2:	491f      	ldr	r1, [pc, #124]	; (8007f30 <timing_state_update_task_func+0xb0>)
 8007eb4:	0112      	lsls	r2, r2, #4
 8007eb6:	440a      	add	r2, r1
 8007eb8:	3208      	adds	r2, #8
 8007eba:	8812      	ldrh	r2, [r2, #0]
 8007ebc:	1a9b      	subs	r3, r3, r2
 8007ebe:	60bb      	str	r3, [r7, #8]

    timing_state[next_timing_state_idx].update_seconds = timing_state[timing_state_idx].update_seconds + delta_ticks / CH_CFG_ST_FREQUENCY;
 8007ec0:	7bfc      	ldrb	r4, [r7, #15]
 8007ec2:	4b19      	ldr	r3, [pc, #100]	; (8007f28 <timing_state_update_task_func+0xa8>)
 8007ec4:	781b      	ldrb	r3, [r3, #0]
 8007ec6:	b2db      	uxtb	r3, r3
 8007ec8:	4a19      	ldr	r2, [pc, #100]	; (8007f30 <timing_state_update_task_func+0xb0>)
 8007eca:	011b      	lsls	r3, r3, #4
 8007ecc:	4413      	add	r3, r2
 8007ece:	e9d3 0100 	ldrd	r0, r1, [r3]
 8007ed2:	68bb      	ldr	r3, [r7, #8]
 8007ed4:	4a17      	ldr	r2, [pc, #92]	; (8007f34 <timing_state_update_task_func+0xb4>)
 8007ed6:	fba2 2303 	umull	r2, r3, r2, r3
 8007eda:	0b5b      	lsrs	r3, r3, #13
 8007edc:	461a      	mov	r2, r3
 8007ede:	f04f 0300 	mov.w	r3, #0
 8007ee2:	1812      	adds	r2, r2, r0
 8007ee4:	eb43 0301 	adc.w	r3, r3, r1
 8007ee8:	4811      	ldr	r0, [pc, #68]	; (8007f30 <timing_state_update_task_func+0xb0>)
 8007eea:	0121      	lsls	r1, r4, #4
 8007eec:	4401      	add	r1, r0
 8007eee:	e9c1 2300 	strd	r2, r3, [r1]
    timing_state[next_timing_state_idx].update_systime = systime_now - (delta_ticks % CH_CFG_ST_FREQUENCY);
 8007ef2:	7bf9      	ldrb	r1, [r7, #15]
 8007ef4:	68ba      	ldr	r2, [r7, #8]
 8007ef6:	4b0f      	ldr	r3, [pc, #60]	; (8007f34 <timing_state_update_task_func+0xb4>)
 8007ef8:	fba3 0302 	umull	r0, r3, r3, r2
 8007efc:	0b5b      	lsrs	r3, r3, #13
 8007efe:	f242 7010 	movw	r0, #10000	; 0x2710
 8007f02:	fb00 f303 	mul.w	r3, r0, r3
 8007f06:	1ad3      	subs	r3, r2, r3
 8007f08:	b29b      	uxth	r3, r3
 8007f0a:	89ba      	ldrh	r2, [r7, #12]
 8007f0c:	1ad3      	subs	r3, r2, r3
 8007f0e:	b298      	uxth	r0, r3
 8007f10:	4a07      	ldr	r2, [pc, #28]	; (8007f30 <timing_state_update_task_func+0xb0>)
 8007f12:	010b      	lsls	r3, r1, #4
 8007f14:	4413      	add	r3, r2
 8007f16:	3308      	adds	r3, #8
 8007f18:	4602      	mov	r2, r0
 8007f1a:	801a      	strh	r2, [r3, #0]

    timing_state_idx = next_timing_state_idx;
 8007f1c:	4a02      	ldr	r2, [pc, #8]	; (8007f28 <timing_state_update_task_func+0xa8>)
 8007f1e:	7bfb      	ldrb	r3, [r7, #15]
 8007f20:	7013      	strb	r3, [r2, #0]
}
 8007f22:	3714      	adds	r7, #20
 8007f24:	46bd      	mov	sp, r7
 8007f26:	bd90      	pop	{r4, r7, pc}
 8007f28:	20001448 	.word	0x20001448
 8007f2c:	80000001 	.word	0x80000001
 8007f30:	20001428 	.word	0x20001428
 8007f34:	d1b71759 	.word	0xd1b71759

08007f38 <system_get_restart_allowed>:

void system_set_restart_allowed_cb(restart_allowed_func_ptr_t cb) {
    restart_allowed_cb = cb;
}

bool system_get_restart_allowed(void) {
 8007f38:	b580      	push	{r7, lr}
 8007f3a:	af00      	add	r7, sp, #0
    return !restart_allowed_cb || restart_allowed_cb();
 8007f3c:	4b08      	ldr	r3, [pc, #32]	; (8007f60 <system_get_restart_allowed+0x28>)
 8007f3e:	681b      	ldr	r3, [r3, #0]
 8007f40:	2b00      	cmp	r3, #0
 8007f42:	d005      	beq.n	8007f50 <system_get_restart_allowed+0x18>
 8007f44:	4b06      	ldr	r3, [pc, #24]	; (8007f60 <system_get_restart_allowed+0x28>)
 8007f46:	681b      	ldr	r3, [r3, #0]
 8007f48:	4798      	blx	r3
 8007f4a:	4603      	mov	r3, r0
 8007f4c:	2b00      	cmp	r3, #0
 8007f4e:	d001      	beq.n	8007f54 <system_get_restart_allowed+0x1c>
 8007f50:	2301      	movs	r3, #1
 8007f52:	e000      	b.n	8007f56 <system_get_restart_allowed+0x1e>
 8007f54:	2300      	movs	r3, #0
 8007f56:	f003 0301 	and.w	r3, r3, #1
 8007f5a:	b2db      	uxtb	r3, r3
}
 8007f5c:	4618      	mov	r0, r3
 8007f5e:	bd80      	pop	{r7, pc}
 8007f60:	20001460 	.word	0x20001460

08007f64 <fifoallocator_init>:

#define FIFOALLOCATOR_ALIGN(ptr) ((void*)(((size_t)(ptr) + (sizeof(void*)-1)) & ~(sizeof(void*)-1)))

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size);

void fifoallocator_init(struct fifoallocator_instance_s* instance, size_t memory_pool_size, void* memory_pool) {
 8007f64:	b480      	push	{r7}
 8007f66:	b085      	sub	sp, #20
 8007f68:	af00      	add	r7, sp, #0
 8007f6a:	60f8      	str	r0, [r7, #12]
 8007f6c:	60b9      	str	r1, [r7, #8]
 8007f6e:	607a      	str	r2, [r7, #4]
    if (!instance || !memory_pool) {
 8007f70:	68fb      	ldr	r3, [r7, #12]
 8007f72:	2b00      	cmp	r3, #0
 8007f74:	d00e      	beq.n	8007f94 <fifoallocator_init+0x30>
 8007f76:	687b      	ldr	r3, [r7, #4]
 8007f78:	2b00      	cmp	r3, #0
 8007f7a:	d00b      	beq.n	8007f94 <fifoallocator_init+0x30>
        return;
    }

    instance->memory_pool = memory_pool;
 8007f7c:	68fb      	ldr	r3, [r7, #12]
 8007f7e:	687a      	ldr	r2, [r7, #4]
 8007f80:	601a      	str	r2, [r3, #0]
    instance->memory_pool_size = memory_pool_size;
 8007f82:	68fb      	ldr	r3, [r7, #12]
 8007f84:	68ba      	ldr	r2, [r7, #8]
 8007f86:	605a      	str	r2, [r3, #4]
    instance->newest = NULL;
 8007f88:	68fb      	ldr	r3, [r7, #12]
 8007f8a:	2200      	movs	r2, #0
 8007f8c:	609a      	str	r2, [r3, #8]
    instance->oldest = NULL;
 8007f8e:	68fb      	ldr	r3, [r7, #12]
 8007f90:	2200      	movs	r2, #0
 8007f92:	60da      	str	r2, [r3, #12]
}
 8007f94:	3714      	adds	r7, #20
 8007f96:	46bd      	mov	sp, r7
 8007f98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f9c:	4770      	bx	lr
 8007f9e:	bf00      	nop

08007fa0 <fifoallocator_allocate>:

void* fifoallocator_allocate(struct fifoallocator_instance_s* instance, size_t data_size) {
 8007fa0:	b580      	push	{r7, lr}
 8007fa2:	b084      	sub	sp, #16
 8007fa4:	af00      	add	r7, sp, #0
 8007fa6:	6078      	str	r0, [r7, #4]
 8007fa8:	6039      	str	r1, [r7, #0]

    if (!instance || !instance->memory_pool) {
 8007faa:	687b      	ldr	r3, [r7, #4]
 8007fac:	2b00      	cmp	r3, #0
 8007fae:	d003      	beq.n	8007fb8 <fifoallocator_allocate+0x18>
 8007fb0:	687b      	ldr	r3, [r7, #4]
 8007fb2:	681b      	ldr	r3, [r3, #0]
 8007fb4:	2b00      	cmp	r3, #0
 8007fb6:	d101      	bne.n	8007fbc <fifoallocator_allocate+0x1c>
        return NULL;
 8007fb8:	2300      	movs	r3, #0
 8007fba:	e06c      	b.n	8008096 <fifoallocator_allocate+0xf6>
    }

    size_t insert_block_size = data_size+sizeof(struct fifoallocator_block_s);
 8007fbc:	683b      	ldr	r3, [r7, #0]
 8007fbe:	3308      	adds	r3, #8
 8007fc0:	60bb      	str	r3, [r7, #8]

    struct fifoallocator_block_s* insert_block;
    if (instance->newest) {
 8007fc2:	687b      	ldr	r3, [r7, #4]
 8007fc4:	689b      	ldr	r3, [r3, #8]
 8007fc6:	2b00      	cmp	r3, #0
 8007fc8:	d008      	beq.n	8007fdc <fifoallocator_allocate+0x3c>
        insert_block = (struct fifoallocator_block_s*)((uint8_t*)instance->newest->data + instance->newest->data_size);
 8007fca:	687b      	ldr	r3, [r7, #4]
 8007fcc:	689a      	ldr	r2, [r3, #8]
 8007fce:	687b      	ldr	r3, [r7, #4]
 8007fd0:	689b      	ldr	r3, [r3, #8]
 8007fd2:	685b      	ldr	r3, [r3, #4]
 8007fd4:	3308      	adds	r3, #8
 8007fd6:	4413      	add	r3, r2
 8007fd8:	60fb      	str	r3, [r7, #12]
 8007fda:	e002      	b.n	8007fe2 <fifoallocator_allocate+0x42>
    } else {
        insert_block = (struct fifoallocator_block_s*)instance->memory_pool;
 8007fdc:	687b      	ldr	r3, [r7, #4]
 8007fde:	681b      	ldr	r3, [r3, #0]
 8007fe0:	60fb      	str	r3, [r7, #12]
    }

    insert_block = FIFOALLOCATOR_ALIGN(insert_block);
 8007fe2:	68fb      	ldr	r3, [r7, #12]
 8007fe4:	3303      	adds	r3, #3
 8007fe6:	f023 0303 	bic.w	r3, r3, #3
 8007fea:	60fb      	str	r3, [r7, #12]

    // Check if the block to be inserted is inside the memory pool
    if (!fifoallocator_block_in_range(instance, insert_block, insert_block_size)) {
 8007fec:	6878      	ldr	r0, [r7, #4]
 8007fee:	68f9      	ldr	r1, [r7, #12]
 8007ff0:	68ba      	ldr	r2, [r7, #8]
 8007ff2:	f000 f89b 	bl	800812c <fifoallocator_block_in_range>
 8007ff6:	4603      	mov	r3, r0
 8007ff8:	f083 0301 	eor.w	r3, r3, #1
 8007ffc:	b2db      	uxtb	r3, r3
 8007ffe:	2b00      	cmp	r3, #0
 8008000:	d01b      	beq.n	800803a <fifoallocator_allocate+0x9a>
        // The block doesn't fit. Move it to the beginning of the memory pool.
        insert_block = FIFOALLOCATOR_ALIGN((struct fifoallocator_block_s*)instance->memory_pool);
 8008002:	687b      	ldr	r3, [r7, #4]
 8008004:	681b      	ldr	r3, [r3, #0]
 8008006:	3303      	adds	r3, #3
 8008008:	f023 0303 	bic.w	r3, r3, #3
 800800c:	60fb      	str	r3, [r7, #12]

        if (!fifoallocator_block_in_range(instance, insert_block, insert_block_size)) {
 800800e:	6878      	ldr	r0, [r7, #4]
 8008010:	68f9      	ldr	r1, [r7, #12]
 8008012:	68ba      	ldr	r2, [r7, #8]
 8008014:	f000 f88a 	bl	800812c <fifoallocator_block_in_range>
 8008018:	4603      	mov	r3, r0
 800801a:	f083 0301 	eor.w	r3, r3, #1
 800801e:	b2db      	uxtb	r3, r3
 8008020:	2b00      	cmp	r3, #0
 8008022:	d001      	beq.n	8008028 <fifoallocator_allocate+0x88>
            // Block does not fit in pool
            return NULL;
 8008024:	2300      	movs	r3, #0
 8008026:	e036      	b.n	8008096 <fifoallocator_allocate+0xf6>
        }

        if ((size_t)instance->oldest > (size_t)instance->newest) {
 8008028:	687b      	ldr	r3, [r7, #4]
 800802a:	68db      	ldr	r3, [r3, #12]
 800802c:	461a      	mov	r2, r3
 800802e:	687b      	ldr	r3, [r7, #4]
 8008030:	689b      	ldr	r3, [r3, #8]
 8008032:	429a      	cmp	r2, r3
 8008034:	d901      	bls.n	800803a <fifoallocator_allocate+0x9a>
            // Allocated blocks wrap, beginning of memory pool is allocated
            return NULL;
 8008036:	2300      	movs	r3, #0
 8008038:	e02d      	b.n	8008096 <fifoallocator_allocate+0xf6>
        }
    }

    // Check if the insert block overlaps with the oldest block
    if (instance->oldest && (size_t)instance->oldest >= (size_t)insert_block && (size_t)instance->oldest < (size_t)insert_block+insert_block_size) {
 800803a:	687b      	ldr	r3, [r7, #4]
 800803c:	68db      	ldr	r3, [r3, #12]
 800803e:	2b00      	cmp	r3, #0
 8008040:	d00f      	beq.n	8008062 <fifoallocator_allocate+0xc2>
 8008042:	687b      	ldr	r3, [r7, #4]
 8008044:	68db      	ldr	r3, [r3, #12]
 8008046:	461a      	mov	r2, r3
 8008048:	68fb      	ldr	r3, [r7, #12]
 800804a:	429a      	cmp	r2, r3
 800804c:	d309      	bcc.n	8008062 <fifoallocator_allocate+0xc2>
 800804e:	687b      	ldr	r3, [r7, #4]
 8008050:	68db      	ldr	r3, [r3, #12]
 8008052:	4619      	mov	r1, r3
 8008054:	68fa      	ldr	r2, [r7, #12]
 8008056:	68bb      	ldr	r3, [r7, #8]
 8008058:	4413      	add	r3, r2
 800805a:	4299      	cmp	r1, r3
 800805c:	d201      	bcs.n	8008062 <fifoallocator_allocate+0xc2>
        return NULL;
 800805e:	2300      	movs	r3, #0
 8008060:	e019      	b.n	8008096 <fifoallocator_allocate+0xf6>
    }

    insert_block->next_oldest = NULL;
 8008062:	68fb      	ldr	r3, [r7, #12]
 8008064:	2200      	movs	r2, #0
 8008066:	601a      	str	r2, [r3, #0]
    insert_block->data_size = data_size;
 8008068:	68fb      	ldr	r3, [r7, #12]
 800806a:	683a      	ldr	r2, [r7, #0]
 800806c:	605a      	str	r2, [r3, #4]

    if (instance->newest) {
 800806e:	687b      	ldr	r3, [r7, #4]
 8008070:	689b      	ldr	r3, [r3, #8]
 8008072:	2b00      	cmp	r3, #0
 8008074:	d003      	beq.n	800807e <fifoallocator_allocate+0xde>
        instance->newest->next_oldest = insert_block;
 8008076:	687b      	ldr	r3, [r7, #4]
 8008078:	689b      	ldr	r3, [r3, #8]
 800807a:	68fa      	ldr	r2, [r7, #12]
 800807c:	601a      	str	r2, [r3, #0]
    }

    instance->newest = insert_block;
 800807e:	687b      	ldr	r3, [r7, #4]
 8008080:	68fa      	ldr	r2, [r7, #12]
 8008082:	609a      	str	r2, [r3, #8]

    if (!instance->oldest) {
 8008084:	687b      	ldr	r3, [r7, #4]
 8008086:	68db      	ldr	r3, [r3, #12]
 8008088:	2b00      	cmp	r3, #0
 800808a:	d102      	bne.n	8008092 <fifoallocator_allocate+0xf2>
        instance->oldest = insert_block;
 800808c:	687b      	ldr	r3, [r7, #4]
 800808e:	68fa      	ldr	r2, [r7, #12]
 8008090:	60da      	str	r2, [r3, #12]
    }

    return insert_block->data;
 8008092:	68fb      	ldr	r3, [r7, #12]
 8008094:	3308      	adds	r3, #8
}
 8008096:	4618      	mov	r0, r3
 8008098:	3710      	adds	r7, #16
 800809a:	46bd      	mov	sp, r7
 800809c:	bd80      	pop	{r7, pc}
 800809e:	bf00      	nop

080080a0 <fifoallocator_peek_oldest>:

void* fifoallocator_peek_oldest(struct fifoallocator_instance_s* instance) {
 80080a0:	b480      	push	{r7}
 80080a2:	b083      	sub	sp, #12
 80080a4:	af00      	add	r7, sp, #0
 80080a6:	6078      	str	r0, [r7, #4]
    if (!instance || !instance->oldest) {
 80080a8:	687b      	ldr	r3, [r7, #4]
 80080aa:	2b00      	cmp	r3, #0
 80080ac:	d003      	beq.n	80080b6 <fifoallocator_peek_oldest+0x16>
 80080ae:	687b      	ldr	r3, [r7, #4]
 80080b0:	68db      	ldr	r3, [r3, #12]
 80080b2:	2b00      	cmp	r3, #0
 80080b4:	d101      	bne.n	80080ba <fifoallocator_peek_oldest+0x1a>
        return NULL;
 80080b6:	2300      	movs	r3, #0
 80080b8:	e002      	b.n	80080c0 <fifoallocator_peek_oldest+0x20>
    }

    return instance->oldest->data;
 80080ba:	687b      	ldr	r3, [r7, #4]
 80080bc:	68db      	ldr	r3, [r3, #12]
 80080be:	3308      	adds	r3, #8
}
 80080c0:	4618      	mov	r0, r3
 80080c2:	370c      	adds	r7, #12
 80080c4:	46bd      	mov	sp, r7
 80080c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80080ca:	4770      	bx	lr

080080cc <fifoallocator_get_block_size>:

size_t fifoallocator_get_block_size(const void* block) {
 80080cc:	b480      	push	{r7}
 80080ce:	b083      	sub	sp, #12
 80080d0:	af00      	add	r7, sp, #0
 80080d2:	6078      	str	r0, [r7, #4]
    if (!block) {
 80080d4:	687b      	ldr	r3, [r7, #4]
 80080d6:	2b00      	cmp	r3, #0
 80080d8:	d101      	bne.n	80080de <fifoallocator_get_block_size+0x12>
        return 0;
 80080da:	2300      	movs	r3, #0
 80080dc:	e002      	b.n	80080e4 <fifoallocator_get_block_size+0x18>
    }

    return ((struct fifoallocator_block_s*)((uint8_t*)block - offsetof(struct fifoallocator_block_s, data)))->data_size;
 80080de:	687b      	ldr	r3, [r7, #4]
 80080e0:	3b08      	subs	r3, #8
 80080e2:	685b      	ldr	r3, [r3, #4]
}
 80080e4:	4618      	mov	r0, r3
 80080e6:	370c      	adds	r7, #12
 80080e8:	46bd      	mov	sp, r7
 80080ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80080ee:	4770      	bx	lr

080080f0 <fifoallocator_pop_oldest>:

void fifoallocator_pop_oldest(struct fifoallocator_instance_s* instance) {
 80080f0:	b480      	push	{r7}
 80080f2:	b083      	sub	sp, #12
 80080f4:	af00      	add	r7, sp, #0
 80080f6:	6078      	str	r0, [r7, #4]
    if (!instance || !instance->oldest) {
 80080f8:	687b      	ldr	r3, [r7, #4]
 80080fa:	2b00      	cmp	r3, #0
 80080fc:	d011      	beq.n	8008122 <fifoallocator_pop_oldest+0x32>
 80080fe:	687b      	ldr	r3, [r7, #4]
 8008100:	68db      	ldr	r3, [r3, #12]
 8008102:	2b00      	cmp	r3, #0
 8008104:	d00d      	beq.n	8008122 <fifoallocator_pop_oldest+0x32>
        return;
    }

    if (instance->newest == instance->oldest) {
 8008106:	687b      	ldr	r3, [r7, #4]
 8008108:	689a      	ldr	r2, [r3, #8]
 800810a:	687b      	ldr	r3, [r7, #4]
 800810c:	68db      	ldr	r3, [r3, #12]
 800810e:	429a      	cmp	r2, r3
 8008110:	d102      	bne.n	8008118 <fifoallocator_pop_oldest+0x28>
        instance->newest = NULL;
 8008112:	687b      	ldr	r3, [r7, #4]
 8008114:	2200      	movs	r2, #0
 8008116:	609a      	str	r2, [r3, #8]
    }

    instance->oldest = instance->oldest->next_oldest;
 8008118:	687b      	ldr	r3, [r7, #4]
 800811a:	68db      	ldr	r3, [r3, #12]
 800811c:	681a      	ldr	r2, [r3, #0]
 800811e:	687b      	ldr	r3, [r7, #4]
 8008120:	60da      	str	r2, [r3, #12]
}
 8008122:	370c      	adds	r7, #12
 8008124:	46bd      	mov	sp, r7
 8008126:	f85d 7b04 	ldr.w	r7, [sp], #4
 800812a:	4770      	bx	lr

0800812c <fifoallocator_block_in_range>:

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size) {
 800812c:	b480      	push	{r7}
 800812e:	b085      	sub	sp, #20
 8008130:	af00      	add	r7, sp, #0
 8008132:	60f8      	str	r0, [r7, #12]
 8008134:	60b9      	str	r1, [r7, #8]
 8008136:	607a      	str	r2, [r7, #4]
    return instance && instance->memory_pool &&
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
 8008138:	68fb      	ldr	r3, [r7, #12]
 800813a:	2b00      	cmp	r3, #0
 800813c:	d017      	beq.n	800816e <fifoallocator_block_in_range+0x42>

    instance->oldest = instance->oldest->next_oldest;
}

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size) {
    return instance && instance->memory_pool &&
 800813e:	68fb      	ldr	r3, [r7, #12]
 8008140:	681b      	ldr	r3, [r3, #0]
 8008142:	2b00      	cmp	r3, #0
 8008144:	d013      	beq.n	800816e <fifoallocator_block_in_range+0x42>
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
 8008146:	68bb      	ldr	r3, [r7, #8]
 8008148:	68fa      	ldr	r2, [r7, #12]
 800814a:	6812      	ldr	r2, [r2, #0]
 800814c:	1a9a      	subs	r2, r3, r2
 800814e:	68fb      	ldr	r3, [r7, #12]
 8008150:	685b      	ldr	r3, [r3, #4]

    instance->oldest = instance->oldest->next_oldest;
}

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size) {
    return instance && instance->memory_pool &&
 8008152:	429a      	cmp	r2, r3
 8008154:	d20b      	bcs.n	800816e <fifoallocator_block_in_range+0x42>
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
           (size_t)block+block_size-(size_t)instance->memory_pool <= instance->memory_pool_size;
 8008156:	68ba      	ldr	r2, [r7, #8]
 8008158:	687b      	ldr	r3, [r7, #4]
 800815a:	4413      	add	r3, r2
 800815c:	68fa      	ldr	r2, [r7, #12]
 800815e:	6812      	ldr	r2, [r2, #0]
 8008160:	1a9a      	subs	r2, r3, r2
 8008162:	68fb      	ldr	r3, [r7, #12]
 8008164:	685b      	ldr	r3, [r3, #4]
    instance->oldest = instance->oldest->next_oldest;
}

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size) {
    return instance && instance->memory_pool &&
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
 8008166:	429a      	cmp	r2, r3
 8008168:	d801      	bhi.n	800816e <fifoallocator_block_in_range+0x42>
 800816a:	2301      	movs	r3, #1
 800816c:	e000      	b.n	8008170 <fifoallocator_block_in_range+0x44>
 800816e:	2300      	movs	r3, #0

    instance->oldest = instance->oldest->next_oldest;
}

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size) {
    return instance && instance->memory_pool &&
 8008170:	f003 0301 	and.w	r3, r3, #1
 8008174:	b2db      	uxtb	r3, r3
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
           (size_t)block+block_size-(size_t)instance->memory_pool <= instance->memory_pool_size;
}
 8008176:	4618      	mov	r0, r3
 8008178:	3714      	adds	r7, #20
 800817a:	46bd      	mov	sp, r7
 800817c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008180:	4770      	bx	lr
 8008182:	bf00      	nop

08008184 <port_lock.lto_priv.148>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8008184:	b480      	push	{r7}
 8008186:	b083      	sub	sp, #12
 8008188:	af00      	add	r7, sp, #0
 800818a:	2320      	movs	r3, #32
 800818c:	607b      	str	r3, [r7, #4]
 800818e:	687b      	ldr	r3, [r7, #4]
 8008190:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008194:	370c      	adds	r7, #12
 8008196:	46bd      	mov	sp, r7
 8008198:	f85d 7b04 	ldr.w	r7, [sp], #4
 800819c:	4770      	bx	lr
 800819e:	bf00      	nop

080081a0 <port_unlock.lto_priv.146>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80081a0:	b480      	push	{r7}
 80081a2:	b083      	sub	sp, #12
 80081a4:	af00      	add	r7, sp, #0
 80081a6:	2300      	movs	r3, #0
 80081a8:	607b      	str	r3, [r7, #4]
 80081aa:	687b      	ldr	r3, [r7, #4]
 80081ac:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80081b0:	370c      	adds	r7, #12
 80081b2:	46bd      	mov	sp, r7
 80081b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80081b8:	4770      	bx	lr
 80081ba:	bf00      	nop

080081bc <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80081bc:	b580      	push	{r7, lr}
 80081be:	af00      	add	r7, sp, #0

  port_lock();
 80081c0:	f7ff ffe0 	bl	8008184 <port_lock.lto_priv.148>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80081c4:	f002 fe6a 	bl	800ae9c <_dbg_check_lock>
}
 80081c8:	bd80      	pop	{r7, pc}
 80081ca:	bf00      	nop

080081cc <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80081cc:	b580      	push	{r7, lr}
 80081ce:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 80081d0:	f002 fe7a 	bl	800aec8 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80081d4:	4b09      	ldr	r3, [pc, #36]	; (80081fc <chSysUnlock+0x30>)
 80081d6:	681b      	ldr	r3, [r3, #0]
 80081d8:	4a08      	ldr	r2, [pc, #32]	; (80081fc <chSysUnlock+0x30>)
 80081da:	4293      	cmp	r3, r2
 80081dc:	d00a      	beq.n	80081f4 <chSysUnlock+0x28>
 80081de:	4b07      	ldr	r3, [pc, #28]	; (80081fc <chSysUnlock+0x30>)
 80081e0:	699b      	ldr	r3, [r3, #24]
 80081e2:	689a      	ldr	r2, [r3, #8]
 80081e4:	4b05      	ldr	r3, [pc, #20]	; (80081fc <chSysUnlock+0x30>)
 80081e6:	681b      	ldr	r3, [r3, #0]
 80081e8:	689b      	ldr	r3, [r3, #8]
 80081ea:	429a      	cmp	r2, r3
 80081ec:	d202      	bcs.n	80081f4 <chSysUnlock+0x28>
 80081ee:	4804      	ldr	r0, [pc, #16]	; (8008200 <chSysUnlock+0x34>)
 80081f0:	f002 fe06 	bl	800ae00 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 80081f4:	f7ff ffd4 	bl	80081a0 <port_unlock.lto_priv.146>
}
 80081f8:	bd80      	pop	{r7, pc}
 80081fa:	bf00      	nop
 80081fc:	20001338 	.word	0x20001338
 8008200:	0800eb4c 	.word	0x0800eb4c

08008204 <pubsub_create_topic_group>:
#error Please define PUBSUB_DEFAULT_TOPIC_GROUP in framework_conf.h.
#endif

PUBSUB_TOPIC_GROUP_DECLARE_EXTERN(PUBSUB_DEFAULT_TOPIC_GROUP);

void pubsub_create_topic_group(struct pubsub_topic_group_s* topic_group, size_t memory_pool_size, void* memory_pool) {
 8008204:	b580      	push	{r7, lr}
 8008206:	b084      	sub	sp, #16
 8008208:	af00      	add	r7, sp, #0
 800820a:	60f8      	str	r0, [r7, #12]
 800820c:	60b9      	str	r1, [r7, #8]
 800820e:	607a      	str	r2, [r7, #4]
    if (!topic_group || !memory_pool) {
 8008210:	68fb      	ldr	r3, [r7, #12]
 8008212:	2b00      	cmp	r3, #0
 8008214:	d008      	beq.n	8008228 <pubsub_create_topic_group+0x24>
 8008216:	687b      	ldr	r3, [r7, #4]
 8008218:	2b00      	cmp	r3, #0
 800821a:	d005      	beq.n	8008228 <pubsub_create_topic_group+0x24>
        return;
    }

    fifoallocator_init(&topic_group->allocator, memory_pool_size, memory_pool);
 800821c:	68fb      	ldr	r3, [r7, #12]
 800821e:	4618      	mov	r0, r3
 8008220:	68b9      	ldr	r1, [r7, #8]
 8008222:	687a      	ldr	r2, [r7, #4]
 8008224:	f7ff fe9e 	bl	8007f64 <fifoallocator_init>
}
 8008228:	3710      	adds	r7, #16
 800822a:	46bd      	mov	sp, r7
 800822c:	bd80      	pop	{r7, pc}
 800822e:	bf00      	nop

08008230 <pubsub_init_topic>:

void pubsub_init_topic(struct pubsub_topic_s* topic, struct pubsub_topic_group_s* topic_group) {
 8008230:	b480      	push	{r7}
 8008232:	b083      	sub	sp, #12
 8008234:	af00      	add	r7, sp, #0
 8008236:	6078      	str	r0, [r7, #4]
 8008238:	6039      	str	r1, [r7, #0]
    if (!topic) {
 800823a:	687b      	ldr	r3, [r7, #4]
 800823c:	2b00      	cmp	r3, #0
 800823e:	d00d      	beq.n	800825c <pubsub_init_topic+0x2c>
        return;
    }

    if (!topic_group) {
 8008240:	683b      	ldr	r3, [r7, #0]
 8008242:	2b00      	cmp	r3, #0
 8008244:	d101      	bne.n	800824a <pubsub_init_topic+0x1a>
        topic_group = &PUBSUB_DEFAULT_TOPIC_GROUP;
 8008246:	4b08      	ldr	r3, [pc, #32]	; (8008268 <pubsub_init_topic+0x38>)
 8008248:	603b      	str	r3, [r7, #0]
    }

    topic->message_list_tail = NULL;
 800824a:	687b      	ldr	r3, [r7, #4]
 800824c:	2200      	movs	r2, #0
 800824e:	601a      	str	r2, [r3, #0]
    topic->group = topic_group;
 8008250:	687b      	ldr	r3, [r7, #4]
 8008252:	683a      	ldr	r2, [r7, #0]
 8008254:	605a      	str	r2, [r3, #4]
    topic->listener_list_head = NULL;
 8008256:	687b      	ldr	r3, [r7, #4]
 8008258:	2200      	movs	r2, #0
 800825a:	609a      	str	r2, [r3, #8]
}
 800825c:	370c      	adds	r7, #12
 800825e:	46bd      	mov	sp, r7
 8008260:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008264:	4770      	bx	lr
 8008266:	bf00      	nop
 8008268:	20000a58 	.word	0x20000a58

0800826c <pubsub_listener_init_and_register>:

void pubsub_listener_init_and_register(struct pubsub_listener_s* listener, struct pubsub_topic_s* topic, pubsub_message_handler_func_ptr handler_cb, void* handler_cb_ctx) {
 800826c:	b580      	push	{r7, lr}
 800826e:	b086      	sub	sp, #24
 8008270:	af00      	add	r7, sp, #0
 8008272:	60f8      	str	r0, [r7, #12]
 8008274:	60b9      	str	r1, [r7, #8]
 8008276:	607a      	str	r2, [r7, #4]
 8008278:	603b      	str	r3, [r7, #0]
    if (!topic || !topic->group || !listener) {
 800827a:	68bb      	ldr	r3, [r7, #8]
 800827c:	2b00      	cmp	r3, #0
 800827e:	d036      	beq.n	80082ee <pubsub_listener_init_and_register+0x82>
 8008280:	68bb      	ldr	r3, [r7, #8]
 8008282:	685b      	ldr	r3, [r3, #4]
 8008284:	2b00      	cmp	r3, #0
 8008286:	d032      	beq.n	80082ee <pubsub_listener_init_and_register+0x82>
 8008288:	68fb      	ldr	r3, [r7, #12]
 800828a:	2b00      	cmp	r3, #0
 800828c:	d02f      	beq.n	80082ee <pubsub_listener_init_and_register+0x82>
        return;
    }

    // initialize listener
    listener->topic = topic;
 800828e:	68fb      	ldr	r3, [r7, #12]
 8008290:	68ba      	ldr	r2, [r7, #8]
 8008292:	601a      	str	r2, [r3, #0]
    listener->next_message = NULL;
 8008294:	68fb      	ldr	r3, [r7, #12]
 8008296:	2200      	movs	r2, #0
 8008298:	605a      	str	r2, [r3, #4]
    listener->waiting_thread_reference_ptr = NULL;
 800829a:	68fb      	ldr	r3, [r7, #12]
 800829c:	2200      	movs	r2, #0
 800829e:	609a      	str	r2, [r3, #8]
    listener->handler_cb = handler_cb;
 80082a0:	68fb      	ldr	r3, [r7, #12]
 80082a2:	687a      	ldr	r2, [r7, #4]
 80082a4:	60da      	str	r2, [r3, #12]
    listener->handler_cb_ctx = handler_cb_ctx;
 80082a6:	68fb      	ldr	r3, [r7, #12]
 80082a8:	683a      	ldr	r2, [r7, #0]
 80082aa:	611a      	str	r2, [r3, #16]
    chMtxObjectInit(&listener->mtx);
 80082ac:	68fb      	ldr	r3, [r7, #12]
 80082ae:	3318      	adds	r3, #24
 80082b0:	4618      	mov	r0, r3
 80082b2:	f002 faeb 	bl	800a88c <chMtxObjectInit>
    listener->next = NULL;
 80082b6:	68fb      	ldr	r3, [r7, #12]
 80082b8:	2200      	movs	r2, #0
 80082ba:	62da      	str	r2, [r3, #44]	; 0x2c
    listener->misses = 0;
 80082bc:	68fb      	ldr	r3, [r7, #12]
 80082be:	2200      	movs	r2, #0
 80082c0:	615a      	str	r2, [r3, #20]

    // append listener to topic's listener list
    chSysLock();
 80082c2:	f7ff ff7b 	bl	80081bc <chSysLock>
    LINKED_LIST_APPEND(struct pubsub_listener_s, topic->listener_list_head, listener);
 80082c6:	68fb      	ldr	r3, [r7, #12]
 80082c8:	2200      	movs	r2, #0
 80082ca:	62da      	str	r2, [r3, #44]	; 0x2c
 80082cc:	68bb      	ldr	r3, [r7, #8]
 80082ce:	3308      	adds	r3, #8
 80082d0:	617b      	str	r3, [r7, #20]
 80082d2:	e003      	b.n	80082dc <pubsub_listener_init_and_register+0x70>
 80082d4:	697b      	ldr	r3, [r7, #20]
 80082d6:	681b      	ldr	r3, [r3, #0]
 80082d8:	332c      	adds	r3, #44	; 0x2c
 80082da:	617b      	str	r3, [r7, #20]
 80082dc:	697b      	ldr	r3, [r7, #20]
 80082de:	681b      	ldr	r3, [r3, #0]
 80082e0:	2b00      	cmp	r3, #0
 80082e2:	d1f7      	bne.n	80082d4 <pubsub_listener_init_and_register+0x68>
 80082e4:	697b      	ldr	r3, [r7, #20]
 80082e6:	68fa      	ldr	r2, [r7, #12]
 80082e8:	601a      	str	r2, [r3, #0]
    chSysUnlock();
 80082ea:	f7ff ff6f 	bl	80081cc <chSysUnlock>
}
 80082ee:	3718      	adds	r7, #24
 80082f0:	46bd      	mov	sp, r7
 80082f2:	bd80      	pop	{r7, pc}

080082f4 <pubsub_listener_unregister>:

void pubsub_listener_unregister(struct pubsub_listener_s* listener) {
 80082f4:	b580      	push	{r7, lr}
 80082f6:	b084      	sub	sp, #16
 80082f8:	af00      	add	r7, sp, #0
 80082fa:	6078      	str	r0, [r7, #4]
    if (!listener) {
 80082fc:	687b      	ldr	r3, [r7, #4]
 80082fe:	2b00      	cmp	r3, #0
 8008300:	d01e      	beq.n	8008340 <pubsub_listener_unregister+0x4c>
        return;
    }

    // remove listener from topic's listener list
    chSysLock();
 8008302:	f7ff ff5b 	bl	80081bc <chSysLock>
    LINKED_LIST_REMOVE(struct pubsub_listener_s, listener->topic->listener_list_head, listener);
 8008306:	687b      	ldr	r3, [r7, #4]
 8008308:	681b      	ldr	r3, [r3, #0]
 800830a:	3308      	adds	r3, #8
 800830c:	60fb      	str	r3, [r7, #12]
 800830e:	e003      	b.n	8008318 <pubsub_listener_unregister+0x24>
 8008310:	68fb      	ldr	r3, [r7, #12]
 8008312:	681b      	ldr	r3, [r3, #0]
 8008314:	332c      	adds	r3, #44	; 0x2c
 8008316:	60fb      	str	r3, [r7, #12]
 8008318:	68fb      	ldr	r3, [r7, #12]
 800831a:	681b      	ldr	r3, [r3, #0]
 800831c:	2b00      	cmp	r3, #0
 800831e:	d004      	beq.n	800832a <pubsub_listener_unregister+0x36>
 8008320:	68fb      	ldr	r3, [r7, #12]
 8008322:	681a      	ldr	r2, [r3, #0]
 8008324:	687b      	ldr	r3, [r7, #4]
 8008326:	429a      	cmp	r2, r3
 8008328:	d1f2      	bne.n	8008310 <pubsub_listener_unregister+0x1c>
 800832a:	68fb      	ldr	r3, [r7, #12]
 800832c:	681b      	ldr	r3, [r3, #0]
 800832e:	2b00      	cmp	r3, #0
 8008330:	d004      	beq.n	800833c <pubsub_listener_unregister+0x48>
 8008332:	68fb      	ldr	r3, [r7, #12]
 8008334:	681b      	ldr	r3, [r3, #0]
 8008336:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008338:	68fb      	ldr	r3, [r7, #12]
 800833a:	601a      	str	r2, [r3, #0]
    chSysUnlock();
 800833c:	f7ff ff46 	bl	80081cc <chSysUnlock>
}
 8008340:	3710      	adds	r7, #16
 8008342:	46bd      	mov	sp, r7
 8008344:	bd80      	pop	{r7, pc}
 8008346:	bf00      	nop

08008348 <pubsub_listener_has_message>:
    chMtxLock(&listener->mtx);
    listener->next_message = NULL;
    chMtxUnlock(&listener->mtx);
}

bool pubsub_listener_has_message(struct pubsub_listener_s* listener) {
 8008348:	b480      	push	{r7}
 800834a:	b083      	sub	sp, #12
 800834c:	af00      	add	r7, sp, #0
 800834e:	6078      	str	r0, [r7, #4]
    return listener->next_message != NULL;
 8008350:	687b      	ldr	r3, [r7, #4]
 8008352:	685b      	ldr	r3, [r3, #4]
 8008354:	2b00      	cmp	r3, #0
 8008356:	bf14      	ite	ne
 8008358:	2301      	movne	r3, #1
 800835a:	2300      	moveq	r3, #0
 800835c:	b2db      	uxtb	r3, r3
}
 800835e:	4618      	mov	r0, r3
 8008360:	370c      	adds	r7, #12
 8008362:	46bd      	mov	sp, r7
 8008364:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008368:	4770      	bx	lr
 800836a:	bf00      	nop

0800836c <pubsub_copy_writer_func>:

void pubsub_copy_writer_func(size_t msg_size, void* msg, void* ctx) {
 800836c:	b580      	push	{r7, lr}
 800836e:	b084      	sub	sp, #16
 8008370:	af00      	add	r7, sp, #0
 8008372:	60f8      	str	r0, [r7, #12]
 8008374:	60b9      	str	r1, [r7, #8]
 8008376:	607a      	str	r2, [r7, #4]
    memcpy(msg, ctx, msg_size);
 8008378:	68b8      	ldr	r0, [r7, #8]
 800837a:	6879      	ldr	r1, [r7, #4]
 800837c:	68fa      	ldr	r2, [r7, #12]
 800837e:	f006 f8ff 	bl	800e580 <memcpy>
}
 8008382:	3710      	adds	r7, #16
 8008384:	46bd      	mov	sp, r7
 8008386:	bd80      	pop	{r7, pc}

08008388 <pubsub_delete_message_S>:

static void pubsub_delete_message_S(struct pubsub_message_s* message_to_delete) {
 8008388:	b580      	push	{r7, lr}
 800838a:	b084      	sub	sp, #16
 800838c:	af00      	add	r7, sp, #0
 800838e:	6078      	str	r0, [r7, #4]
    struct pubsub_listener_s* listener = message_to_delete->topic->listener_list_head;
 8008390:	687b      	ldr	r3, [r7, #4]
 8008392:	681b      	ldr	r3, [r3, #0]
 8008394:	689b      	ldr	r3, [r3, #8]
 8008396:	60fb      	str	r3, [r7, #12]

    if (message_to_delete->topic->message_list_tail == message_to_delete) {
 8008398:	687b      	ldr	r3, [r7, #4]
 800839a:	681b      	ldr	r3, [r3, #0]
 800839c:	681a      	ldr	r2, [r3, #0]
 800839e:	687b      	ldr	r3, [r7, #4]
 80083a0:	429a      	cmp	r2, r3
 80083a2:	d124      	bne.n	80083ee <pubsub_delete_message_S+0x66>
        message_to_delete->topic->message_list_tail = NULL;
 80083a4:	687b      	ldr	r3, [r7, #4]
 80083a6:	681b      	ldr	r3, [r3, #0]
 80083a8:	2200      	movs	r2, #0
 80083aa:	601a      	str	r2, [r3, #0]
 80083ac:	e01f      	b.n	80083ee <pubsub_delete_message_S+0x66>
    }

    while (listener) {
        if (listener->next_message == message_to_delete) {
 80083ae:	68fb      	ldr	r3, [r7, #12]
 80083b0:	685a      	ldr	r2, [r3, #4]
 80083b2:	687b      	ldr	r3, [r7, #4]
 80083b4:	429a      	cmp	r2, r3
 80083b6:	d117      	bne.n	80083e8 <pubsub_delete_message_S+0x60>
            chMtxLockS(&listener->mtx);
 80083b8:	68fb      	ldr	r3, [r7, #12]
 80083ba:	3318      	adds	r3, #24
 80083bc:	4618      	mov	r0, r3
 80083be:	f002 fa7f 	bl	800a8c0 <chMtxLockS>
            if (listener->next_message == message_to_delete) {
 80083c2:	68fb      	ldr	r3, [r7, #12]
 80083c4:	685a      	ldr	r2, [r3, #4]
 80083c6:	687b      	ldr	r3, [r7, #4]
 80083c8:	429a      	cmp	r2, r3
 80083ca:	d108      	bne.n	80083de <pubsub_delete_message_S+0x56>
                listener->next_message = message_to_delete->next_in_topic;
 80083cc:	687b      	ldr	r3, [r7, #4]
 80083ce:	685a      	ldr	r2, [r3, #4]
 80083d0:	68fb      	ldr	r3, [r7, #12]
 80083d2:	605a      	str	r2, [r3, #4]
                listener->misses++;
 80083d4:	68fb      	ldr	r3, [r7, #12]
 80083d6:	695b      	ldr	r3, [r3, #20]
 80083d8:	1c5a      	adds	r2, r3, #1
 80083da:	68fb      	ldr	r3, [r7, #12]
 80083dc:	615a      	str	r2, [r3, #20]
            }
            chMtxUnlockS(&listener->mtx);
 80083de:	68fb      	ldr	r3, [r7, #12]
 80083e0:	3318      	adds	r3, #24
 80083e2:	4618      	mov	r0, r3
 80083e4:	f002 fb88 	bl	800aaf8 <chMtxUnlockS>
        }
        listener = listener->next;
 80083e8:	68fb      	ldr	r3, [r7, #12]
 80083ea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80083ec:	60fb      	str	r3, [r7, #12]

    if (message_to_delete->topic->message_list_tail == message_to_delete) {
        message_to_delete->topic->message_list_tail = NULL;
    }

    while (listener) {
 80083ee:	68fb      	ldr	r3, [r7, #12]
 80083f0:	2b00      	cmp	r3, #0
 80083f2:	d1dc      	bne.n	80083ae <pubsub_delete_message_S+0x26>
            }
            chMtxUnlockS(&listener->mtx);
        }
        listener = listener->next;
    }
}
 80083f4:	3710      	adds	r7, #16
 80083f6:	46bd      	mov	sp, r7
 80083f8:	bd80      	pop	{r7, pc}
 80083fa:	bf00      	nop

080083fc <pubsub_publish_message>:

void pubsub_publish_message(struct pubsub_topic_s* topic, size_t size, pubsub_message_writer_func_ptr writer_cb, void* ctx) {
 80083fc:	b580      	push	{r7, lr}
 80083fe:	b088      	sub	sp, #32
 8008400:	af00      	add	r7, sp, #0
 8008402:	60f8      	str	r0, [r7, #12]
 8008404:	60b9      	str	r1, [r7, #8]
 8008406:	607a      	str	r2, [r7, #4]
 8008408:	603b      	str	r3, [r7, #0]
    if (!topic || !topic->group || !topic->listener_list_head) {
 800840a:	68fb      	ldr	r3, [r7, #12]
 800840c:	2b00      	cmp	r3, #0
 800840e:	d07c      	beq.n	800850a <pubsub_publish_message+0x10e>
 8008410:	68fb      	ldr	r3, [r7, #12]
 8008412:	685b      	ldr	r3, [r3, #4]
 8008414:	2b00      	cmp	r3, #0
 8008416:	d078      	beq.n	800850a <pubsub_publish_message+0x10e>
 8008418:	68fb      	ldr	r3, [r7, #12]
 800841a:	689b      	ldr	r3, [r3, #8]
 800841c:	2b00      	cmp	r3, #0
 800841e:	d074      	beq.n	800850a <pubsub_publish_message+0x10e>
        return;
    }

    struct pubsub_message_s* message;
    while (true) {
        chSysLock();
 8008420:	f7ff fecc 	bl	80081bc <chSysLock>
        message = fifoallocator_allocate(&topic->group->allocator, size+sizeof(struct pubsub_message_s));
 8008424:	68fb      	ldr	r3, [r7, #12]
 8008426:	685b      	ldr	r3, [r3, #4]
 8008428:	461a      	mov	r2, r3
 800842a:	68bb      	ldr	r3, [r7, #8]
 800842c:	3308      	adds	r3, #8
 800842e:	4610      	mov	r0, r2
 8008430:	4619      	mov	r1, r3
 8008432:	f7ff fdb5 	bl	8007fa0 <fifoallocator_allocate>
 8008436:	61b8      	str	r0, [r7, #24]

        if (message != NULL) {
 8008438:	69bb      	ldr	r3, [r7, #24]
 800843a:	2b00      	cmp	r3, #0
 800843c:	d119      	bne.n	8008472 <pubsub_publish_message+0x76>
            break;
        }

        // Delete the oldest message in the topic group
        struct pubsub_message_s* message_to_delete = fifoallocator_peek_oldest(&topic->group->allocator);
 800843e:	68fb      	ldr	r3, [r7, #12]
 8008440:	685b      	ldr	r3, [r3, #4]
 8008442:	4618      	mov	r0, r3
 8008444:	f7ff fe2c 	bl	80080a0 <fifoallocator_peek_oldest>
 8008448:	6178      	str	r0, [r7, #20]
        pubsub_delete_message_S(message_to_delete);
 800844a:	6978      	ldr	r0, [r7, #20]
 800844c:	f7ff ff9c 	bl	8008388 <pubsub_delete_message_S>

        if (fifoallocator_peek_oldest(&topic->group->allocator) == message_to_delete) {
 8008450:	68fb      	ldr	r3, [r7, #12]
 8008452:	685b      	ldr	r3, [r3, #4]
 8008454:	4618      	mov	r0, r3
 8008456:	f7ff fe23 	bl	80080a0 <fifoallocator_peek_oldest>
 800845a:	4602      	mov	r2, r0
 800845c:	697b      	ldr	r3, [r7, #20]
 800845e:	429a      	cmp	r2, r3
 8008460:	d104      	bne.n	800846c <pubsub_publish_message+0x70>
            fifoallocator_pop_oldest(&topic->group->allocator);
 8008462:	68fb      	ldr	r3, [r7, #12]
 8008464:	685b      	ldr	r3, [r3, #4]
 8008466:	4618      	mov	r0, r3
 8008468:	f7ff fe42 	bl	80080f0 <fifoallocator_pop_oldest>
        }

        chSysUnlock();
 800846c:	f7ff feae 	bl	80081cc <chSysUnlock>
 8008470:	e7d6      	b.n	8008420 <pubsub_publish_message+0x24>
    }

    message->topic = topic;
 8008472:	69bb      	ldr	r3, [r7, #24]
 8008474:	68fa      	ldr	r2, [r7, #12]
 8008476:	601a      	str	r2, [r3, #0]
    message->next_in_topic = NULL;
 8008478:	69bb      	ldr	r3, [r7, #24]
 800847a:	2200      	movs	r2, #0
 800847c:	605a      	str	r2, [r3, #4]

    if (writer_cb) {
 800847e:	687b      	ldr	r3, [r7, #4]
 8008480:	2b00      	cmp	r3, #0
 8008482:	d007      	beq.n	8008494 <pubsub_publish_message+0x98>
        writer_cb(size, message->data, ctx);
 8008484:	69bb      	ldr	r3, [r7, #24]
 8008486:	f103 0208 	add.w	r2, r3, #8
 800848a:	687b      	ldr	r3, [r7, #4]
 800848c:	68b8      	ldr	r0, [r7, #8]
 800848e:	4611      	mov	r1, r2
 8008490:	683a      	ldr	r2, [r7, #0]
 8008492:	4798      	blx	r3
    }

    if (topic->message_list_tail) {
 8008494:	68fb      	ldr	r3, [r7, #12]
 8008496:	681b      	ldr	r3, [r3, #0]
 8008498:	2b00      	cmp	r3, #0
 800849a:	d00b      	beq.n	80084b4 <pubsub_publish_message+0xb8>
        chDbgCheck(topic->message_list_tail != message); // Circular reference
 800849c:	68fb      	ldr	r3, [r7, #12]
 800849e:	681a      	ldr	r2, [r3, #0]
 80084a0:	69bb      	ldr	r3, [r7, #24]
 80084a2:	429a      	cmp	r2, r3
 80084a4:	d102      	bne.n	80084ac <pubsub_publish_message+0xb0>
 80084a6:	481a      	ldr	r0, [pc, #104]	; (8008510 <pubsub_publish_message+0x114>)
 80084a8:	f002 fcaa 	bl	800ae00 <chSysHalt>
        topic->message_list_tail->next_in_topic = message;
 80084ac:	68fb      	ldr	r3, [r7, #12]
 80084ae:	681b      	ldr	r3, [r3, #0]
 80084b0:	69ba      	ldr	r2, [r7, #24]
 80084b2:	605a      	str	r2, [r3, #4]
    }
    topic->message_list_tail = message;
 80084b4:	68fb      	ldr	r3, [r7, #12]
 80084b6:	69ba      	ldr	r2, [r7, #24]
 80084b8:	601a      	str	r2, [r3, #0]

    // Set listeners' next messages
    struct pubsub_listener_s* listener = topic->listener_list_head;
 80084ba:	68fb      	ldr	r3, [r7, #12]
 80084bc:	689b      	ldr	r3, [r3, #8]
 80084be:	61fb      	str	r3, [r7, #28]
 80084c0:	e009      	b.n	80084d6 <pubsub_publish_message+0xda>
    while (listener) {
        if (!listener->next_message) {
 80084c2:	69fb      	ldr	r3, [r7, #28]
 80084c4:	685b      	ldr	r3, [r3, #4]
 80084c6:	2b00      	cmp	r3, #0
 80084c8:	d102      	bne.n	80084d0 <pubsub_publish_message+0xd4>
            listener->next_message = message;
 80084ca:	69fb      	ldr	r3, [r7, #28]
 80084cc:	69ba      	ldr	r2, [r7, #24]
 80084ce:	605a      	str	r2, [r3, #4]
        }

        listener = listener->next;
 80084d0:	69fb      	ldr	r3, [r7, #28]
 80084d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80084d4:	61fb      	str	r3, [r7, #28]
    }
    topic->message_list_tail = message;

    // Set listeners' next messages
    struct pubsub_listener_s* listener = topic->listener_list_head;
    while (listener) {
 80084d6:	69fb      	ldr	r3, [r7, #28]
 80084d8:	2b00      	cmp	r3, #0
 80084da:	d1f2      	bne.n	80084c2 <pubsub_publish_message+0xc6>

        listener = listener->next;
    }

    // Wake listener threads
    listener = topic->listener_list_head;
 80084dc:	68fb      	ldr	r3, [r7, #12]
 80084de:	689b      	ldr	r3, [r3, #8]
 80084e0:	61fb      	str	r3, [r7, #28]
 80084e2:	e00d      	b.n	8008500 <pubsub_publish_message+0x104>
    while (listener) {
        if (listener->waiting_thread_reference_ptr) {
 80084e4:	69fb      	ldr	r3, [r7, #28]
 80084e6:	689b      	ldr	r3, [r3, #8]
 80084e8:	2b00      	cmp	r3, #0
 80084ea:	d006      	beq.n	80084fa <pubsub_publish_message+0xfe>
            chThdResumeS(listener->waiting_thread_reference_ptr, (msg_t)listener);
 80084ec:	69fb      	ldr	r3, [r7, #28]
 80084ee:	689a      	ldr	r2, [r3, #8]
 80084f0:	69fb      	ldr	r3, [r7, #28]
 80084f2:	4610      	mov	r0, r2
 80084f4:	4619      	mov	r1, r3
 80084f6:	f002 f847 	bl	800a588 <chThdResumeS>
        }

        listener = listener->next;
 80084fa:	69fb      	ldr	r3, [r7, #28]
 80084fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80084fe:	61fb      	str	r3, [r7, #28]
        listener = listener->next;
    }

    // Wake listener threads
    listener = topic->listener_list_head;
    while (listener) {
 8008500:	69fb      	ldr	r3, [r7, #28]
 8008502:	2b00      	cmp	r3, #0
 8008504:	d1ee      	bne.n	80084e4 <pubsub_publish_message+0xe8>
        }

        listener = listener->next;
    }

    chSysUnlock();
 8008506:	f7ff fe61 	bl	80081cc <chSysUnlock>
}
 800850a:	3720      	adds	r7, #32
 800850c:	46bd      	mov	sp, r7
 800850e:	bd80      	pop	{r7, pc}
 8008510:	0800eb58 	.word	0x0800eb58

08008514 <pubsub_listener_handle_one_timeout>:

void pubsub_listener_handle_until_timeout(struct pubsub_listener_s* listener, systime_t timeout) {
    pubsub_multiple_listener_handle_until_timeout(1, &listener, timeout);
}

bool pubsub_listener_handle_one_timeout(struct pubsub_listener_s* listener, systime_t timeout) {
 8008514:	b580      	push	{r7, lr}
 8008516:	b082      	sub	sp, #8
 8008518:	af00      	add	r7, sp, #0
 800851a:	6078      	str	r0, [r7, #4]
 800851c:	460b      	mov	r3, r1
 800851e:	807b      	strh	r3, [r7, #2]
    return pubsub_multiple_listener_handle_one_timeout(1, &listener, timeout);
 8008520:	1d3a      	adds	r2, r7, #4
 8008522:	887b      	ldrh	r3, [r7, #2]
 8008524:	2001      	movs	r0, #1
 8008526:	4611      	mov	r1, r2
 8008528:	461a      	mov	r2, r3
 800852a:	f000 f805 	bl	8008538 <pubsub_multiple_listener_handle_one_timeout>
 800852e:	4603      	mov	r3, r0
}
 8008530:	4618      	mov	r0, r3
 8008532:	3708      	adds	r7, #8
 8008534:	46bd      	mov	sp, r7
 8008536:	bd80      	pop	{r7, pc}

08008538 <pubsub_multiple_listener_handle_one_timeout>:

static struct pubsub_listener_s* pubsub_multiple_listener_wait_timeout_S(size_t num_listeners, struct pubsub_listener_s** listeners, systime_t timeout);

bool pubsub_multiple_listener_handle_one_timeout(size_t num_listeners, struct pubsub_listener_s** listeners, systime_t timeout) {
 8008538:	b580      	push	{r7, lr}
 800853a:	b088      	sub	sp, #32
 800853c:	af00      	add	r7, sp, #0
 800853e:	60f8      	str	r0, [r7, #12]
 8008540:	60b9      	str	r1, [r7, #8]
 8008542:	4613      	mov	r3, r2
 8008544:	80fb      	strh	r3, [r7, #6]
    chSysLock();
 8008546:	f7ff fe39 	bl	80081bc <chSysLock>
    struct pubsub_listener_s* listener_with_message = pubsub_multiple_listener_wait_timeout_S(num_listeners, listeners, timeout);
 800854a:	88fb      	ldrh	r3, [r7, #6]
 800854c:	68f8      	ldr	r0, [r7, #12]
 800854e:	68b9      	ldr	r1, [r7, #8]
 8008550:	461a      	mov	r2, r3
 8008552:	f000 f843 	bl	80085dc <pubsub_multiple_listener_wait_timeout_S>
 8008556:	61f8      	str	r0, [r7, #28]

    if (listener_with_message) {
 8008558:	69fb      	ldr	r3, [r7, #28]
 800855a:	2b00      	cmp	r3, #0
 800855c:	d027      	beq.n	80085ae <pubsub_multiple_listener_handle_one_timeout+0x76>
        chMtxLockS(&listener_with_message->mtx);
 800855e:	69fb      	ldr	r3, [r7, #28]
 8008560:	3318      	adds	r3, #24
 8008562:	4618      	mov	r0, r3
 8008564:	f002 f9ac 	bl	800a8c0 <chMtxLockS>
        chSysUnlock();
 8008568:	f7ff fe30 	bl	80081cc <chSysUnlock>

        struct pubsub_message_s* message = listener_with_message->next_message;
 800856c:	69fb      	ldr	r3, [r7, #28]
 800856e:	685b      	ldr	r3, [r3, #4]
 8008570:	61bb      	str	r3, [r7, #24]
        listener_with_message->next_message = message->next_in_topic;
 8008572:	69bb      	ldr	r3, [r7, #24]
 8008574:	685a      	ldr	r2, [r3, #4]
 8008576:	69fb      	ldr	r3, [r7, #28]
 8008578:	605a      	str	r2, [r3, #4]

        if (listener_with_message->handler_cb) {
 800857a:	69fb      	ldr	r3, [r7, #28]
 800857c:	68db      	ldr	r3, [r3, #12]
 800857e:	2b00      	cmp	r3, #0
 8008580:	d00e      	beq.n	80085a0 <pubsub_multiple_listener_handle_one_timeout+0x68>
            size_t message_size = fifoallocator_get_block_size(message)-sizeof(struct pubsub_message_s);
 8008582:	69b8      	ldr	r0, [r7, #24]
 8008584:	f7ff fda2 	bl	80080cc <fifoallocator_get_block_size>
 8008588:	4603      	mov	r3, r0
 800858a:	3b08      	subs	r3, #8
 800858c:	617b      	str	r3, [r7, #20]

            listener_with_message->handler_cb(message_size, message->data, listener_with_message->handler_cb_ctx);
 800858e:	69fb      	ldr	r3, [r7, #28]
 8008590:	68db      	ldr	r3, [r3, #12]
 8008592:	69ba      	ldr	r2, [r7, #24]
 8008594:	f102 0108 	add.w	r1, r2, #8
 8008598:	69fa      	ldr	r2, [r7, #28]
 800859a:	6912      	ldr	r2, [r2, #16]
 800859c:	6978      	ldr	r0, [r7, #20]
 800859e:	4798      	blx	r3
        }

        chMtxUnlock(&listener_with_message->mtx);
 80085a0:	69fb      	ldr	r3, [r7, #28]
 80085a2:	3318      	adds	r3, #24
 80085a4:	4618      	mov	r0, r3
 80085a6:	f002 fa21 	bl	800a9ec <chMtxUnlock>
        return true;
 80085aa:	2301      	movs	r3, #1
 80085ac:	e002      	b.n	80085b4 <pubsub_multiple_listener_handle_one_timeout+0x7c>
    } else {
        chSysUnlock();
 80085ae:	f7ff fe0d 	bl	80081cc <chSysUnlock>
        return false;
 80085b2:	2300      	movs	r3, #0
    }
}
 80085b4:	4618      	mov	r0, r3
 80085b6:	3720      	adds	r7, #32
 80085b8:	46bd      	mov	sp, r7
 80085ba:	bd80      	pop	{r7, pc}

080085bc <pubsub_listener_set_waiting_thread_reference>:
            elapsed = chVTTimeElapsedSinceX(start);
        }
    } while(elapsed < timeout);
}

void pubsub_listener_set_waiting_thread_reference(struct pubsub_listener_s* listener, thread_reference_t* trpp) {
 80085bc:	b480      	push	{r7}
 80085be:	b083      	sub	sp, #12
 80085c0:	af00      	add	r7, sp, #0
 80085c2:	6078      	str	r0, [r7, #4]
 80085c4:	6039      	str	r1, [r7, #0]
    if (!listener) {
 80085c6:	687b      	ldr	r3, [r7, #4]
 80085c8:	2b00      	cmp	r3, #0
 80085ca:	d002      	beq.n	80085d2 <pubsub_listener_set_waiting_thread_reference+0x16>
        return;
    }

    listener->waiting_thread_reference_ptr = trpp;
 80085cc:	687b      	ldr	r3, [r7, #4]
 80085ce:	683a      	ldr	r2, [r7, #0]
 80085d0:	609a      	str	r2, [r3, #8]
}
 80085d2:	370c      	adds	r7, #12
 80085d4:	46bd      	mov	sp, r7
 80085d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80085da:	4770      	bx	lr

080085dc <pubsub_multiple_listener_wait_timeout_S>:

static struct pubsub_listener_s* pubsub_multiple_listener_wait_timeout_S(size_t num_listeners, struct pubsub_listener_s** listeners, systime_t timeout) {
 80085dc:	b580      	push	{r7, lr}
 80085de:	b08c      	sub	sp, #48	; 0x30
 80085e0:	af00      	add	r7, sp, #0
 80085e2:	60f8      	str	r0, [r7, #12]
 80085e4:	60b9      	str	r1, [r7, #8]
 80085e6:	4613      	mov	r3, r2
 80085e8:	80fb      	strh	r3, [r7, #6]
    chDbgCheckClassS();
 80085ea:	f002 fcf9 	bl	800afe0 <chDbgCheckClassS>

    // Check for immediately available messages
    for (size_t i=0; i<num_listeners; i++) {
 80085ee:	2300      	movs	r3, #0
 80085f0:	62fb      	str	r3, [r7, #44]	; 0x2c
 80085f2:	e01a      	b.n	800862a <pubsub_multiple_listener_wait_timeout_S+0x4e>
        if (listeners && listeners[i] && listeners[i]->next_message) {
 80085f4:	68bb      	ldr	r3, [r7, #8]
 80085f6:	2b00      	cmp	r3, #0
 80085f8:	d014      	beq.n	8008624 <pubsub_multiple_listener_wait_timeout_S+0x48>
 80085fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80085fc:	009b      	lsls	r3, r3, #2
 80085fe:	68ba      	ldr	r2, [r7, #8]
 8008600:	4413      	add	r3, r2
 8008602:	681b      	ldr	r3, [r3, #0]
 8008604:	2b00      	cmp	r3, #0
 8008606:	d00d      	beq.n	8008624 <pubsub_multiple_listener_wait_timeout_S+0x48>
 8008608:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800860a:	009b      	lsls	r3, r3, #2
 800860c:	68ba      	ldr	r2, [r7, #8]
 800860e:	4413      	add	r3, r2
 8008610:	681b      	ldr	r3, [r3, #0]
 8008612:	685b      	ldr	r3, [r3, #4]
 8008614:	2b00      	cmp	r3, #0
 8008616:	d005      	beq.n	8008624 <pubsub_multiple_listener_wait_timeout_S+0x48>
            return listeners[i];
 8008618:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800861a:	009b      	lsls	r3, r3, #2
 800861c:	68ba      	ldr	r2, [r7, #8]
 800861e:	4413      	add	r3, r2
 8008620:	681b      	ldr	r3, [r3, #0]
 8008622:	e06b      	b.n	80086fc <pubsub_multiple_listener_wait_timeout_S+0x120>

static struct pubsub_listener_s* pubsub_multiple_listener_wait_timeout_S(size_t num_listeners, struct pubsub_listener_s** listeners, systime_t timeout) {
    chDbgCheckClassS();

    // Check for immediately available messages
    for (size_t i=0; i<num_listeners; i++) {
 8008624:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008626:	3301      	adds	r3, #1
 8008628:	62fb      	str	r3, [r7, #44]	; 0x2c
 800862a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800862c:	68fb      	ldr	r3, [r7, #12]
 800862e:	429a      	cmp	r2, r3
 8008630:	d3e0      	bcc.n	80085f4 <pubsub_multiple_listener_wait_timeout_S+0x18>
        if (listeners && listeners[i] && listeners[i]->next_message) {
            return listeners[i];
        }
    }

    if (timeout == TIME_IMMEDIATE) {
 8008632:	88fb      	ldrh	r3, [r7, #6]
 8008634:	2b00      	cmp	r3, #0
 8008636:	d101      	bne.n	800863c <pubsub_multiple_listener_wait_timeout_S+0x60>
        return NULL;
 8008638:	2300      	movs	r3, #0
 800863a:	e05f      	b.n	80086fc <pubsub_multiple_listener_wait_timeout_S+0x120>
    }

    // Point listeners' waiting thread references to our thread
    thread_reference_t trp = NULL;
 800863c:	2300      	movs	r3, #0
 800863e:	617b      	str	r3, [r7, #20]
    for (size_t i=0; i<num_listeners; i++) {
 8008640:	2300      	movs	r3, #0
 8008642:	62bb      	str	r3, [r7, #40]	; 0x28
 8008644:	e014      	b.n	8008670 <pubsub_multiple_listener_wait_timeout_S+0x94>
        if (listeners && listeners[i]) {
 8008646:	68bb      	ldr	r3, [r7, #8]
 8008648:	2b00      	cmp	r3, #0
 800864a:	d00e      	beq.n	800866a <pubsub_multiple_listener_wait_timeout_S+0x8e>
 800864c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800864e:	009b      	lsls	r3, r3, #2
 8008650:	68ba      	ldr	r2, [r7, #8]
 8008652:	4413      	add	r3, r2
 8008654:	681b      	ldr	r3, [r3, #0]
 8008656:	2b00      	cmp	r3, #0
 8008658:	d007      	beq.n	800866a <pubsub_multiple_listener_wait_timeout_S+0x8e>
            listeners[i]->waiting_thread_reference_ptr = &trp;
 800865a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800865c:	009b      	lsls	r3, r3, #2
 800865e:	68ba      	ldr	r2, [r7, #8]
 8008660:	4413      	add	r3, r2
 8008662:	681b      	ldr	r3, [r3, #0]
 8008664:	f107 0214 	add.w	r2, r7, #20
 8008668:	609a      	str	r2, [r3, #8]
        return NULL;
    }

    // Point listeners' waiting thread references to our thread
    thread_reference_t trp = NULL;
    for (size_t i=0; i<num_listeners; i++) {
 800866a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800866c:	3301      	adds	r3, #1
 800866e:	62bb      	str	r3, [r7, #40]	; 0x28
 8008670:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8008672:	68fb      	ldr	r3, [r7, #12]
 8008674:	429a      	cmp	r2, r3
 8008676:	d3e6      	bcc.n	8008646 <pubsub_multiple_listener_wait_timeout_S+0x6a>
            listeners[i]->waiting_thread_reference_ptr = &trp;
        }
    }

    // Wait for a listener to wake us up
    msg_t message = chThdSuspendTimeoutS(&trp, timeout);
 8008678:	f107 0214 	add.w	r2, r7, #20
 800867c:	88fb      	ldrh	r3, [r7, #6]
 800867e:	4610      	mov	r0, r2
 8008680:	4619      	mov	r1, r3
 8008682:	f001 ff37 	bl	800a4f4 <chThdSuspendTimeoutS>
 8008686:	61b8      	str	r0, [r7, #24]

    struct pubsub_listener_s* ret = NULL;
 8008688:	2300      	movs	r3, #0
 800868a:	627b      	str	r3, [r7, #36]	; 0x24
    if (message != MSG_TIMEOUT) {
 800868c:	69bb      	ldr	r3, [r7, #24]
 800868e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8008692:	d017      	beq.n	80086c4 <pubsub_multiple_listener_wait_timeout_S+0xe8>
        for (size_t i=0; i<num_listeners; i++) {
 8008694:	2300      	movs	r3, #0
 8008696:	623b      	str	r3, [r7, #32]
 8008698:	e010      	b.n	80086bc <pubsub_multiple_listener_wait_timeout_S+0xe0>
            if (listeners[i] == (void*)message) {
 800869a:	6a3b      	ldr	r3, [r7, #32]
 800869c:	009b      	lsls	r3, r3, #2
 800869e:	68ba      	ldr	r2, [r7, #8]
 80086a0:	4413      	add	r3, r2
 80086a2:	681a      	ldr	r2, [r3, #0]
 80086a4:	69bb      	ldr	r3, [r7, #24]
 80086a6:	429a      	cmp	r2, r3
 80086a8:	d105      	bne.n	80086b6 <pubsub_multiple_listener_wait_timeout_S+0xda>
                ret = listeners[i];
 80086aa:	6a3b      	ldr	r3, [r7, #32]
 80086ac:	009b      	lsls	r3, r3, #2
 80086ae:	68ba      	ldr	r2, [r7, #8]
 80086b0:	4413      	add	r3, r2
 80086b2:	681b      	ldr	r3, [r3, #0]
 80086b4:	627b      	str	r3, [r7, #36]	; 0x24
    // Wait for a listener to wake us up
    msg_t message = chThdSuspendTimeoutS(&trp, timeout);

    struct pubsub_listener_s* ret = NULL;
    if (message != MSG_TIMEOUT) {
        for (size_t i=0; i<num_listeners; i++) {
 80086b6:	6a3b      	ldr	r3, [r7, #32]
 80086b8:	3301      	adds	r3, #1
 80086ba:	623b      	str	r3, [r7, #32]
 80086bc:	6a3a      	ldr	r2, [r7, #32]
 80086be:	68fb      	ldr	r3, [r7, #12]
 80086c0:	429a      	cmp	r2, r3
 80086c2:	d3ea      	bcc.n	800869a <pubsub_multiple_listener_wait_timeout_S+0xbe>
            }
        }
    }

    // Set listeners' waiting thread references back to NULL
    for (size_t i=0; i<num_listeners; i++) {
 80086c4:	2300      	movs	r3, #0
 80086c6:	61fb      	str	r3, [r7, #28]
 80086c8:	e013      	b.n	80086f2 <pubsub_multiple_listener_wait_timeout_S+0x116>
        if (listeners && listeners[i]) {
 80086ca:	68bb      	ldr	r3, [r7, #8]
 80086cc:	2b00      	cmp	r3, #0
 80086ce:	d00d      	beq.n	80086ec <pubsub_multiple_listener_wait_timeout_S+0x110>
 80086d0:	69fb      	ldr	r3, [r7, #28]
 80086d2:	009b      	lsls	r3, r3, #2
 80086d4:	68ba      	ldr	r2, [r7, #8]
 80086d6:	4413      	add	r3, r2
 80086d8:	681b      	ldr	r3, [r3, #0]
 80086da:	2b00      	cmp	r3, #0
 80086dc:	d006      	beq.n	80086ec <pubsub_multiple_listener_wait_timeout_S+0x110>
            listeners[i]->waiting_thread_reference_ptr = NULL;
 80086de:	69fb      	ldr	r3, [r7, #28]
 80086e0:	009b      	lsls	r3, r3, #2
 80086e2:	68ba      	ldr	r2, [r7, #8]
 80086e4:	4413      	add	r3, r2
 80086e6:	681b      	ldr	r3, [r3, #0]
 80086e8:	2200      	movs	r2, #0
 80086ea:	609a      	str	r2, [r3, #8]
            }
        }
    }

    // Set listeners' waiting thread references back to NULL
    for (size_t i=0; i<num_listeners; i++) {
 80086ec:	69fb      	ldr	r3, [r7, #28]
 80086ee:	3301      	adds	r3, #1
 80086f0:	61fb      	str	r3, [r7, #28]
 80086f2:	69fa      	ldr	r2, [r7, #28]
 80086f4:	68fb      	ldr	r3, [r7, #12]
 80086f6:	429a      	cmp	r2, r3
 80086f8:	d3e7      	bcc.n	80086ca <pubsub_multiple_listener_wait_timeout_S+0xee>
        if (listeners && listeners[i]) {
            listeners[i]->waiting_thread_reference_ptr = NULL;
        }
    }

    return ret;
 80086fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 80086fc:	4618      	mov	r0, r3
 80086fe:	3730      	adds	r7, #48	; 0x30
 8008700:	46bd      	mov	sp, r7
 8008702:	bd80      	pop	{r7, pc}

08008704 <port_lock.lto_priv.149>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8008704:	b480      	push	{r7}
 8008706:	b083      	sub	sp, #12
 8008708:	af00      	add	r7, sp, #0
 800870a:	2320      	movs	r3, #32
 800870c:	607b      	str	r3, [r7, #4]
 800870e:	687b      	ldr	r3, [r7, #4]
 8008710:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008714:	370c      	adds	r7, #12
 8008716:	46bd      	mov	sp, r7
 8008718:	f85d 7b04 	ldr.w	r7, [sp], #4
 800871c:	4770      	bx	lr
 800871e:	bf00      	nop

08008720 <port_unlock.lto_priv.147>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8008720:	b480      	push	{r7}
 8008722:	b083      	sub	sp, #12
 8008724:	af00      	add	r7, sp, #0
 8008726:	2300      	movs	r3, #0
 8008728:	607b      	str	r3, [r7, #4]
 800872a:	687b      	ldr	r3, [r7, #4]
 800872c:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008730:	370c      	adds	r7, #12
 8008732:	46bd      	mov	sp, r7
 8008734:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008738:	4770      	bx	lr
 800873a:	bf00      	nop

0800873c <st_lld_get_counter.lto_priv.145>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 800873c:	b480      	push	{r7}
 800873e:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 8008740:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008744:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008746:	b29b      	uxth	r3, r3
}
 8008748:	4618      	mov	r0, r3
 800874a:	46bd      	mov	sp, r7
 800874c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008750:	4770      	bx	lr
 8008752:	bf00      	nop

08008754 <port_timer_get_time.lto_priv.142>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8008754:	b580      	push	{r7, lr}
 8008756:	af00      	add	r7, sp, #0

  return stGetCounter();
 8008758:	f7ff fff0 	bl	800873c <st_lld_get_counter.lto_priv.145>
 800875c:	4603      	mov	r3, r0
}
 800875e:	4618      	mov	r0, r3
 8008760:	bd80      	pop	{r7, pc}
 8008762:	bf00      	nop

08008764 <chSysLock.lto_priv.125>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8008764:	b580      	push	{r7, lr}
 8008766:	af00      	add	r7, sp, #0

  port_lock();
 8008768:	f7ff ffcc 	bl	8008704 <port_lock.lto_priv.149>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800876c:	f002 fb96 	bl	800ae9c <_dbg_check_lock>
}
 8008770:	bd80      	pop	{r7, pc}
 8008772:	bf00      	nop

08008774 <chSysUnlock.lto_priv.123>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8008774:	b580      	push	{r7, lr}
 8008776:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8008778:	f002 fba6 	bl	800aec8 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800877c:	4b09      	ldr	r3, [pc, #36]	; (80087a4 <chSysUnlock.lto_priv.123+0x30>)
 800877e:	681b      	ldr	r3, [r3, #0]
 8008780:	4a08      	ldr	r2, [pc, #32]	; (80087a4 <chSysUnlock.lto_priv.123+0x30>)
 8008782:	4293      	cmp	r3, r2
 8008784:	d00a      	beq.n	800879c <chSysUnlock.lto_priv.123+0x28>
 8008786:	4b07      	ldr	r3, [pc, #28]	; (80087a4 <chSysUnlock.lto_priv.123+0x30>)
 8008788:	699b      	ldr	r3, [r3, #24]
 800878a:	689a      	ldr	r2, [r3, #8]
 800878c:	4b05      	ldr	r3, [pc, #20]	; (80087a4 <chSysUnlock.lto_priv.123+0x30>)
 800878e:	681b      	ldr	r3, [r3, #0]
 8008790:	689b      	ldr	r3, [r3, #8]
 8008792:	429a      	cmp	r2, r3
 8008794:	d202      	bcs.n	800879c <chSysUnlock.lto_priv.123+0x28>
 8008796:	4804      	ldr	r0, [pc, #16]	; (80087a8 <chSysUnlock.lto_priv.123+0x34>)
 8008798:	f002 fb32 	bl	800ae00 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 800879c:	f7ff ffc0 	bl	8008720 <port_unlock.lto_priv.147>
}
 80087a0:	bd80      	pop	{r7, pc}
 80087a2:	bf00      	nop
 80087a4:	20001338 	.word	0x20001338
 80087a8:	0800eb98 	.word	0x0800eb98

080087ac <chVTGetSystemTimeX.lto_priv.116>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 80087ac:	b580      	push	{r7, lr}
 80087ae:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 80087b0:	f7ff ffd0 	bl	8008754 <port_timer_get_time.lto_priv.142>
 80087b4:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80087b6:	4618      	mov	r0, r3
 80087b8:	bd80      	pop	{r7, pc}
 80087ba:	bf00      	nop

080087bc <chThdGetSelfX.lto_priv.132>:
  *
  * @return             A pointer to the current thread.
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {
 80087bc:	b480      	push	{r7}
 80087be:	af00      	add	r7, sp, #0

  return ch.rlist.current;
 80087c0:	4b03      	ldr	r3, [pc, #12]	; (80087d0 <chThdGetSelfX.lto_priv.132+0x14>)
 80087c2:	699b      	ldr	r3, [r3, #24]
}
 80087c4:	4618      	mov	r0, r3
 80087c6:	46bd      	mov	sp, r7
 80087c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80087cc:	4770      	bx	lr
 80087ce:	bf00      	nop
 80087d0:	20001338 	.word	0x20001338

080087d4 <chRegSetThreadName.lto_priv.133>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 80087d4:	b480      	push	{r7}
 80087d6:	b083      	sub	sp, #12
 80087d8:	af00      	add	r7, sp, #0
 80087da:	6078      	str	r0, [r7, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 80087dc:	4b04      	ldr	r3, [pc, #16]	; (80087f0 <chRegSetThreadName.lto_priv.133+0x1c>)
 80087de:	699b      	ldr	r3, [r3, #24]
 80087e0:	687a      	ldr	r2, [r7, #4]
 80087e2:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 80087e4:	370c      	adds	r7, #12
 80087e6:	46bd      	mov	sp, r7
 80087e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80087ec:	4770      	bx	lr
 80087ee:	bf00      	nop
 80087f0:	20001338 	.word	0x20001338

080087f4 <chMBGetUsedCountI.lto_priv.131>:
 * @return              The number of queued messages.
 * @retval QUEUE_RESET  if the queue is in reset state.
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(const mailbox_t *mbp) {
 80087f4:	b580      	push	{r7, lr}
 80087f6:	b082      	sub	sp, #8
 80087f8:	af00      	add	r7, sp, #0
 80087fa:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 80087fc:	f002 fbde 	bl	800afbc <chDbgCheckClassI>

  return mbp->cnt;
 8008800:	687b      	ldr	r3, [r7, #4]
 8008802:	691b      	ldr	r3, [r3, #16]
}
 8008804:	4618      	mov	r0, r3
 8008806:	3708      	adds	r7, #8
 8008808:	46bd      	mov	sp, r7
 800880a:	bd80      	pop	{r7, pc}

0800880c <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
static inline void *chCoreAllocAligned(size_t size, unsigned align) {
 800880c:	b580      	push	{r7, lr}
 800880e:	b084      	sub	sp, #16
 8008810:	af00      	add	r7, sp, #0
 8008812:	6078      	str	r0, [r7, #4]
 8008814:	6039      	str	r1, [r7, #0]
  void *p;

  chSysLock();
 8008816:	f7ff ffa5 	bl	8008764 <chSysLock.lto_priv.125>
  p = chCoreAllocAlignedWithOffsetI(size, align, 0U);
 800881a:	6878      	ldr	r0, [r7, #4]
 800881c:	6839      	ldr	r1, [r7, #0]
 800881e:	2200      	movs	r2, #0
 8008820:	f001 fab4 	bl	8009d8c <chCoreAllocAlignedWithOffsetI>
 8008824:	60f8      	str	r0, [r7, #12]
  chSysUnlock();
 8008826:	f7ff ffa5 	bl	8008774 <chSysUnlock.lto_priv.123>

  return p;
 800882a:	68fb      	ldr	r3, [r7, #12]
}
 800882c:	4618      	mov	r0, r3
 800882e:	3710      	adds	r7, #16
 8008830:	46bd      	mov	sp, r7
 8008832:	bd80      	pop	{r7, pc}

08008834 <chCoreAllocI.lto_priv.135>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocI(size_t size) {
 8008834:	b580      	push	{r7, lr}
 8008836:	b082      	sub	sp, #8
 8008838:	af00      	add	r7, sp, #0
 800883a:	6078      	str	r0, [r7, #4]

  return chCoreAllocAlignedWithOffsetI(size, PORT_NATURAL_ALIGN, 0U);
 800883c:	6878      	ldr	r0, [r7, #4]
 800883e:	2104      	movs	r1, #4
 8008840:	2200      	movs	r2, #0
 8008842:	f001 faa3 	bl	8009d8c <chCoreAllocAlignedWithOffsetI>
 8008846:	4603      	mov	r3, r0
}
 8008848:	4618      	mov	r0, r3
 800884a:	3708      	adds	r7, #8
 800884c:	46bd      	mov	sp, r7
 800884e:	bd80      	pop	{r7, pc}

08008850 <chPoolAddI.lto_priv.134>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be added
 *
 * @iclass
 */
static inline void chPoolAddI(memory_pool_t *mp, void *objp) {
 8008850:	b580      	push	{r7, lr}
 8008852:	b082      	sub	sp, #8
 8008854:	af00      	add	r7, sp, #0
 8008856:	6078      	str	r0, [r7, #4]
 8008858:	6039      	str	r1, [r7, #0]

  chDbgCheckClassI();
 800885a:	f002 fbaf 	bl	800afbc <chDbgCheckClassI>

  chPoolFreeI(mp, objp);
 800885e:	6878      	ldr	r0, [r7, #4]
 8008860:	6839      	ldr	r1, [r7, #0]
 8008862:	f001 fbc9 	bl	8009ff8 <chPoolFreeI>
}
 8008866:	3708      	adds	r7, #8
 8008868:	46bd      	mov	sp, r7
 800886a:	bd80      	pop	{r7, pc}

0800886c <worker_thread_init>:
static bool worker_thread_listener_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* check_task);
static bool worker_thread_listener_task_is_registered(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* check_task);
static bool worker_thread_get_any_listener_task_due_I(struct worker_thread_s* worker_thread);
#endif

void worker_thread_init(struct worker_thread_s* worker_thread, const char* name, tprio_t priority) {
 800886c:	b580      	push	{r7, lr}
 800886e:	b084      	sub	sp, #16
 8008870:	af00      	add	r7, sp, #0
 8008872:	60f8      	str	r0, [r7, #12]
 8008874:	60b9      	str	r1, [r7, #8]
 8008876:	607a      	str	r2, [r7, #4]
    chDbgCheck(worker_thread != NULL);
 8008878:	68fb      	ldr	r3, [r7, #12]
 800887a:	2b00      	cmp	r3, #0
 800887c:	d102      	bne.n	8008884 <worker_thread_init+0x18>
 800887e:	480d      	ldr	r0, [pc, #52]	; (80088b4 <worker_thread_init+0x48>)
 8008880:	f002 fabe 	bl	800ae00 <chSysHalt>

    worker_thread->name = name;
 8008884:	68fb      	ldr	r3, [r7, #12]
 8008886:	68ba      	ldr	r2, [r7, #8]
 8008888:	601a      	str	r2, [r3, #0]
    worker_thread->priority = priority;
 800888a:	68fb      	ldr	r3, [r7, #12]
 800888c:	687a      	ldr	r2, [r7, #4]
 800888e:	605a      	str	r2, [r3, #4]

    worker_thread->timer_task_list_head = NULL;
 8008890:	68fb      	ldr	r3, [r7, #12]
 8008892:	2200      	movs	r2, #0
 8008894:	611a      	str	r2, [r3, #16]
#ifdef MODULE_PUBSUB_ENABLED
    worker_thread->listener_task_list_head = NULL;
 8008896:	68fb      	ldr	r3, [r7, #12]
 8008898:	2200      	movs	r2, #0
 800889a:	615a      	str	r2, [r3, #20]
    worker_thread->publisher_task_list_head = NULL;
 800889c:	68fb      	ldr	r3, [r7, #12]
 800889e:	2200      	movs	r2, #0
 80088a0:	619a      	str	r2, [r3, #24]
#endif

    worker_thread->thread = NULL;
 80088a2:	68fb      	ldr	r3, [r7, #12]
 80088a4:	2200      	movs	r2, #0
 80088a6:	609a      	str	r2, [r3, #8]
    worker_thread->suspend_trp = NULL;
 80088a8:	68fb      	ldr	r3, [r7, #12]
 80088aa:	2200      	movs	r2, #0
 80088ac:	60da      	str	r2, [r3, #12]
}
 80088ae:	3710      	adds	r7, #16
 80088b0:	46bd      	mov	sp, r7
 80088b2:	bd80      	pop	{r7, pc}
 80088b4:	0800eb70 	.word	0x0800eb70

080088b8 <worker_thread_start>:

void worker_thread_start(struct worker_thread_s* worker_thread, size_t stack_size) {
 80088b8:	b580      	push	{r7, lr}
 80088ba:	b08a      	sub	sp, #40	; 0x28
 80088bc:	af00      	add	r7, sp, #0
 80088be:	6078      	str	r0, [r7, #4]
 80088c0:	6039      	str	r1, [r7, #0]
    chDbgCheck(worker_thread != NULL);
 80088c2:	687b      	ldr	r3, [r7, #4]
 80088c4:	2b00      	cmp	r3, #0
 80088c6:	d102      	bne.n	80088ce <worker_thread_start+0x16>
 80088c8:	4818      	ldr	r0, [pc, #96]	; (800892c <worker_thread_start+0x74>)
 80088ca:	f002 fa99 	bl	800ae00 <chSysHalt>

    void* working_area = chCoreAllocAligned(THD_WORKING_AREA_SIZE(stack_size), PORT_WORKING_AREA_ALIGN);
 80088ce:	683b      	ldr	r3, [r7, #0]
 80088d0:	33c3      	adds	r3, #195	; 0xc3
 80088d2:	f023 0307 	bic.w	r3, r3, #7
 80088d6:	4618      	mov	r0, r3
 80088d8:	2108      	movs	r1, #8
 80088da:	f7ff ff97 	bl	800880c <chCoreAllocAligned>
 80088de:	6278      	str	r0, [r7, #36]	; 0x24
    chDbgCheck(working_area != NULL);
 80088e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80088e2:	2b00      	cmp	r3, #0
 80088e4:	d102      	bne.n	80088ec <worker_thread_start+0x34>
 80088e6:	4811      	ldr	r0, [pc, #68]	; (800892c <worker_thread_start+0x74>)
 80088e8:	f002 fa8a 	bl	800ae00 <chSysHalt>
    
    const thread_descriptor_t thread_descriptor = {
        worker_thread->name,
 80088ec:	687b      	ldr	r3, [r7, #4]
 80088ee:	681b      	ldr	r3, [r3, #0]
    chDbgCheck(worker_thread != NULL);

    void* working_area = chCoreAllocAligned(THD_WORKING_AREA_SIZE(stack_size), PORT_WORKING_AREA_ALIGN);
    chDbgCheck(working_area != NULL);
    
    const thread_descriptor_t thread_descriptor = {
 80088f0:	60fb      	str	r3, [r7, #12]
 80088f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80088f4:	613b      	str	r3, [r7, #16]
        worker_thread->name,
        THD_WORKING_AREA_BASE(working_area),
        THD_WORKING_AREA_BASE(working_area) + THD_WORKING_AREA_SIZE(stack_size)/sizeof(stkalign_t),
 80088f6:	683b      	ldr	r3, [r7, #0]
 80088f8:	33c3      	adds	r3, #195	; 0xc3
 80088fa:	f023 0307 	bic.w	r3, r3, #7
 80088fe:	08db      	lsrs	r3, r3, #3
 8008900:	00db      	lsls	r3, r3, #3
 8008902:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008904:	4413      	add	r3, r2
    chDbgCheck(worker_thread != NULL);

    void* working_area = chCoreAllocAligned(THD_WORKING_AREA_SIZE(stack_size), PORT_WORKING_AREA_ALIGN);
    chDbgCheck(working_area != NULL);
    
    const thread_descriptor_t thread_descriptor = {
 8008906:	617b      	str	r3, [r7, #20]
        worker_thread->name,
        THD_WORKING_AREA_BASE(working_area),
        THD_WORKING_AREA_BASE(working_area) + THD_WORKING_AREA_SIZE(stack_size)/sizeof(stkalign_t),
        worker_thread->priority,
 8008908:	687b      	ldr	r3, [r7, #4]
 800890a:	685b      	ldr	r3, [r3, #4]
    chDbgCheck(worker_thread != NULL);

    void* working_area = chCoreAllocAligned(THD_WORKING_AREA_SIZE(stack_size), PORT_WORKING_AREA_ALIGN);
    chDbgCheck(working_area != NULL);
    
    const thread_descriptor_t thread_descriptor = {
 800890c:	61bb      	str	r3, [r7, #24]
 800890e:	4b08      	ldr	r3, [pc, #32]	; (8008930 <worker_thread_start+0x78>)
 8008910:	61fb      	str	r3, [r7, #28]
 8008912:	687b      	ldr	r3, [r7, #4]
 8008914:	623b      	str	r3, [r7, #32]
        worker_thread->priority,
        worker_thread_func,
        worker_thread
    };
    
    worker_thread->thread = chThdCreate(&thread_descriptor);
 8008916:	f107 030c 	add.w	r3, r7, #12
 800891a:	4618      	mov	r0, r3
 800891c:	f001 fcf8 	bl	800a310 <chThdCreate>
 8008920:	4602      	mov	r2, r0
 8008922:	687b      	ldr	r3, [r7, #4]
 8008924:	609a      	str	r2, [r3, #8]
}
 8008926:	3728      	adds	r7, #40	; 0x28
 8008928:	46bd      	mov	sp, r7
 800892a:	bd80      	pop	{r7, pc}
 800892c:	0800eb84 	.word	0x0800eb84
 8008930:	08006b25 	.word	0x08006b25

08008934 <_worker_thread_add_timer_task_no_wake_I>:

static void _worker_thread_add_timer_task_no_wake_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, timer_task_handler_func_ptr task_func, void* ctx, systime_t timer_expiration_ticks, bool auto_repeat) {
 8008934:	b590      	push	{r4, r7, lr}
 8008936:	b087      	sub	sp, #28
 8008938:	af02      	add	r7, sp, #8
 800893a:	60f8      	str	r0, [r7, #12]
 800893c:	60b9      	str	r1, [r7, #8]
 800893e:	607a      	str	r2, [r7, #4]
 8008940:	603b      	str	r3, [r7, #0]
    chDbgCheckClassI();
 8008942:	f002 fb3b 	bl	800afbc <chDbgCheckClassI>

    worker_thread_init_timer_task(task, chVTGetSystemTimeX(), timer_expiration_ticks, auto_repeat, task_func, ctx);
 8008946:	f7ff ff31 	bl	80087ac <chVTGetSystemTimeX.lto_priv.116>
 800894a:	4603      	mov	r3, r0
 800894c:	4619      	mov	r1, r3
 800894e:	8c3a      	ldrh	r2, [r7, #32]
 8008950:	f897 4024 	ldrb.w	r4, [r7, #36]	; 0x24
 8008954:	687b      	ldr	r3, [r7, #4]
 8008956:	9300      	str	r3, [sp, #0]
 8008958:	683b      	ldr	r3, [r7, #0]
 800895a:	9301      	str	r3, [sp, #4]
 800895c:	68b8      	ldr	r0, [r7, #8]
 800895e:	4623      	mov	r3, r4
 8008960:	f7fe f90a 	bl	8006b78 <worker_thread_init_timer_task.lto_priv.164>
    worker_thread_insert_timer_task_I(worker_thread, task);
 8008964:	68f8      	ldr	r0, [r7, #12]
 8008966:	68b9      	ldr	r1, [r7, #8]
 8008968:	f7fe f944 	bl	8006bf4 <worker_thread_insert_timer_task_I.lto_priv.163>
}
 800896c:	3714      	adds	r7, #20
 800896e:	46bd      	mov	sp, r7
 8008970:	bd90      	pop	{r4, r7, pc}
 8008972:	bf00      	nop

08008974 <worker_thread_add_timer_task>:

    // Wake worker thread to process tasks
    worker_thread_wake_I(worker_thread);
}

void worker_thread_add_timer_task(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, timer_task_handler_func_ptr task_func, void* ctx, systime_t timer_expiration_ticks, bool auto_repeat) {
 8008974:	b580      	push	{r7, lr}
 8008976:	b086      	sub	sp, #24
 8008978:	af02      	add	r7, sp, #8
 800897a:	60f8      	str	r0, [r7, #12]
 800897c:	60b9      	str	r1, [r7, #8]
 800897e:	607a      	str	r2, [r7, #4]
 8008980:	603b      	str	r3, [r7, #0]
    chSysLock();
 8008982:	f7ff feef 	bl	8008764 <chSysLock.lto_priv.125>
    _worker_thread_add_timer_task_no_wake_I(worker_thread, task, task_func, ctx, timer_expiration_ticks, auto_repeat);
 8008986:	8b3b      	ldrh	r3, [r7, #24]
 8008988:	9300      	str	r3, [sp, #0]
 800898a:	7f3b      	ldrb	r3, [r7, #28]
 800898c:	9301      	str	r3, [sp, #4]
 800898e:	68f8      	ldr	r0, [r7, #12]
 8008990:	68b9      	ldr	r1, [r7, #8]
 8008992:	687a      	ldr	r2, [r7, #4]
 8008994:	683b      	ldr	r3, [r7, #0]
 8008996:	f7ff ffcd 	bl	8008934 <_worker_thread_add_timer_task_no_wake_I>
    chSysUnlock();
 800899a:	f7ff feeb 	bl	8008774 <chSysUnlock.lto_priv.123>

    // Wake worker thread to process tasks
    worker_thread_wake(worker_thread);
 800899e:	68f8      	ldr	r0, [r7, #12]
 80089a0:	f7fe f8dc 	bl	8006b5c <worker_thread_wake.lto_priv.160>
}
 80089a4:	3710      	adds	r7, #16
 80089a6:	46bd      	mov	sp, r7
 80089a8:	bd80      	pop	{r7, pc}
 80089aa:	bf00      	nop

080089ac <_worker_thread_timer_task_reschedule_no_wake_I>:

static void _worker_thread_timer_task_reschedule_no_wake_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, systime_t timer_expiration_ticks) {
 80089ac:	b580      	push	{r7, lr}
 80089ae:	b086      	sub	sp, #24
 80089b0:	af00      	add	r7, sp, #0
 80089b2:	60f8      	str	r0, [r7, #12]
 80089b4:	60b9      	str	r1, [r7, #8]
 80089b6:	4613      	mov	r3, r2
 80089b8:	80fb      	strh	r3, [r7, #6]
    chDbgCheckClassI();
 80089ba:	f002 faff 	bl	800afbc <chDbgCheckClassI>

    systime_t t_now = chVTGetSystemTimeX();
 80089be:	f7ff fef5 	bl	80087ac <chVTGetSystemTimeX.lto_priv.116>
 80089c2:	4603      	mov	r3, r0
 80089c4:	82fb      	strh	r3, [r7, #22]

    worker_thread_remove_timer_task_I(worker_thread, task);
 80089c6:	68f8      	ldr	r0, [r7, #12]
 80089c8:	68b9      	ldr	r1, [r7, #8]
 80089ca:	f000 f83b 	bl	8008a44 <worker_thread_remove_timer_task_I>

    task->timer_expiration_ticks = timer_expiration_ticks;
 80089ce:	68bb      	ldr	r3, [r7, #8]
 80089d0:	88fa      	ldrh	r2, [r7, #6]
 80089d2:	811a      	strh	r2, [r3, #8]
    task->timer_begin_systime = t_now;
 80089d4:	68bb      	ldr	r3, [r7, #8]
 80089d6:	8afa      	ldrh	r2, [r7, #22]
 80089d8:	815a      	strh	r2, [r3, #10]

    worker_thread_insert_timer_task_I(worker_thread, task);
 80089da:	68f8      	ldr	r0, [r7, #12]
 80089dc:	68b9      	ldr	r1, [r7, #8]
 80089de:	f7fe f909 	bl	8006bf4 <worker_thread_insert_timer_task_I.lto_priv.163>
}
 80089e2:	3718      	adds	r7, #24
 80089e4:	46bd      	mov	sp, r7
 80089e6:	bd80      	pop	{r7, pc}

080089e8 <worker_thread_timer_task_reschedule_I>:

void worker_thread_timer_task_reschedule_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, systime_t timer_expiration_ticks) {
 80089e8:	b580      	push	{r7, lr}
 80089ea:	b084      	sub	sp, #16
 80089ec:	af00      	add	r7, sp, #0
 80089ee:	60f8      	str	r0, [r7, #12]
 80089f0:	60b9      	str	r1, [r7, #8]
 80089f2:	4613      	mov	r3, r2
 80089f4:	80fb      	strh	r3, [r7, #6]
    chDbgCheckClassI();
 80089f6:	f002 fae1 	bl	800afbc <chDbgCheckClassI>
    _worker_thread_timer_task_reschedule_no_wake_I(worker_thread, task, timer_expiration_ticks);
 80089fa:	88fb      	ldrh	r3, [r7, #6]
 80089fc:	68f8      	ldr	r0, [r7, #12]
 80089fe:	68b9      	ldr	r1, [r7, #8]
 8008a00:	461a      	mov	r2, r3
 8008a02:	f7ff ffd3 	bl	80089ac <_worker_thread_timer_task_reschedule_no_wake_I>

    // Wake worker thread to process tasks
    worker_thread_wake_I(worker_thread);
 8008a06:	68f8      	ldr	r0, [r7, #12]
 8008a08:	f7fe f898 	bl	8006b3c <worker_thread_wake_I.lto_priv.162>
}
 8008a0c:	3710      	adds	r7, #16
 8008a0e:	46bd      	mov	sp, r7
 8008a10:	bd80      	pop	{r7, pc}
 8008a12:	bf00      	nop

08008a14 <worker_thread_timer_task_reschedule>:

void worker_thread_timer_task_reschedule(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, systime_t timer_expiration_ticks) {
 8008a14:	b580      	push	{r7, lr}
 8008a16:	b084      	sub	sp, #16
 8008a18:	af00      	add	r7, sp, #0
 8008a1a:	60f8      	str	r0, [r7, #12]
 8008a1c:	60b9      	str	r1, [r7, #8]
 8008a1e:	4613      	mov	r3, r2
 8008a20:	80fb      	strh	r3, [r7, #6]
    chSysLock();
 8008a22:	f7ff fe9f 	bl	8008764 <chSysLock.lto_priv.125>
    _worker_thread_timer_task_reschedule_no_wake_I(worker_thread, task, timer_expiration_ticks);
 8008a26:	88fb      	ldrh	r3, [r7, #6]
 8008a28:	68f8      	ldr	r0, [r7, #12]
 8008a2a:	68b9      	ldr	r1, [r7, #8]
 8008a2c:	461a      	mov	r2, r3
 8008a2e:	f7ff ffbd 	bl	80089ac <_worker_thread_timer_task_reschedule_no_wake_I>
    chSysUnlock();
 8008a32:	f7ff fe9f 	bl	8008774 <chSysUnlock.lto_priv.123>

    // Wake worker thread to process tasks
    worker_thread_wake(worker_thread);
 8008a36:	68f8      	ldr	r0, [r7, #12]
 8008a38:	f7fe f890 	bl	8006b5c <worker_thread_wake.lto_priv.160>
}
 8008a3c:	3710      	adds	r7, #16
 8008a3e:	46bd      	mov	sp, r7
 8008a40:	bd80      	pop	{r7, pc}
 8008a42:	bf00      	nop

08008a44 <worker_thread_remove_timer_task_I>:

void worker_thread_remove_timer_task_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task) {
 8008a44:	b580      	push	{r7, lr}
 8008a46:	b084      	sub	sp, #16
 8008a48:	af00      	add	r7, sp, #0
 8008a4a:	6078      	str	r0, [r7, #4]
 8008a4c:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 8008a4e:	f002 fab5 	bl	800afbc <chDbgCheckClassI>
    LINKED_LIST_REMOVE(struct worker_thread_timer_task_s, worker_thread->timer_task_list_head, task);
 8008a52:	687b      	ldr	r3, [r7, #4]
 8008a54:	3310      	adds	r3, #16
 8008a56:	60fb      	str	r3, [r7, #12]
 8008a58:	e003      	b.n	8008a62 <worker_thread_remove_timer_task_I+0x1e>
 8008a5a:	68fb      	ldr	r3, [r7, #12]
 8008a5c:	681b      	ldr	r3, [r3, #0]
 8008a5e:	3310      	adds	r3, #16
 8008a60:	60fb      	str	r3, [r7, #12]
 8008a62:	68fb      	ldr	r3, [r7, #12]
 8008a64:	681b      	ldr	r3, [r3, #0]
 8008a66:	2b00      	cmp	r3, #0
 8008a68:	d004      	beq.n	8008a74 <worker_thread_remove_timer_task_I+0x30>
 8008a6a:	68fb      	ldr	r3, [r7, #12]
 8008a6c:	681a      	ldr	r2, [r3, #0]
 8008a6e:	683b      	ldr	r3, [r7, #0]
 8008a70:	429a      	cmp	r2, r3
 8008a72:	d1f2      	bne.n	8008a5a <worker_thread_remove_timer_task_I+0x16>
 8008a74:	68fb      	ldr	r3, [r7, #12]
 8008a76:	681b      	ldr	r3, [r3, #0]
 8008a78:	2b00      	cmp	r3, #0
 8008a7a:	d004      	beq.n	8008a86 <worker_thread_remove_timer_task_I+0x42>
 8008a7c:	68fb      	ldr	r3, [r7, #12]
 8008a7e:	681b      	ldr	r3, [r3, #0]
 8008a80:	691a      	ldr	r2, [r3, #16]
 8008a82:	68fb      	ldr	r3, [r7, #12]
 8008a84:	601a      	str	r2, [r3, #0]
}
 8008a86:	3710      	adds	r7, #16
 8008a88:	46bd      	mov	sp, r7
 8008a8a:	bd80      	pop	{r7, pc}

08008a8c <worker_thread_remove_timer_task>:

void worker_thread_remove_timer_task(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task) {
 8008a8c:	b580      	push	{r7, lr}
 8008a8e:	b082      	sub	sp, #8
 8008a90:	af00      	add	r7, sp, #0
 8008a92:	6078      	str	r0, [r7, #4]
 8008a94:	6039      	str	r1, [r7, #0]
    chSysLock();
 8008a96:	f7ff fe65 	bl	8008764 <chSysLock.lto_priv.125>
    worker_thread_remove_timer_task_I(worker_thread, task);
 8008a9a:	6878      	ldr	r0, [r7, #4]
 8008a9c:	6839      	ldr	r1, [r7, #0]
 8008a9e:	f7ff ffd1 	bl	8008a44 <worker_thread_remove_timer_task_I>
    chSysUnlock();
 8008aa2:	f7ff fe67 	bl	8008774 <chSysUnlock.lto_priv.123>
}
 8008aa6:	3708      	adds	r7, #8
 8008aa8:	46bd      	mov	sp, r7
 8008aaa:	bd80      	pop	{r7, pc}

08008aac <worker_thread_task_get_user_context>:

void* worker_thread_task_get_user_context(struct worker_thread_timer_task_s* task) {
 8008aac:	b480      	push	{r7}
 8008aae:	b083      	sub	sp, #12
 8008ab0:	af00      	add	r7, sp, #0
 8008ab2:	6078      	str	r0, [r7, #4]
    if (!task) {
 8008ab4:	687b      	ldr	r3, [r7, #4]
 8008ab6:	2b00      	cmp	r3, #0
 8008ab8:	d101      	bne.n	8008abe <worker_thread_task_get_user_context+0x12>
        return NULL;
 8008aba:	2300      	movs	r3, #0
 8008abc:	e001      	b.n	8008ac2 <worker_thread_task_get_user_context+0x16>
    }

    return task->ctx;
 8008abe:	687b      	ldr	r3, [r7, #4]
 8008ac0:	685b      	ldr	r3, [r3, #4]
}
 8008ac2:	4618      	mov	r0, r3
 8008ac4:	370c      	adds	r7, #12
 8008ac6:	46bd      	mov	sp, r7
 8008ac8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008acc:	4770      	bx	lr
 8008ace:	bf00      	nop

08008ad0 <worker_thread_add_listener_task>:

#ifdef MODULE_PUBSUB_ENABLED
void worker_thread_add_listener_task(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* task, struct pubsub_topic_s* topic, pubsub_message_handler_func_ptr handler_cb, void* handler_cb_ctx) {
 8008ad0:	b580      	push	{r7, lr}
 8008ad2:	b086      	sub	sp, #24
 8008ad4:	af00      	add	r7, sp, #0
 8008ad6:	60f8      	str	r0, [r7, #12]
 8008ad8:	60b9      	str	r1, [r7, #8]
 8008ada:	607a      	str	r2, [r7, #4]
 8008adc:	603b      	str	r3, [r7, #0]
    chDbgCheck(!worker_thread_listener_task_is_registered(worker_thread, task));
 8008ade:	68f8      	ldr	r0, [r7, #12]
 8008ae0:	68b9      	ldr	r1, [r7, #8]
 8008ae2:	f7fe f949 	bl	8006d78 <worker_thread_listener_task_is_registered.lto_priv.161>
 8008ae6:	4603      	mov	r3, r0
 8008ae8:	2b00      	cmp	r3, #0
 8008aea:	d002      	beq.n	8008af2 <worker_thread_add_listener_task+0x22>
 8008aec:	4816      	ldr	r0, [pc, #88]	; (8008b48 <worker_thread_add_listener_task+0x78>)
 8008aee:	f002 f987 	bl	800ae00 <chSysHalt>

    pubsub_listener_init_and_register(&task->listener, topic, handler_cb, handler_cb_ctx);
 8008af2:	68bb      	ldr	r3, [r7, #8]
 8008af4:	4618      	mov	r0, r3
 8008af6:	6879      	ldr	r1, [r7, #4]
 8008af8:	683a      	ldr	r2, [r7, #0]
 8008afa:	6a3b      	ldr	r3, [r7, #32]
 8008afc:	f7ff fbb6 	bl	800826c <pubsub_listener_init_and_register>
    pubsub_listener_set_waiting_thread_reference(&task->listener, &worker_thread->suspend_trp);
 8008b00:	68ba      	ldr	r2, [r7, #8]
 8008b02:	68fb      	ldr	r3, [r7, #12]
 8008b04:	330c      	adds	r3, #12
 8008b06:	4610      	mov	r0, r2
 8008b08:	4619      	mov	r1, r3
 8008b0a:	f7ff fd57 	bl	80085bc <pubsub_listener_set_waiting_thread_reference>

    chSysLock();
 8008b0e:	f7ff fe29 	bl	8008764 <chSysLock.lto_priv.125>
    LINKED_LIST_APPEND(struct worker_thread_listener_task_s, worker_thread->listener_task_list_head, task);
 8008b12:	68bb      	ldr	r3, [r7, #8]
 8008b14:	2200      	movs	r2, #0
 8008b16:	631a      	str	r2, [r3, #48]	; 0x30
 8008b18:	68fb      	ldr	r3, [r7, #12]
 8008b1a:	3314      	adds	r3, #20
 8008b1c:	617b      	str	r3, [r7, #20]
 8008b1e:	e003      	b.n	8008b28 <worker_thread_add_listener_task+0x58>
 8008b20:	697b      	ldr	r3, [r7, #20]
 8008b22:	681b      	ldr	r3, [r3, #0]
 8008b24:	3330      	adds	r3, #48	; 0x30
 8008b26:	617b      	str	r3, [r7, #20]
 8008b28:	697b      	ldr	r3, [r7, #20]
 8008b2a:	681b      	ldr	r3, [r3, #0]
 8008b2c:	2b00      	cmp	r3, #0
 8008b2e:	d1f7      	bne.n	8008b20 <worker_thread_add_listener_task+0x50>
 8008b30:	697b      	ldr	r3, [r7, #20]
 8008b32:	68ba      	ldr	r2, [r7, #8]
 8008b34:	601a      	str	r2, [r3, #0]
    chSysUnlock();
 8008b36:	f7ff fe1d 	bl	8008774 <chSysUnlock.lto_priv.123>

    // Wake worker thread to process tasks
    worker_thread_wake(worker_thread);
 8008b3a:	68f8      	ldr	r0, [r7, #12]
 8008b3c:	f7fe f80e 	bl	8006b5c <worker_thread_wake.lto_priv.160>
}
 8008b40:	3718      	adds	r7, #24
 8008b42:	46bd      	mov	sp, r7
 8008b44:	bd80      	pop	{r7, pc}
 8008b46:	bf00      	nop
 8008b48:	0800eba4 	.word	0x0800eba4

08008b4c <iqPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 8008b4c:	b580      	push	{r7, lr}
 8008b4e:	b082      	sub	sp, #8
 8008b50:	af00      	add	r7, sp, #0
 8008b52:	6078      	str	r0, [r7, #4]
 8008b54:	460b      	mov	r3, r1
 8008b56:	70fb      	strb	r3, [r7, #3]

  osalDbgCheckClassI();
 8008b58:	f002 fa30 	bl	800afbc <chDbgCheckClassI>

  if (iqIsFullI(iqp)) {
 8008b5c:	687b      	ldr	r3, [r7, #4]
 8008b5e:	695a      	ldr	r2, [r3, #20]
 8008b60:	687b      	ldr	r3, [r7, #4]
 8008b62:	699b      	ldr	r3, [r3, #24]
 8008b64:	429a      	cmp	r2, r3
 8008b66:	d105      	bne.n	8008b74 <iqPutI+0x28>
 8008b68:	687b      	ldr	r3, [r7, #4]
 8008b6a:	689b      	ldr	r3, [r3, #8]
 8008b6c:	2b00      	cmp	r3, #0
 8008b6e:	d001      	beq.n	8008b74 <iqPutI+0x28>
 8008b70:	2301      	movs	r3, #1
 8008b72:	e000      	b.n	8008b76 <iqPutI+0x2a>
 8008b74:	2300      	movs	r3, #0
 8008b76:	f003 0301 	and.w	r3, r3, #1
 8008b7a:	b2db      	uxtb	r3, r3
 8008b7c:	2b00      	cmp	r3, #0
 8008b7e:	d002      	beq.n	8008b86 <iqPutI+0x3a>
    return MSG_TIMEOUT;
 8008b80:	f04f 33ff 	mov.w	r3, #4294967295
 8008b84:	e01b      	b.n	8008bbe <iqPutI+0x72>
  }

  iqp->q_counter++;
 8008b86:	687b      	ldr	r3, [r7, #4]
 8008b88:	689b      	ldr	r3, [r3, #8]
 8008b8a:	1c5a      	adds	r2, r3, #1
 8008b8c:	687b      	ldr	r3, [r7, #4]
 8008b8e:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 8008b90:	687b      	ldr	r3, [r7, #4]
 8008b92:	695b      	ldr	r3, [r3, #20]
 8008b94:	1c59      	adds	r1, r3, #1
 8008b96:	687a      	ldr	r2, [r7, #4]
 8008b98:	6151      	str	r1, [r2, #20]
 8008b9a:	78fa      	ldrb	r2, [r7, #3]
 8008b9c:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8008b9e:	687b      	ldr	r3, [r7, #4]
 8008ba0:	695a      	ldr	r2, [r3, #20]
 8008ba2:	687b      	ldr	r3, [r7, #4]
 8008ba4:	691b      	ldr	r3, [r3, #16]
 8008ba6:	429a      	cmp	r2, r3
 8008ba8:	d303      	bcc.n	8008bb2 <iqPutI+0x66>
    iqp->q_wrptr = iqp->q_buffer;
 8008baa:	687b      	ldr	r3, [r7, #4]
 8008bac:	68da      	ldr	r2, [r3, #12]
 8008bae:	687b      	ldr	r3, [r7, #4]
 8008bb0:	615a      	str	r2, [r3, #20]
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 8008bb2:	687b      	ldr	r3, [r7, #4]
 8008bb4:	4618      	mov	r0, r3
 8008bb6:	2100      	movs	r1, #0
 8008bb8:	f001 fb78 	bl	800a2ac <osalThreadDequeueNextI.lto_priv.208>

  return MSG_OK;
 8008bbc:	2300      	movs	r3, #0
}
 8008bbe:	4618      	mov	r0, r3
 8008bc0:	3708      	adds	r7, #8
 8008bc2:	46bd      	mov	sp, r7
 8008bc4:	bd80      	pop	{r7, pc}
 8008bc6:	bf00      	nop

08008bc8 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8008bc8:	b580      	push	{r7, lr}
 8008bca:	b084      	sub	sp, #16
 8008bcc:	af00      	add	r7, sp, #0
 8008bce:	6078      	str	r0, [r7, #4]
 8008bd0:	460b      	mov	r3, r1
 8008bd2:	807b      	strh	r3, [r7, #2]
  uint8_t b;

  osalSysLock();
 8008bd4:	f001 fb3c 	bl	800a250 <osalSysLock.lto_priv.200>
 8008bd8:	e00d      	b.n	8008bf6 <iqGetTimeout+0x2e>

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8008bda:	687a      	ldr	r2, [r7, #4]
 8008bdc:	887b      	ldrh	r3, [r7, #2]
 8008bde:	4610      	mov	r0, r2
 8008be0:	4619      	mov	r1, r3
 8008be2:	f001 fb53 	bl	800a28c <osalThreadEnqueueTimeoutS.lto_priv.206>
 8008be6:	60f8      	str	r0, [r7, #12]
    if (msg < MSG_OK) {
 8008be8:	68fb      	ldr	r3, [r7, #12]
 8008bea:	2b00      	cmp	r3, #0
 8008bec:	da03      	bge.n	8008bf6 <iqGetTimeout+0x2e>
      osalSysUnlock();
 8008bee:	f001 fb35 	bl	800a25c <osalSysUnlock.lto_priv.198>
      return msg;
 8008bf2:	68fb      	ldr	r3, [r7, #12]
 8008bf4:	e024      	b.n	8008c40 <iqGetTimeout+0x78>
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
 8008bf6:	687b      	ldr	r3, [r7, #4]
 8008bf8:	689b      	ldr	r3, [r3, #8]
 8008bfa:	2b00      	cmp	r3, #0
 8008bfc:	d0ed      	beq.n	8008bda <iqGetTimeout+0x12>
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8008bfe:	687b      	ldr	r3, [r7, #4]
 8008c00:	689b      	ldr	r3, [r3, #8]
 8008c02:	1e5a      	subs	r2, r3, #1
 8008c04:	687b      	ldr	r3, [r7, #4]
 8008c06:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 8008c08:	687b      	ldr	r3, [r7, #4]
 8008c0a:	699b      	ldr	r3, [r3, #24]
 8008c0c:	1c59      	adds	r1, r3, #1
 8008c0e:	687a      	ldr	r2, [r7, #4]
 8008c10:	6191      	str	r1, [r2, #24]
 8008c12:	781b      	ldrb	r3, [r3, #0]
 8008c14:	72fb      	strb	r3, [r7, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
 8008c16:	687b      	ldr	r3, [r7, #4]
 8008c18:	699a      	ldr	r2, [r3, #24]
 8008c1a:	687b      	ldr	r3, [r7, #4]
 8008c1c:	691b      	ldr	r3, [r3, #16]
 8008c1e:	429a      	cmp	r2, r3
 8008c20:	d303      	bcc.n	8008c2a <iqGetTimeout+0x62>
    iqp->q_rdptr = iqp->q_buffer;
 8008c22:	687b      	ldr	r3, [r7, #4]
 8008c24:	68da      	ldr	r2, [r3, #12]
 8008c26:	687b      	ldr	r3, [r7, #4]
 8008c28:	619a      	str	r2, [r3, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 8008c2a:	687b      	ldr	r3, [r7, #4]
 8008c2c:	69db      	ldr	r3, [r3, #28]
 8008c2e:	2b00      	cmp	r3, #0
 8008c30:	d003      	beq.n	8008c3a <iqGetTimeout+0x72>
    iqp->q_notify(iqp);
 8008c32:	687b      	ldr	r3, [r7, #4]
 8008c34:	69db      	ldr	r3, [r3, #28]
 8008c36:	6878      	ldr	r0, [r7, #4]
 8008c38:	4798      	blx	r3
  }

  osalSysUnlock();
 8008c3a:	f001 fb0f 	bl	800a25c <osalSysUnlock.lto_priv.198>

  return (msg_t)b;
 8008c3e:	7afb      	ldrb	r3, [r7, #11]
}
 8008c40:	4618      	mov	r0, r3
 8008c42:	3710      	adds	r7, #16
 8008c44:	46bd      	mov	sp, r7
 8008c46:	bd80      	pop	{r7, pc}

08008c48 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 8008c48:	b580      	push	{r7, lr}
 8008c4a:	b088      	sub	sp, #32
 8008c4c:	af00      	add	r7, sp, #0
 8008c4e:	60f8      	str	r0, [r7, #12]
 8008c50:	60b9      	str	r1, [r7, #8]
 8008c52:	607a      	str	r2, [r7, #4]
 8008c54:	807b      	strh	r3, [r7, #2]
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
 8008c56:	68fb      	ldr	r3, [r7, #12]
 8008c58:	69db      	ldr	r3, [r3, #28]
 8008c5a:	617b      	str	r3, [r7, #20]
  size_t r = 0;
 8008c5c:	2300      	movs	r3, #0
 8008c5e:	61fb      	str	r3, [r7, #28]

  osalDbgCheck(n > 0U);
 8008c60:	687b      	ldr	r3, [r7, #4]
 8008c62:	2b00      	cmp	r3, #0
 8008c64:	d102      	bne.n	8008c6c <iqReadTimeout+0x24>
 8008c66:	4838      	ldr	r0, [pc, #224]	; (8008d48 <iqReadTimeout+0x100>)
 8008c68:	f002 f8ca 	bl	800ae00 <chSysHalt>

  osalSysLock();
 8008c6c:	f001 faf0 	bl	800a250 <osalSysLock.lto_priv.200>

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8008c70:	f001 fafa 	bl	800a268 <osalOsGetSystemTimeX.lto_priv.207>
 8008c74:	4603      	mov	r3, r0
 8008c76:	461a      	mov	r2, r3
 8008c78:	887b      	ldrh	r3, [r7, #2]
 8008c7a:	4413      	add	r3, r2
 8008c7c:	827b      	strh	r3, [r7, #18]
 8008c7e:	e02c      	b.n	8008cda <iqReadTimeout+0x92>
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8008c80:	887b      	ldrh	r3, [r7, #2]
 8008c82:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8008c86:	4293      	cmp	r3, r2
 8008c88:	d002      	beq.n	8008c90 <iqReadTimeout+0x48>
 8008c8a:	887b      	ldrh	r3, [r7, #2]
 8008c8c:	2b00      	cmp	r3, #0
 8008c8e:	d107      	bne.n	8008ca0 <iqReadTimeout+0x58>
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8008c90:	68fa      	ldr	r2, [r7, #12]
 8008c92:	887b      	ldrh	r3, [r7, #2]
 8008c94:	4610      	mov	r0, r2
 8008c96:	4619      	mov	r1, r3
 8008c98:	f001 faf8 	bl	800a28c <osalThreadEnqueueTimeoutS.lto_priv.206>
 8008c9c:	61b8      	str	r0, [r7, #24]
 8008c9e:	e015      	b.n	8008ccc <iqReadTimeout+0x84>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8008ca0:	f001 fae2 	bl	800a268 <osalOsGetSystemTimeX.lto_priv.207>
 8008ca4:	4603      	mov	r3, r0
 8008ca6:	461a      	mov	r2, r3
 8008ca8:	8a7b      	ldrh	r3, [r7, #18]
 8008caa:	1a9b      	subs	r3, r3, r2
 8008cac:	823b      	strh	r3, [r7, #16]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8008cae:	8a3a      	ldrh	r2, [r7, #16]
 8008cb0:	887b      	ldrh	r3, [r7, #2]
 8008cb2:	429a      	cmp	r2, r3
 8008cb4:	d903      	bls.n	8008cbe <iqReadTimeout+0x76>
          osalSysUnlock();
 8008cb6:	f001 fad1 	bl	800a25c <osalSysUnlock.lto_priv.198>
          return r;
 8008cba:	69fb      	ldr	r3, [r7, #28]
 8008cbc:	e040      	b.n	8008d40 <iqReadTimeout+0xf8>
        }

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
 8008cbe:	68fa      	ldr	r2, [r7, #12]
 8008cc0:	8a3b      	ldrh	r3, [r7, #16]
 8008cc2:	4610      	mov	r0, r2
 8008cc4:	4619      	mov	r1, r3
 8008cc6:	f001 fae1 	bl	800a28c <osalThreadEnqueueTimeoutS.lto_priv.206>
 8008cca:	61b8      	str	r0, [r7, #24]
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8008ccc:	69bb      	ldr	r3, [r7, #24]
 8008cce:	2b00      	cmp	r3, #0
 8008cd0:	d003      	beq.n	8008cda <iqReadTimeout+0x92>
        osalSysUnlock();
 8008cd2:	f001 fac3 	bl	800a25c <osalSysUnlock.lto_priv.198>
        return r;
 8008cd6:	69fb      	ldr	r3, [r7, #28]
 8008cd8:	e032      	b.n	8008d40 <iqReadTimeout+0xf8>
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 8008cda:	68fb      	ldr	r3, [r7, #12]
 8008cdc:	689b      	ldr	r3, [r3, #8]
 8008cde:	2b00      	cmp	r3, #0
 8008ce0:	d0ce      	beq.n	8008c80 <iqReadTimeout+0x38>
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8008ce2:	68fb      	ldr	r3, [r7, #12]
 8008ce4:	689b      	ldr	r3, [r3, #8]
 8008ce6:	1e5a      	subs	r2, r3, #1
 8008ce8:	68fb      	ldr	r3, [r7, #12]
 8008cea:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 8008cec:	68bb      	ldr	r3, [r7, #8]
 8008cee:	1c5a      	adds	r2, r3, #1
 8008cf0:	60ba      	str	r2, [r7, #8]
 8008cf2:	68fa      	ldr	r2, [r7, #12]
 8008cf4:	6992      	ldr	r2, [r2, #24]
 8008cf6:	1c50      	adds	r0, r2, #1
 8008cf8:	68f9      	ldr	r1, [r7, #12]
 8008cfa:	6188      	str	r0, [r1, #24]
 8008cfc:	7812      	ldrb	r2, [r2, #0]
 8008cfe:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 8008d00:	68fb      	ldr	r3, [r7, #12]
 8008d02:	699a      	ldr	r2, [r3, #24]
 8008d04:	68fb      	ldr	r3, [r7, #12]
 8008d06:	691b      	ldr	r3, [r3, #16]
 8008d08:	429a      	cmp	r2, r3
 8008d0a:	d303      	bcc.n	8008d14 <iqReadTimeout+0xcc>
      iqp->q_rdptr = iqp->q_buffer;
 8008d0c:	68fb      	ldr	r3, [r7, #12]
 8008d0e:	68da      	ldr	r2, [r3, #12]
 8008d10:	68fb      	ldr	r3, [r7, #12]
 8008d12:	619a      	str	r2, [r3, #24]
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
 8008d14:	697b      	ldr	r3, [r7, #20]
 8008d16:	2b00      	cmp	r3, #0
 8008d18:	d002      	beq.n	8008d20 <iqReadTimeout+0xd8>
      nfy(iqp);
 8008d1a:	697b      	ldr	r3, [r7, #20]
 8008d1c:	68f8      	ldr	r0, [r7, #12]
 8008d1e:	4798      	blx	r3
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
 8008d20:	f001 fa9c 	bl	800a25c <osalSysUnlock.lto_priv.198>

    r++;
 8008d24:	69fb      	ldr	r3, [r7, #28]
 8008d26:	3301      	adds	r3, #1
 8008d28:	61fb      	str	r3, [r7, #28]
    if (--n == 0U) {
 8008d2a:	687b      	ldr	r3, [r7, #4]
 8008d2c:	3b01      	subs	r3, #1
 8008d2e:	607b      	str	r3, [r7, #4]
 8008d30:	687b      	ldr	r3, [r7, #4]
 8008d32:	2b00      	cmp	r3, #0
 8008d34:	d101      	bne.n	8008d3a <iqReadTimeout+0xf2>
      return r;
 8008d36:	69fb      	ldr	r3, [r7, #28]
 8008d38:	e002      	b.n	8008d40 <iqReadTimeout+0xf8>
    }

    osalSysLock();
 8008d3a:	f001 fa89 	bl	800a250 <osalSysLock.lto_priv.200>
 8008d3e:	e7cc      	b.n	8008cda <iqReadTimeout+0x92>
  }
}
 8008d40:	4618      	mov	r0, r3
 8008d42:	3720      	adds	r7, #32
 8008d44:	46bd      	mov	sp, r7
 8008d46:	bd80      	pop	{r7, pc}
 8008d48:	0800eaa4 	.word	0x0800eaa4

08008d4c <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
 8008d4c:	b580      	push	{r7, lr}
 8008d4e:	b084      	sub	sp, #16
 8008d50:	af00      	add	r7, sp, #0
 8008d52:	60f8      	str	r0, [r7, #12]
 8008d54:	60b9      	str	r1, [r7, #8]
 8008d56:	607a      	str	r2, [r7, #4]
 8008d58:	603b      	str	r3, [r7, #0]

  osalThreadQueueObjectInit(&oqp->q_waiting);
 8008d5a:	68fb      	ldr	r3, [r7, #12]
 8008d5c:	4618      	mov	r0, r3
 8008d5e:	f001 fa8b 	bl	800a278 <osalThreadQueueObjectInit.lto_priv.210>
  oqp->q_counter = size;
 8008d62:	68fb      	ldr	r3, [r7, #12]
 8008d64:	687a      	ldr	r2, [r7, #4]
 8008d66:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 8008d68:	68fb      	ldr	r3, [r7, #12]
 8008d6a:	68ba      	ldr	r2, [r7, #8]
 8008d6c:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 8008d6e:	68fb      	ldr	r3, [r7, #12]
 8008d70:	68ba      	ldr	r2, [r7, #8]
 8008d72:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 8008d74:	68fb      	ldr	r3, [r7, #12]
 8008d76:	68ba      	ldr	r2, [r7, #8]
 8008d78:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 8008d7a:	68ba      	ldr	r2, [r7, #8]
 8008d7c:	687b      	ldr	r3, [r7, #4]
 8008d7e:	441a      	add	r2, r3
 8008d80:	68fb      	ldr	r3, [r7, #12]
 8008d82:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 8008d84:	68fb      	ldr	r3, [r7, #12]
 8008d86:	683a      	ldr	r2, [r7, #0]
 8008d88:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 8008d8a:	68fb      	ldr	r3, [r7, #12]
 8008d8c:	69ba      	ldr	r2, [r7, #24]
 8008d8e:	621a      	str	r2, [r3, #32]
}
 8008d90:	3710      	adds	r7, #16
 8008d92:	46bd      	mov	sp, r7
 8008d94:	bd80      	pop	{r7, pc}
 8008d96:	bf00      	nop

08008d98 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8008d98:	b580      	push	{r7, lr}
 8008d9a:	b084      	sub	sp, #16
 8008d9c:	af00      	add	r7, sp, #0
 8008d9e:	6078      	str	r0, [r7, #4]
 8008da0:	460b      	mov	r3, r1
 8008da2:	70fb      	strb	r3, [r7, #3]
 8008da4:	4613      	mov	r3, r2
 8008da6:	803b      	strh	r3, [r7, #0]

  osalSysLock();
 8008da8:	f001 fa52 	bl	800a250 <osalSysLock.lto_priv.200>
 8008dac:	e00d      	b.n	8008dca <oqPutTimeout+0x32>

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8008dae:	687a      	ldr	r2, [r7, #4]
 8008db0:	883b      	ldrh	r3, [r7, #0]
 8008db2:	4610      	mov	r0, r2
 8008db4:	4619      	mov	r1, r3
 8008db6:	f001 fa69 	bl	800a28c <osalThreadEnqueueTimeoutS.lto_priv.206>
 8008dba:	60f8      	str	r0, [r7, #12]
    if (msg < MSG_OK) {
 8008dbc:	68fb      	ldr	r3, [r7, #12]
 8008dbe:	2b00      	cmp	r3, #0
 8008dc0:	da03      	bge.n	8008dca <oqPutTimeout+0x32>
      osalSysUnlock();
 8008dc2:	f001 fa4b 	bl	800a25c <osalSysUnlock.lto_priv.198>
      return msg;
 8008dc6:	68fb      	ldr	r3, [r7, #12]
 8008dc8:	e024      	b.n	8008e14 <oqPutTimeout+0x7c>
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 8008dca:	687b      	ldr	r3, [r7, #4]
 8008dcc:	689b      	ldr	r3, [r3, #8]
 8008dce:	2b00      	cmp	r3, #0
 8008dd0:	d0ed      	beq.n	8008dae <oqPutTimeout+0x16>
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8008dd2:	687b      	ldr	r3, [r7, #4]
 8008dd4:	689b      	ldr	r3, [r3, #8]
 8008dd6:	1e5a      	subs	r2, r3, #1
 8008dd8:	687b      	ldr	r3, [r7, #4]
 8008dda:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8008ddc:	687b      	ldr	r3, [r7, #4]
 8008dde:	695b      	ldr	r3, [r3, #20]
 8008de0:	1c59      	adds	r1, r3, #1
 8008de2:	687a      	ldr	r2, [r7, #4]
 8008de4:	6151      	str	r1, [r2, #20]
 8008de6:	78fa      	ldrb	r2, [r7, #3]
 8008de8:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8008dea:	687b      	ldr	r3, [r7, #4]
 8008dec:	695a      	ldr	r2, [r3, #20]
 8008dee:	687b      	ldr	r3, [r7, #4]
 8008df0:	691b      	ldr	r3, [r3, #16]
 8008df2:	429a      	cmp	r2, r3
 8008df4:	d303      	bcc.n	8008dfe <oqPutTimeout+0x66>
    oqp->q_wrptr = oqp->q_buffer;
 8008df6:	687b      	ldr	r3, [r7, #4]
 8008df8:	68da      	ldr	r2, [r3, #12]
 8008dfa:	687b      	ldr	r3, [r7, #4]
 8008dfc:	615a      	str	r2, [r3, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8008dfe:	687b      	ldr	r3, [r7, #4]
 8008e00:	69db      	ldr	r3, [r3, #28]
 8008e02:	2b00      	cmp	r3, #0
 8008e04:	d003      	beq.n	8008e0e <oqPutTimeout+0x76>
    oqp->q_notify(oqp);
 8008e06:	687b      	ldr	r3, [r7, #4]
 8008e08:	69db      	ldr	r3, [r3, #28]
 8008e0a:	6878      	ldr	r0, [r7, #4]
 8008e0c:	4798      	blx	r3
  }

  osalSysUnlock();
 8008e0e:	f001 fa25 	bl	800a25c <osalSysUnlock.lto_priv.198>

  return MSG_OK;
 8008e12:	2300      	movs	r3, #0
}
 8008e14:	4618      	mov	r0, r3
 8008e16:	3710      	adds	r7, #16
 8008e18:	46bd      	mov	sp, r7
 8008e1a:	bd80      	pop	{r7, pc}

08008e1c <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
 8008e1c:	b580      	push	{r7, lr}
 8008e1e:	b084      	sub	sp, #16
 8008e20:	af00      	add	r7, sp, #0
 8008e22:	6078      	str	r0, [r7, #4]
  uint8_t b;

  osalDbgCheckClassI();
 8008e24:	f002 f8ca 	bl	800afbc <chDbgCheckClassI>

  if (oqIsEmptyI(oqp)) {
 8008e28:	687b      	ldr	r3, [r7, #4]
 8008e2a:	695a      	ldr	r2, [r3, #20]
 8008e2c:	687b      	ldr	r3, [r7, #4]
 8008e2e:	699b      	ldr	r3, [r3, #24]
 8008e30:	429a      	cmp	r2, r3
 8008e32:	d105      	bne.n	8008e40 <oqGetI+0x24>
 8008e34:	687b      	ldr	r3, [r7, #4]
 8008e36:	689b      	ldr	r3, [r3, #8]
 8008e38:	2b00      	cmp	r3, #0
 8008e3a:	d001      	beq.n	8008e40 <oqGetI+0x24>
 8008e3c:	2301      	movs	r3, #1
 8008e3e:	e000      	b.n	8008e42 <oqGetI+0x26>
 8008e40:	2300      	movs	r3, #0
 8008e42:	f003 0301 	and.w	r3, r3, #1
 8008e46:	b2db      	uxtb	r3, r3
 8008e48:	2b00      	cmp	r3, #0
 8008e4a:	d002      	beq.n	8008e52 <oqGetI+0x36>
    return MSG_TIMEOUT;
 8008e4c:	f04f 33ff 	mov.w	r3, #4294967295
 8008e50:	e01b      	b.n	8008e8a <oqGetI+0x6e>
  }

  oqp->q_counter++;
 8008e52:	687b      	ldr	r3, [r7, #4]
 8008e54:	689b      	ldr	r3, [r3, #8]
 8008e56:	1c5a      	adds	r2, r3, #1
 8008e58:	687b      	ldr	r3, [r7, #4]
 8008e5a:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 8008e5c:	687b      	ldr	r3, [r7, #4]
 8008e5e:	699b      	ldr	r3, [r3, #24]
 8008e60:	1c59      	adds	r1, r3, #1
 8008e62:	687a      	ldr	r2, [r7, #4]
 8008e64:	6191      	str	r1, [r2, #24]
 8008e66:	781b      	ldrb	r3, [r3, #0]
 8008e68:	73fb      	strb	r3, [r7, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
 8008e6a:	687b      	ldr	r3, [r7, #4]
 8008e6c:	699a      	ldr	r2, [r3, #24]
 8008e6e:	687b      	ldr	r3, [r7, #4]
 8008e70:	691b      	ldr	r3, [r3, #16]
 8008e72:	429a      	cmp	r2, r3
 8008e74:	d303      	bcc.n	8008e7e <oqGetI+0x62>
    oqp->q_rdptr = oqp->q_buffer;
 8008e76:	687b      	ldr	r3, [r7, #4]
 8008e78:	68da      	ldr	r2, [r3, #12]
 8008e7a:	687b      	ldr	r3, [r7, #4]
 8008e7c:	619a      	str	r2, [r3, #24]
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
 8008e7e:	687b      	ldr	r3, [r7, #4]
 8008e80:	4618      	mov	r0, r3
 8008e82:	2100      	movs	r1, #0
 8008e84:	f001 fa12 	bl	800a2ac <osalThreadDequeueNextI.lto_priv.208>

  return (msg_t)b;
 8008e88:	7bfb      	ldrb	r3, [r7, #15]
}
 8008e8a:	4618      	mov	r0, r3
 8008e8c:	3710      	adds	r7, #16
 8008e8e:	46bd      	mov	sp, r7
 8008e90:	bd80      	pop	{r7, pc}
 8008e92:	bf00      	nop

08008e94 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8008e94:	b580      	push	{r7, lr}
 8008e96:	b088      	sub	sp, #32
 8008e98:	af00      	add	r7, sp, #0
 8008e9a:	60f8      	str	r0, [r7, #12]
 8008e9c:	60b9      	str	r1, [r7, #8]
 8008e9e:	607a      	str	r2, [r7, #4]
 8008ea0:	807b      	strh	r3, [r7, #2]
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
 8008ea2:	68fb      	ldr	r3, [r7, #12]
 8008ea4:	69db      	ldr	r3, [r3, #28]
 8008ea6:	617b      	str	r3, [r7, #20]
  size_t w = 0;
 8008ea8:	2300      	movs	r3, #0
 8008eaa:	61fb      	str	r3, [r7, #28]

  osalDbgCheck(n > 0U);
 8008eac:	687b      	ldr	r3, [r7, #4]
 8008eae:	2b00      	cmp	r3, #0
 8008eb0:	d102      	bne.n	8008eb8 <oqWriteTimeout+0x24>
 8008eb2:	4838      	ldr	r0, [pc, #224]	; (8008f94 <oqWriteTimeout+0x100>)
 8008eb4:	f001 ffa4 	bl	800ae00 <chSysHalt>

  osalSysLock();
 8008eb8:	f001 f9ca 	bl	800a250 <osalSysLock.lto_priv.200>

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8008ebc:	f001 f9d4 	bl	800a268 <osalOsGetSystemTimeX.lto_priv.207>
 8008ec0:	4603      	mov	r3, r0
 8008ec2:	461a      	mov	r2, r3
 8008ec4:	887b      	ldrh	r3, [r7, #2]
 8008ec6:	4413      	add	r3, r2
 8008ec8:	827b      	strh	r3, [r7, #18]
 8008eca:	e02c      	b.n	8008f26 <oqWriteTimeout+0x92>
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8008ecc:	887b      	ldrh	r3, [r7, #2]
 8008ece:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8008ed2:	4293      	cmp	r3, r2
 8008ed4:	d002      	beq.n	8008edc <oqWriteTimeout+0x48>
 8008ed6:	887b      	ldrh	r3, [r7, #2]
 8008ed8:	2b00      	cmp	r3, #0
 8008eda:	d107      	bne.n	8008eec <oqWriteTimeout+0x58>
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8008edc:	68fa      	ldr	r2, [r7, #12]
 8008ede:	887b      	ldrh	r3, [r7, #2]
 8008ee0:	4610      	mov	r0, r2
 8008ee2:	4619      	mov	r1, r3
 8008ee4:	f001 f9d2 	bl	800a28c <osalThreadEnqueueTimeoutS.lto_priv.206>
 8008ee8:	61b8      	str	r0, [r7, #24]
 8008eea:	e015      	b.n	8008f18 <oqWriteTimeout+0x84>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8008eec:	f001 f9bc 	bl	800a268 <osalOsGetSystemTimeX.lto_priv.207>
 8008ef0:	4603      	mov	r3, r0
 8008ef2:	461a      	mov	r2, r3
 8008ef4:	8a7b      	ldrh	r3, [r7, #18]
 8008ef6:	1a9b      	subs	r3, r3, r2
 8008ef8:	823b      	strh	r3, [r7, #16]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8008efa:	8a3a      	ldrh	r2, [r7, #16]
 8008efc:	887b      	ldrh	r3, [r7, #2]
 8008efe:	429a      	cmp	r2, r3
 8008f00:	d903      	bls.n	8008f0a <oqWriteTimeout+0x76>
          osalSysUnlock();
 8008f02:	f001 f9ab 	bl	800a25c <osalSysUnlock.lto_priv.198>
          return w;
 8008f06:	69fb      	ldr	r3, [r7, #28]
 8008f08:	e040      	b.n	8008f8c <oqWriteTimeout+0xf8>
        }

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
 8008f0a:	68fa      	ldr	r2, [r7, #12]
 8008f0c:	8a3b      	ldrh	r3, [r7, #16]
 8008f0e:	4610      	mov	r0, r2
 8008f10:	4619      	mov	r1, r3
 8008f12:	f001 f9bb 	bl	800a28c <osalThreadEnqueueTimeoutS.lto_priv.206>
 8008f16:	61b8      	str	r0, [r7, #24]
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8008f18:	69bb      	ldr	r3, [r7, #24]
 8008f1a:	2b00      	cmp	r3, #0
 8008f1c:	d003      	beq.n	8008f26 <oqWriteTimeout+0x92>
        osalSysUnlock();
 8008f1e:	f001 f99d 	bl	800a25c <osalSysUnlock.lto_priv.198>
        return w;
 8008f22:	69fb      	ldr	r3, [r7, #28]
 8008f24:	e032      	b.n	8008f8c <oqWriteTimeout+0xf8>
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 8008f26:	68fb      	ldr	r3, [r7, #12]
 8008f28:	689b      	ldr	r3, [r3, #8]
 8008f2a:	2b00      	cmp	r3, #0
 8008f2c:	d0ce      	beq.n	8008ecc <oqWriteTimeout+0x38>
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8008f2e:	68fb      	ldr	r3, [r7, #12]
 8008f30:	689b      	ldr	r3, [r3, #8]
 8008f32:	1e5a      	subs	r2, r3, #1
 8008f34:	68fb      	ldr	r3, [r7, #12]
 8008f36:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 8008f38:	68fb      	ldr	r3, [r7, #12]
 8008f3a:	695b      	ldr	r3, [r3, #20]
 8008f3c:	1c59      	adds	r1, r3, #1
 8008f3e:	68fa      	ldr	r2, [r7, #12]
 8008f40:	6151      	str	r1, [r2, #20]
 8008f42:	68ba      	ldr	r2, [r7, #8]
 8008f44:	1c51      	adds	r1, r2, #1
 8008f46:	60b9      	str	r1, [r7, #8]
 8008f48:	7812      	ldrb	r2, [r2, #0]
 8008f4a:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8008f4c:	68fb      	ldr	r3, [r7, #12]
 8008f4e:	695a      	ldr	r2, [r3, #20]
 8008f50:	68fb      	ldr	r3, [r7, #12]
 8008f52:	691b      	ldr	r3, [r3, #16]
 8008f54:	429a      	cmp	r2, r3
 8008f56:	d303      	bcc.n	8008f60 <oqWriteTimeout+0xcc>
      oqp->q_wrptr = oqp->q_buffer;
 8008f58:	68fb      	ldr	r3, [r7, #12]
 8008f5a:	68da      	ldr	r2, [r3, #12]
 8008f5c:	68fb      	ldr	r3, [r7, #12]
 8008f5e:	615a      	str	r2, [r3, #20]
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
 8008f60:	697b      	ldr	r3, [r7, #20]
 8008f62:	2b00      	cmp	r3, #0
 8008f64:	d002      	beq.n	8008f6c <oqWriteTimeout+0xd8>
      nfy(oqp);
 8008f66:	697b      	ldr	r3, [r7, #20]
 8008f68:	68f8      	ldr	r0, [r7, #12]
 8008f6a:	4798      	blx	r3
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
 8008f6c:	f001 f976 	bl	800a25c <osalSysUnlock.lto_priv.198>

    w++;
 8008f70:	69fb      	ldr	r3, [r7, #28]
 8008f72:	3301      	adds	r3, #1
 8008f74:	61fb      	str	r3, [r7, #28]
    if (--n == 0U) {
 8008f76:	687b      	ldr	r3, [r7, #4]
 8008f78:	3b01      	subs	r3, #1
 8008f7a:	607b      	str	r3, [r7, #4]
 8008f7c:	687b      	ldr	r3, [r7, #4]
 8008f7e:	2b00      	cmp	r3, #0
 8008f80:	d101      	bne.n	8008f86 <oqWriteTimeout+0xf2>
      return w;
 8008f82:	69fb      	ldr	r3, [r7, #28]
 8008f84:	e002      	b.n	8008f8c <oqWriteTimeout+0xf8>
    }

    osalSysLock();
 8008f86:	f001 f963 	bl	800a250 <osalSysLock.lto_priv.200>
 8008f8a:	e7cc      	b.n	8008f26 <oqWriteTimeout+0x92>
  }
}
 8008f8c:	4618      	mov	r0, r3
 8008f8e:	3720      	adds	r7, #32
 8008f90:	46bd      	mov	sp, r7
 8008f92:	bd80      	pop	{r7, pc}
 8008f94:	0800eab4 	.word	0x0800eab4

08008f98 <port_lock.lto_priv.187>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8008f98:	b480      	push	{r7}
 8008f9a:	b083      	sub	sp, #12
 8008f9c:	af00      	add	r7, sp, #0
 8008f9e:	2320      	movs	r3, #32
 8008fa0:	607b      	str	r3, [r7, #4]
 8008fa2:	687b      	ldr	r3, [r7, #4]
 8008fa4:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008fa8:	370c      	adds	r7, #12
 8008faa:	46bd      	mov	sp, r7
 8008fac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008fb0:	4770      	bx	lr
 8008fb2:	bf00      	nop

08008fb4 <port_unlock.lto_priv.184>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8008fb4:	b480      	push	{r7}
 8008fb6:	b083      	sub	sp, #12
 8008fb8:	af00      	add	r7, sp, #0
 8008fba:	2300      	movs	r3, #0
 8008fbc:	607b      	str	r3, [r7, #4]
 8008fbe:	687b      	ldr	r3, [r7, #4]
 8008fc0:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008fc4:	370c      	adds	r7, #12
 8008fc6:	46bd      	mov	sp, r7
 8008fc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008fcc:	4770      	bx	lr
 8008fce:	bf00      	nop

08008fd0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8008fd0:	b580      	push	{r7, lr}
 8008fd2:	af00      	add	r7, sp, #0

  port_lock();
 8008fd4:	f7ff ffe0 	bl	8008f98 <port_lock.lto_priv.187>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8008fd8:	f001 ff60 	bl	800ae9c <_dbg_check_lock>
}
 8008fdc:	bd80      	pop	{r7, pc}
 8008fde:	bf00      	nop

08008fe0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8008fe0:	b580      	push	{r7, lr}
 8008fe2:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8008fe4:	f001 ff70 	bl	800aec8 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008fe8:	4b09      	ldr	r3, [pc, #36]	; (8009010 <chSysUnlock+0x30>)
 8008fea:	681b      	ldr	r3, [r3, #0]
 8008fec:	4a08      	ldr	r2, [pc, #32]	; (8009010 <chSysUnlock+0x30>)
 8008fee:	4293      	cmp	r3, r2
 8008ff0:	d00a      	beq.n	8009008 <chSysUnlock+0x28>
 8008ff2:	4b07      	ldr	r3, [pc, #28]	; (8009010 <chSysUnlock+0x30>)
 8008ff4:	699b      	ldr	r3, [r3, #24]
 8008ff6:	689a      	ldr	r2, [r3, #8]
 8008ff8:	4b05      	ldr	r3, [pc, #20]	; (8009010 <chSysUnlock+0x30>)
 8008ffa:	681b      	ldr	r3, [r3, #0]
 8008ffc:	689b      	ldr	r3, [r3, #8]
 8008ffe:	429a      	cmp	r2, r3
 8009000:	d202      	bcs.n	8009008 <chSysUnlock+0x28>
 8009002:	4804      	ldr	r0, [pc, #16]	; (8009014 <chSysUnlock+0x34>)
 8009004:	f001 fefc 	bl	800ae00 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8009008:	f7ff ffd4 	bl	8008fb4 <port_unlock.lto_priv.184>
}
 800900c:	bd80      	pop	{r7, pc}
 800900e:	bf00      	nop
 8009010:	20001338 	.word	0x20001338
 8009014:	0800eaec 	.word	0x0800eaec

08009018 <osalSysLock.lto_priv.201>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8009018:	b580      	push	{r7, lr}
 800901a:	af00      	add	r7, sp, #0

  chSysLock();
 800901c:	f7ff ffd8 	bl	8008fd0 <chSysLock>
}
 8009020:	bd80      	pop	{r7, pc}
 8009022:	bf00      	nop

08009024 <osalSysUnlock.lto_priv.199>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8009024:	b580      	push	{r7, lr}
 8009026:	af00      	add	r7, sp, #0

  chSysUnlock();
 8009028:	f7ff ffda 	bl	8008fe0 <chSysUnlock>
}
 800902c:	bd80      	pop	{r7, pc}
 800902e:	bf00      	nop

08009030 <osalEventObjectInit>:
static inline void osalEventObjectInit(event_source_t *esp) {

  chEvtObjectInit(esp);
}
#else
static inline void osalEventObjectInit(event_source_t *esp) {
 8009030:	b480      	push	{r7}
 8009032:	b083      	sub	sp, #12
 8009034:	af00      	add	r7, sp, #0
 8009036:	6078      	str	r0, [r7, #4]

  esp->flags = 0;
 8009038:	687b      	ldr	r3, [r7, #4]
 800903a:	2200      	movs	r2, #0
 800903c:	601a      	str	r2, [r3, #0]
}
 800903e:	370c      	adds	r7, #12
 8009040:	46bd      	mov	sp, r7
 8009042:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009046:	4770      	bx	lr

08009048 <osalEventBroadcastFlagsI.lto_priv.170>:

  chEvtBroadcastFlagsI(esp, flags);
}
#else
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8009048:	b480      	push	{r7}
 800904a:	b083      	sub	sp, #12
 800904c:	af00      	add	r7, sp, #0
 800904e:	6078      	str	r0, [r7, #4]
 8009050:	6039      	str	r1, [r7, #0]

  esp->flags |= flags;
 8009052:	687b      	ldr	r3, [r7, #4]
 8009054:	681a      	ldr	r2, [r3, #0]
 8009056:	683b      	ldr	r3, [r7, #0]
 8009058:	431a      	orrs	r2, r3
 800905a:	687b      	ldr	r3, [r7, #4]
 800905c:	601a      	str	r2, [r3, #0]
}
 800905e:	370c      	adds	r7, #12
 8009060:	46bd      	mov	sp, r7
 8009062:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009066:	4770      	bx	lr

08009068 <_write.lto_priv.26>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8009068:	b580      	push	{r7, lr}
 800906a:	b084      	sub	sp, #16
 800906c:	af00      	add	r7, sp, #0
 800906e:	60f8      	str	r0, [r7, #12]
 8009070:	60b9      	str	r1, [r7, #8]
 8009072:	607a      	str	r2, [r7, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8009074:	68fb      	ldr	r3, [r7, #12]
 8009076:	3330      	adds	r3, #48	; 0x30
 8009078:	4618      	mov	r0, r3
 800907a:	68b9      	ldr	r1, [r7, #8]
 800907c:	687a      	ldr	r2, [r7, #4]
 800907e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009082:	f7ff ff07 	bl	8008e94 <oqWriteTimeout>
 8009086:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 8009088:	4618      	mov	r0, r3
 800908a:	3710      	adds	r7, #16
 800908c:	46bd      	mov	sp, r7
 800908e:	bd80      	pop	{r7, pc}

08009090 <_read.lto_priv.27>:

static size_t _read(void *ip, uint8_t *bp, size_t n) {
 8009090:	b580      	push	{r7, lr}
 8009092:	b084      	sub	sp, #16
 8009094:	af00      	add	r7, sp, #0
 8009096:	60f8      	str	r0, [r7, #12]
 8009098:	60b9      	str	r1, [r7, #8]
 800909a:	607a      	str	r2, [r7, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800909c:	68fb      	ldr	r3, [r7, #12]
 800909e:	330c      	adds	r3, #12
 80090a0:	4618      	mov	r0, r3
 80090a2:	68b9      	ldr	r1, [r7, #8]
 80090a4:	687a      	ldr	r2, [r7, #4]
 80090a6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80090aa:	f7ff fdcd 	bl	8008c48 <iqReadTimeout>
 80090ae:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 80090b0:	4618      	mov	r0, r3
 80090b2:	3710      	adds	r7, #16
 80090b4:	46bd      	mov	sp, r7
 80090b6:	bd80      	pop	{r7, pc}

080090b8 <_put.lto_priv.5>:

static msg_t _put(void *ip, uint8_t b) {
 80090b8:	b580      	push	{r7, lr}
 80090ba:	b082      	sub	sp, #8
 80090bc:	af00      	add	r7, sp, #0
 80090be:	6078      	str	r0, [r7, #4]
 80090c0:	460b      	mov	r3, r1
 80090c2:	70fb      	strb	r3, [r7, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80090c4:	687b      	ldr	r3, [r7, #4]
 80090c6:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80090ca:	78fb      	ldrb	r3, [r7, #3]
 80090cc:	4610      	mov	r0, r2
 80090ce:	4619      	mov	r1, r3
 80090d0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80090d4:	f7ff fe60 	bl	8008d98 <oqPutTimeout>
 80090d8:	4603      	mov	r3, r0
}
 80090da:	4618      	mov	r0, r3
 80090dc:	3708      	adds	r7, #8
 80090de:	46bd      	mov	sp, r7
 80090e0:	bd80      	pop	{r7, pc}
 80090e2:	bf00      	nop

080090e4 <_get.lto_priv.3>:

static msg_t _get(void *ip) {
 80090e4:	b580      	push	{r7, lr}
 80090e6:	b082      	sub	sp, #8
 80090e8:	af00      	add	r7, sp, #0
 80090ea:	6078      	str	r0, [r7, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80090ec:	687b      	ldr	r3, [r7, #4]
 80090ee:	330c      	adds	r3, #12
 80090f0:	4618      	mov	r0, r3
 80090f2:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80090f6:	f7ff fd67 	bl	8008bc8 <iqGetTimeout>
 80090fa:	4603      	mov	r3, r0
}
 80090fc:	4618      	mov	r0, r3
 80090fe:	3708      	adds	r7, #8
 8009100:	46bd      	mov	sp, r7
 8009102:	bd80      	pop	{r7, pc}

08009104 <_putt.lto_priv.28>:

static msg_t _putt(void *ip, uint8_t b, systime_t timeout) {
 8009104:	b580      	push	{r7, lr}
 8009106:	b082      	sub	sp, #8
 8009108:	af00      	add	r7, sp, #0
 800910a:	6078      	str	r0, [r7, #4]
 800910c:	460b      	mov	r3, r1
 800910e:	70fb      	strb	r3, [r7, #3]
 8009110:	4613      	mov	r3, r2
 8009112:	803b      	strh	r3, [r7, #0]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8009114:	687b      	ldr	r3, [r7, #4]
 8009116:	f103 0130 	add.w	r1, r3, #48	; 0x30
 800911a:	78fa      	ldrb	r2, [r7, #3]
 800911c:	883b      	ldrh	r3, [r7, #0]
 800911e:	4608      	mov	r0, r1
 8009120:	4611      	mov	r1, r2
 8009122:	461a      	mov	r2, r3
 8009124:	f7ff fe38 	bl	8008d98 <oqPutTimeout>
 8009128:	4603      	mov	r3, r0
}
 800912a:	4618      	mov	r0, r3
 800912c:	3708      	adds	r7, #8
 800912e:	46bd      	mov	sp, r7
 8009130:	bd80      	pop	{r7, pc}
 8009132:	bf00      	nop

08009134 <_gett.lto_priv.29>:

static msg_t _gett(void *ip, systime_t timeout) {
 8009134:	b580      	push	{r7, lr}
 8009136:	b082      	sub	sp, #8
 8009138:	af00      	add	r7, sp, #0
 800913a:	6078      	str	r0, [r7, #4]
 800913c:	460b      	mov	r3, r1
 800913e:	807b      	strh	r3, [r7, #2]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8009140:	687b      	ldr	r3, [r7, #4]
 8009142:	f103 020c 	add.w	r2, r3, #12
 8009146:	887b      	ldrh	r3, [r7, #2]
 8009148:	4610      	mov	r0, r2
 800914a:	4619      	mov	r1, r3
 800914c:	f7ff fd3c 	bl	8008bc8 <iqGetTimeout>
 8009150:	4603      	mov	r3, r0
}
 8009152:	4618      	mov	r0, r3
 8009154:	3708      	adds	r7, #8
 8009156:	46bd      	mov	sp, r7
 8009158:	bd80      	pop	{r7, pc}
 800915a:	bf00      	nop

0800915c <_writet.lto_priv.30>:

static size_t _writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 800915c:	b580      	push	{r7, lr}
 800915e:	b084      	sub	sp, #16
 8009160:	af00      	add	r7, sp, #0
 8009162:	60f8      	str	r0, [r7, #12]
 8009164:	60b9      	str	r1, [r7, #8]
 8009166:	607a      	str	r2, [r7, #4]
 8009168:	807b      	strh	r3, [r7, #2]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 800916a:	68fb      	ldr	r3, [r7, #12]
 800916c:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8009170:	887b      	ldrh	r3, [r7, #2]
 8009172:	4610      	mov	r0, r2
 8009174:	68b9      	ldr	r1, [r7, #8]
 8009176:	687a      	ldr	r2, [r7, #4]
 8009178:	f7ff fe8c 	bl	8008e94 <oqWriteTimeout>
 800917c:	4603      	mov	r3, r0
}
 800917e:	4618      	mov	r0, r3
 8009180:	3710      	adds	r7, #16
 8009182:	46bd      	mov	sp, r7
 8009184:	bd80      	pop	{r7, pc}
 8009186:	bf00      	nop

08009188 <_readt.lto_priv.31>:

static size_t _readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8009188:	b580      	push	{r7, lr}
 800918a:	b084      	sub	sp, #16
 800918c:	af00      	add	r7, sp, #0
 800918e:	60f8      	str	r0, [r7, #12]
 8009190:	60b9      	str	r1, [r7, #8]
 8009192:	607a      	str	r2, [r7, #4]
 8009194:	807b      	strh	r3, [r7, #2]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8009196:	68fb      	ldr	r3, [r7, #12]
 8009198:	f103 020c 	add.w	r2, r3, #12
 800919c:	887b      	ldrh	r3, [r7, #2]
 800919e:	4610      	mov	r0, r2
 80091a0:	68b9      	ldr	r1, [r7, #8]
 80091a2:	687a      	ldr	r2, [r7, #4]
 80091a4:	f7ff fd50 	bl	8008c48 <iqReadTimeout>
 80091a8:	4603      	mov	r3, r0
}
 80091aa:	4618      	mov	r0, r3
 80091ac:	3710      	adds	r7, #16
 80091ae:	46bd      	mov	sp, r7
 80091b0:	bd80      	pop	{r7, pc}
 80091b2:	bf00      	nop

080091b4 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 80091b4:	b580      	push	{r7, lr}
 80091b6:	af00      	add	r7, sp, #0

  sd_lld_init();
 80091b8:	f000 fc68 	bl	8009a8c <sd_lld_init>
}
 80091bc:	bd80      	pop	{r7, pc}
 80091be:	bf00      	nop

080091c0 <sdObjectInit>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80091c0:	b580      	push	{r7, lr}
 80091c2:	b086      	sub	sp, #24
 80091c4:	af02      	add	r7, sp, #8
 80091c6:	60f8      	str	r0, [r7, #12]
 80091c8:	60b9      	str	r1, [r7, #8]
 80091ca:	607a      	str	r2, [r7, #4]

  sdp->vmt = &vmt;
 80091cc:	68fb      	ldr	r3, [r7, #12]
 80091ce:	4a14      	ldr	r2, [pc, #80]	; (8009220 <sdObjectInit+0x60>)
 80091d0:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 80091d2:	68fb      	ldr	r3, [r7, #12]
 80091d4:	3304      	adds	r3, #4
 80091d6:	4618      	mov	r0, r3
 80091d8:	f7ff ff2a 	bl	8009030 <osalEventObjectInit>
  sdp->state = SD_STOP;
 80091dc:	68fb      	ldr	r3, [r7, #12]
 80091de:	2201      	movs	r2, #1
 80091e0:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80091e2:	68fb      	ldr	r3, [r7, #12]
 80091e4:	f103 010c 	add.w	r1, r3, #12
 80091e8:	68fb      	ldr	r3, [r7, #12]
 80091ea:	f103 0254 	add.w	r2, r3, #84	; 0x54
 80091ee:	68fb      	ldr	r3, [r7, #12]
 80091f0:	9300      	str	r3, [sp, #0]
 80091f2:	4608      	mov	r0, r1
 80091f4:	4611      	mov	r1, r2
 80091f6:	2210      	movs	r2, #16
 80091f8:	68bb      	ldr	r3, [r7, #8]
 80091fa:	f001 f863 	bl	800a2c4 <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 80091fe:	68fb      	ldr	r3, [r7, #12]
 8009200:	f103 0130 	add.w	r1, r3, #48	; 0x30
 8009204:	68fb      	ldr	r3, [r7, #12]
 8009206:	f103 0264 	add.w	r2, r3, #100	; 0x64
 800920a:	68fb      	ldr	r3, [r7, #12]
 800920c:	9300      	str	r3, [sp, #0]
 800920e:	4608      	mov	r0, r1
 8009210:	4611      	mov	r1, r2
 8009212:	2210      	movs	r2, #16
 8009214:	687b      	ldr	r3, [r7, #4]
 8009216:	f7ff fd99 	bl	8008d4c <oqObjectInit>
}
 800921a:	3710      	adds	r7, #16
 800921c:	46bd      	mov	sp, r7
 800921e:	bd80      	pop	{r7, pc}
 8009220:	0800eac4 	.word	0x0800eac4

08009224 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8009224:	b580      	push	{r7, lr}
 8009226:	b082      	sub	sp, #8
 8009228:	af00      	add	r7, sp, #0
 800922a:	6078      	str	r0, [r7, #4]
 800922c:	6039      	str	r1, [r7, #0]

  osalDbgCheck(sdp != NULL);
 800922e:	687b      	ldr	r3, [r7, #4]
 8009230:	2b00      	cmp	r3, #0
 8009232:	d102      	bne.n	800923a <sdStart+0x16>
 8009234:	480d      	ldr	r0, [pc, #52]	; (800926c <sdStart+0x48>)
 8009236:	f001 fde3 	bl	800ae00 <chSysHalt>

  osalSysLock();
 800923a:	f7ff feed 	bl	8009018 <osalSysLock.lto_priv.201>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 800923e:	687b      	ldr	r3, [r7, #4]
 8009240:	7a1b      	ldrb	r3, [r3, #8]
 8009242:	2b01      	cmp	r3, #1
 8009244:	d006      	beq.n	8009254 <sdStart+0x30>
 8009246:	687b      	ldr	r3, [r7, #4]
 8009248:	7a1b      	ldrb	r3, [r3, #8]
 800924a:	2b02      	cmp	r3, #2
 800924c:	d002      	beq.n	8009254 <sdStart+0x30>
 800924e:	4807      	ldr	r0, [pc, #28]	; (800926c <sdStart+0x48>)
 8009250:	f001 fdd6 	bl	800ae00 <chSysHalt>
                "invalid state");
  sd_lld_start(sdp, config);
 8009254:	6878      	ldr	r0, [r7, #4]
 8009256:	6839      	ldr	r1, [r7, #0]
 8009258:	f000 fc2a 	bl	8009ab0 <sd_lld_start>
  sdp->state = SD_READY;
 800925c:	687b      	ldr	r3, [r7, #4]
 800925e:	2202      	movs	r2, #2
 8009260:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 8009262:	f7ff fedf 	bl	8009024 <osalSysUnlock.lto_priv.199>
}
 8009266:	3708      	adds	r7, #8
 8009268:	46bd      	mov	sp, r7
 800926a:	bd80      	pop	{r7, pc}
 800926c:	0800eae4 	.word	0x0800eae4

08009270 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8009270:	b580      	push	{r7, lr}
 8009272:	b082      	sub	sp, #8
 8009274:	af00      	add	r7, sp, #0
 8009276:	6078      	str	r0, [r7, #4]
 8009278:	460b      	mov	r3, r1
 800927a:	70fb      	strb	r3, [r7, #3]

  osalDbgCheckClassI();
 800927c:	f001 fe9e 	bl	800afbc <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);
 8009280:	687b      	ldr	r3, [r7, #4]
 8009282:	2b00      	cmp	r3, #0
 8009284:	d102      	bne.n	800928c <sdIncomingDataI+0x1c>
 8009286:	4811      	ldr	r0, [pc, #68]	; (80092cc <sdIncomingDataI+0x5c>)
 8009288:	f001 fdba 	bl	800ae00 <chSysHalt>

  if (iqIsEmptyI(&sdp->iqueue))
 800928c:	687b      	ldr	r3, [r7, #4]
 800928e:	695b      	ldr	r3, [r3, #20]
 8009290:	2b00      	cmp	r3, #0
 8009292:	d105      	bne.n	80092a0 <sdIncomingDataI+0x30>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8009294:	687b      	ldr	r3, [r7, #4]
 8009296:	3304      	adds	r3, #4
 8009298:	4618      	mov	r0, r3
 800929a:	2104      	movs	r1, #4
 800929c:	f7ff fed4 	bl	8009048 <osalEventBroadcastFlagsI.lto_priv.170>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 80092a0:	687b      	ldr	r3, [r7, #4]
 80092a2:	f103 020c 	add.w	r2, r3, #12
 80092a6:	78fb      	ldrb	r3, [r7, #3]
 80092a8:	4610      	mov	r0, r2
 80092aa:	4619      	mov	r1, r3
 80092ac:	f7ff fc4e 	bl	8008b4c <iqPutI>
 80092b0:	4603      	mov	r3, r0
 80092b2:	2b00      	cmp	r3, #0
 80092b4:	da06      	bge.n	80092c4 <sdIncomingDataI+0x54>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
 80092b6:	687b      	ldr	r3, [r7, #4]
 80092b8:	3304      	adds	r3, #4
 80092ba:	4618      	mov	r0, r3
 80092bc:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80092c0:	f7ff fec2 	bl	8009048 <osalEventBroadcastFlagsI.lto_priv.170>
}
 80092c4:	3708      	adds	r7, #8
 80092c6:	46bd      	mov	sp, r7
 80092c8:	bd80      	pop	{r7, pc}
 80092ca:	bf00      	nop
 80092cc:	0800eaf8 	.word	0x0800eaf8

080092d0 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 80092d0:	b480      	push	{r7}
 80092d2:	b083      	sub	sp, #12
 80092d4:	af00      	add	r7, sp, #0
 80092d6:	4603      	mov	r3, r0
 80092d8:	80fb      	strh	r3, [r7, #6]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80092da:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80092de:	88fb      	ldrh	r3, [r7, #6]
 80092e0:	6353      	str	r3, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80092e2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80092e6:	2200      	movs	r2, #0
 80092e8:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80092ea:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80092ee:	2202      	movs	r2, #2
 80092f0:	60da      	str	r2, [r3, #12]
}
 80092f2:	370c      	adds	r7, #12
 80092f4:	46bd      	mov	sp, r7
 80092f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80092fa:	4770      	bx	lr

080092fc <st_lld_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {
 80092fc:	b480      	push	{r7}
 80092fe:	af00      	add	r7, sp, #0

  STM32_ST_TIM->DIER = 0;
 8009300:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009304:	2200      	movs	r2, #0
 8009306:	60da      	str	r2, [r3, #12]
}
 8009308:	46bd      	mov	sp, r7
 800930a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800930e:	4770      	bx	lr

08009310 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8009310:	b480      	push	{r7}
 8009312:	b083      	sub	sp, #12
 8009314:	af00      	add	r7, sp, #0
 8009316:	4603      	mov	r3, r0
 8009318:	80fb      	strh	r3, [r7, #6]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800931a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800931e:	88fb      	ldrh	r3, [r7, #6]
 8009320:	6353      	str	r3, [r2, #52]	; 0x34
}
 8009322:	370c      	adds	r7, #12
 8009324:	46bd      	mov	sp, r7
 8009326:	f85d 7b04 	ldr.w	r7, [sp], #4
 800932a:	4770      	bx	lr

0800932c <st_lld_is_alarm_active>:
 * @retval false        if the alarm is not active.
 * @retval true         is the alarm is active
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {
 800932c:	b480      	push	{r7}
 800932e:	af00      	add	r7, sp, #0

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8009330:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009334:	68db      	ldr	r3, [r3, #12]
 8009336:	f003 0302 	and.w	r3, r3, #2
 800933a:	2b00      	cmp	r3, #0
 800933c:	bf14      	ite	ne
 800933e:	2301      	movne	r3, #1
 8009340:	2300      	moveq	r3, #0
 8009342:	b2db      	uxtb	r3, r3
}
 8009344:	4618      	mov	r0, r3
 8009346:	46bd      	mov	sp, r7
 8009348:	f85d 7b04 	ldr.w	r7, [sp], #4
 800934c:	4770      	bx	lr
 800934e:	bf00      	nop

08009350 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8009350:	b580      	push	{r7, lr}
 8009352:	af00      	add	r7, sp, #0

  st_lld_init();
 8009354:	f000 f9c0 	bl	80096d8 <st_lld_init>
}
 8009358:	bd80      	pop	{r7, pc}
 800935a:	bf00      	nop

0800935c <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 800935c:	b580      	push	{r7, lr}
 800935e:	b082      	sub	sp, #8
 8009360:	af00      	add	r7, sp, #0
 8009362:	4603      	mov	r3, r0
 8009364:	80fb      	strh	r3, [r7, #6]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8009366:	f7ff ffe1 	bl	800932c <st_lld_is_alarm_active>
 800936a:	4603      	mov	r3, r0
 800936c:	2b00      	cmp	r3, #0
 800936e:	d002      	beq.n	8009376 <stStartAlarm+0x1a>
 8009370:	4804      	ldr	r0, [pc, #16]	; (8009384 <stStartAlarm+0x28>)
 8009372:	f001 fd45 	bl	800ae00 <chSysHalt>

  st_lld_start_alarm(abstime);
 8009376:	88fb      	ldrh	r3, [r7, #6]
 8009378:	4618      	mov	r0, r3
 800937a:	f7ff ffa9 	bl	80092d0 <st_lld_start_alarm>
}
 800937e:	3708      	adds	r7, #8
 8009380:	46bd      	mov	sp, r7
 8009382:	bd80      	pop	{r7, pc}
 8009384:	0800eb08 	.word	0x0800eb08

08009388 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8009388:	b580      	push	{r7, lr}
 800938a:	af00      	add	r7, sp, #0

  st_lld_stop_alarm();
 800938c:	f7ff ffb6 	bl	80092fc <st_lld_stop_alarm>
}
 8009390:	bd80      	pop	{r7, pc}
 8009392:	bf00      	nop

08009394 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8009394:	b580      	push	{r7, lr}
 8009396:	b082      	sub	sp, #8
 8009398:	af00      	add	r7, sp, #0
 800939a:	4603      	mov	r3, r0
 800939c:	80fb      	strh	r3, [r7, #6]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 800939e:	f7ff ffc5 	bl	800932c <st_lld_is_alarm_active>
 80093a2:	4603      	mov	r3, r0
 80093a4:	f083 0301 	eor.w	r3, r3, #1
 80093a8:	b2db      	uxtb	r3, r3
 80093aa:	2b00      	cmp	r3, #0
 80093ac:	d002      	beq.n	80093b4 <stSetAlarm+0x20>
 80093ae:	4805      	ldr	r0, [pc, #20]	; (80093c4 <stSetAlarm+0x30>)
 80093b0:	f001 fd26 	bl	800ae00 <chSysHalt>

  st_lld_set_alarm(abstime);
 80093b4:	88fb      	ldrh	r3, [r7, #6]
 80093b6:	4618      	mov	r0, r3
 80093b8:	f7ff ffaa 	bl	8009310 <st_lld_set_alarm>
}
 80093bc:	3708      	adds	r7, #8
 80093be:	46bd      	mov	sp, r7
 80093c0:	bd80      	pop	{r7, pc}
 80093c2:	bf00      	nop
 80093c4:	0800eb18 	.word	0x0800eb18

080093c8 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 80093c8:	b480      	push	{r7}
 80093ca:	b083      	sub	sp, #12
 80093cc:	af00      	add	r7, sp, #0
 80093ce:	6078      	str	r0, [r7, #4]
 80093d0:	6039      	str	r1, [r7, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80093d2:	4a13      	ldr	r2, [pc, #76]	; (8009420 <nvicEnableVector+0x58>)
 80093d4:	683b      	ldr	r3, [r7, #0]
 80093d6:	b2db      	uxtb	r3, r3
 80093d8:	011b      	lsls	r3, r3, #4
 80093da:	b2d9      	uxtb	r1, r3
 80093dc:	687b      	ldr	r3, [r7, #4]
 80093de:	4413      	add	r3, r2
 80093e0:	f503 7340 	add.w	r3, r3, #768	; 0x300
 80093e4:	460a      	mov	r2, r1
 80093e6:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80093e8:	490d      	ldr	r1, [pc, #52]	; (8009420 <nvicEnableVector+0x58>)
 80093ea:	687b      	ldr	r3, [r7, #4]
 80093ec:	095b      	lsrs	r3, r3, #5
 80093ee:	687a      	ldr	r2, [r7, #4]
 80093f0:	f002 021f 	and.w	r2, r2, #31
 80093f4:	2001      	movs	r0, #1
 80093f6:	fa00 f202 	lsl.w	r2, r0, r2
 80093fa:	3360      	adds	r3, #96	; 0x60
 80093fc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8009400:	4907      	ldr	r1, [pc, #28]	; (8009420 <nvicEnableVector+0x58>)
 8009402:	687b      	ldr	r3, [r7, #4]
 8009404:	095b      	lsrs	r3, r3, #5
 8009406:	687a      	ldr	r2, [r7, #4]
 8009408:	f002 021f 	and.w	r2, r2, #31
 800940c:	2001      	movs	r0, #1
 800940e:	fa00 f202 	lsl.w	r2, r0, r2
 8009412:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8009416:	370c      	adds	r7, #12
 8009418:	46bd      	mov	sp, r7
 800941a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800941e:	4770      	bx	lr
 8009420:	e000e100 	.word	0xe000e100

08009424 <nvicDisableVector>:
/**
 * @brief   Disables an interrupt handler.
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {
 8009424:	b480      	push	{r7}
 8009426:	b083      	sub	sp, #12
 8009428:	af00      	add	r7, sp, #0
 800942a:	6078      	str	r0, [r7, #4]

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 800942c:	490b      	ldr	r1, [pc, #44]	; (800945c <nvicDisableVector+0x38>)
 800942e:	687b      	ldr	r3, [r7, #4]
 8009430:	095b      	lsrs	r3, r3, #5
 8009432:	687a      	ldr	r2, [r7, #4]
 8009434:	f002 021f 	and.w	r2, r2, #31
 8009438:	2001      	movs	r0, #1
 800943a:	fa00 f202 	lsl.w	r2, r0, r2
 800943e:	3320      	adds	r3, #32
 8009440:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8009444:	4a05      	ldr	r2, [pc, #20]	; (800945c <nvicDisableVector+0x38>)
 8009446:	687b      	ldr	r3, [r7, #4]
 8009448:	4413      	add	r3, r2
 800944a:	f503 7340 	add.w	r3, r3, #768	; 0x300
 800944e:	2200      	movs	r2, #0
 8009450:	701a      	strb	r2, [r3, #0]
#endif
}
 8009452:	370c      	adds	r7, #12
 8009454:	46bd      	mov	sp, r7
 8009456:	f85d 7b04 	ldr.w	r7, [sp], #4
 800945a:	4770      	bx	lr
 800945c:	e000e100 	.word	0xe000e100

08009460 <hal_lld_backup_domain_init>:
/**
 * @brief   Initializes the backup domain.
 * @note    WARNING! Changing clock source impossible without resetting
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {
 8009460:	b480      	push	{r7}
 8009462:	af00      	add	r7, sp, #0

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8009464:	4a04      	ldr	r2, [pc, #16]	; (8009478 <hal_lld_backup_domain_init+0x18>)
 8009466:	4b04      	ldr	r3, [pc, #16]	; (8009478 <hal_lld_backup_domain_init+0x18>)
 8009468:	681b      	ldr	r3, [r3, #0]
 800946a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800946e:	6013      	str	r3, [r2, #0]
    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
  }
#endif /* STM32_RTCSEL != STM32_RTCSEL_NOCLOCK */
#endif /* HAL_USE_RTC */
}
 8009470:	46bd      	mov	sp, r7
 8009472:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009476:	4770      	bx	lr
 8009478:	40007000 	.word	0x40007000

0800947c <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 800947c:	b580      	push	{r7, lr}
 800947e:	af00      	add	r7, sp, #0

  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
 8009480:	4b10      	ldr	r3, [pc, #64]	; (80094c4 <hal_lld_init+0x48>)
 8009482:	691b      	ldr	r3, [r3, #16]
 8009484:	4b0f      	ldr	r3, [pc, #60]	; (80094c4 <hal_lld_init+0x48>)
 8009486:	f04f 32ff 	mov.w	r2, #4294967295
 800948a:	611a      	str	r2, [r3, #16]
 800948c:	4b0d      	ldr	r3, [pc, #52]	; (80094c4 <hal_lld_init+0x48>)
 800948e:	2200      	movs	r2, #0
 8009490:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 8009492:	4b0c      	ldr	r3, [pc, #48]	; (80094c4 <hal_lld_init+0x48>)
 8009494:	68db      	ldr	r3, [r3, #12]
 8009496:	4b0b      	ldr	r3, [pc, #44]	; (80094c4 <hal_lld_init+0x48>)
 8009498:	f04f 32ff 	mov.w	r2, #4294967295
 800949c:	60da      	str	r2, [r3, #12]
 800949e:	4b09      	ldr	r3, [pc, #36]	; (80094c4 <hal_lld_init+0x48>)
 80094a0:	2200      	movs	r2, #0
 80094a2:	60da      	str	r2, [r3, #12]

  /* PWR and BD clocks enabled.*/
  /*** these were false in framework ***/
  rccEnablePWRInterface(TRUE);
 80094a4:	4a07      	ldr	r2, [pc, #28]	; (80094c4 <hal_lld_init+0x48>)
 80094a6:	4b07      	ldr	r3, [pc, #28]	; (80094c4 <hal_lld_init+0x48>)
 80094a8:	69db      	ldr	r3, [r3, #28]
 80094aa:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80094ae:	61d3      	str	r3, [r2, #28]
  rccEnableBKPInterface(TRUE);
 80094b0:	4a04      	ldr	r2, [pc, #16]	; (80094c4 <hal_lld_init+0x48>)
 80094b2:	4b04      	ldr	r3, [pc, #16]	; (80094c4 <hal_lld_init+0x48>)
 80094b4:	69db      	ldr	r3, [r3, #28]
 80094b6:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 80094ba:	61d3      	str	r3, [r2, #28]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 80094bc:	f7ff ffd0 	bl	8009460 <hal_lld_backup_domain_init>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 80094c0:	bd80      	pop	{r7, pc}
 80094c2:	bf00      	nop
 80094c4:	40021000 	.word	0x40021000

080094c8 <stm32_clock_init>:
    defined(STM32F10X_HD) || defined(STM32F10X_XL) ||                       \
    defined(__DOXYGEN__)
/*
 * Clocks initialization for all sub-families except CL.
 */
void stm32_clock_init(void) {
 80094c8:	b480      	push	{r7}
 80094ca:	af00      	add	r7, sp, #0

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80094cc:	4a27      	ldr	r2, [pc, #156]	; (800956c <stm32_clock_init+0xa4>)
 80094ce:	4b27      	ldr	r3, [pc, #156]	; (800956c <stm32_clock_init+0xa4>)
 80094d0:	681b      	ldr	r3, [r3, #0]
 80094d2:	f043 0301 	orr.w	r3, r3, #1
 80094d6:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80094d8:	4b24      	ldr	r3, [pc, #144]	; (800956c <stm32_clock_init+0xa4>)
 80094da:	681b      	ldr	r3, [r3, #0]
 80094dc:	f003 0302 	and.w	r3, r3, #2
 80094e0:	2b00      	cmp	r3, #0
 80094e2:	d0f9      	beq.n	80094d8 <stm32_clock_init+0x10>
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80094e4:	4a21      	ldr	r2, [pc, #132]	; (800956c <stm32_clock_init+0xa4>)
 80094e6:	4b21      	ldr	r3, [pc, #132]	; (800956c <stm32_clock_init+0xa4>)
 80094e8:	681b      	ldr	r3, [r3, #0]
 80094ea:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 80094ee:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80094f0:	4b1e      	ldr	r3, [pc, #120]	; (800956c <stm32_clock_init+0xa4>)
 80094f2:	2200      	movs	r2, #0
 80094f4:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80094f6:	4b1d      	ldr	r3, [pc, #116]	; (800956c <stm32_clock_init+0xa4>)
 80094f8:	685b      	ldr	r3, [r3, #4]
 80094fa:	f003 030c 	and.w	r3, r3, #12
 80094fe:	2b00      	cmp	r3, #0
 8009500:	d1f9      	bne.n	80094f6 <stm32_clock_init+0x2e>
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
 8009502:	4a1a      	ldr	r2, [pc, #104]	; (800956c <stm32_clock_init+0xa4>)
 8009504:	4b19      	ldr	r3, [pc, #100]	; (800956c <stm32_clock_init+0xa4>)
 8009506:	681b      	ldr	r3, [r3, #0]
 8009508:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800950c:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 800950e:	4b17      	ldr	r3, [pc, #92]	; (800956c <stm32_clock_init+0xa4>)
 8009510:	681b      	ldr	r3, [r3, #0]
 8009512:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8009516:	2b00      	cmp	r3, #0
 8009518:	d0f9      	beq.n	800950e <stm32_clock_init+0x46>
    ;                                       /* Waits until LSI is stable.   */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
 800951a:	4a14      	ldr	r2, [pc, #80]	; (800956c <stm32_clock_init+0xa4>)
 800951c:	4b13      	ldr	r3, [pc, #76]	; (800956c <stm32_clock_init+0xa4>)
 800951e:	685b      	ldr	r3, [r3, #4]
 8009520:	f443 13e8 	orr.w	r3, r3, #1900544	; 0x1d0000
 8009524:	6053      	str	r3, [r2, #4]
  RCC->CR   |= RCC_CR_PLLON;
 8009526:	4a11      	ldr	r2, [pc, #68]	; (800956c <stm32_clock_init+0xa4>)
 8009528:	4b10      	ldr	r3, [pc, #64]	; (800956c <stm32_clock_init+0xa4>)
 800952a:	681b      	ldr	r3, [r3, #0]
 800952c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8009530:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8009532:	4b0e      	ldr	r3, [pc, #56]	; (800956c <stm32_clock_init+0xa4>)
 8009534:	681b      	ldr	r3, [r3, #0]
 8009536:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800953a:	2b00      	cmp	r3, #0
 800953c:	d0f9      	beq.n	8009532 <stm32_clock_init+0x6a>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Clock settings.*/
#if STM32_HAS_USB
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
 800953e:	4b0b      	ldr	r3, [pc, #44]	; (800956c <stm32_clock_init+0xa4>)
 8009540:	4a0b      	ldr	r2, [pc, #44]	; (8009570 <stm32_clock_init+0xa8>)
 8009542:	605a      	str	r2, [r3, #4]
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8009544:	4b0b      	ldr	r3, [pc, #44]	; (8009574 <stm32_clock_init+0xac>)
 8009546:	2212      	movs	r2, #18
 8009548:	601a      	str	r2, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 800954a:	4a08      	ldr	r2, [pc, #32]	; (800956c <stm32_clock_init+0xa4>)
 800954c:	4b07      	ldr	r3, [pc, #28]	; (800956c <stm32_clock_init+0xa4>)
 800954e:	685b      	ldr	r3, [r3, #4]
 8009550:	f043 0302 	orr.w	r3, r3, #2
 8009554:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8009556:	4b05      	ldr	r3, [pc, #20]	; (800956c <stm32_clock_init+0xa4>)
 8009558:	685b      	ldr	r3, [r3, #4]
 800955a:	f003 030c 	and.w	r3, r3, #12
 800955e:	2b08      	cmp	r3, #8
 8009560:	d1f9      	bne.n	8009556 <stm32_clock_init+0x8e>

#if !STM32_HSI_ENABLED
  RCC->CR &= ~RCC_CR_HSION;
#endif
#endif /* !STM32_NO_INIT */
}
 8009562:	46bd      	mov	sp, r7
 8009564:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009568:	4770      	bx	lr
 800956a:	bf00      	nop
 800956c:	40021000 	.word	0x40021000
 8009570:	001d6400 	.word	0x001d6400
 8009574:	40022000 	.word	0x40022000

08009578 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init() {
 8009578:	b480      	push	{r7}
 800957a:	af00      	add	r7, sp, #0
#endif

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, true);
 800957c:	4a19      	ldr	r2, [pc, #100]	; (80095e4 <_pal_lld_init+0x6c>)
 800957e:	4b19      	ldr	r3, [pc, #100]	; (80095e4 <_pal_lld_init+0x6c>)
 8009580:	699b      	ldr	r3, [r3, #24]
 8009582:	f043 037d 	orr.w	r3, r3, #125	; 0x7d
 8009586:	6193      	str	r3, [r2, #24]

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = VAL_GPIOAODR;
 8009588:	4b17      	ldr	r3, [pc, #92]	; (80095e8 <_pal_lld_init+0x70>)
 800958a:	f04f 32ff 	mov.w	r2, #4294967295
 800958e:	60da      	str	r2, [r3, #12]
  GPIOA->CRH = VAL_GPIOACRH;
 8009590:	4b15      	ldr	r3, [pc, #84]	; (80095e8 <_pal_lld_init+0x70>)
 8009592:	4a16      	ldr	r2, [pc, #88]	; (80095ec <_pal_lld_init+0x74>)
 8009594:	605a      	str	r2, [r3, #4]
  GPIOA->CRL = VAL_GPIOACRL;
 8009596:	4b14      	ldr	r3, [pc, #80]	; (80095e8 <_pal_lld_init+0x70>)
 8009598:	4a15      	ldr	r2, [pc, #84]	; (80095f0 <_pal_lld_init+0x78>)
 800959a:	601a      	str	r2, [r3, #0]
  GPIOB->ODR = VAL_GPIOBODR;
 800959c:	4b15      	ldr	r3, [pc, #84]	; (80095f4 <_pal_lld_init+0x7c>)
 800959e:	f04f 32ff 	mov.w	r2, #4294967295
 80095a2:	60da      	str	r2, [r3, #12]
  GPIOB->CRH = VAL_GPIOBCRH;
 80095a4:	4b13      	ldr	r3, [pc, #76]	; (80095f4 <_pal_lld_init+0x7c>)
 80095a6:	4a14      	ldr	r2, [pc, #80]	; (80095f8 <_pal_lld_init+0x80>)
 80095a8:	605a      	str	r2, [r3, #4]
  GPIOB->CRL = VAL_GPIOBCRL;
 80095aa:	4b12      	ldr	r3, [pc, #72]	; (80095f4 <_pal_lld_init+0x7c>)
 80095ac:	f04f 3288 	mov.w	r2, #2290649224	; 0x88888888
 80095b0:	601a      	str	r2, [r3, #0]
  GPIOC->ODR = VAL_GPIOCODR;
 80095b2:	4b12      	ldr	r3, [pc, #72]	; (80095fc <_pal_lld_init+0x84>)
 80095b4:	f04f 32ff 	mov.w	r2, #4294967295
 80095b8:	60da      	str	r2, [r3, #12]
  GPIOC->CRH = VAL_GPIOCCRH;
 80095ba:	4b10      	ldr	r3, [pc, #64]	; (80095fc <_pal_lld_init+0x84>)
 80095bc:	4a10      	ldr	r2, [pc, #64]	; (8009600 <_pal_lld_init+0x88>)
 80095be:	605a      	str	r2, [r3, #4]
  GPIOC->CRL = VAL_GPIOCCRL;
 80095c0:	4b0e      	ldr	r3, [pc, #56]	; (80095fc <_pal_lld_init+0x84>)
 80095c2:	4a10      	ldr	r2, [pc, #64]	; (8009604 <_pal_lld_init+0x8c>)
 80095c4:	601a      	str	r2, [r3, #0]
  GPIOD->ODR = VAL_GPIODODR;
 80095c6:	4b10      	ldr	r3, [pc, #64]	; (8009608 <_pal_lld_init+0x90>)
 80095c8:	f04f 32ff 	mov.w	r2, #4294967295
 80095cc:	60da      	str	r2, [r3, #12]
  GPIOD->CRH = VAL_GPIODCRH;
 80095ce:	4b0e      	ldr	r3, [pc, #56]	; (8009608 <_pal_lld_init+0x90>)
 80095d0:	f04f 3288 	mov.w	r2, #2290649224	; 0x88888888
 80095d4:	605a      	str	r2, [r3, #4]
  GPIOD->CRL = VAL_GPIODCRL;
 80095d6:	4b0c      	ldr	r3, [pc, #48]	; (8009608 <_pal_lld_init+0x90>)
 80095d8:	4a0c      	ldr	r2, [pc, #48]	; (800960c <_pal_lld_init+0x94>)
 80095da:	601a      	str	r2, [r3, #0]
}
 80095dc:	46bd      	mov	sp, r7
 80095de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80095e2:	4770      	bx	lr
 80095e4:	40021000 	.word	0x40021000
 80095e8:	40010800 	.word	0x40010800
 80095ec:	888b44b8 	.word	0x888b44b8
 80095f0:	88884b84 	.word	0x88884b84
 80095f4:	40010c00 	.word	0x40010c00
 80095f8:	b4b88888 	.word	0xb4b88888
 80095fc:	40011000 	.word	0x40011000
 8009600:	88833388 	.word	0x88833388
 8009604:	44848888 	.word	0x44848888
 8009608:	40011400 	.word	0x40011400
 800960c:	88888844 	.word	0x88888844

08009610 <port_lock.lto_priv.188>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8009610:	b480      	push	{r7}
 8009612:	b083      	sub	sp, #12
 8009614:	af00      	add	r7, sp, #0
 8009616:	2320      	movs	r3, #32
 8009618:	607b      	str	r3, [r7, #4]
 800961a:	687b      	ldr	r3, [r7, #4]
 800961c:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8009620:	370c      	adds	r7, #12
 8009622:	46bd      	mov	sp, r7
 8009624:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009628:	4770      	bx	lr
 800962a:	bf00      	nop

0800962c <port_unlock.lto_priv.185>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800962c:	b480      	push	{r7}
 800962e:	b083      	sub	sp, #12
 8009630:	af00      	add	r7, sp, #0
 8009632:	2300      	movs	r3, #0
 8009634:	607b      	str	r3, [r7, #4]
 8009636:	687b      	ldr	r3, [r7, #4]
 8009638:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800963c:	370c      	adds	r7, #12
 800963e:	46bd      	mov	sp, r7
 8009640:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009644:	4770      	bx	lr
 8009646:	bf00      	nop

08009648 <port_lock_from_isr.lto_priv.182>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8009648:	b580      	push	{r7, lr}
 800964a:	af00      	add	r7, sp, #0

  port_lock();
 800964c:	f7ff ffe0 	bl	8009610 <port_lock.lto_priv.188>
}
 8009650:	bd80      	pop	{r7, pc}
 8009652:	bf00      	nop

08009654 <port_unlock_from_isr.lto_priv.180>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8009654:	b580      	push	{r7, lr}
 8009656:	af00      	add	r7, sp, #0

  port_unlock();
 8009658:	f7ff ffe8 	bl	800962c <port_unlock.lto_priv.185>
}
 800965c:	bd80      	pop	{r7, pc}
 800965e:	bf00      	nop

08009660 <chSysLockFromISR.lto_priv.178>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8009660:	b580      	push	{r7, lr}
 8009662:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 8009664:	f7ff fff0 	bl	8009648 <port_lock_from_isr.lto_priv.182>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8009668:	f001 fc44 	bl	800aef4 <_dbg_check_lock_from_isr>
}
 800966c:	bd80      	pop	{r7, pc}
 800966e:	bf00      	nop

08009670 <chSysUnlockFromISR.lto_priv.176>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8009670:	b580      	push	{r7, lr}
 8009672:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
 8009674:	f001 fc54 	bl	800af20 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8009678:	f7ff ffec 	bl	8009654 <port_unlock_from_isr.lto_priv.180>
}
 800967c:	bd80      	pop	{r7, pc}
 800967e:	bf00      	nop

08009680 <osalSysLockFromISR.lto_priv.174>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8009680:	b580      	push	{r7, lr}
 8009682:	af00      	add	r7, sp, #0

  chSysLockFromISR();
 8009684:	f7ff ffec 	bl	8009660 <chSysLockFromISR.lto_priv.178>
}
 8009688:	bd80      	pop	{r7, pc}
 800968a:	bf00      	nop

0800968c <osalSysUnlockFromISR.lto_priv.172>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 800968c:	b580      	push	{r7, lr}
 800968e:	af00      	add	r7, sp, #0

  chSysUnlockFromISR();
 8009690:	f7ff ffee 	bl	8009670 <chSysUnlockFromISR.lto_priv.176>
}
 8009694:	bd80      	pop	{r7, pc}
 8009696:	bf00      	nop

08009698 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8009698:	b580      	push	{r7, lr}
 800969a:	af00      	add	r7, sp, #0

  chSysTimerHandlerI();
 800969c:	f001 fbbc 	bl	800ae18 <chSysTimerHandlerI>
}
 80096a0:	bd80      	pop	{r7, pc}
 80096a2:	bf00      	nop

080096a4 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80096a4:	b580      	push	{r7, lr}
 80096a6:	af00      	add	r7, sp, #0

  OSAL_IRQ_PROLOGUE();
 80096a8:	f001 fc50 	bl	800af4c <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80096ac:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80096b0:	691b      	ldr	r3, [r3, #16]
 80096b2:	f003 0302 	and.w	r3, r3, #2
 80096b6:	2b00      	cmp	r3, #0
 80096b8:	d009      	beq.n	80096ce <VectorB0+0x2a>
    STM32_ST_TIM->SR = 0U;
 80096ba:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80096be:	2200      	movs	r2, #0
 80096c0:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 80096c2:	f7ff ffdd 	bl	8009680 <osalSysLockFromISR.lto_priv.174>
    osalOsTimerHandlerI();
 80096c6:	f7ff ffe7 	bl	8009698 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 80096ca:	f7ff ffdf 	bl	800968c <osalSysUnlockFromISR.lto_priv.172>
  }

  OSAL_IRQ_EPILOGUE();
 80096ce:	f001 fc59 	bl	800af84 <_dbg_check_leave_isr>
 80096d2:	f000 fcfd 	bl	800a0d0 <_port_irq_epilogue>
}
 80096d6:	bd80      	pop	{r7, pc}

080096d8 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 80096d8:	b580      	push	{r7, lr}
 80096da:	af00      	add	r7, sp, #0

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80096dc:	4a19      	ldr	r2, [pc, #100]	; (8009744 <st_lld_init+0x6c>)
 80096de:	4b19      	ldr	r3, [pc, #100]	; (8009744 <st_lld_init+0x6c>)
 80096e0:	69db      	ldr	r3, [r3, #28]
 80096e2:	f043 0301 	orr.w	r3, r3, #1
 80096e6:	61d3      	str	r3, [r2, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80096e8:	4a17      	ldr	r2, [pc, #92]	; (8009748 <st_lld_init+0x70>)
 80096ea:	4b17      	ldr	r3, [pc, #92]	; (8009748 <st_lld_init+0x70>)
 80096ec:	685b      	ldr	r3, [r3, #4]
 80096ee:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80096f2:	6053      	str	r3, [r2, #4]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80096f4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80096f8:	f641 421f 	movw	r2, #7199	; 0x1c1f
 80096fc:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80096fe:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009702:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8009706:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8009708:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800970c:	2200      	movs	r2, #0
 800970e:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8009710:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009714:	2200      	movs	r2, #0
 8009716:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8009718:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800971c:	2200      	movs	r2, #0
 800971e:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8009720:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009724:	2200      	movs	r2, #0
 8009726:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8009728:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800972c:	2201      	movs	r2, #1
 800972e:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8009730:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009734:	2201      	movs	r2, #1
 8009736:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8009738:	201c      	movs	r0, #28
 800973a:	2108      	movs	r1, #8
 800973c:	f7ff fe44 	bl	80093c8 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8009740:	bd80      	pop	{r7, pc}
 8009742:	bf00      	nop
 8009744:	40021000 	.word	0x40021000
 8009748:	e0042000 	.word	0xe0042000

0800974c <port_lock.lto_priv.189>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800974c:	b480      	push	{r7}
 800974e:	b083      	sub	sp, #12
 8009750:	af00      	add	r7, sp, #0
 8009752:	2320      	movs	r3, #32
 8009754:	607b      	str	r3, [r7, #4]
 8009756:	687b      	ldr	r3, [r7, #4]
 8009758:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800975c:	370c      	adds	r7, #12
 800975e:	46bd      	mov	sp, r7
 8009760:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009764:	4770      	bx	lr
 8009766:	bf00      	nop

08009768 <port_unlock.lto_priv.186>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8009768:	b480      	push	{r7}
 800976a:	b083      	sub	sp, #12
 800976c:	af00      	add	r7, sp, #0
 800976e:	2300      	movs	r3, #0
 8009770:	607b      	str	r3, [r7, #4]
 8009772:	687b      	ldr	r3, [r7, #4]
 8009774:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8009778:	370c      	adds	r7, #12
 800977a:	46bd      	mov	sp, r7
 800977c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009780:	4770      	bx	lr
 8009782:	bf00      	nop

08009784 <port_lock_from_isr.lto_priv.183>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8009784:	b580      	push	{r7, lr}
 8009786:	af00      	add	r7, sp, #0

  port_lock();
 8009788:	f7ff ffe0 	bl	800974c <port_lock.lto_priv.189>
}
 800978c:	bd80      	pop	{r7, pc}
 800978e:	bf00      	nop

08009790 <port_unlock_from_isr.lto_priv.181>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8009790:	b580      	push	{r7, lr}
 8009792:	af00      	add	r7, sp, #0

  port_unlock();
 8009794:	f7ff ffe8 	bl	8009768 <port_unlock.lto_priv.186>
}
 8009798:	bd80      	pop	{r7, pc}
 800979a:	bf00      	nop

0800979c <chSysLockFromISR.lto_priv.179>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800979c:	b580      	push	{r7, lr}
 800979e:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 80097a0:	f7ff fff0 	bl	8009784 <port_lock_from_isr.lto_priv.183>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80097a4:	f001 fba6 	bl	800aef4 <_dbg_check_lock_from_isr>
}
 80097a8:	bd80      	pop	{r7, pc}
 80097aa:	bf00      	nop

080097ac <chSysUnlockFromISR.lto_priv.177>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80097ac:	b580      	push	{r7, lr}
 80097ae:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
 80097b0:	f001 fbb6 	bl	800af20 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80097b4:	f7ff ffec 	bl	8009790 <port_unlock_from_isr.lto_priv.181>
}
 80097b8:	bd80      	pop	{r7, pc}
 80097ba:	bf00      	nop

080097bc <osalSysLockFromISR.lto_priv.175>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 80097bc:	b580      	push	{r7, lr}
 80097be:	af00      	add	r7, sp, #0

  chSysLockFromISR();
 80097c0:	f7ff ffec 	bl	800979c <chSysLockFromISR.lto_priv.179>
}
 80097c4:	bd80      	pop	{r7, pc}
 80097c6:	bf00      	nop

080097c8 <osalSysUnlockFromISR.lto_priv.173>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 80097c8:	b580      	push	{r7, lr}
 80097ca:	af00      	add	r7, sp, #0

  chSysUnlockFromISR();
 80097cc:	f7ff ffee 	bl	80097ac <chSysUnlockFromISR.lto_priv.177>
}
 80097d0:	bd80      	pop	{r7, pc}
 80097d2:	bf00      	nop

080097d4 <osalEventBroadcastFlagsI.lto_priv.171>:

  chEvtBroadcastFlagsI(esp, flags);
}
#else
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 80097d4:	b480      	push	{r7}
 80097d6:	b083      	sub	sp, #12
 80097d8:	af00      	add	r7, sp, #0
 80097da:	6078      	str	r0, [r7, #4]
 80097dc:	6039      	str	r1, [r7, #0]

  esp->flags |= flags;
 80097de:	687b      	ldr	r3, [r7, #4]
 80097e0:	681a      	ldr	r2, [r3, #0]
 80097e2:	683b      	ldr	r3, [r7, #0]
 80097e4:	431a      	orrs	r2, r3
 80097e6:	687b      	ldr	r3, [r7, #4]
 80097e8:	601a      	str	r2, [r3, #0]
}
 80097ea:	370c      	adds	r7, #12
 80097ec:	46bd      	mov	sp, r7
 80097ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80097f2:	4770      	bx	lr

080097f4 <usart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 80097f4:	b480      	push	{r7}
 80097f6:	b085      	sub	sp, #20
 80097f8:	af00      	add	r7, sp, #0
 80097fa:	6078      	str	r0, [r7, #4]
 80097fc:	6039      	str	r1, [r7, #0]
  USART_TypeDef *u = sdp->usart;
 80097fe:	687b      	ldr	r3, [r7, #4]
 8009800:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009802:	60fb      	str	r3, [r7, #12]

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
 8009804:	687b      	ldr	r3, [r7, #4]
 8009806:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009808:	4a23      	ldr	r2, [pc, #140]	; (8009898 <usart_init+0xa4>)
 800980a:	4293      	cmp	r3, r2
 800980c:	d107      	bne.n	800981e <usart_init+0x2a>
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 800980e:	683b      	ldr	r3, [r7, #0]
 8009810:	681b      	ldr	r3, [r3, #0]
 8009812:	4a22      	ldr	r2, [pc, #136]	; (800989c <usart_init+0xa8>)
 8009814:	fbb2 f2f3 	udiv	r2, r2, r3
 8009818:	68fb      	ldr	r3, [r7, #12]
 800981a:	609a      	str	r2, [r3, #8]
 800981c:	e006      	b.n	800982c <usart_init+0x38>
  else
    u->BRR = STM32_PCLK1 / config->speed;
 800981e:	683b      	ldr	r3, [r7, #0]
 8009820:	681b      	ldr	r3, [r3, #0]
 8009822:	4a1e      	ldr	r2, [pc, #120]	; (800989c <usart_init+0xa8>)
 8009824:	fbb2 f2f3 	udiv	r2, r2, r3
 8009828:	68fb      	ldr	r3, [r7, #12]
 800982a:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800982c:	683b      	ldr	r3, [r7, #0]
 800982e:	88db      	ldrh	r3, [r3, #6]
 8009830:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009834:	b29b      	uxth	r3, r3
 8009836:	461a      	mov	r2, r3
 8009838:	68fb      	ldr	r3, [r7, #12]
 800983a:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800983c:	683b      	ldr	r3, [r7, #0]
 800983e:	891b      	ldrh	r3, [r3, #8]
 8009840:	f043 0301 	orr.w	r3, r3, #1
 8009844:	b29b      	uxth	r3, r3
 8009846:	461a      	mov	r2, r3
 8009848:	68fb      	ldr	r3, [r7, #12]
 800984a:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800984c:	683b      	ldr	r3, [r7, #0]
 800984e:	889b      	ldrh	r3, [r3, #4]
 8009850:	f443 5304 	orr.w	r3, r3, #8448	; 0x2100
 8009854:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
 8009858:	b29b      	uxth	r3, r3
 800985a:	461a      	mov	r2, r3
 800985c:	68fb      	ldr	r3, [r7, #12]
 800985e:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8009860:	68fb      	ldr	r3, [r7, #12]
 8009862:	2200      	movs	r2, #0
 8009864:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8009866:	68fb      	ldr	r3, [r7, #12]
 8009868:	681b      	ldr	r3, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 800986a:	68fb      	ldr	r3, [r7, #12]
 800986c:	685b      	ldr	r3, [r3, #4]

  /* Deciding mask to be applied on the data register on receive, this is
     required in order to mask out the parity bit.*/
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
 800986e:	683b      	ldr	r3, [r7, #0]
 8009870:	889b      	ldrh	r3, [r3, #4]
 8009872:	f403 53a0 	and.w	r3, r3, #5120	; 0x1400
 8009876:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800987a:	d104      	bne.n	8009886 <usart_init+0x92>
    sdp->rxmask = 0x7F;
 800987c:	687b      	ldr	r3, [r7, #4]
 800987e:	227f      	movs	r2, #127	; 0x7f
 8009880:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
 8009884:	e003      	b.n	800988e <usart_init+0x9a>
  }
  else {
    sdp->rxmask = 0xFF;
 8009886:	687b      	ldr	r3, [r7, #4]
 8009888:	22ff      	movs	r2, #255	; 0xff
 800988a:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
  }
}
 800988e:	3714      	adds	r7, #20
 8009890:	46bd      	mov	sp, r7
 8009892:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009896:	4770      	bx	lr
 8009898:	40013800 	.word	0x40013800
 800989c:	02255100 	.word	0x02255100

080098a0 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
 80098a0:	b580      	push	{r7, lr}
 80098a2:	b084      	sub	sp, #16
 80098a4:	af00      	add	r7, sp, #0
 80098a6:	6078      	str	r0, [r7, #4]
 80098a8:	460b      	mov	r3, r1
 80098aa:	807b      	strh	r3, [r7, #2]
  eventflags_t sts = 0;
 80098ac:	2300      	movs	r3, #0
 80098ae:	60fb      	str	r3, [r7, #12]

  if (sr & USART_SR_ORE)
 80098b0:	887b      	ldrh	r3, [r7, #2]
 80098b2:	f003 0308 	and.w	r3, r3, #8
 80098b6:	2b00      	cmp	r3, #0
 80098b8:	d003      	beq.n	80098c2 <set_error+0x22>
    sts |= SD_OVERRUN_ERROR;
 80098ba:	68fb      	ldr	r3, [r7, #12]
 80098bc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80098c0:	60fb      	str	r3, [r7, #12]
  if (sr & USART_SR_PE)
 80098c2:	887b      	ldrh	r3, [r7, #2]
 80098c4:	f003 0301 	and.w	r3, r3, #1
 80098c8:	2b00      	cmp	r3, #0
 80098ca:	d003      	beq.n	80098d4 <set_error+0x34>
    sts |= SD_PARITY_ERROR;
 80098cc:	68fb      	ldr	r3, [r7, #12]
 80098ce:	f043 0320 	orr.w	r3, r3, #32
 80098d2:	60fb      	str	r3, [r7, #12]
  if (sr & USART_SR_FE)
 80098d4:	887b      	ldrh	r3, [r7, #2]
 80098d6:	f003 0302 	and.w	r3, r3, #2
 80098da:	2b00      	cmp	r3, #0
 80098dc:	d003      	beq.n	80098e6 <set_error+0x46>
    sts |= SD_FRAMING_ERROR;
 80098de:	68fb      	ldr	r3, [r7, #12]
 80098e0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80098e4:	60fb      	str	r3, [r7, #12]
  if (sr & USART_SR_NE)
 80098e6:	887b      	ldrh	r3, [r7, #2]
 80098e8:	f003 0304 	and.w	r3, r3, #4
 80098ec:	2b00      	cmp	r3, #0
 80098ee:	d003      	beq.n	80098f8 <set_error+0x58>
    sts |= SD_NOISE_ERROR;
 80098f0:	68fb      	ldr	r3, [r7, #12]
 80098f2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80098f6:	60fb      	str	r3, [r7, #12]
  chnAddFlagsI(sdp, sts);
 80098f8:	687b      	ldr	r3, [r7, #4]
 80098fa:	3304      	adds	r3, #4
 80098fc:	4618      	mov	r0, r3
 80098fe:	68f9      	ldr	r1, [r7, #12]
 8009900:	f7ff ff68 	bl	80097d4 <osalEventBroadcastFlagsI.lto_priv.171>
}
 8009904:	3710      	adds	r7, #16
 8009906:	46bd      	mov	sp, r7
 8009908:	bd80      	pop	{r7, pc}
 800990a:	bf00      	nop

0800990c <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 800990c:	b580      	push	{r7, lr}
 800990e:	b086      	sub	sp, #24
 8009910:	af00      	add	r7, sp, #0
 8009912:	6078      	str	r0, [r7, #4]
  USART_TypeDef *u = sdp->usart;
 8009914:	687b      	ldr	r3, [r7, #4]
 8009916:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009918:	613b      	str	r3, [r7, #16]
  uint16_t cr1 = u->CR1;
 800991a:	693b      	ldr	r3, [r7, #16]
 800991c:	68db      	ldr	r3, [r3, #12]
 800991e:	81fb      	strh	r3, [r7, #14]
  uint16_t sr = u->SR;
 8009920:	693b      	ldr	r3, [r7, #16]
 8009922:	681b      	ldr	r3, [r3, #0]
 8009924:	82fb      	strh	r3, [r7, #22]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8009926:	8afb      	ldrh	r3, [r7, #22]
 8009928:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800992c:	2b00      	cmp	r3, #0
 800992e:	d00e      	beq.n	800994e <serve_interrupt+0x42>
    osalSysLockFromISR();
 8009930:	f7ff ff44 	bl	80097bc <osalSysLockFromISR.lto_priv.175>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 8009934:	687b      	ldr	r3, [r7, #4]
 8009936:	3304      	adds	r3, #4
 8009938:	4618      	mov	r0, r3
 800993a:	f44f 7100 	mov.w	r1, #512	; 0x200
 800993e:	f7ff ff49 	bl	80097d4 <osalEventBroadcastFlagsI.lto_priv.171>
    u->SR = ~USART_SR_LBD;
 8009942:	693b      	ldr	r3, [r7, #16]
 8009944:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8009948:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 800994a:	f7ff ff3d 	bl	80097c8 <osalSysUnlockFromISR.lto_priv.173>
  }

  /* Data available.*/
  osalSysLockFromISR();
 800994e:	f7ff ff35 	bl	80097bc <osalSysLockFromISR.lto_priv.175>
 8009952:	e01e      	b.n	8009992 <serve_interrupt+0x86>
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8009954:	8afb      	ldrh	r3, [r7, #22]
 8009956:	f003 030f 	and.w	r3, r3, #15
 800995a:	2b00      	cmp	r3, #0
 800995c:	d004      	beq.n	8009968 <serve_interrupt+0x5c>
      set_error(sdp, sr);
 800995e:	8afb      	ldrh	r3, [r7, #22]
 8009960:	6878      	ldr	r0, [r7, #4]
 8009962:	4619      	mov	r1, r3
 8009964:	f7ff ff9c 	bl	80098a0 <set_error>
    b = (uint8_t)u->DR & sdp->rxmask;
 8009968:	693b      	ldr	r3, [r7, #16]
 800996a:	685b      	ldr	r3, [r3, #4]
 800996c:	b2da      	uxtb	r2, r3
 800996e:	687b      	ldr	r3, [r7, #4]
 8009970:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
 8009974:	4013      	ands	r3, r2
 8009976:	737b      	strb	r3, [r7, #13]
    if (sr & USART_SR_RXNE)
 8009978:	8afb      	ldrh	r3, [r7, #22]
 800997a:	f003 0320 	and.w	r3, r3, #32
 800997e:	2b00      	cmp	r3, #0
 8009980:	d004      	beq.n	800998c <serve_interrupt+0x80>
      sdIncomingDataI(sdp, b);
 8009982:	7b7b      	ldrb	r3, [r7, #13]
 8009984:	6878      	ldr	r0, [r7, #4]
 8009986:	4619      	mov	r1, r3
 8009988:	f7ff fc72 	bl	8009270 <sdIncomingDataI>
    sr = u->SR;
 800998c:	693b      	ldr	r3, [r7, #16]
 800998e:	681b      	ldr	r3, [r3, #0]
 8009990:	82fb      	strh	r3, [r7, #22]
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8009992:	8afb      	ldrh	r3, [r7, #22]
 8009994:	f003 032f 	and.w	r3, r3, #47	; 0x2f
 8009998:	2b00      	cmp	r3, #0
 800999a:	d1db      	bne.n	8009954 <serve_interrupt+0x48>
    b = (uint8_t)u->DR & sdp->rxmask;
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
  }
  osalSysUnlockFromISR();
 800999c:	f7ff ff14 	bl	80097c8 <osalSysUnlockFromISR.lto_priv.173>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 80099a0:	89fb      	ldrh	r3, [r7, #14]
 80099a2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80099a6:	2b00      	cmp	r3, #0
 80099a8:	d022      	beq.n	80099f0 <serve_interrupt+0xe4>
 80099aa:	8afb      	ldrh	r3, [r7, #22]
 80099ac:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80099b0:	2b00      	cmp	r3, #0
 80099b2:	d01d      	beq.n	80099f0 <serve_interrupt+0xe4>
    msg_t b;
    osalSysLockFromISR();
 80099b4:	f7ff ff02 	bl	80097bc <osalSysLockFromISR.lto_priv.175>
    b = oqGetI(&sdp->oqueue);
 80099b8:	687b      	ldr	r3, [r7, #4]
 80099ba:	3330      	adds	r3, #48	; 0x30
 80099bc:	4618      	mov	r0, r3
 80099be:	f7ff fa2d 	bl	8008e1c <oqGetI>
 80099c2:	60b8      	str	r0, [r7, #8]
    if (b < MSG_OK) {
 80099c4:	68bb      	ldr	r3, [r7, #8]
 80099c6:	2b00      	cmp	r3, #0
 80099c8:	da0d      	bge.n	80099e6 <serve_interrupt+0xda>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 80099ca:	687b      	ldr	r3, [r7, #4]
 80099cc:	3304      	adds	r3, #4
 80099ce:	4618      	mov	r0, r3
 80099d0:	2108      	movs	r1, #8
 80099d2:	f7ff feff 	bl	80097d4 <osalEventBroadcastFlagsI.lto_priv.171>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 80099d6:	89fb      	ldrh	r3, [r7, #14]
 80099d8:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 80099dc:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 80099e0:	693b      	ldr	r3, [r7, #16]
 80099e2:	60da      	str	r2, [r3, #12]
 80099e4:	e002      	b.n	80099ec <serve_interrupt+0xe0>
    }
    else
      u->DR = b;
 80099e6:	68ba      	ldr	r2, [r7, #8]
 80099e8:	693b      	ldr	r3, [r7, #16]
 80099ea:	605a      	str	r2, [r3, #4]
    osalSysUnlockFromISR();
 80099ec:	f7ff feec 	bl	80097c8 <osalSysUnlockFromISR.lto_priv.173>
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 80099f0:	8afb      	ldrh	r3, [r7, #22]
 80099f2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80099f6:	2b00      	cmp	r3, #0
 80099f8:	d024      	beq.n	8009a44 <serve_interrupt+0x138>
    osalSysLockFromISR();
 80099fa:	f7ff fedf 	bl	80097bc <osalSysLockFromISR.lto_priv.175>
    if (oqIsEmptyI(&sdp->oqueue))
 80099fe:	687b      	ldr	r3, [r7, #4]
 8009a00:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8009a02:	687b      	ldr	r3, [r7, #4]
 8009a04:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009a06:	429a      	cmp	r2, r3
 8009a08:	d105      	bne.n	8009a16 <serve_interrupt+0x10a>
 8009a0a:	687b      	ldr	r3, [r7, #4]
 8009a0c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009a0e:	2b00      	cmp	r3, #0
 8009a10:	d001      	beq.n	8009a16 <serve_interrupt+0x10a>
 8009a12:	2301      	movs	r3, #1
 8009a14:	e000      	b.n	8009a18 <serve_interrupt+0x10c>
 8009a16:	2300      	movs	r3, #0
 8009a18:	f003 0301 	and.w	r3, r3, #1
 8009a1c:	b2db      	uxtb	r3, r3
 8009a1e:	2b00      	cmp	r3, #0
 8009a20:	d005      	beq.n	8009a2e <serve_interrupt+0x122>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8009a22:	687b      	ldr	r3, [r7, #4]
 8009a24:	3304      	adds	r3, #4
 8009a26:	4618      	mov	r0, r3
 8009a28:	2110      	movs	r1, #16
 8009a2a:	f7ff fed3 	bl	80097d4 <osalEventBroadcastFlagsI.lto_priv.171>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8009a2e:	89fb      	ldrh	r3, [r7, #14]
 8009a30:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 8009a34:	693b      	ldr	r3, [r7, #16]
 8009a36:	60da      	str	r2, [r3, #12]
    u->SR = ~USART_SR_TC;
 8009a38:	693b      	ldr	r3, [r7, #16]
 8009a3a:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8009a3e:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 8009a40:	f7ff fec2 	bl	80097c8 <osalSysUnlockFromISR.lto_priv.173>
  }
}
 8009a44:	3718      	adds	r7, #24
 8009a46:	46bd      	mov	sp, r7
 8009a48:	bd80      	pop	{r7, pc}
 8009a4a:	bf00      	nop

08009a4c <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {
 8009a4c:	b480      	push	{r7}
 8009a4e:	b083      	sub	sp, #12
 8009a50:	af00      	add	r7, sp, #0
 8009a52:	6078      	str	r0, [r7, #4]

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8009a54:	4a05      	ldr	r2, [pc, #20]	; (8009a6c <notify1+0x20>)
 8009a56:	4b05      	ldr	r3, [pc, #20]	; (8009a6c <notify1+0x20>)
 8009a58:	68db      	ldr	r3, [r3, #12]
 8009a5a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009a5e:	60d3      	str	r3, [r2, #12]
}
 8009a60:	370c      	adds	r7, #12
 8009a62:	46bd      	mov	sp, r7
 8009a64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a68:	4770      	bx	lr
 8009a6a:	bf00      	nop
 8009a6c:	40013800 	.word	0x40013800

08009a70 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8009a70:	b580      	push	{r7, lr}
 8009a72:	af00      	add	r7, sp, #0

  OSAL_IRQ_PROLOGUE();
 8009a74:	f001 fa6a 	bl	800af4c <_dbg_check_enter_isr>

  serve_interrupt(&SD1);
 8009a78:	4803      	ldr	r0, [pc, #12]	; (8009a88 <VectorD4+0x18>)
 8009a7a:	f7ff ff47 	bl	800990c <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8009a7e:	f001 fa81 	bl	800af84 <_dbg_check_leave_isr>
 8009a82:	f000 fb25 	bl	800a0d0 <_port_irq_epilogue>
}
 8009a86:	bd80      	pop	{r7, pc}
 8009a88:	200013ac 	.word	0x200013ac

08009a8c <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8009a8c:	b580      	push	{r7, lr}
 8009a8e:	af00      	add	r7, sp, #0

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 8009a90:	4804      	ldr	r0, [pc, #16]	; (8009aa4 <sd_lld_init+0x18>)
 8009a92:	2100      	movs	r1, #0
 8009a94:	4a04      	ldr	r2, [pc, #16]	; (8009aa8 <sd_lld_init+0x1c>)
 8009a96:	f7ff fb93 	bl	80091c0 <sdObjectInit>
  SD1.usart = USART1;
 8009a9a:	4b02      	ldr	r3, [pc, #8]	; (8009aa4 <sd_lld_init+0x18>)
 8009a9c:	4a03      	ldr	r2, [pc, #12]	; (8009aac <sd_lld_init+0x20>)
 8009a9e:	675a      	str	r2, [r3, #116]	; 0x74

#if STM32_SERIAL_USE_UART8
  sdObjectInit(&SD8, NULL, notify8);
  SD8.usart = UART8;
#endif
}
 8009aa0:	bd80      	pop	{r7, pc}
 8009aa2:	bf00      	nop
 8009aa4:	200013ac 	.word	0x200013ac
 8009aa8:	08009a4d 	.word	0x08009a4d
 8009aac:	40013800 	.word	0x40013800

08009ab0 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8009ab0:	b580      	push	{r7, lr}
 8009ab2:	b082      	sub	sp, #8
 8009ab4:	af00      	add	r7, sp, #0
 8009ab6:	6078      	str	r0, [r7, #4]
 8009ab8:	6039      	str	r1, [r7, #0]

  if (config == NULL)
 8009aba:	683b      	ldr	r3, [r7, #0]
 8009abc:	2b00      	cmp	r3, #0
 8009abe:	d101      	bne.n	8009ac4 <sd_lld_start+0x14>
    config = &default_config;
 8009ac0:	4b0d      	ldr	r3, [pc, #52]	; (8009af8 <sd_lld_start+0x48>)
 8009ac2:	603b      	str	r3, [r7, #0]

  if (sdp->state == SD_STOP) {
 8009ac4:	687b      	ldr	r3, [r7, #4]
 8009ac6:	7a1b      	ldrb	r3, [r3, #8]
 8009ac8:	2b01      	cmp	r3, #1
 8009aca:	d10d      	bne.n	8009ae8 <sd_lld_start+0x38>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
 8009acc:	687b      	ldr	r3, [r7, #4]
 8009ace:	4a0b      	ldr	r2, [pc, #44]	; (8009afc <sd_lld_start+0x4c>)
 8009ad0:	4293      	cmp	r3, r2
 8009ad2:	d109      	bne.n	8009ae8 <sd_lld_start+0x38>
      rccEnableUSART1(FALSE);
 8009ad4:	4a0a      	ldr	r2, [pc, #40]	; (8009b00 <sd_lld_start+0x50>)
 8009ad6:	4b0a      	ldr	r3, [pc, #40]	; (8009b00 <sd_lld_start+0x50>)
 8009ad8:	699b      	ldr	r3, [r3, #24]
 8009ada:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8009ade:	6193      	str	r3, [r2, #24]
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 8009ae0:	2025      	movs	r0, #37	; 0x25
 8009ae2:	210c      	movs	r1, #12
 8009ae4:	f7ff fc70 	bl	80093c8 <nvicEnableVector>
      rccEnableUART8(FALSE);
      nvicEnableVector(STM32_UART8_NUMBER, STM32_SERIAL_UART8_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
 8009ae8:	6878      	ldr	r0, [r7, #4]
 8009aea:	6839      	ldr	r1, [r7, #0]
 8009aec:	f7ff fe82 	bl	80097f4 <usart_init>
}
 8009af0:	3708      	adds	r7, #8
 8009af2:	46bd      	mov	sp, r7
 8009af4:	bd80      	pop	{r7, pc}
 8009af6:	bf00      	nop
 8009af8:	0800eb24 	.word	0x0800eb24
 8009afc:	200013ac 	.word	0x200013ac
 8009b00:	40021000 	.word	0x40021000

08009b04 <boardInit>:
#include <hal.h>

void boardInit(void) {
 8009b04:	b580      	push	{r7, lr}
 8009b06:	af00      	add	r7, sp, #0

    /*
     * Activates the serial driver 1 using the driver default configuration.
     * PA9 and PA10 are routed to USART1.
     */
    sdStart(&SD1, &uartCfg);
 8009b08:	4802      	ldr	r0, [pc, #8]	; (8009b14 <boardInit+0x10>)
 8009b0a:	4903      	ldr	r1, [pc, #12]	; (8009b18 <boardInit+0x14>)
 8009b0c:	f7ff fb8a 	bl	8009224 <sdStart>

    /* this is set in board.h */
//    palSetPadMode(GPIOA, 9, PPAL_MODE_STM32_ALTERNATE_PUSHPULL);
//    palSetPadMode(GPIOA, 10, PAL_MODE_INPUT);
}
 8009b10:	bd80      	pop	{r7, pc}
 8009b12:	bf00      	nop
 8009b14:	200013ac 	.word	0x200013ac
 8009b18:	0800eb30 	.word	0x0800eb30

08009b1c <param_struct_valid>:
{
    return shared_find_marker(*((uint64_t*)SHARED_APP_DESCRIPTOR_SIGNATURE), buf, buf_len);
}

static bool param_struct_valid(const struct shared_app_parameters_s* parameters, bool ignore_crc64)
{
 8009b1c:	b5b0      	push	{r4, r5, r7, lr}
 8009b1e:	b082      	sub	sp, #8
 8009b20:	af00      	add	r7, sp, #0
 8009b22:	6078      	str	r0, [r7, #4]
 8009b24:	460b      	mov	r3, r1
 8009b26:	70fb      	strb	r3, [r7, #3]
    return parameters && (ignore_crc64 || crc64_we((uint8_t*)parameters, sizeof(struct shared_app_parameters_s)-sizeof(uint64_t), 0) == parameters->crc64);
 8009b28:	687b      	ldr	r3, [r7, #4]
 8009b2a:	2b00      	cmp	r3, #0
 8009b2c:	d017      	beq.n	8009b5e <param_struct_valid+0x42>
 8009b2e:	78fb      	ldrb	r3, [r7, #3]
 8009b30:	2b00      	cmp	r3, #0
 8009b32:	d112      	bne.n	8009b5a <param_struct_valid+0x3e>
 8009b34:	6878      	ldr	r0, [r7, #4]
 8009b36:	2107      	movs	r1, #7
 8009b38:	f04f 0200 	mov.w	r2, #0
 8009b3c:	f04f 0300 	mov.w	r3, #0
 8009b40:	f7fe f82e 	bl	8007ba0 <crc64_we>
 8009b44:	4604      	mov	r4, r0
 8009b46:	460d      	mov	r5, r1
 8009b48:	6879      	ldr	r1, [r7, #4]
 8009b4a:	f8d1 2007 	ldr.w	r2, [r1, #7]
 8009b4e:	f8d1 300b 	ldr.w	r3, [r1, #11]
 8009b52:	429d      	cmp	r5, r3
 8009b54:	bf08      	it	eq
 8009b56:	4294      	cmpeq	r4, r2
 8009b58:	d101      	bne.n	8009b5e <param_struct_valid+0x42>
 8009b5a:	2301      	movs	r3, #1
 8009b5c:	e000      	b.n	8009b60 <param_struct_valid+0x44>
 8009b5e:	2300      	movs	r3, #0
 8009b60:	f003 0301 	and.w	r3, r3, #1
 8009b64:	b2db      	uxtb	r3, r3
}
 8009b66:	4618      	mov	r0, r3
 8009b68:	3708      	adds	r7, #8
 8009b6a:	46bd      	mov	sp, r7
 8009b6c:	bdb0      	pop	{r4, r5, r7, pc}
 8009b6e:	bf00      	nop

08009b70 <shared_get_parameters>:

const struct shared_app_parameters_s* shared_get_parameters(const struct shared_app_descriptor_s* descriptor)
{
 8009b70:	b580      	push	{r7, lr}
 8009b72:	b084      	sub	sp, #16
 8009b74:	af00      	add	r7, sp, #0
 8009b76:	6078      	str	r0, [r7, #4]
    if (descriptor->parameters_fmt != SHARED_APP_PARAMETERS_FMT) {
 8009b78:	687b      	ldr	r3, [r7, #4]
 8009b7a:	7e9b      	ldrb	r3, [r3, #26]
 8009b7c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8009b80:	b2db      	uxtb	r3, r3
 8009b82:	2b01      	cmp	r3, #1
 8009b84:	d001      	beq.n	8009b8a <shared_get_parameters+0x1a>
        return 0;
 8009b86:	2300      	movs	r3, #0
 8009b88:	e03e      	b.n	8009c08 <shared_get_parameters+0x98>
    }

    const struct shared_app_parameters_s* ret = 0;
 8009b8a:	2300      	movs	r3, #0
 8009b8c:	60fb      	str	r3, [r7, #12]

    for (uint8_t i=0; i<2; i++) {
 8009b8e:	2300      	movs	r3, #0
 8009b90:	72fb      	strb	r3, [r7, #11]
 8009b92:	e035      	b.n	8009c00 <shared_get_parameters+0x90>
        if (param_struct_valid(descriptor->parameters[i], descriptor->parameters_ignore_crc64) &&
 8009b94:	7afb      	ldrb	r3, [r7, #11]
 8009b96:	687a      	ldr	r2, [r7, #4]
 8009b98:	3306      	adds	r3, #6
 8009b9a:	009b      	lsls	r3, r3, #2
 8009b9c:	4413      	add	r3, r2
 8009b9e:	f8d3 2003 	ldr.w	r2, [r3, #3]
 8009ba2:	687b      	ldr	r3, [r7, #4]
 8009ba4:	7e9b      	ldrb	r3, [r3, #26]
 8009ba6:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 8009baa:	b2db      	uxtb	r3, r3
 8009bac:	2b00      	cmp	r3, #0
 8009bae:	bf14      	ite	ne
 8009bb0:	2301      	movne	r3, #1
 8009bb2:	2300      	moveq	r3, #0
 8009bb4:	b2db      	uxtb	r3, r3
 8009bb6:	4610      	mov	r0, r2
 8009bb8:	4619      	mov	r1, r3
 8009bba:	f7ff ffaf 	bl	8009b1c <param_struct_valid>
 8009bbe:	4603      	mov	r3, r0
 8009bc0:	2b00      	cmp	r3, #0
 8009bc2:	d01a      	beq.n	8009bfa <shared_get_parameters+0x8a>
 8009bc4:	68fb      	ldr	r3, [r7, #12]
 8009bc6:	2b00      	cmp	r3, #0
 8009bc8:	d00f      	beq.n	8009bea <shared_get_parameters+0x7a>
            (!ret || (int8_t)(descriptor->parameters[i]->param_idx-ret->param_idx) > 0)) {
 8009bca:	7afb      	ldrb	r3, [r7, #11]
 8009bcc:	687a      	ldr	r2, [r7, #4]
 8009bce:	3306      	adds	r3, #6
 8009bd0:	009b      	lsls	r3, r3, #2
 8009bd2:	4413      	add	r3, r2
 8009bd4:	f8d3 3003 	ldr.w	r3, [r3, #3]
 8009bd8:	781a      	ldrb	r2, [r3, #0]
 8009bda:	68fb      	ldr	r3, [r7, #12]
 8009bdc:	781b      	ldrb	r3, [r3, #0]
 8009bde:	1ad3      	subs	r3, r2, r3
 8009be0:	b2db      	uxtb	r3, r3
 8009be2:	b2db      	uxtb	r3, r3
 8009be4:	b25b      	sxtb	r3, r3
 8009be6:	2b00      	cmp	r3, #0
 8009be8:	dd07      	ble.n	8009bfa <shared_get_parameters+0x8a>
            ret = descriptor->parameters[i];
 8009bea:	7afb      	ldrb	r3, [r7, #11]
 8009bec:	687a      	ldr	r2, [r7, #4]
 8009bee:	3306      	adds	r3, #6
 8009bf0:	009b      	lsls	r3, r3, #2
 8009bf2:	4413      	add	r3, r2
 8009bf4:	f8d3 3003 	ldr.w	r3, [r3, #3]
 8009bf8:	60fb      	str	r3, [r7, #12]
        return 0;
    }

    const struct shared_app_parameters_s* ret = 0;

    for (uint8_t i=0; i<2; i++) {
 8009bfa:	7afb      	ldrb	r3, [r7, #11]
 8009bfc:	3301      	adds	r3, #1
 8009bfe:	72fb      	strb	r3, [r7, #11]
 8009c00:	7afb      	ldrb	r3, [r7, #11]
 8009c02:	2b01      	cmp	r3, #1
 8009c04:	d9c6      	bls.n	8009b94 <shared_get_parameters+0x24>
            (!ret || (int8_t)(descriptor->parameters[i]->param_idx-ret->param_idx) > 0)) {
            ret = descriptor->parameters[i];
        }
    }

    return ret;
 8009c06:	68fb      	ldr	r3, [r7, #12]
}
 8009c08:	4618      	mov	r0, r3
 8009c0a:	3710      	adds	r7, #16
 8009c0c:	46bd      	mov	sp, r7
 8009c0e:	bd80      	pop	{r7, pc}

08009c10 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8009c10:	b580      	push	{r7, lr}
 8009c12:	b086      	sub	sp, #24
 8009c14:	af00      	add	r7, sp, #0
 8009c16:	60f8      	str	r0, [r7, #12]
 8009c18:	60b9      	str	r1, [r7, #8]
 8009c1a:	4613      	mov	r3, r2
 8009c1c:	80fb      	strh	r3, [r7, #6]
  msg_t rdymsg;

  chSysLock();
 8009c1e:	f001 f819 	bl	800ac54 <chSysLock.lto_priv.220>
  rdymsg = chMBFetchS(mbp, msgp, timeout);
 8009c22:	88fb      	ldrh	r3, [r7, #6]
 8009c24:	68f8      	ldr	r0, [r7, #12]
 8009c26:	68b9      	ldr	r1, [r7, #8]
 8009c28:	461a      	mov	r2, r3
 8009c2a:	f000 f809 	bl	8009c40 <chMBFetchS>
 8009c2e:	6178      	str	r0, [r7, #20]
  chSysUnlock();
 8009c30:	f001 f818 	bl	800ac64 <chSysUnlock.lto_priv.215>

  return rdymsg;
 8009c34:	697b      	ldr	r3, [r7, #20]
}
 8009c36:	4618      	mov	r0, r3
 8009c38:	3718      	adds	r7, #24
 8009c3a:	46bd      	mov	sp, r7
 8009c3c:	bd80      	pop	{r7, pc}
 8009c3e:	bf00      	nop

08009c40 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8009c40:	b580      	push	{r7, lr}
 8009c42:	b086      	sub	sp, #24
 8009c44:	af00      	add	r7, sp, #0
 8009c46:	60f8      	str	r0, [r7, #12]
 8009c48:	60b9      	str	r1, [r7, #8]
 8009c4a:	4613      	mov	r3, r2
 8009c4c:	80fb      	strh	r3, [r7, #6]
  msg_t rdymsg;

  chDbgCheckClassS();
 8009c4e:	f001 f9c7 	bl	800afe0 <chDbgCheckClassS>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 8009c52:	68fb      	ldr	r3, [r7, #12]
 8009c54:	2b00      	cmp	r3, #0
 8009c56:	d002      	beq.n	8009c5e <chMBFetchS+0x1e>
 8009c58:	68bb      	ldr	r3, [r7, #8]
 8009c5a:	2b00      	cmp	r3, #0
 8009c5c:	d102      	bne.n	8009c64 <chMBFetchS+0x24>
 8009c5e:	4821      	ldr	r0, [pc, #132]	; (8009ce4 <chMBFetchS+0xa4>)
 8009c60:	f001 f8ce 	bl	800ae00 <chSysHalt>

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 8009c64:	68fb      	ldr	r3, [r7, #12]
 8009c66:	7d1b      	ldrb	r3, [r3, #20]
 8009c68:	2b00      	cmp	r3, #0
 8009c6a:	d002      	beq.n	8009c72 <chMBFetchS+0x32>
      return MSG_RESET;
 8009c6c:	f06f 0301 	mvn.w	r3, #1
 8009c70:	e033      	b.n	8009cda <chMBFetchS+0x9a>
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
 8009c72:	68f8      	ldr	r0, [r7, #12]
 8009c74:	f001 f82e 	bl	800acd4 <chMBGetUsedCountI.lto_priv.254>
 8009c78:	4603      	mov	r3, r0
 8009c7a:	2b00      	cmp	r3, #0
 8009c7c:	dd20      	ble.n	8009cc0 <chMBFetchS+0x80>
      *msgp = *mbp->rdptr++;
 8009c7e:	68fb      	ldr	r3, [r7, #12]
 8009c80:	68db      	ldr	r3, [r3, #12]
 8009c82:	1d19      	adds	r1, r3, #4
 8009c84:	68fa      	ldr	r2, [r7, #12]
 8009c86:	60d1      	str	r1, [r2, #12]
 8009c88:	681a      	ldr	r2, [r3, #0]
 8009c8a:	68bb      	ldr	r3, [r7, #8]
 8009c8c:	601a      	str	r2, [r3, #0]
      if (mbp->rdptr >= mbp->top) {
 8009c8e:	68fb      	ldr	r3, [r7, #12]
 8009c90:	68da      	ldr	r2, [r3, #12]
 8009c92:	68fb      	ldr	r3, [r7, #12]
 8009c94:	685b      	ldr	r3, [r3, #4]
 8009c96:	429a      	cmp	r2, r3
 8009c98:	d303      	bcc.n	8009ca2 <chMBFetchS+0x62>
        mbp->rdptr = mbp->buffer;
 8009c9a:	68fb      	ldr	r3, [r7, #12]
 8009c9c:	681a      	ldr	r2, [r3, #0]
 8009c9e:	68fb      	ldr	r3, [r7, #12]
 8009ca0:	60da      	str	r2, [r3, #12]
      }
      mbp->cnt--;
 8009ca2:	68fb      	ldr	r3, [r7, #12]
 8009ca4:	691b      	ldr	r3, [r3, #16]
 8009ca6:	1e5a      	subs	r2, r3, #1
 8009ca8:	68fb      	ldr	r3, [r7, #12]
 8009caa:	611a      	str	r2, [r3, #16]

      /* If there is a writer waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 8009cac:	68fb      	ldr	r3, [r7, #12]
 8009cae:	3318      	adds	r3, #24
 8009cb0:	4618      	mov	r0, r3
 8009cb2:	2100      	movs	r1, #0
 8009cb4:	f000 fcb6 	bl	800a624 <chThdDequeueNextI>
      chSchRescheduleS();
 8009cb8:	f001 fd82 	bl	800b7c0 <chSchRescheduleS>

      return MSG_OK;
 8009cbc:	2300      	movs	r3, #0
 8009cbe:	e00c      	b.n	8009cda <chMBFetchS+0x9a>
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 8009cc0:	68fb      	ldr	r3, [r7, #12]
 8009cc2:	f103 0220 	add.w	r2, r3, #32
 8009cc6:	88fb      	ldrh	r3, [r7, #6]
 8009cc8:	4610      	mov	r0, r2
 8009cca:	4619      	mov	r1, r3
 8009ccc:	f000 fc8c 	bl	800a5e8 <chThdEnqueueTimeoutS>
 8009cd0:	6178      	str	r0, [r7, #20]
  } while (rdymsg == MSG_OK);
 8009cd2:	697b      	ldr	r3, [r7, #20]
 8009cd4:	2b00      	cmp	r3, #0
 8009cd6:	d0c5      	beq.n	8009c64 <chMBFetchS+0x24>

  return rdymsg;
 8009cd8:	697b      	ldr	r3, [r7, #20]
}
 8009cda:	4618      	mov	r0, r3
 8009cdc:	3718      	adds	r7, #24
 8009cde:	46bd      	mov	sp, r7
 8009ce0:	bd80      	pop	{r7, pc}
 8009ce2:	bf00      	nop
 8009ce4:	0800ea14 	.word	0x0800ea14

08009ce8 <port_lock.lto_priv.236>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8009ce8:	b480      	push	{r7}
 8009cea:	b083      	sub	sp, #12
 8009cec:	af00      	add	r7, sp, #0
 8009cee:	2320      	movs	r3, #32
 8009cf0:	607b      	str	r3, [r7, #4]
 8009cf2:	687b      	ldr	r3, [r7, #4]
 8009cf4:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8009cf8:	370c      	adds	r7, #12
 8009cfa:	46bd      	mov	sp, r7
 8009cfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d00:	4770      	bx	lr
 8009d02:	bf00      	nop

08009d04 <port_unlock.lto_priv.231>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8009d04:	b480      	push	{r7}
 8009d06:	b083      	sub	sp, #12
 8009d08:	af00      	add	r7, sp, #0
 8009d0a:	2300      	movs	r3, #0
 8009d0c:	607b      	str	r3, [r7, #4]
 8009d0e:	687b      	ldr	r3, [r7, #4]
 8009d10:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8009d14:	370c      	adds	r7, #12
 8009d16:	46bd      	mov	sp, r7
 8009d18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d1c:	4770      	bx	lr
 8009d1e:	bf00      	nop

08009d20 <chSysLock.lto_priv.221>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8009d20:	b580      	push	{r7, lr}
 8009d22:	af00      	add	r7, sp, #0

  port_lock();
 8009d24:	f7ff ffe0 	bl	8009ce8 <port_lock.lto_priv.236>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8009d28:	f001 f8b8 	bl	800ae9c <_dbg_check_lock>
}
 8009d2c:	bd80      	pop	{r7, pc}
 8009d2e:	bf00      	nop

08009d30 <chSysUnlock.lto_priv.216>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8009d30:	b580      	push	{r7, lr}
 8009d32:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8009d34:	f001 f8c8 	bl	800aec8 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009d38:	4b09      	ldr	r3, [pc, #36]	; (8009d60 <chSysUnlock.lto_priv.216+0x30>)
 8009d3a:	681b      	ldr	r3, [r3, #0]
 8009d3c:	4a08      	ldr	r2, [pc, #32]	; (8009d60 <chSysUnlock.lto_priv.216+0x30>)
 8009d3e:	4293      	cmp	r3, r2
 8009d40:	d00a      	beq.n	8009d58 <chSysUnlock.lto_priv.216+0x28>
 8009d42:	4b07      	ldr	r3, [pc, #28]	; (8009d60 <chSysUnlock.lto_priv.216+0x30>)
 8009d44:	699b      	ldr	r3, [r3, #24]
 8009d46:	689a      	ldr	r2, [r3, #8]
 8009d48:	4b05      	ldr	r3, [pc, #20]	; (8009d60 <chSysUnlock.lto_priv.216+0x30>)
 8009d4a:	681b      	ldr	r3, [r3, #0]
 8009d4c:	689b      	ldr	r3, [r3, #8]
 8009d4e:	429a      	cmp	r2, r3
 8009d50:	d202      	bcs.n	8009d58 <chSysUnlock.lto_priv.216+0x28>
 8009d52:	4804      	ldr	r0, [pc, #16]	; (8009d64 <chSysUnlock.lto_priv.216+0x34>)
 8009d54:	f001 f854 	bl	800ae00 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8009d58:	f7ff ffd4 	bl	8009d04 <port_unlock.lto_priv.231>
}
 8009d5c:	bd80      	pop	{r7, pc}
 8009d5e:	bf00      	nop
 8009d60:	20001338 	.word	0x20001338
 8009d64:	0800ea40 	.word	0x0800ea40

08009d68 <_core_init>:
/**
 * @brief   Low level memory manager initialization.
 *
 * @notapi
 */
void _core_init(void) {
 8009d68:	b480      	push	{r7}
 8009d6a:	af00      	add	r7, sp, #0
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
 8009d6c:	4b04      	ldr	r3, [pc, #16]	; (8009d80 <_core_init+0x18>)
 8009d6e:	4a05      	ldr	r2, [pc, #20]	; (8009d84 <_core_init+0x1c>)
 8009d70:	601a      	str	r2, [r3, #0]
  ch_memcore.endmem  = __heap_end__;
 8009d72:	4b03      	ldr	r3, [pc, #12]	; (8009d80 <_core_init+0x18>)
 8009d74:	4a04      	ldr	r2, [pc, #16]	; (8009d88 <_core_init+0x20>)
 8009d76:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.nextmem = &static_heap[0];
  ch_memcore.endmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 8009d78:	46bd      	mov	sp, r7
 8009d7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d7e:	4770      	bx	lr
 8009d80:	200013a4 	.word	0x200013a4
 8009d84:	20001558 	.word	0x20001558
 8009d88:	20003f00 	.word	0x20003f00

08009d8c <chCoreAllocAlignedWithOffsetI>:
 *
 * @iclass
 */
void *chCoreAllocAlignedWithOffsetI(size_t size,
                                    unsigned align,
                                    size_t offset) {
 8009d8c:	b580      	push	{r7, lr}
 8009d8e:	b086      	sub	sp, #24
 8009d90:	af00      	add	r7, sp, #0
 8009d92:	60f8      	str	r0, [r7, #12]
 8009d94:	60b9      	str	r1, [r7, #8]
 8009d96:	607a      	str	r2, [r7, #4]
  uint8_t *p, *next;

  chDbgCheckClassI();
 8009d98:	f001 f910 	bl	800afbc <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8009d9c:	68bb      	ldr	r3, [r7, #8]
 8009d9e:	2b00      	cmp	r3, #0
 8009da0:	d005      	beq.n	8009dae <chCoreAllocAlignedWithOffsetI+0x22>
 8009da2:	68bb      	ldr	r3, [r7, #8]
 8009da4:	1e5a      	subs	r2, r3, #1
 8009da6:	68bb      	ldr	r3, [r7, #8]
 8009da8:	4013      	ands	r3, r2
 8009daa:	2b00      	cmp	r3, #0
 8009dac:	d002      	beq.n	8009db4 <chCoreAllocAlignedWithOffsetI+0x28>
 8009dae:	4817      	ldr	r0, [pc, #92]	; (8009e0c <chCoreAllocAlignedWithOffsetI+0x80>)
 8009db0:	f001 f826 	bl	800ae00 <chSysHalt>

  size = MEM_ALIGN_NEXT(size, align);
 8009db4:	68ba      	ldr	r2, [r7, #8]
 8009db6:	68fb      	ldr	r3, [r7, #12]
 8009db8:	4413      	add	r3, r2
 8009dba:	1e5a      	subs	r2, r3, #1
 8009dbc:	68bb      	ldr	r3, [r7, #8]
 8009dbe:	425b      	negs	r3, r3
 8009dc0:	4013      	ands	r3, r2
 8009dc2:	60fb      	str	r3, [r7, #12]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8009dc4:	4b12      	ldr	r3, [pc, #72]	; (8009e10 <chCoreAllocAlignedWithOffsetI+0x84>)
 8009dc6:	681a      	ldr	r2, [r3, #0]
 8009dc8:	687b      	ldr	r3, [r7, #4]
 8009dca:	4413      	add	r3, r2
 8009dcc:	461a      	mov	r2, r3
 8009dce:	68bb      	ldr	r3, [r7, #8]
 8009dd0:	4413      	add	r3, r2
 8009dd2:	1e5a      	subs	r2, r3, #1
 8009dd4:	68bb      	ldr	r3, [r7, #8]
 8009dd6:	425b      	negs	r3, r3
 8009dd8:	4013      	ands	r3, r2
 8009dda:	617b      	str	r3, [r7, #20]
  next = p + size;
 8009ddc:	697a      	ldr	r2, [r7, #20]
 8009dde:	68fb      	ldr	r3, [r7, #12]
 8009de0:	4413      	add	r3, r2
 8009de2:	613b      	str	r3, [r7, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8009de4:	4b0a      	ldr	r3, [pc, #40]	; (8009e10 <chCoreAllocAlignedWithOffsetI+0x84>)
 8009de6:	685a      	ldr	r2, [r3, #4]
 8009de8:	693b      	ldr	r3, [r7, #16]
 8009dea:	429a      	cmp	r2, r3
 8009dec:	d304      	bcc.n	8009df8 <chCoreAllocAlignedWithOffsetI+0x6c>
 8009dee:	4b08      	ldr	r3, [pc, #32]	; (8009e10 <chCoreAllocAlignedWithOffsetI+0x84>)
 8009df0:	681a      	ldr	r2, [r3, #0]
 8009df2:	693b      	ldr	r3, [r7, #16]
 8009df4:	429a      	cmp	r2, r3
 8009df6:	d901      	bls.n	8009dfc <chCoreAllocAlignedWithOffsetI+0x70>
//    CH_CFG_CORE_ALLOCATOR_FAILURE_HOOK();
    return NULL;
 8009df8:	2300      	movs	r3, #0
 8009dfa:	e003      	b.n	8009e04 <chCoreAllocAlignedWithOffsetI+0x78>
  }

  ch_memcore.nextmem = next;
 8009dfc:	4a04      	ldr	r2, [pc, #16]	; (8009e10 <chCoreAllocAlignedWithOffsetI+0x84>)
 8009dfe:	693b      	ldr	r3, [r7, #16]
 8009e00:	6013      	str	r3, [r2, #0]

  return p;
 8009e02:	697b      	ldr	r3, [r7, #20]
}
 8009e04:	4618      	mov	r0, r3
 8009e06:	3718      	adds	r7, #24
 8009e08:	46bd      	mov	sp, r7
 8009e0a:	bd80      	pop	{r7, pc}
 8009e0c:	0800ea20 	.word	0x0800ea20
 8009e10:	200013a4 	.word	0x200013a4

08009e14 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 8009e14:	b580      	push	{r7, lr}
 8009e16:	b086      	sub	sp, #24
 8009e18:	af00      	add	r7, sp, #0
 8009e1a:	60f8      	str	r0, [r7, #12]
 8009e1c:	60b9      	str	r1, [r7, #8]
 8009e1e:	607a      	str	r2, [r7, #4]
  void *p;

  chSysLock();
 8009e20:	f7ff ff7e 	bl	8009d20 <chSysLock.lto_priv.221>
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
 8009e24:	68f8      	ldr	r0, [r7, #12]
 8009e26:	68b9      	ldr	r1, [r7, #8]
 8009e28:	687a      	ldr	r2, [r7, #4]
 8009e2a:	f7ff ffaf 	bl	8009d8c <chCoreAllocAlignedWithOffsetI>
 8009e2e:	6178      	str	r0, [r7, #20]
  chSysUnlock();
 8009e30:	f7ff ff7e 	bl	8009d30 <chSysUnlock.lto_priv.216>

  return p;
 8009e34:	697b      	ldr	r3, [r7, #20]
}
 8009e36:	4618      	mov	r0, r3
 8009e38:	3718      	adds	r7, #24
 8009e3a:	46bd      	mov	sp, r7
 8009e3c:	bd80      	pop	{r7, pc}
 8009e3e:	bf00      	nop

08009e40 <chCoreGetStatusX>:
 *
 * @return              The size, in bytes, of the free core memory.
 *
 * @xclass
 */
size_t chCoreGetStatusX(void) {
 8009e40:	b480      	push	{r7}
 8009e42:	af00      	add	r7, sp, #0

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(ch_memcore.endmem - ch_memcore.nextmem);
 8009e44:	4b05      	ldr	r3, [pc, #20]	; (8009e5c <chCoreGetStatusX+0x1c>)
 8009e46:	685b      	ldr	r3, [r3, #4]
 8009e48:	461a      	mov	r2, r3
 8009e4a:	4b04      	ldr	r3, [pc, #16]	; (8009e5c <chCoreGetStatusX+0x1c>)
 8009e4c:	681b      	ldr	r3, [r3, #0]
 8009e4e:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 8009e50:	4618      	mov	r0, r3
 8009e52:	46bd      	mov	sp, r7
 8009e54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009e58:	4770      	bx	lr
 8009e5a:	bf00      	nop
 8009e5c:	200013a4 	.word	0x200013a4

08009e60 <port_lock.lto_priv.237>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8009e60:	b480      	push	{r7}
 8009e62:	b083      	sub	sp, #12
 8009e64:	af00      	add	r7, sp, #0
 8009e66:	2320      	movs	r3, #32
 8009e68:	607b      	str	r3, [r7, #4]
 8009e6a:	687b      	ldr	r3, [r7, #4]
 8009e6c:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8009e70:	370c      	adds	r7, #12
 8009e72:	46bd      	mov	sp, r7
 8009e74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009e78:	4770      	bx	lr
 8009e7a:	bf00      	nop

08009e7c <port_unlock.lto_priv.232>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8009e7c:	b480      	push	{r7}
 8009e7e:	b083      	sub	sp, #12
 8009e80:	af00      	add	r7, sp, #0
 8009e82:	2300      	movs	r3, #0
 8009e84:	607b      	str	r3, [r7, #4]
 8009e86:	687b      	ldr	r3, [r7, #4]
 8009e88:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8009e8c:	370c      	adds	r7, #12
 8009e8e:	46bd      	mov	sp, r7
 8009e90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009e94:	4770      	bx	lr
 8009e96:	bf00      	nop

08009e98 <chSysLock.lto_priv.222>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8009e98:	b580      	push	{r7, lr}
 8009e9a:	af00      	add	r7, sp, #0

  port_lock();
 8009e9c:	f7ff ffe0 	bl	8009e60 <port_lock.lto_priv.237>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8009ea0:	f000 fffc 	bl	800ae9c <_dbg_check_lock>
}
 8009ea4:	bd80      	pop	{r7, pc}
 8009ea6:	bf00      	nop

08009ea8 <chSysUnlock.lto_priv.217>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8009ea8:	b580      	push	{r7, lr}
 8009eaa:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8009eac:	f001 f80c 	bl	800aec8 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009eb0:	4b09      	ldr	r3, [pc, #36]	; (8009ed8 <chSysUnlock.lto_priv.217+0x30>)
 8009eb2:	681b      	ldr	r3, [r3, #0]
 8009eb4:	4a08      	ldr	r2, [pc, #32]	; (8009ed8 <chSysUnlock.lto_priv.217+0x30>)
 8009eb6:	4293      	cmp	r3, r2
 8009eb8:	d00a      	beq.n	8009ed0 <chSysUnlock.lto_priv.217+0x28>
 8009eba:	4b07      	ldr	r3, [pc, #28]	; (8009ed8 <chSysUnlock.lto_priv.217+0x30>)
 8009ebc:	699b      	ldr	r3, [r3, #24]
 8009ebe:	689a      	ldr	r2, [r3, #8]
 8009ec0:	4b05      	ldr	r3, [pc, #20]	; (8009ed8 <chSysUnlock.lto_priv.217+0x30>)
 8009ec2:	681b      	ldr	r3, [r3, #0]
 8009ec4:	689b      	ldr	r3, [r3, #8]
 8009ec6:	429a      	cmp	r2, r3
 8009ec8:	d202      	bcs.n	8009ed0 <chSysUnlock.lto_priv.217+0x28>
 8009eca:	4804      	ldr	r0, [pc, #16]	; (8009edc <chSysUnlock.lto_priv.217+0x34>)
 8009ecc:	f000 ff98 	bl	800ae00 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8009ed0:	f7ff ffd4 	bl	8009e7c <port_unlock.lto_priv.232>
}
 8009ed4:	bd80      	pop	{r7, pc}
 8009ed6:	bf00      	nop
 8009ed8:	20001338 	.word	0x20001338
 8009edc:	0800ea80 	.word	0x0800ea80

08009ee0 <chPoolAdd>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be added
 *
 * @api
 */
static inline void chPoolAdd(memory_pool_t *mp, void *objp) {
 8009ee0:	b580      	push	{r7, lr}
 8009ee2:	b082      	sub	sp, #8
 8009ee4:	af00      	add	r7, sp, #0
 8009ee6:	6078      	str	r0, [r7, #4]
 8009ee8:	6039      	str	r1, [r7, #0]

  chPoolFree(mp, objp);
 8009eea:	6878      	ldr	r0, [r7, #4]
 8009eec:	6839      	ldr	r1, [r7, #0]
 8009eee:	f000 f8a1 	bl	800a034 <chPoolFree>
}
 8009ef2:	3708      	adds	r7, #8
 8009ef4:	46bd      	mov	sp, r7
 8009ef6:	bd80      	pop	{r7, pc}

08009ef8 <chPoolObjectInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {
 8009ef8:	b580      	push	{r7, lr}
 8009efa:	b084      	sub	sp, #16
 8009efc:	af00      	add	r7, sp, #0
 8009efe:	60f8      	str	r0, [r7, #12]
 8009f00:	60b9      	str	r1, [r7, #8]
 8009f02:	607a      	str	r2, [r7, #4]

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));
 8009f04:	68fb      	ldr	r3, [r7, #12]
 8009f06:	2b00      	cmp	r3, #0
 8009f08:	d002      	beq.n	8009f10 <chPoolObjectInit+0x18>
 8009f0a:	68bb      	ldr	r3, [r7, #8]
 8009f0c:	2b03      	cmp	r3, #3
 8009f0e:	d802      	bhi.n	8009f16 <chPoolObjectInit+0x1e>
 8009f10:	4807      	ldr	r0, [pc, #28]	; (8009f30 <chPoolObjectInit+0x38>)
 8009f12:	f000 ff75 	bl	800ae00 <chSysHalt>

  mp->next = NULL;
 8009f16:	68fb      	ldr	r3, [r7, #12]
 8009f18:	2200      	movs	r2, #0
 8009f1a:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 8009f1c:	68fb      	ldr	r3, [r7, #12]
 8009f1e:	68ba      	ldr	r2, [r7, #8]
 8009f20:	605a      	str	r2, [r3, #4]
  mp->provider = provider;
 8009f22:	68fb      	ldr	r3, [r7, #12]
 8009f24:	687a      	ldr	r2, [r7, #4]
 8009f26:	609a      	str	r2, [r3, #8]
}
 8009f28:	3710      	adds	r7, #16
 8009f2a:	46bd      	mov	sp, r7
 8009f2c:	bd80      	pop	{r7, pc}
 8009f2e:	bf00      	nop
 8009f30:	0800ea4c 	.word	0x0800ea4c

08009f34 <chPoolLoadArray>:
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
 8009f34:	b580      	push	{r7, lr}
 8009f36:	b084      	sub	sp, #16
 8009f38:	af00      	add	r7, sp, #0
 8009f3a:	60f8      	str	r0, [r7, #12]
 8009f3c:	60b9      	str	r1, [r7, #8]
 8009f3e:	607a      	str	r2, [r7, #4]

  chDbgCheck((mp != NULL) && (n != 0U));
 8009f40:	68fb      	ldr	r3, [r7, #12]
 8009f42:	2b00      	cmp	r3, #0
 8009f44:	d002      	beq.n	8009f4c <chPoolLoadArray+0x18>
 8009f46:	687b      	ldr	r3, [r7, #4]
 8009f48:	2b00      	cmp	r3, #0
 8009f4a:	d10f      	bne.n	8009f6c <chPoolLoadArray+0x38>
 8009f4c:	480a      	ldr	r0, [pc, #40]	; (8009f78 <chPoolLoadArray+0x44>)
 8009f4e:	f000 ff57 	bl	800ae00 <chSysHalt>
 8009f52:	e00b      	b.n	8009f6c <chPoolLoadArray+0x38>

  while (n != 0U) {
    chPoolAdd(mp, p);
 8009f54:	68f8      	ldr	r0, [r7, #12]
 8009f56:	68b9      	ldr	r1, [r7, #8]
 8009f58:	f7ff ffc2 	bl	8009ee0 <chPoolAdd>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
 8009f5c:	68fb      	ldr	r3, [r7, #12]
 8009f5e:	685b      	ldr	r3, [r3, #4]
 8009f60:	68ba      	ldr	r2, [r7, #8]
 8009f62:	4413      	add	r3, r2
 8009f64:	60bb      	str	r3, [r7, #8]
    /*lint -restore*/
    n--;
 8009f66:	687b      	ldr	r3, [r7, #4]
 8009f68:	3b01      	subs	r3, #1
 8009f6a:	607b      	str	r3, [r7, #4]
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8009f6c:	687b      	ldr	r3, [r7, #4]
 8009f6e:	2b00      	cmp	r3, #0
 8009f70:	d1f0      	bne.n	8009f54 <chPoolLoadArray+0x20>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
    /*lint -restore*/
    n--;
  }
}
 8009f72:	3710      	adds	r7, #16
 8009f74:	46bd      	mov	sp, r7
 8009f76:	bd80      	pop	{r7, pc}
 8009f78:	0800ea60 	.word	0x0800ea60

08009f7c <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
 8009f7c:	b580      	push	{r7, lr}
 8009f7e:	b084      	sub	sp, #16
 8009f80:	af00      	add	r7, sp, #0
 8009f82:	6078      	str	r0, [r7, #4]
  void *objp;

  chDbgCheckClassI();
 8009f84:	f001 f81a 	bl	800afbc <chDbgCheckClassI>
  chDbgCheck(mp != NULL);
 8009f88:	687b      	ldr	r3, [r7, #4]
 8009f8a:	2b00      	cmp	r3, #0
 8009f8c:	d102      	bne.n	8009f94 <chPoolAllocI+0x18>
 8009f8e:	4810      	ldr	r0, [pc, #64]	; (8009fd0 <chPoolAllocI+0x54>)
 8009f90:	f000 ff36 	bl	800ae00 <chSysHalt>

  objp = mp->next;
 8009f94:	687b      	ldr	r3, [r7, #4]
 8009f96:	681b      	ldr	r3, [r3, #0]
 8009f98:	60fb      	str	r3, [r7, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 8009f9a:	68fb      	ldr	r3, [r7, #12]
 8009f9c:	2b00      	cmp	r3, #0
 8009f9e:	d005      	beq.n	8009fac <chPoolAllocI+0x30>
    mp->next = mp->next->next;
 8009fa0:	687b      	ldr	r3, [r7, #4]
 8009fa2:	681b      	ldr	r3, [r3, #0]
 8009fa4:	681a      	ldr	r2, [r3, #0]
 8009fa6:	687b      	ldr	r3, [r7, #4]
 8009fa8:	601a      	str	r2, [r3, #0]
 8009faa:	e00b      	b.n	8009fc4 <chPoolAllocI+0x48>
  }
  else if (mp->provider != NULL) {
 8009fac:	687b      	ldr	r3, [r7, #4]
 8009fae:	689b      	ldr	r3, [r3, #8]
 8009fb0:	2b00      	cmp	r3, #0
 8009fb2:	d007      	beq.n	8009fc4 <chPoolAllocI+0x48>
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
 8009fb4:	687b      	ldr	r3, [r7, #4]
 8009fb6:	689b      	ldr	r3, [r3, #8]
 8009fb8:	687a      	ldr	r2, [r7, #4]
 8009fba:	6852      	ldr	r2, [r2, #4]
 8009fbc:	4610      	mov	r0, r2
 8009fbe:	2104      	movs	r1, #4
 8009fc0:	4798      	blx	r3
 8009fc2:	60f8      	str	r0, [r7, #12]
  }
  /*lint -restore*/

  return objp;
 8009fc4:	68fb      	ldr	r3, [r7, #12]
}
 8009fc6:	4618      	mov	r0, r3
 8009fc8:	3710      	adds	r7, #16
 8009fca:	46bd      	mov	sp, r7
 8009fcc:	bd80      	pop	{r7, pc}
 8009fce:	bf00      	nop
 8009fd0:	0800ea70 	.word	0x0800ea70

08009fd4 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 8009fd4:	b580      	push	{r7, lr}
 8009fd6:	b084      	sub	sp, #16
 8009fd8:	af00      	add	r7, sp, #0
 8009fda:	6078      	str	r0, [r7, #4]
  void *objp;

  chSysLock();
 8009fdc:	f7ff ff5c 	bl	8009e98 <chSysLock.lto_priv.222>
  objp = chPoolAllocI(mp);
 8009fe0:	6878      	ldr	r0, [r7, #4]
 8009fe2:	f7ff ffcb 	bl	8009f7c <chPoolAllocI>
 8009fe6:	60f8      	str	r0, [r7, #12]
  chSysUnlock();
 8009fe8:	f7ff ff5e 	bl	8009ea8 <chSysUnlock.lto_priv.217>

  return objp;
 8009fec:	68fb      	ldr	r3, [r7, #12]
}
 8009fee:	4618      	mov	r0, r3
 8009ff0:	3710      	adds	r7, #16
 8009ff2:	46bd      	mov	sp, r7
 8009ff4:	bd80      	pop	{r7, pc}
 8009ff6:	bf00      	nop

08009ff8 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8009ff8:	b580      	push	{r7, lr}
 8009ffa:	b084      	sub	sp, #16
 8009ffc:	af00      	add	r7, sp, #0
 8009ffe:	6078      	str	r0, [r7, #4]
 800a000:	6039      	str	r1, [r7, #0]
  struct pool_header *php = objp;
 800a002:	683b      	ldr	r3, [r7, #0]
 800a004:	60fb      	str	r3, [r7, #12]

  chDbgCheckClassI();
 800a006:	f000 ffd9 	bl	800afbc <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 800a00a:	687b      	ldr	r3, [r7, #4]
 800a00c:	2b00      	cmp	r3, #0
 800a00e:	d002      	beq.n	800a016 <chPoolFreeI+0x1e>
 800a010:	683b      	ldr	r3, [r7, #0]
 800a012:	2b00      	cmp	r3, #0
 800a014:	d102      	bne.n	800a01c <chPoolFreeI+0x24>
 800a016:	4806      	ldr	r0, [pc, #24]	; (800a030 <chPoolFreeI+0x38>)
 800a018:	f000 fef2 	bl	800ae00 <chSysHalt>

  php->next = mp->next;
 800a01c:	687b      	ldr	r3, [r7, #4]
 800a01e:	681a      	ldr	r2, [r3, #0]
 800a020:	68fb      	ldr	r3, [r7, #12]
 800a022:	601a      	str	r2, [r3, #0]
  mp->next = php;
 800a024:	687b      	ldr	r3, [r7, #4]
 800a026:	68fa      	ldr	r2, [r7, #12]
 800a028:	601a      	str	r2, [r3, #0]
}
 800a02a:	3710      	adds	r7, #16
 800a02c:	46bd      	mov	sp, r7
 800a02e:	bd80      	pop	{r7, pc}
 800a030:	0800ea8c 	.word	0x0800ea8c

0800a034 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 800a034:	b580      	push	{r7, lr}
 800a036:	b082      	sub	sp, #8
 800a038:	af00      	add	r7, sp, #0
 800a03a:	6078      	str	r0, [r7, #4]
 800a03c:	6039      	str	r1, [r7, #0]

  chSysLock();
 800a03e:	f7ff ff2b 	bl	8009e98 <chSysLock.lto_priv.222>
  chPoolFreeI(mp, objp);
 800a042:	6878      	ldr	r0, [r7, #4]
 800a044:	6839      	ldr	r1, [r7, #0]
 800a046:	f7ff ffd7 	bl	8009ff8 <chPoolFreeI>
  chSysUnlock();
 800a04a:	f7ff ff2d 	bl	8009ea8 <chSysUnlock.lto_priv.217>
}
 800a04e:	3708      	adds	r7, #8
 800a050:	46bd      	mov	sp, r7
 800a052:	bd80      	pop	{r7, pc}

0800a054 <port_lock.lto_priv.238>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800a054:	b480      	push	{r7}
 800a056:	b083      	sub	sp, #12
 800a058:	af00      	add	r7, sp, #0
 800a05a:	2320      	movs	r3, #32
 800a05c:	607b      	str	r3, [r7, #4]
 800a05e:	687b      	ldr	r3, [r7, #4]
 800a060:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a064:	370c      	adds	r7, #12
 800a066:	46bd      	mov	sp, r7
 800a068:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a06c:	4770      	bx	lr
 800a06e:	bf00      	nop

0800a070 <port_unlock.lto_priv.233>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800a070:	b480      	push	{r7}
 800a072:	b083      	sub	sp, #12
 800a074:	af00      	add	r7, sp, #0
 800a076:	2300      	movs	r3, #0
 800a078:	607b      	str	r3, [r7, #4]
 800a07a:	687b      	ldr	r3, [r7, #4]
 800a07c:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a080:	370c      	adds	r7, #12
 800a082:	46bd      	mov	sp, r7
 800a084:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a088:	4770      	bx	lr
 800a08a:	bf00      	nop

0800a08c <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800a08c:	b580      	push	{r7, lr}
 800a08e:	af00      	add	r7, sp, #0

  port_lock();
 800a090:	f7ff ffe0 	bl	800a054 <port_lock.lto_priv.238>
}
 800a094:	bd80      	pop	{r7, pc}
 800a096:	bf00      	nop

0800a098 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800a098:	b580      	push	{r7, lr}
 800a09a:	af00      	add	r7, sp, #0

  port_unlock();
 800a09c:	f7ff ffe8 	bl	800a070 <port_unlock.lto_priv.233>
}
 800a0a0:	bd80      	pop	{r7, pc}
 800a0a2:	bf00      	nop

0800a0a4 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 800a0a4:	b590      	push	{r4, r7, lr}
 800a0a6:	b083      	sub	sp, #12
 800a0a8:	af00      	add	r7, sp, #0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800a0aa:	f3ef 8309 	mrs	r3, PSP
 800a0ae:	461c      	mov	r4, r3
  return(result);
 800a0b0:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 800a0b2:	607b      	str	r3, [r7, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 800a0b4:	687b      	ldr	r3, [r7, #4]
 800a0b6:	3320      	adds	r3, #32
 800a0b8:	607b      	str	r3, [r7, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 800a0ba:	687b      	ldr	r3, [r7, #4]
 800a0bc:	603b      	str	r3, [r7, #0]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800a0be:	683b      	ldr	r3, [r7, #0]
 800a0c0:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 800a0c4:	f7ff ffe8 	bl	800a098 <port_unlock_from_isr>
}
 800a0c8:	370c      	adds	r7, #12
 800a0ca:	46bd      	mov	sp, r7
 800a0cc:	bd90      	pop	{r4, r7, pc}
 800a0ce:	bf00      	nop

0800a0d0 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 800a0d0:	b590      	push	{r4, r7, lr}
 800a0d2:	b083      	sub	sp, #12
 800a0d4:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 800a0d6:	f7ff ffd9 	bl	800a08c <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 800a0da:	4b14      	ldr	r3, [pc, #80]	; (800a12c <_port_irq_epilogue+0x5c>)
 800a0dc:	685b      	ldr	r3, [r3, #4]
 800a0de:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800a0e2:	2b00      	cmp	r3, #0
 800a0e4:	d01d      	beq.n	800a122 <_port_irq_epilogue+0x52>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800a0e6:	f3ef 8309 	mrs	r3, PSP
 800a0ea:	461c      	mov	r4, r3
  return(result);
 800a0ec:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 800a0ee:	607b      	str	r3, [r7, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 800a0f0:	687b      	ldr	r3, [r7, #4]
 800a0f2:	3b20      	subs	r3, #32
 800a0f4:	607b      	str	r3, [r7, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800a0f6:	687b      	ldr	r3, [r7, #4]
 800a0f8:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800a0fc:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 800a0fe:	687b      	ldr	r3, [r7, #4]
 800a100:	603b      	str	r3, [r7, #0]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800a102:	683b      	ldr	r3, [r7, #0]
 800a104:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800a108:	f001 fb66 	bl	800b7d8 <chSchIsPreemptionRequired>
 800a10c:	4603      	mov	r3, r0
 800a10e:	2b00      	cmp	r3, #0
 800a110:	d003      	beq.n	800a11a <_port_irq_epilogue+0x4a>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800a112:	687b      	ldr	r3, [r7, #4]
 800a114:	4a06      	ldr	r2, [pc, #24]	; (800a130 <_port_irq_epilogue+0x60>)
 800a116:	619a      	str	r2, [r3, #24]
 800a118:	e005      	b.n	800a126 <_port_irq_epilogue+0x56>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 800a11a:	687b      	ldr	r3, [r7, #4]
 800a11c:	4a05      	ldr	r2, [pc, #20]	; (800a134 <_port_irq_epilogue+0x64>)
 800a11e:	619a      	str	r2, [r3, #24]
 800a120:	e001      	b.n	800a126 <_port_irq_epilogue+0x56>

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
 800a122:	f7ff ffb9 	bl	800a098 <port_unlock_from_isr>
}
 800a126:	370c      	adds	r7, #12
 800a128:	46bd      	mov	sp, r7
 800a12a:	bd90      	pop	{r4, r7, pc}
 800a12c:	e000ed00 	.word	0xe000ed00
 800a130:	080032c9 	.word	0x080032c9
 800a134:	080032d4 	.word	0x080032d4

0800a138 <osalInit>:
/**
 * @brief   OSAL module initialization.
 *
 * @api
 */
static inline void osalInit(void) {
 800a138:	b480      	push	{r7}
 800a13a:	af00      	add	r7, sp, #0

}
 800a13c:	46bd      	mov	sp, r7
 800a13e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a142:	4770      	bx	lr

0800a144 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 800a144:	b580      	push	{r7, lr}
 800a146:	af00      	add	r7, sp, #0

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 800a148:	f7ff fff6 	bl	800a138 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 800a14c:	f7ff f996 	bl	800947c <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit();
 800a150:	f7ff fa12 	bl	8009578 <_pal_lld_init>
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 800a154:	f7ff f82e 	bl	80091b4 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 800a158:	f7ff fcd4 	bl	8009b04 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 800a15c:	f7ff f8f8 	bl	8009350 <stInit>
#endif
}
 800a160:	bd80      	pop	{r7, pc}
 800a162:	bf00      	nop

0800a164 <port_lock.lto_priv.240>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800a164:	b480      	push	{r7}
 800a166:	b083      	sub	sp, #12
 800a168:	af00      	add	r7, sp, #0
 800a16a:	2320      	movs	r3, #32
 800a16c:	607b      	str	r3, [r7, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800a16e:	687b      	ldr	r3, [r7, #4]
 800a170:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a174:	370c      	adds	r7, #12
 800a176:	46bd      	mov	sp, r7
 800a178:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a17c:	4770      	bx	lr
 800a17e:	bf00      	nop

0800a180 <port_unlock.lto_priv.235>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800a180:	b480      	push	{r7}
 800a182:	b083      	sub	sp, #12
 800a184:	af00      	add	r7, sp, #0
 800a186:	2300      	movs	r3, #0
 800a188:	607b      	str	r3, [r7, #4]
 800a18a:	687b      	ldr	r3, [r7, #4]
 800a18c:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a190:	370c      	adds	r7, #12
 800a192:	46bd      	mov	sp, r7
 800a194:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a198:	4770      	bx	lr
 800a19a:	bf00      	nop

0800a19c <st_lld_get_counter.lto_priv.230>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 800a19c:	b480      	push	{r7}
 800a19e:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 800a1a0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800a1a4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a1a6:	b29b      	uxth	r3, r3
}
 800a1a8:	4618      	mov	r0, r3
 800a1aa:	46bd      	mov	sp, r7
 800a1ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a1b0:	4770      	bx	lr
 800a1b2:	bf00      	nop

0800a1b4 <port_timer_get_time.lto_priv.228>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 800a1b4:	b580      	push	{r7, lr}
 800a1b6:	af00      	add	r7, sp, #0

  return stGetCounter();
 800a1b8:	f7ff fff0 	bl	800a19c <st_lld_get_counter.lto_priv.230>
 800a1bc:	4603      	mov	r3, r0
}
 800a1be:	4618      	mov	r0, r3
 800a1c0:	bd80      	pop	{r7, pc}
 800a1c2:	bf00      	nop

0800a1c4 <queue_init.lto_priv.226>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 800a1c4:	b480      	push	{r7}
 800a1c6:	b083      	sub	sp, #12
 800a1c8:	af00      	add	r7, sp, #0
 800a1ca:	6078      	str	r0, [r7, #4]

  tqp->next = (thread_t *)tqp;
 800a1cc:	687b      	ldr	r3, [r7, #4]
 800a1ce:	687a      	ldr	r2, [r7, #4]
 800a1d0:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800a1d2:	687b      	ldr	r3, [r7, #4]
 800a1d4:	687a      	ldr	r2, [r7, #4]
 800a1d6:	605a      	str	r2, [r3, #4]
}
 800a1d8:	370c      	adds	r7, #12
 800a1da:	46bd      	mov	sp, r7
 800a1dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a1e0:	4770      	bx	lr
 800a1e2:	bf00      	nop

0800a1e4 <chSysLock.lto_priv.224>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800a1e4:	b580      	push	{r7, lr}
 800a1e6:	af00      	add	r7, sp, #0

  port_lock();
 800a1e8:	f7ff ffbc 	bl	800a164 <port_lock.lto_priv.240>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800a1ec:	f000 fe56 	bl	800ae9c <_dbg_check_lock>
}
 800a1f0:	bd80      	pop	{r7, pc}
 800a1f2:	bf00      	nop

0800a1f4 <chSysUnlock.lto_priv.219>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800a1f4:	b580      	push	{r7, lr}
 800a1f6:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 800a1f8:	f000 fe66 	bl	800aec8 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a1fc:	4b09      	ldr	r3, [pc, #36]	; (800a224 <chSysUnlock.lto_priv.219+0x30>)
 800a1fe:	681b      	ldr	r3, [r3, #0]
 800a200:	4a08      	ldr	r2, [pc, #32]	; (800a224 <chSysUnlock.lto_priv.219+0x30>)
 800a202:	4293      	cmp	r3, r2
 800a204:	d00a      	beq.n	800a21c <chSysUnlock.lto_priv.219+0x28>
 800a206:	4b07      	ldr	r3, [pc, #28]	; (800a224 <chSysUnlock.lto_priv.219+0x30>)
 800a208:	699b      	ldr	r3, [r3, #24]
 800a20a:	689a      	ldr	r2, [r3, #8]
 800a20c:	4b05      	ldr	r3, [pc, #20]	; (800a224 <chSysUnlock.lto_priv.219+0x30>)
 800a20e:	681b      	ldr	r3, [r3, #0]
 800a210:	689b      	ldr	r3, [r3, #8]
 800a212:	429a      	cmp	r2, r3
 800a214:	d202      	bcs.n	800a21c <chSysUnlock.lto_priv.219+0x28>
 800a216:	4804      	ldr	r0, [pc, #16]	; (800a228 <chSysUnlock.lto_priv.219+0x34>)
 800a218:	f000 fdf2 	bl	800ae00 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 800a21c:	f7ff ffb0 	bl	800a180 <port_unlock.lto_priv.235>
}
 800a220:	bd80      	pop	{r7, pc}
 800a222:	bf00      	nop
 800a224:	20001338 	.word	0x20001338
 800a228:	0800ea98 	.word	0x0800ea98

0800a22c <chVTGetSystemTimeX.lto_priv.214>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 800a22c:	b580      	push	{r7, lr}
 800a22e:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 800a230:	f7ff ffc0 	bl	800a1b4 <port_timer_get_time.lto_priv.228>
 800a234:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800a236:	4618      	mov	r0, r3
 800a238:	bd80      	pop	{r7, pc}
 800a23a:	bf00      	nop

0800a23c <chThdQueueObjectInit.lto_priv.212>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 800a23c:	b580      	push	{r7, lr}
 800a23e:	b082      	sub	sp, #8
 800a240:	af00      	add	r7, sp, #0
 800a242:	6078      	str	r0, [r7, #4]

  queue_init(tqp);
 800a244:	6878      	ldr	r0, [r7, #4]
 800a246:	f7ff ffbd 	bl	800a1c4 <queue_init.lto_priv.226>
}
 800a24a:	3708      	adds	r7, #8
 800a24c:	46bd      	mov	sp, r7
 800a24e:	bd80      	pop	{r7, pc}

0800a250 <osalSysLock.lto_priv.200>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 800a250:	b580      	push	{r7, lr}
 800a252:	af00      	add	r7, sp, #0

  chSysLock();
 800a254:	f7ff ffc6 	bl	800a1e4 <chSysLock.lto_priv.224>
}
 800a258:	bd80      	pop	{r7, pc}
 800a25a:	bf00      	nop

0800a25c <osalSysUnlock.lto_priv.198>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 800a25c:	b580      	push	{r7, lr}
 800a25e:	af00      	add	r7, sp, #0

  chSysUnlock();
 800a260:	f7ff ffc8 	bl	800a1f4 <chSysUnlock.lto_priv.219>
}
 800a264:	bd80      	pop	{r7, pc}
 800a266:	bf00      	nop

0800a268 <osalOsGetSystemTimeX.lto_priv.207>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {
 800a268:	b580      	push	{r7, lr}
 800a26a:	af00      	add	r7, sp, #0

  return chVTGetSystemTimeX();
 800a26c:	f7ff ffde 	bl	800a22c <chVTGetSystemTimeX.lto_priv.214>
 800a270:	4603      	mov	r3, r0
}
 800a272:	4618      	mov	r0, r3
 800a274:	bd80      	pop	{r7, pc}
 800a276:	bf00      	nop

0800a278 <osalThreadQueueObjectInit.lto_priv.210>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 800a278:	b580      	push	{r7, lr}
 800a27a:	b082      	sub	sp, #8
 800a27c:	af00      	add	r7, sp, #0
 800a27e:	6078      	str	r0, [r7, #4]

  chThdQueueObjectInit(tqp);
 800a280:	6878      	ldr	r0, [r7, #4]
 800a282:	f7ff ffdb 	bl	800a23c <chThdQueueObjectInit.lto_priv.212>
}
 800a286:	3708      	adds	r7, #8
 800a288:	46bd      	mov	sp, r7
 800a28a:	bd80      	pop	{r7, pc}

0800a28c <osalThreadEnqueueTimeoutS.lto_priv.206>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
 800a28c:	b580      	push	{r7, lr}
 800a28e:	b082      	sub	sp, #8
 800a290:	af00      	add	r7, sp, #0
 800a292:	6078      	str	r0, [r7, #4]
 800a294:	460b      	mov	r3, r1
 800a296:	807b      	strh	r3, [r7, #2]

  return chThdEnqueueTimeoutS(tqp, time);
 800a298:	887b      	ldrh	r3, [r7, #2]
 800a29a:	6878      	ldr	r0, [r7, #4]
 800a29c:	4619      	mov	r1, r3
 800a29e:	f000 f9a3 	bl	800a5e8 <chThdEnqueueTimeoutS>
 800a2a2:	4603      	mov	r3, r0
}
 800a2a4:	4618      	mov	r0, r3
 800a2a6:	3708      	adds	r7, #8
 800a2a8:	46bd      	mov	sp, r7
 800a2aa:	bd80      	pop	{r7, pc}

0800a2ac <osalThreadDequeueNextI.lto_priv.208>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 800a2ac:	b580      	push	{r7, lr}
 800a2ae:	b082      	sub	sp, #8
 800a2b0:	af00      	add	r7, sp, #0
 800a2b2:	6078      	str	r0, [r7, #4]
 800a2b4:	6039      	str	r1, [r7, #0]

  chThdDequeueNextI(tqp, msg);
 800a2b6:	6878      	ldr	r0, [r7, #4]
 800a2b8:	6839      	ldr	r1, [r7, #0]
 800a2ba:	f000 f9b3 	bl	800a624 <chThdDequeueNextI>
}
 800a2be:	3708      	adds	r7, #8
 800a2c0:	46bd      	mov	sp, r7
 800a2c2:	bd80      	pop	{r7, pc}

0800a2c4 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
 800a2c4:	b580      	push	{r7, lr}
 800a2c6:	b084      	sub	sp, #16
 800a2c8:	af00      	add	r7, sp, #0
 800a2ca:	60f8      	str	r0, [r7, #12]
 800a2cc:	60b9      	str	r1, [r7, #8]
 800a2ce:	607a      	str	r2, [r7, #4]
 800a2d0:	603b      	str	r3, [r7, #0]

  osalThreadQueueObjectInit(&iqp->q_waiting);
 800a2d2:	68fb      	ldr	r3, [r7, #12]
 800a2d4:	4618      	mov	r0, r3
 800a2d6:	f7ff ffcf 	bl	800a278 <osalThreadQueueObjectInit.lto_priv.210>
  iqp->q_counter = 0;
 800a2da:	68fb      	ldr	r3, [r7, #12]
 800a2dc:	2200      	movs	r2, #0
 800a2de:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 800a2e0:	68fb      	ldr	r3, [r7, #12]
 800a2e2:	68ba      	ldr	r2, [r7, #8]
 800a2e4:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 800a2e6:	68fb      	ldr	r3, [r7, #12]
 800a2e8:	68ba      	ldr	r2, [r7, #8]
 800a2ea:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 800a2ec:	68fb      	ldr	r3, [r7, #12]
 800a2ee:	68ba      	ldr	r2, [r7, #8]
 800a2f0:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 800a2f2:	68ba      	ldr	r2, [r7, #8]
 800a2f4:	687b      	ldr	r3, [r7, #4]
 800a2f6:	441a      	add	r2, r3
 800a2f8:	68fb      	ldr	r3, [r7, #12]
 800a2fa:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 800a2fc:	68fb      	ldr	r3, [r7, #12]
 800a2fe:	683a      	ldr	r2, [r7, #0]
 800a300:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 800a302:	68fb      	ldr	r3, [r7, #12]
 800a304:	69ba      	ldr	r2, [r7, #24]
 800a306:	621a      	str	r2, [r3, #32]
}
 800a308:	3710      	adds	r7, #16
 800a30a:	46bd      	mov	sp, r7
 800a30c:	bd80      	pop	{r7, pc}
 800a30e:	bf00      	nop

0800a310 <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 800a310:	b580      	push	{r7, lr}
 800a312:	b084      	sub	sp, #16
 800a314:	af00      	add	r7, sp, #0
 800a316:	6078      	str	r0, [r7, #4]
  thread_t *tp;

#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 800a318:	687b      	ldr	r3, [r7, #4]
 800a31a:	685b      	ldr	r3, [r3, #4]
 800a31c:	4618      	mov	r0, r3
 800a31e:	f000 fa27 	bl	800a770 <chRegFindThreadByWorkingArea>
 800a322:	4603      	mov	r3, r0
 800a324:	2b00      	cmp	r3, #0
 800a326:	d002      	beq.n	800a32e <chThdCreate+0x1e>
 800a328:	480e      	ldr	r0, [pc, #56]	; (800a364 <chThdCreate+0x54>)
 800a32a:	f000 fd69 	bl	800ae00 <chSysHalt>
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)tdp->wbase,
 800a32e:	687b      	ldr	r3, [r7, #4]
 800a330:	685a      	ldr	r2, [r3, #4]
                  (uint8_t *)tdp->wend,
 800a332:	687b      	ldr	r3, [r7, #4]
 800a334:	689b      	ldr	r3, [r3, #8]
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)tdp->wbase,
 800a336:	4610      	mov	r0, r2
 800a338:	4619      	mov	r1, r3
 800a33a:	2255      	movs	r2, #85	; 0x55
 800a33c:	f001 fbb2 	bl	800baa4 <_thread_memfill>
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 800a340:	f001 fb14 	bl	800b96c <chSysLock.lto_priv.274>
  tp = chThdCreateSuspendedI(tdp);
 800a344:	6878      	ldr	r0, [r7, #4]
 800a346:	f001 fbc3 	bl	800bad0 <chThdCreateSuspendedI>
 800a34a:	60f8      	str	r0, [r7, #12]
  chSchWakeupS(tp, MSG_OK);
 800a34c:	68f8      	ldr	r0, [r7, #12]
 800a34e:	2100      	movs	r1, #0
 800a350:	f001 f9e8 	bl	800b724 <chSchWakeupS>
  chSysUnlock();
 800a354:	f001 fb12 	bl	800b97c <chSysUnlock.lto_priv.270>

  return tp;
 800a358:	68fb      	ldr	r3, [r7, #12]
}
 800a35a:	4618      	mov	r0, r3
 800a35c:	3710      	adds	r7, #16
 800a35e:	46bd      	mov	sp, r7
 800a360:	bd80      	pop	{r7, pc}
 800a362:	bf00      	nop
 800a364:	0800e8ec 	.word	0x0800e8ec

0800a368 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 800a368:	b590      	push	{r4, r7, lr}
 800a36a:	b083      	sub	sp, #12
 800a36c:	af00      	add	r7, sp, #0
 800a36e:	6078      	str	r0, [r7, #4]

  chSysLock();
 800a370:	f001 fafc 	bl	800b96c <chSysLock.lto_priv.274>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 800a374:	687b      	ldr	r3, [r7, #4]
 800a376:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a37a:	2b00      	cmp	r3, #0
 800a37c:	d102      	bne.n	800a384 <chThdRelease+0x1c>
 800a37e:	481c      	ldr	r0, [pc, #112]	; (800a3f0 <chThdRelease+0x88>)
 800a380:	f000 fd3e 	bl	800ae00 <chSysHalt>
  tp->refs--;
 800a384:	687b      	ldr	r3, [r7, #4]
 800a386:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a38a:	3b01      	subs	r3, #1
 800a38c:	b2da      	uxtb	r2, r3
 800a38e:	687b      	ldr	r3, [r7, #4]
 800a390:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 800a394:	687b      	ldr	r3, [r7, #4]
 800a396:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a39a:	2b00      	cmp	r3, #0
 800a39c:	d123      	bne.n	800a3e6 <chThdRelease+0x7e>
 800a39e:	687b      	ldr	r3, [r7, #4]
 800a3a0:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a3a4:	2b0f      	cmp	r3, #15
 800a3a6:	d11e      	bne.n	800a3e6 <chThdRelease+0x7e>
    REG_REMOVE(tp);
 800a3a8:	687b      	ldr	r3, [r7, #4]
 800a3aa:	695b      	ldr	r3, [r3, #20]
 800a3ac:	687a      	ldr	r2, [r7, #4]
 800a3ae:	6912      	ldr	r2, [r2, #16]
 800a3b0:	611a      	str	r2, [r3, #16]
 800a3b2:	687b      	ldr	r3, [r7, #4]
 800a3b4:	691b      	ldr	r3, [r3, #16]
 800a3b6:	687a      	ldr	r2, [r7, #4]
 800a3b8:	6952      	ldr	r2, [r2, #20]
 800a3ba:	615a      	str	r2, [r3, #20]
    chSysUnlock();
 800a3bc:	f001 fade 	bl	800b97c <chSysUnlock.lto_priv.270>

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 800a3c0:	687b      	ldr	r3, [r7, #4]
 800a3c2:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800a3c6:	f003 0303 	and.w	r3, r3, #3
 800a3ca:	2b02      	cmp	r3, #2
 800a3cc:	d000      	beq.n	800a3d0 <chThdRelease+0x68>
 800a3ce:	e00c      	b.n	800a3ea <chThdRelease+0x82>
      chHeapFree(chThdGetWorkingAreaX(tp));
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 800a3d0:	687b      	ldr	r3, [r7, #4]
 800a3d2:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 800a3d4:	6878      	ldr	r0, [r7, #4]
 800a3d6:	f001 faf9 	bl	800b9cc <chThdGetWorkingAreaX.lto_priv.285>
 800a3da:	4603      	mov	r3, r0
 800a3dc:	4620      	mov	r0, r4
 800a3de:	4619      	mov	r1, r3
 800a3e0:	f7ff fe28 	bl	800a034 <chPoolFree>
 800a3e4:	e001      	b.n	800a3ea <chThdRelease+0x82>
      break;
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
 800a3e6:	f001 fac9 	bl	800b97c <chSysUnlock.lto_priv.270>
}
 800a3ea:	370c      	adds	r7, #12
 800a3ec:	46bd      	mov	sp, r7
 800a3ee:	bd90      	pop	{r4, r7, pc}
 800a3f0:	0800e8f8 	.word	0x0800e8f8

0800a3f4 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 800a3f4:	b580      	push	{r7, lr}
 800a3f6:	b082      	sub	sp, #8
 800a3f8:	af00      	add	r7, sp, #0
 800a3fa:	6078      	str	r0, [r7, #4]

  chSysLock();
 800a3fc:	f001 fab6 	bl	800b96c <chSysLock.lto_priv.274>
  chThdExitS(msg);
 800a400:	6878      	ldr	r0, [r7, #4]
 800a402:	f000 f803 	bl	800a40c <chThdExitS>
  /* The thread never returns here.*/
}
 800a406:	3708      	adds	r7, #8
 800a408:	46bd      	mov	sp, r7
 800a40a:	bd80      	pop	{r7, pc}

0800a40c <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 800a40c:	b580      	push	{r7, lr}
 800a40e:	b084      	sub	sp, #16
 800a410:	af00      	add	r7, sp, #0
 800a412:	6078      	str	r0, [r7, #4]
  thread_t *tp = currp;
 800a414:	4b1b      	ldr	r3, [pc, #108]	; (800a484 <chThdExitS+0x78>)
 800a416:	699b      	ldr	r3, [r3, #24]
 800a418:	60fb      	str	r3, [r7, #12]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 800a41a:	68fb      	ldr	r3, [r7, #12]
 800a41c:	687a      	ldr	r2, [r7, #4]
 800a41e:	625a      	str	r2, [r3, #36]	; 0x24
 800a420:	e008      	b.n	800a434 <chThdExitS+0x28>
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
    (void) chSchReadyI(list_remove(&tp->waiting));
 800a422:	68fb      	ldr	r3, [r7, #12]
 800a424:	3328      	adds	r3, #40	; 0x28
 800a426:	4618      	mov	r0, r3
 800a428:	f001 f852 	bl	800b4d0 <list_remove>
 800a42c:	4603      	mov	r3, r0
 800a42e:	4618      	mov	r0, r3
 800a430:	f001 f860 	bl	800b4f4 <chSchReadyI>
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 800a434:	68fb      	ldr	r3, [r7, #12]
 800a436:	3328      	adds	r3, #40	; 0x28
 800a438:	4618      	mov	r0, r3
 800a43a:	f001 fa73 	bl	800b924 <list_notempty.lto_priv.305>
 800a43e:	4603      	mov	r3, r0
 800a440:	2b00      	cmp	r3, #0
 800a442:	d1ee      	bne.n	800a422 <chThdExitS+0x16>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 800a444:	68fb      	ldr	r3, [r7, #12]
 800a446:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a44a:	2b00      	cmp	r3, #0
 800a44c:	d110      	bne.n	800a470 <chThdExitS+0x64>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 800a44e:	68fb      	ldr	r3, [r7, #12]
 800a450:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800a454:	f003 0303 	and.w	r3, r3, #3

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 800a458:	2b00      	cmp	r3, #0
 800a45a:	d109      	bne.n	800a470 <chThdExitS+0x64>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 800a45c:	68fb      	ldr	r3, [r7, #12]
 800a45e:	695b      	ldr	r3, [r3, #20]
 800a460:	68fa      	ldr	r2, [r7, #12]
 800a462:	6912      	ldr	r2, [r2, #16]
 800a464:	611a      	str	r2, [r3, #16]
 800a466:	68fb      	ldr	r3, [r7, #12]
 800a468:	691b      	ldr	r3, [r3, #16]
 800a46a:	68fa      	ldr	r2, [r7, #12]
 800a46c:	6952      	ldr	r2, [r2, #20]
 800a46e:	615a      	str	r2, [r3, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 800a470:	200f      	movs	r0, #15
 800a472:	f001 f8bf 	bl	800b5f4 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 800a476:	4804      	ldr	r0, [pc, #16]	; (800a488 <chThdExitS+0x7c>)
 800a478:	f000 fcc2 	bl	800ae00 <chSysHalt>
}
 800a47c:	3710      	adds	r7, #16
 800a47e:	46bd      	mov	sp, r7
 800a480:	bd80      	pop	{r7, pc}
 800a482:	bf00      	nop
 800a484:	20001338 	.word	0x20001338
 800a488:	0800e908 	.word	0x0800e908

0800a48c <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 800a48c:	b580      	push	{r7, lr}
 800a48e:	b084      	sub	sp, #16
 800a490:	af00      	add	r7, sp, #0
 800a492:	6078      	str	r0, [r7, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);
 800a494:	687b      	ldr	r3, [r7, #4]
 800a496:	2bff      	cmp	r3, #255	; 0xff
 800a498:	d902      	bls.n	800a4a0 <chThdSetPriority+0x14>
 800a49a:	4814      	ldr	r0, [pc, #80]	; (800a4ec <chThdSetPriority+0x60>)
 800a49c:	f000 fcb0 	bl	800ae00 <chSysHalt>

  chSysLock();
 800a4a0:	f001 fa64 	bl	800b96c <chSysLock.lto_priv.274>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->realprio;
 800a4a4:	4b12      	ldr	r3, [pc, #72]	; (800a4f0 <chThdSetPriority+0x64>)
 800a4a6:	699b      	ldr	r3, [r3, #24]
 800a4a8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a4aa:	60fb      	str	r3, [r7, #12]
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
 800a4ac:	4b10      	ldr	r3, [pc, #64]	; (800a4f0 <chThdSetPriority+0x64>)
 800a4ae:	699b      	ldr	r3, [r3, #24]
 800a4b0:	689a      	ldr	r2, [r3, #8]
 800a4b2:	4b0f      	ldr	r3, [pc, #60]	; (800a4f0 <chThdSetPriority+0x64>)
 800a4b4:	699b      	ldr	r3, [r3, #24]
 800a4b6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a4b8:	429a      	cmp	r2, r3
 800a4ba:	d005      	beq.n	800a4c8 <chThdSetPriority+0x3c>
 800a4bc:	4b0c      	ldr	r3, [pc, #48]	; (800a4f0 <chThdSetPriority+0x64>)
 800a4be:	699b      	ldr	r3, [r3, #24]
 800a4c0:	689a      	ldr	r2, [r3, #8]
 800a4c2:	687b      	ldr	r3, [r7, #4]
 800a4c4:	429a      	cmp	r2, r3
 800a4c6:	d203      	bcs.n	800a4d0 <chThdSetPriority+0x44>
    currp->prio = newprio;
 800a4c8:	4b09      	ldr	r3, [pc, #36]	; (800a4f0 <chThdSetPriority+0x64>)
 800a4ca:	699b      	ldr	r3, [r3, #24]
 800a4cc:	687a      	ldr	r2, [r7, #4]
 800a4ce:	609a      	str	r2, [r3, #8]
  }
  currp->realprio = newprio;
 800a4d0:	4b07      	ldr	r3, [pc, #28]	; (800a4f0 <chThdSetPriority+0x64>)
 800a4d2:	699b      	ldr	r3, [r3, #24]
 800a4d4:	687a      	ldr	r2, [r7, #4]
 800a4d6:	631a      	str	r2, [r3, #48]	; 0x30
#else
  oldprio = currp->prio;
  currp->prio = newprio;
#endif
  chSchRescheduleS();
 800a4d8:	f001 f972 	bl	800b7c0 <chSchRescheduleS>
  chSysUnlock();
 800a4dc:	f001 fa4e 	bl	800b97c <chSysUnlock.lto_priv.270>

  return oldprio;
 800a4e0:	68fb      	ldr	r3, [r7, #12]
}
 800a4e2:	4618      	mov	r0, r3
 800a4e4:	3710      	adds	r7, #16
 800a4e6:	46bd      	mov	sp, r7
 800a4e8:	bd80      	pop	{r7, pc}
 800a4ea:	bf00      	nop
 800a4ec:	0800e914 	.word	0x0800e914
 800a4f0:	20001338 	.word	0x20001338

0800a4f4 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
 800a4f4:	b580      	push	{r7, lr}
 800a4f6:	b084      	sub	sp, #16
 800a4f8:	af00      	add	r7, sp, #0
 800a4fa:	6078      	str	r0, [r7, #4]
 800a4fc:	460b      	mov	r3, r1
 800a4fe:	807b      	strh	r3, [r7, #2]
  thread_t *tp = chThdGetSelfX();
 800a500:	f001 fa58 	bl	800b9b4 <chThdGetSelfX.lto_priv.300>
 800a504:	60f8      	str	r0, [r7, #12]

  chDbgAssert(*trp == NULL, "not NULL");
 800a506:	687b      	ldr	r3, [r7, #4]
 800a508:	681b      	ldr	r3, [r3, #0]
 800a50a:	2b00      	cmp	r3, #0
 800a50c:	d002      	beq.n	800a514 <chThdSuspendTimeoutS+0x20>
 800a50e:	480c      	ldr	r0, [pc, #48]	; (800a540 <chThdSuspendTimeoutS+0x4c>)
 800a510:	f000 fc76 	bl	800ae00 <chSysHalt>

  if (TIME_IMMEDIATE == timeout) {
 800a514:	887b      	ldrh	r3, [r7, #2]
 800a516:	2b00      	cmp	r3, #0
 800a518:	d102      	bne.n	800a520 <chThdSuspendTimeoutS+0x2c>
    return MSG_TIMEOUT;
 800a51a:	f04f 33ff 	mov.w	r3, #4294967295
 800a51e:	e00b      	b.n	800a538 <chThdSuspendTimeoutS+0x44>
  }

  *trp = tp;
 800a520:	687b      	ldr	r3, [r7, #4]
 800a522:	68fa      	ldr	r2, [r7, #12]
 800a524:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 800a526:	68fb      	ldr	r3, [r7, #12]
 800a528:	687a      	ldr	r2, [r7, #4]
 800a52a:	625a      	str	r2, [r3, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800a52c:	887b      	ldrh	r3, [r7, #2]
 800a52e:	2003      	movs	r0, #3
 800a530:	4619      	mov	r1, r3
 800a532:	f001 f8bd 	bl	800b6b0 <chSchGoSleepTimeoutS>
 800a536:	4603      	mov	r3, r0
}
 800a538:	4618      	mov	r0, r3
 800a53a:	3710      	adds	r7, #16
 800a53c:	46bd      	mov	sp, r7
 800a53e:	bd80      	pop	{r7, pc}
 800a540:	0800e928 	.word	0x0800e928

0800a544 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 800a544:	b580      	push	{r7, lr}
 800a546:	b084      	sub	sp, #16
 800a548:	af00      	add	r7, sp, #0
 800a54a:	6078      	str	r0, [r7, #4]
 800a54c:	6039      	str	r1, [r7, #0]

  if (*trp != NULL) {
 800a54e:	687b      	ldr	r3, [r7, #4]
 800a550:	681b      	ldr	r3, [r3, #0]
 800a552:	2b00      	cmp	r3, #0
 800a554:	d013      	beq.n	800a57e <chThdResumeI+0x3a>
    thread_t *tp = *trp;
 800a556:	687b      	ldr	r3, [r7, #4]
 800a558:	681b      	ldr	r3, [r3, #0]
 800a55a:	60fb      	str	r3, [r7, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 800a55c:	68fb      	ldr	r3, [r7, #12]
 800a55e:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a562:	2b03      	cmp	r3, #3
 800a564:	d002      	beq.n	800a56c <chThdResumeI+0x28>
 800a566:	4807      	ldr	r0, [pc, #28]	; (800a584 <chThdResumeI+0x40>)
 800a568:	f000 fc4a 	bl	800ae00 <chSysHalt>

    *trp = NULL;
 800a56c:	687b      	ldr	r3, [r7, #4]
 800a56e:	2200      	movs	r2, #0
 800a570:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 800a572:	68fb      	ldr	r3, [r7, #12]
 800a574:	683a      	ldr	r2, [r7, #0]
 800a576:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800a578:	68f8      	ldr	r0, [r7, #12]
 800a57a:	f000 ffbb 	bl	800b4f4 <chSchReadyI>
  }
}
 800a57e:	3710      	adds	r7, #16
 800a580:	46bd      	mov	sp, r7
 800a582:	bd80      	pop	{r7, pc}
 800a584:	0800e940 	.word	0x0800e940

0800a588 <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 800a588:	b580      	push	{r7, lr}
 800a58a:	b084      	sub	sp, #16
 800a58c:	af00      	add	r7, sp, #0
 800a58e:	6078      	str	r0, [r7, #4]
 800a590:	6039      	str	r1, [r7, #0]

  if (*trp != NULL) {
 800a592:	687b      	ldr	r3, [r7, #4]
 800a594:	681b      	ldr	r3, [r3, #0]
 800a596:	2b00      	cmp	r3, #0
 800a598:	d011      	beq.n	800a5be <chThdResumeS+0x36>
    thread_t *tp = *trp;
 800a59a:	687b      	ldr	r3, [r7, #4]
 800a59c:	681b      	ldr	r3, [r3, #0]
 800a59e:	60fb      	str	r3, [r7, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 800a5a0:	68fb      	ldr	r3, [r7, #12]
 800a5a2:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a5a6:	2b03      	cmp	r3, #3
 800a5a8:	d002      	beq.n	800a5b0 <chThdResumeS+0x28>
 800a5aa:	4806      	ldr	r0, [pc, #24]	; (800a5c4 <chThdResumeS+0x3c>)
 800a5ac:	f000 fc28 	bl	800ae00 <chSysHalt>

    *trp = NULL;
 800a5b0:	687b      	ldr	r3, [r7, #4]
 800a5b2:	2200      	movs	r2, #0
 800a5b4:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 800a5b6:	68f8      	ldr	r0, [r7, #12]
 800a5b8:	6839      	ldr	r1, [r7, #0]
 800a5ba:	f001 f8b3 	bl	800b724 <chSchWakeupS>
  }
}
 800a5be:	3710      	adds	r7, #16
 800a5c0:	46bd      	mov	sp, r7
 800a5c2:	bd80      	pop	{r7, pc}
 800a5c4:	0800e950 	.word	0x0800e950

0800a5c8 <chThdResume>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @api
 */
void chThdResume(thread_reference_t *trp, msg_t msg) {
 800a5c8:	b580      	push	{r7, lr}
 800a5ca:	b082      	sub	sp, #8
 800a5cc:	af00      	add	r7, sp, #0
 800a5ce:	6078      	str	r0, [r7, #4]
 800a5d0:	6039      	str	r1, [r7, #0]

  chSysLock();
 800a5d2:	f001 f9cb 	bl	800b96c <chSysLock.lto_priv.274>
  chThdResumeS(trp, msg);
 800a5d6:	6878      	ldr	r0, [r7, #4]
 800a5d8:	6839      	ldr	r1, [r7, #0]
 800a5da:	f7ff ffd5 	bl	800a588 <chThdResumeS>
  chSysUnlock();
 800a5de:	f001 f9cd 	bl	800b97c <chSysUnlock.lto_priv.270>
}
 800a5e2:	3708      	adds	r7, #8
 800a5e4:	46bd      	mov	sp, r7
 800a5e6:	bd80      	pop	{r7, pc}

0800a5e8 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 800a5e8:	b580      	push	{r7, lr}
 800a5ea:	b082      	sub	sp, #8
 800a5ec:	af00      	add	r7, sp, #0
 800a5ee:	6078      	str	r0, [r7, #4]
 800a5f0:	460b      	mov	r3, r1
 800a5f2:	807b      	strh	r3, [r7, #2]

  if (TIME_IMMEDIATE == timeout) {
 800a5f4:	887b      	ldrh	r3, [r7, #2]
 800a5f6:	2b00      	cmp	r3, #0
 800a5f8:	d102      	bne.n	800a600 <chThdEnqueueTimeoutS+0x18>
    return MSG_TIMEOUT;
 800a5fa:	f04f 33ff 	mov.w	r3, #4294967295
 800a5fe:	e00b      	b.n	800a618 <chThdEnqueueTimeoutS+0x30>
  }

  queue_insert(currp, tqp);
 800a600:	4b07      	ldr	r3, [pc, #28]	; (800a620 <chThdEnqueueTimeoutS+0x38>)
 800a602:	699b      	ldr	r3, [r3, #24]
 800a604:	4618      	mov	r0, r3
 800a606:	6879      	ldr	r1, [r7, #4]
 800a608:	f000 ff1e 	bl	800b448 <queue_insert>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800a60c:	887b      	ldrh	r3, [r7, #2]
 800a60e:	2004      	movs	r0, #4
 800a610:	4619      	mov	r1, r3
 800a612:	f001 f84d 	bl	800b6b0 <chSchGoSleepTimeoutS>
 800a616:	4603      	mov	r3, r0
}
 800a618:	4618      	mov	r0, r3
 800a61a:	3708      	adds	r7, #8
 800a61c:	46bd      	mov	sp, r7
 800a61e:	bd80      	pop	{r7, pc}
 800a620:	20001338 	.word	0x20001338

0800a624 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 800a624:	b580      	push	{r7, lr}
 800a626:	b082      	sub	sp, #8
 800a628:	af00      	add	r7, sp, #0
 800a62a:	6078      	str	r0, [r7, #4]
 800a62c:	6039      	str	r1, [r7, #0]

  if (queue_notempty(tqp)) {
 800a62e:	6878      	ldr	r0, [r7, #4]
 800a630:	f001 f98a 	bl	800b948 <queue_notempty.lto_priv.282>
 800a634:	4603      	mov	r3, r0
 800a636:	2b00      	cmp	r3, #0
 800a638:	d003      	beq.n	800a642 <chThdDequeueNextI+0x1e>
    chThdDoDequeueNextI(tqp, msg);
 800a63a:	6878      	ldr	r0, [r7, #4]
 800a63c:	6839      	ldr	r1, [r7, #0]
 800a63e:	f001 f9d1 	bl	800b9e4 <chThdDoDequeueNextI.lto_priv.299>
  }
}
 800a642:	3708      	adds	r7, #8
 800a644:	46bd      	mov	sp, r7
 800a646:	bd80      	pop	{r7, pc}

0800a648 <port_lock.lto_priv.265>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800a648:	b480      	push	{r7}
 800a64a:	b083      	sub	sp, #12
 800a64c:	af00      	add	r7, sp, #0
 800a64e:	2320      	movs	r3, #32
 800a650:	607b      	str	r3, [r7, #4]
 800a652:	687b      	ldr	r3, [r7, #4]
 800a654:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a658:	370c      	adds	r7, #12
 800a65a:	46bd      	mov	sp, r7
 800a65c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a660:	4770      	bx	lr
 800a662:	bf00      	nop

0800a664 <port_unlock.lto_priv.261>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800a664:	b480      	push	{r7}
 800a666:	b083      	sub	sp, #12
 800a668:	af00      	add	r7, sp, #0
 800a66a:	2300      	movs	r3, #0
 800a66c:	607b      	str	r3, [r7, #4]
 800a66e:	687b      	ldr	r3, [r7, #4]
 800a670:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a674:	370c      	adds	r7, #12
 800a676:	46bd      	mov	sp, r7
 800a678:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a67c:	4770      	bx	lr
 800a67e:	bf00      	nop

0800a680 <chSysLock.lto_priv.275>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800a680:	b580      	push	{r7, lr}
 800a682:	af00      	add	r7, sp, #0

  port_lock();
 800a684:	f7ff ffe0 	bl	800a648 <port_lock.lto_priv.265>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800a688:	f000 fc08 	bl	800ae9c <_dbg_check_lock>
}
 800a68c:	bd80      	pop	{r7, pc}
 800a68e:	bf00      	nop

0800a690 <chSysUnlock.lto_priv.271>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800a690:	b580      	push	{r7, lr}
 800a692:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 800a694:	f000 fc18 	bl	800aec8 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a698:	4b09      	ldr	r3, [pc, #36]	; (800a6c0 <chSysUnlock.lto_priv.271+0x30>)
 800a69a:	681b      	ldr	r3, [r3, #0]
 800a69c:	4a08      	ldr	r2, [pc, #32]	; (800a6c0 <chSysUnlock.lto_priv.271+0x30>)
 800a69e:	4293      	cmp	r3, r2
 800a6a0:	d00a      	beq.n	800a6b8 <chSysUnlock.lto_priv.271+0x28>
 800a6a2:	4b07      	ldr	r3, [pc, #28]	; (800a6c0 <chSysUnlock.lto_priv.271+0x30>)
 800a6a4:	699b      	ldr	r3, [r3, #24]
 800a6a6:	689a      	ldr	r2, [r3, #8]
 800a6a8:	4b05      	ldr	r3, [pc, #20]	; (800a6c0 <chSysUnlock.lto_priv.271+0x30>)
 800a6aa:	681b      	ldr	r3, [r3, #0]
 800a6ac:	689b      	ldr	r3, [r3, #8]
 800a6ae:	429a      	cmp	r2, r3
 800a6b0:	d202      	bcs.n	800a6b8 <chSysUnlock.lto_priv.271+0x28>
 800a6b2:	4804      	ldr	r0, [pc, #16]	; (800a6c4 <chSysUnlock.lto_priv.271+0x34>)
 800a6b4:	f000 fba4 	bl	800ae00 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 800a6b8:	f7ff ffd4 	bl	800a664 <port_unlock.lto_priv.261>
}
 800a6bc:	bd80      	pop	{r7, pc}
 800a6be:	bf00      	nop
 800a6c0:	20001338 	.word	0x20001338
 800a6c4:	0800e98c 	.word	0x0800e98c

0800a6c8 <chThdGetWorkingAreaX.lto_priv.286>:
 * @param[in] tp        pointer to the thread
 * @return              The working area base pointer.
 *
 * @xclass
 */
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 800a6c8:	b480      	push	{r7}
 800a6ca:	b083      	sub	sp, #12
 800a6cc:	af00      	add	r7, sp, #0
 800a6ce:	6078      	str	r0, [r7, #4]

  return tp->wabase;
 800a6d0:	687b      	ldr	r3, [r7, #4]
 800a6d2:	69db      	ldr	r3, [r3, #28]
}
 800a6d4:	4618      	mov	r0, r3
 800a6d6:	370c      	adds	r7, #12
 800a6d8:	46bd      	mov	sp, r7
 800a6da:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a6de:	4770      	bx	lr

0800a6e0 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 800a6e0:	b580      	push	{r7, lr}
 800a6e2:	b082      	sub	sp, #8
 800a6e4:	af00      	add	r7, sp, #0
  thread_t *tp;

  chSysLock();
 800a6e6:	f7ff ffcb 	bl	800a680 <chSysLock.lto_priv.275>
  tp = ch.rlist.newer;
 800a6ea:	4b09      	ldr	r3, [pc, #36]	; (800a710 <chRegFirstThread+0x30>)
 800a6ec:	691b      	ldr	r3, [r3, #16]
 800a6ee:	607b      	str	r3, [r7, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 800a6f0:	687b      	ldr	r3, [r7, #4]
 800a6f2:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a6f6:	3301      	adds	r3, #1
 800a6f8:	b2da      	uxtb	r2, r3
 800a6fa:	687b      	ldr	r3, [r7, #4]
 800a6fc:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
  chSysUnlock();
 800a700:	f7ff ffc6 	bl	800a690 <chSysUnlock.lto_priv.271>

  return tp;
 800a704:	687b      	ldr	r3, [r7, #4]
}
 800a706:	4618      	mov	r0, r3
 800a708:	3708      	adds	r7, #8
 800a70a:	46bd      	mov	sp, r7
 800a70c:	bd80      	pop	{r7, pc}
 800a70e:	bf00      	nop
 800a710:	20001338 	.word	0x20001338

0800a714 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 800a714:	b580      	push	{r7, lr}
 800a716:	b084      	sub	sp, #16
 800a718:	af00      	add	r7, sp, #0
 800a71a:	6078      	str	r0, [r7, #4]
  thread_t *ntp;

  chSysLock();
 800a71c:	f7ff ffb0 	bl	800a680 <chSysLock.lto_priv.275>
  ntp = tp->newer;
 800a720:	687b      	ldr	r3, [r7, #4]
 800a722:	691b      	ldr	r3, [r3, #16]
 800a724:	60fb      	str	r3, [r7, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 800a726:	68fb      	ldr	r3, [r7, #12]
 800a728:	4a0f      	ldr	r2, [pc, #60]	; (800a768 <chRegNextThread+0x54>)
 800a72a:	4293      	cmp	r3, r2
 800a72c:	d102      	bne.n	800a734 <chRegNextThread+0x20>
  /*lint -restore*/
    ntp = NULL;
 800a72e:	2300      	movs	r3, #0
 800a730:	60fb      	str	r3, [r7, #12]
 800a732:	e00f      	b.n	800a754 <chRegNextThread+0x40>
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 800a734:	68fb      	ldr	r3, [r7, #12]
 800a736:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a73a:	2bff      	cmp	r3, #255	; 0xff
 800a73c:	d102      	bne.n	800a744 <chRegNextThread+0x30>
 800a73e:	480b      	ldr	r0, [pc, #44]	; (800a76c <chRegNextThread+0x58>)
 800a740:	f000 fb5e 	bl	800ae00 <chSysHalt>
    ntp->refs++;
 800a744:	68fb      	ldr	r3, [r7, #12]
 800a746:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a74a:	3301      	adds	r3, #1
 800a74c:	b2da      	uxtb	r2, r3
 800a74e:	68fb      	ldr	r3, [r7, #12]
 800a750:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  }
#endif
  chSysUnlock();
 800a754:	f7ff ff9c 	bl	800a690 <chSysUnlock.lto_priv.271>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 800a758:	6878      	ldr	r0, [r7, #4]
 800a75a:	f7ff fe05 	bl	800a368 <chThdRelease>
#endif

  return ntp;
 800a75e:	68fb      	ldr	r3, [r7, #12]
}
 800a760:	4618      	mov	r0, r3
 800a762:	3710      	adds	r7, #16
 800a764:	46bd      	mov	sp, r7
 800a766:	bd80      	pop	{r7, pc}
 800a768:	20001338 	.word	0x20001338
 800a76c:	0800e998 	.word	0x0800e998

0800a770 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 800a770:	b580      	push	{r7, lr}
 800a772:	b084      	sub	sp, #16
 800a774:	af00      	add	r7, sp, #0
 800a776:	6078      	str	r0, [r7, #4]
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
 800a778:	f7ff ffb2 	bl	800a6e0 <chRegFirstThread>
 800a77c:	60f8      	str	r0, [r7, #12]
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 800a77e:	68f8      	ldr	r0, [r7, #12]
 800a780:	f7ff ffa2 	bl	800a6c8 <chThdGetWorkingAreaX.lto_priv.286>
 800a784:	4602      	mov	r2, r0
 800a786:	687b      	ldr	r3, [r7, #4]
 800a788:	429a      	cmp	r2, r3
 800a78a:	d101      	bne.n	800a790 <chRegFindThreadByWorkingArea+0x20>
      return ctp;
 800a78c:	68fb      	ldr	r3, [r7, #12]
 800a78e:	e007      	b.n	800a7a0 <chRegFindThreadByWorkingArea+0x30>
    }
    ctp = chRegNextThread(ctp);
 800a790:	68f8      	ldr	r0, [r7, #12]
 800a792:	f7ff ffbf 	bl	800a714 <chRegNextThread>
 800a796:	60f8      	str	r0, [r7, #12]
  } while (ctp != NULL);
 800a798:	68fb      	ldr	r3, [r7, #12]
 800a79a:	2b00      	cmp	r3, #0
 800a79c:	d1ef      	bne.n	800a77e <chRegFindThreadByWorkingArea+0xe>

  return NULL;
 800a79e:	2300      	movs	r3, #0
}
 800a7a0:	4618      	mov	r0, r3
 800a7a2:	3710      	adds	r7, #16
 800a7a4:	46bd      	mov	sp, r7
 800a7a6:	bd80      	pop	{r7, pc}

0800a7a8 <port_lock.lto_priv.266>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800a7a8:	b480      	push	{r7}
 800a7aa:	b083      	sub	sp, #12
 800a7ac:	af00      	add	r7, sp, #0
 800a7ae:	2320      	movs	r3, #32
 800a7b0:	607b      	str	r3, [r7, #4]
 800a7b2:	687b      	ldr	r3, [r7, #4]
 800a7b4:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a7b8:	370c      	adds	r7, #12
 800a7ba:	46bd      	mov	sp, r7
 800a7bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a7c0:	4770      	bx	lr
 800a7c2:	bf00      	nop

0800a7c4 <port_unlock.lto_priv.262>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800a7c4:	b480      	push	{r7}
 800a7c6:	b083      	sub	sp, #12
 800a7c8:	af00      	add	r7, sp, #0
 800a7ca:	2300      	movs	r3, #0
 800a7cc:	607b      	str	r3, [r7, #4]
 800a7ce:	687b      	ldr	r3, [r7, #4]
 800a7d0:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a7d4:	370c      	adds	r7, #12
 800a7d6:	46bd      	mov	sp, r7
 800a7d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a7dc:	4770      	bx	lr
 800a7de:	bf00      	nop

0800a7e0 <queue_init.lto_priv.259>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 800a7e0:	b480      	push	{r7}
 800a7e2:	b083      	sub	sp, #12
 800a7e4:	af00      	add	r7, sp, #0
 800a7e6:	6078      	str	r0, [r7, #4]

  tqp->next = (thread_t *)tqp;
 800a7e8:	687b      	ldr	r3, [r7, #4]
 800a7ea:	687a      	ldr	r2, [r7, #4]
 800a7ec:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800a7ee:	687b      	ldr	r3, [r7, #4]
 800a7f0:	687a      	ldr	r2, [r7, #4]
 800a7f2:	605a      	str	r2, [r3, #4]
}
 800a7f4:	370c      	adds	r7, #12
 800a7f6:	46bd      	mov	sp, r7
 800a7f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a7fc:	4770      	bx	lr
 800a7fe:	bf00      	nop

0800a800 <queue_notempty.lto_priv.283>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 800a800:	b480      	push	{r7}
 800a802:	b083      	sub	sp, #12
 800a804:	af00      	add	r7, sp, #0
 800a806:	6078      	str	r0, [r7, #4]

  return (bool)(tqp->next != (const thread_t *)tqp);
 800a808:	687b      	ldr	r3, [r7, #4]
 800a80a:	681a      	ldr	r2, [r3, #0]
 800a80c:	687b      	ldr	r3, [r7, #4]
 800a80e:	429a      	cmp	r2, r3
 800a810:	bf14      	ite	ne
 800a812:	2301      	movne	r3, #1
 800a814:	2300      	moveq	r3, #0
 800a816:	b2db      	uxtb	r3, r3
}
 800a818:	4618      	mov	r0, r3
 800a81a:	370c      	adds	r7, #12
 800a81c:	46bd      	mov	sp, r7
 800a81e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a822:	4770      	bx	lr

0800a824 <chSysLock.lto_priv.276>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800a824:	b580      	push	{r7, lr}
 800a826:	af00      	add	r7, sp, #0

  port_lock();
 800a828:	f7ff ffbe 	bl	800a7a8 <port_lock.lto_priv.266>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800a82c:	f000 fb36 	bl	800ae9c <_dbg_check_lock>
}
 800a830:	bd80      	pop	{r7, pc}
 800a832:	bf00      	nop

0800a834 <chSysUnlock.lto_priv.272>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800a834:	b580      	push	{r7, lr}
 800a836:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 800a838:	f000 fb46 	bl	800aec8 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a83c:	4b09      	ldr	r3, [pc, #36]	; (800a864 <chSysUnlock.lto_priv.272+0x30>)
 800a83e:	681b      	ldr	r3, [r3, #0]
 800a840:	4a08      	ldr	r2, [pc, #32]	; (800a864 <chSysUnlock.lto_priv.272+0x30>)
 800a842:	4293      	cmp	r3, r2
 800a844:	d00a      	beq.n	800a85c <chSysUnlock.lto_priv.272+0x28>
 800a846:	4b07      	ldr	r3, [pc, #28]	; (800a864 <chSysUnlock.lto_priv.272+0x30>)
 800a848:	699b      	ldr	r3, [r3, #24]
 800a84a:	689a      	ldr	r2, [r3, #8]
 800a84c:	4b05      	ldr	r3, [pc, #20]	; (800a864 <chSysUnlock.lto_priv.272+0x30>)
 800a84e:	681b      	ldr	r3, [r3, #0]
 800a850:	689b      	ldr	r3, [r3, #8]
 800a852:	429a      	cmp	r2, r3
 800a854:	d202      	bcs.n	800a85c <chSysUnlock.lto_priv.272+0x28>
 800a856:	4804      	ldr	r0, [pc, #16]	; (800a868 <chSysUnlock.lto_priv.272+0x34>)
 800a858:	f000 fad2 	bl	800ae00 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 800a85c:	f7ff ffb2 	bl	800a7c4 <port_unlock.lto_priv.262>
}
 800a860:	bd80      	pop	{r7, pc}
 800a862:	bf00      	nop
 800a864:	20001338 	.word	0x20001338
 800a868:	0800e9b8 	.word	0x0800e9b8

0800a86c <chMtxQueueNotEmptyS>:
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 800a86c:	b580      	push	{r7, lr}
 800a86e:	b082      	sub	sp, #8
 800a870:	af00      	add	r7, sp, #0
 800a872:	6078      	str	r0, [r7, #4]

  chDbgCheckClassS();
 800a874:	f000 fbb4 	bl	800afe0 <chDbgCheckClassS>

  return queue_notempty(&mp->queue);
 800a878:	687b      	ldr	r3, [r7, #4]
 800a87a:	4618      	mov	r0, r3
 800a87c:	f7ff ffc0 	bl	800a800 <queue_notempty.lto_priv.283>
 800a880:	4603      	mov	r3, r0
}
 800a882:	4618      	mov	r0, r3
 800a884:	3708      	adds	r7, #8
 800a886:	46bd      	mov	sp, r7
 800a888:	bd80      	pop	{r7, pc}
 800a88a:	bf00      	nop

0800a88c <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 800a88c:	b580      	push	{r7, lr}
 800a88e:	b082      	sub	sp, #8
 800a890:	af00      	add	r7, sp, #0
 800a892:	6078      	str	r0, [r7, #4]

  chDbgCheck(mp != NULL);
 800a894:	687b      	ldr	r3, [r7, #4]
 800a896:	2b00      	cmp	r3, #0
 800a898:	d102      	bne.n	800a8a0 <chMtxObjectInit+0x14>
 800a89a:	4808      	ldr	r0, [pc, #32]	; (800a8bc <chMtxObjectInit+0x30>)
 800a89c:	f000 fab0 	bl	800ae00 <chSysHalt>

  queue_init(&mp->queue);
 800a8a0:	687b      	ldr	r3, [r7, #4]
 800a8a2:	4618      	mov	r0, r3
 800a8a4:	f7ff ff9c 	bl	800a7e0 <queue_init.lto_priv.259>
  mp->owner = NULL;
 800a8a8:	687b      	ldr	r3, [r7, #4]
 800a8aa:	2200      	movs	r2, #0
 800a8ac:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
 800a8ae:	687b      	ldr	r3, [r7, #4]
 800a8b0:	2200      	movs	r2, #0
 800a8b2:	611a      	str	r2, [r3, #16]
#endif
}
 800a8b4:	3708      	adds	r7, #8
 800a8b6:	46bd      	mov	sp, r7
 800a8b8:	bd80      	pop	{r7, pc}
 800a8ba:	bf00      	nop
 800a8bc:	0800e9a8 	.word	0x0800e9a8

0800a8c0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 800a8c0:	b580      	push	{r7, lr}
 800a8c2:	b084      	sub	sp, #16
 800a8c4:	af00      	add	r7, sp, #0
 800a8c6:	6078      	str	r0, [r7, #4]
  thread_t *ctp = currp;
 800a8c8:	4b46      	ldr	r3, [pc, #280]	; (800a9e4 <chMtxLockS+0x124>)
 800a8ca:	699b      	ldr	r3, [r3, #24]
 800a8cc:	60bb      	str	r3, [r7, #8]

  chDbgCheckClassS();
 800a8ce:	f000 fb87 	bl	800afe0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 800a8d2:	687b      	ldr	r3, [r7, #4]
 800a8d4:	2b00      	cmp	r3, #0
 800a8d6:	d102      	bne.n	800a8de <chMtxLockS+0x1e>
 800a8d8:	4843      	ldr	r0, [pc, #268]	; (800a9e8 <chMtxLockS+0x128>)
 800a8da:	f000 fa91 	bl	800ae00 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 800a8de:	687b      	ldr	r3, [r7, #4]
 800a8e0:	689b      	ldr	r3, [r3, #8]
 800a8e2:	2b00      	cmp	r3, #0
 800a8e4:	d065      	beq.n	800a9b2 <chMtxLockS+0xf2>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE

    chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");
 800a8e6:	687b      	ldr	r3, [r7, #4]
 800a8e8:	691b      	ldr	r3, [r3, #16]
 800a8ea:	2b00      	cmp	r3, #0
 800a8ec:	dc02      	bgt.n	800a8f4 <chMtxLockS+0x34>
 800a8ee:	483e      	ldr	r0, [pc, #248]	; (800a9e8 <chMtxLockS+0x128>)
 800a8f0:	f000 fa86 	bl	800ae00 <chSysHalt>

    /* If the mutex is already owned by this thread, the counter is increased
       and there is no need of more actions.*/
    if (mp->owner == ctp) {
 800a8f4:	687b      	ldr	r3, [r7, #4]
 800a8f6:	689a      	ldr	r2, [r3, #8]
 800a8f8:	68bb      	ldr	r3, [r7, #8]
 800a8fa:	429a      	cmp	r2, r3
 800a8fc:	d105      	bne.n	800a90a <chMtxLockS+0x4a>
      mp->cnt++;
 800a8fe:	687b      	ldr	r3, [r7, #4]
 800a900:	691b      	ldr	r3, [r3, #16]
 800a902:	1c5a      	adds	r2, r3, #1
 800a904:	687b      	ldr	r3, [r7, #4]
 800a906:	611a      	str	r2, [r3, #16]
 800a908:	e069      	b.n	800a9de <chMtxLockS+0x11e>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
 800a90a:	687b      	ldr	r3, [r7, #4]
 800a90c:	689b      	ldr	r3, [r3, #8]
 800a90e:	60fb      	str	r3, [r7, #12]
 800a910:	e026      	b.n	800a960 <chMtxLockS+0xa0>

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 800a912:	68bb      	ldr	r3, [r7, #8]
 800a914:	689a      	ldr	r2, [r3, #8]
 800a916:	68fb      	ldr	r3, [r7, #12]
 800a918:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800a91a:	68fb      	ldr	r3, [r7, #12]
 800a91c:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a920:	2b00      	cmp	r3, #0
 800a922:	d011      	beq.n	800a948 <chMtxLockS+0x88>
 800a924:	2b06      	cmp	r3, #6
 800a926:	d000      	beq.n	800a92a <chMtxLockS+0x6a>
 800a928:	e020      	b.n	800a96c <chMtxLockS+0xac>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800a92a:	68f8      	ldr	r0, [r7, #12]
 800a92c:	f000 fdba 	bl	800b4a4 <queue_dequeue>
 800a930:	4602      	mov	r2, r0
 800a932:	68fb      	ldr	r3, [r7, #12]
 800a934:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a936:	4610      	mov	r0, r2
 800a938:	4619      	mov	r1, r3
 800a93a:	f000 fd5d 	bl	800b3f8 <queue_prio_insert>
          tp = tp->u.wtmtxp->owner;
 800a93e:	68fb      	ldr	r3, [r7, #12]
 800a940:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a942:	689b      	ldr	r3, [r3, #8]
 800a944:	60fb      	str	r3, [r7, #12]
 800a946:	e00b      	b.n	800a960 <chMtxLockS+0xa0>
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 800a948:	68fb      	ldr	r3, [r7, #12]
 800a94a:	2201      	movs	r2, #1
 800a94c:	f883 2020 	strb.w	r2, [r3, #32]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 800a950:	68f8      	ldr	r0, [r7, #12]
 800a952:	f000 fda7 	bl	800b4a4 <queue_dequeue>
 800a956:	4603      	mov	r3, r0
 800a958:	4618      	mov	r0, r3
 800a95a:	f000 fdcb 	bl	800b4f4 <chSchReadyI>
 800a95e:	e005      	b.n	800a96c <chMtxLockS+0xac>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 800a960:	68fb      	ldr	r3, [r7, #12]
 800a962:	689a      	ldr	r2, [r3, #8]
 800a964:	68bb      	ldr	r3, [r7, #8]
 800a966:	689b      	ldr	r3, [r3, #8]
 800a968:	429a      	cmp	r2, r3
 800a96a:	d3d2      	bcc.n	800a912 <chMtxLockS+0x52>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
 800a96c:	687b      	ldr	r3, [r7, #4]
 800a96e:	68b8      	ldr	r0, [r7, #8]
 800a970:	4619      	mov	r1, r3
 800a972:	f000 fd41 	bl	800b3f8 <queue_prio_insert>
      ctp->u.wtmtxp = mp;
 800a976:	68bb      	ldr	r3, [r7, #8]
 800a978:	687a      	ldr	r2, [r7, #4]
 800a97a:	625a      	str	r2, [r3, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 800a97c:	2006      	movs	r0, #6
 800a97e:	f000 fe39 	bl	800b5f4 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 800a982:	687b      	ldr	r3, [r7, #4]
 800a984:	689a      	ldr	r2, [r3, #8]
 800a986:	68bb      	ldr	r3, [r7, #8]
 800a988:	429a      	cmp	r2, r3
 800a98a:	d002      	beq.n	800a992 <chMtxLockS+0xd2>
 800a98c:	4816      	ldr	r0, [pc, #88]	; (800a9e8 <chMtxLockS+0x128>)
 800a98e:	f000 fa37 	bl	800ae00 <chSysHalt>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 800a992:	68bb      	ldr	r3, [r7, #8]
 800a994:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a996:	687b      	ldr	r3, [r7, #4]
 800a998:	429a      	cmp	r2, r3
 800a99a:	d002      	beq.n	800a9a2 <chMtxLockS+0xe2>
 800a99c:	4812      	ldr	r0, [pc, #72]	; (800a9e8 <chMtxLockS+0x128>)
 800a99e:	f000 fa2f 	bl	800ae00 <chSysHalt>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      chDbgAssert(mp->cnt == (cnt_t)1, "counter is not one");
 800a9a2:	687b      	ldr	r3, [r7, #4]
 800a9a4:	691b      	ldr	r3, [r3, #16]
 800a9a6:	2b01      	cmp	r3, #1
 800a9a8:	d019      	beq.n	800a9de <chMtxLockS+0x11e>
 800a9aa:	480f      	ldr	r0, [pc, #60]	; (800a9e8 <chMtxLockS+0x128>)
 800a9ac:	f000 fa28 	bl	800ae00 <chSysHalt>
 800a9b0:	e015      	b.n	800a9de <chMtxLockS+0x11e>
    }
#endif
  }
  else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");
 800a9b2:	687b      	ldr	r3, [r7, #4]
 800a9b4:	691b      	ldr	r3, [r3, #16]
 800a9b6:	2b00      	cmp	r3, #0
 800a9b8:	d002      	beq.n	800a9c0 <chMtxLockS+0x100>
 800a9ba:	480b      	ldr	r0, [pc, #44]	; (800a9e8 <chMtxLockS+0x128>)
 800a9bc:	f000 fa20 	bl	800ae00 <chSysHalt>

    mp->cnt++;
 800a9c0:	687b      	ldr	r3, [r7, #4]
 800a9c2:	691b      	ldr	r3, [r3, #16]
 800a9c4:	1c5a      	adds	r2, r3, #1
 800a9c6:	687b      	ldr	r3, [r7, #4]
 800a9c8:	611a      	str	r2, [r3, #16]
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 800a9ca:	687b      	ldr	r3, [r7, #4]
 800a9cc:	68ba      	ldr	r2, [r7, #8]
 800a9ce:	609a      	str	r2, [r3, #8]
    mp->next = ctp->mtxlist;
 800a9d0:	68bb      	ldr	r3, [r7, #8]
 800a9d2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a9d4:	687b      	ldr	r3, [r7, #4]
 800a9d6:	60da      	str	r2, [r3, #12]
    ctp->mtxlist = mp;
 800a9d8:	68bb      	ldr	r3, [r7, #8]
 800a9da:	687a      	ldr	r2, [r7, #4]
 800a9dc:	62da      	str	r2, [r3, #44]	; 0x2c
  }
}
 800a9de:	3710      	adds	r7, #16
 800a9e0:	46bd      	mov	sp, r7
 800a9e2:	bd80      	pop	{r7, pc}
 800a9e4:	20001338 	.word	0x20001338
 800a9e8:	0800e9c4 	.word	0x0800e9c4

0800a9ec <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 800a9ec:	b580      	push	{r7, lr}
 800a9ee:	b086      	sub	sp, #24
 800a9f0:	af00      	add	r7, sp, #0
 800a9f2:	6078      	str	r0, [r7, #4]
  thread_t *ctp = currp;
 800a9f4:	4b3e      	ldr	r3, [pc, #248]	; (800aaf0 <chMtxUnlock+0x104>)
 800a9f6:	699b      	ldr	r3, [r3, #24]
 800a9f8:	60fb      	str	r3, [r7, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 800a9fa:	687b      	ldr	r3, [r7, #4]
 800a9fc:	2b00      	cmp	r3, #0
 800a9fe:	d102      	bne.n	800aa06 <chMtxUnlock+0x1a>
 800aa00:	483c      	ldr	r0, [pc, #240]	; (800aaf4 <chMtxUnlock+0x108>)
 800aa02:	f000 f9fd 	bl	800ae00 <chSysHalt>

  chSysLock();
 800aa06:	f7ff ff0d 	bl	800a824 <chSysLock.lto_priv.276>

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 800aa0a:	68fb      	ldr	r3, [r7, #12]
 800aa0c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aa0e:	2b00      	cmp	r3, #0
 800aa10:	d102      	bne.n	800aa18 <chMtxUnlock+0x2c>
 800aa12:	4838      	ldr	r0, [pc, #224]	; (800aaf4 <chMtxUnlock+0x108>)
 800aa14:	f000 f9f4 	bl	800ae00 <chSysHalt>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 800aa18:	68fb      	ldr	r3, [r7, #12]
 800aa1a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aa1c:	689a      	ldr	r2, [r3, #8]
 800aa1e:	68fb      	ldr	r3, [r7, #12]
 800aa20:	429a      	cmp	r2, r3
 800aa22:	d002      	beq.n	800aa2a <chMtxUnlock+0x3e>
 800aa24:	4833      	ldr	r0, [pc, #204]	; (800aaf4 <chMtxUnlock+0x108>)
 800aa26:	f000 f9eb 	bl	800ae00 <chSysHalt>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");
 800aa2a:	687b      	ldr	r3, [r7, #4]
 800aa2c:	691b      	ldr	r3, [r3, #16]
 800aa2e:	2b00      	cmp	r3, #0
 800aa30:	dc02      	bgt.n	800aa38 <chMtxUnlock+0x4c>
 800aa32:	4830      	ldr	r0, [pc, #192]	; (800aaf4 <chMtxUnlock+0x108>)
 800aa34:	f000 f9e4 	bl	800ae00 <chSysHalt>

  if (--mp->cnt == (cnt_t)0) {
 800aa38:	687b      	ldr	r3, [r7, #4]
 800aa3a:	691b      	ldr	r3, [r3, #16]
 800aa3c:	1e5a      	subs	r2, r3, #1
 800aa3e:	687b      	ldr	r3, [r7, #4]
 800aa40:	611a      	str	r2, [r3, #16]
 800aa42:	687b      	ldr	r3, [r7, #4]
 800aa44:	691b      	ldr	r3, [r3, #16]
 800aa46:	2b00      	cmp	r3, #0
 800aa48:	d14c      	bne.n	800aae4 <chMtxUnlock+0xf8>
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 800aa4a:	68fb      	ldr	r3, [r7, #12]
 800aa4c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800aa4e:	687b      	ldr	r3, [r7, #4]
 800aa50:	429a      	cmp	r2, r3
 800aa52:	d002      	beq.n	800aa5a <chMtxUnlock+0x6e>
 800aa54:	4827      	ldr	r0, [pc, #156]	; (800aaf4 <chMtxUnlock+0x108>)
 800aa56:	f000 f9d3 	bl	800ae00 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 800aa5a:	687b      	ldr	r3, [r7, #4]
 800aa5c:	68da      	ldr	r2, [r3, #12]
 800aa5e:	68fb      	ldr	r3, [r7, #12]
 800aa60:	62da      	str	r2, [r3, #44]	; 0x2c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800aa62:	6878      	ldr	r0, [r7, #4]
 800aa64:	f7ff ff02 	bl	800a86c <chMtxQueueNotEmptyS>
 800aa68:	4603      	mov	r3, r0
 800aa6a:	2b00      	cmp	r3, #0
 800aa6c:	d037      	beq.n	800aade <chMtxUnlock+0xf2>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 800aa6e:	68fb      	ldr	r3, [r7, #12]
 800aa70:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800aa72:	613b      	str	r3, [r7, #16]
      lmp = ctp->mtxlist;
 800aa74:	68fb      	ldr	r3, [r7, #12]
 800aa76:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aa78:	617b      	str	r3, [r7, #20]
 800aa7a:	e012      	b.n	800aaa2 <chMtxUnlock+0xb6>
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800aa7c:	6978      	ldr	r0, [r7, #20]
 800aa7e:	f7ff fef5 	bl	800a86c <chMtxQueueNotEmptyS>
 800aa82:	4603      	mov	r3, r0
 800aa84:	2b00      	cmp	r3, #0
 800aa86:	d009      	beq.n	800aa9c <chMtxUnlock+0xb0>
            (lmp->queue.next->prio > newprio)) {
 800aa88:	697b      	ldr	r3, [r7, #20]
 800aa8a:	681b      	ldr	r3, [r3, #0]
 800aa8c:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800aa8e:	693b      	ldr	r3, [r7, #16]
 800aa90:	429a      	cmp	r2, r3
 800aa92:	d903      	bls.n	800aa9c <chMtxUnlock+0xb0>
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
 800aa94:	697b      	ldr	r3, [r7, #20]
 800aa96:	681b      	ldr	r3, [r3, #0]
 800aa98:	689b      	ldr	r3, [r3, #8]
 800aa9a:	613b      	str	r3, [r7, #16]
        }
        lmp = lmp->next;
 800aa9c:	697b      	ldr	r3, [r7, #20]
 800aa9e:	68db      	ldr	r3, [r3, #12]
 800aaa0:	617b      	str	r3, [r7, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 800aaa2:	697b      	ldr	r3, [r7, #20]
 800aaa4:	2b00      	cmp	r3, #0
 800aaa6:	d1e9      	bne.n	800aa7c <chMtxUnlock+0x90>
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 800aaa8:	68fb      	ldr	r3, [r7, #12]
 800aaaa:	693a      	ldr	r2, [r7, #16]
 800aaac:	609a      	str	r2, [r3, #8]

      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
 800aaae:	687b      	ldr	r3, [r7, #4]
 800aab0:	2201      	movs	r2, #1
 800aab2:	611a      	str	r2, [r3, #16]
#endif
      tp = queue_fifo_remove(&mp->queue);
 800aab4:	687b      	ldr	r3, [r7, #4]
 800aab6:	4618      	mov	r0, r3
 800aab8:	f000 fcde 	bl	800b478 <queue_fifo_remove>
 800aabc:	60b8      	str	r0, [r7, #8]
      mp->owner = tp;
 800aabe:	687b      	ldr	r3, [r7, #4]
 800aac0:	68ba      	ldr	r2, [r7, #8]
 800aac2:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 800aac4:	68bb      	ldr	r3, [r7, #8]
 800aac6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800aac8:	687b      	ldr	r3, [r7, #4]
 800aaca:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 800aacc:	68bb      	ldr	r3, [r7, #8]
 800aace:	687a      	ldr	r2, [r7, #4]
 800aad0:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 800aad2:	68b8      	ldr	r0, [r7, #8]
 800aad4:	f000 fd0e 	bl	800b4f4 <chSchReadyI>
      chSchRescheduleS();
 800aad8:	f000 fe72 	bl	800b7c0 <chSchRescheduleS>
 800aadc:	e002      	b.n	800aae4 <chMtxUnlock+0xf8>
    }
    else {
      mp->owner = NULL;
 800aade:	687b      	ldr	r3, [r7, #4]
 800aae0:	2200      	movs	r2, #0
 800aae2:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 800aae4:	f7ff fea6 	bl	800a834 <chSysUnlock.lto_priv.272>
}
 800aae8:	3718      	adds	r7, #24
 800aaea:	46bd      	mov	sp, r7
 800aaec:	bd80      	pop	{r7, pc}
 800aaee:	bf00      	nop
 800aaf0:	20001338 	.word	0x20001338
 800aaf4:	0800e9d0 	.word	0x0800e9d0

0800aaf8 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 800aaf8:	b580      	push	{r7, lr}
 800aafa:	b086      	sub	sp, #24
 800aafc:	af00      	add	r7, sp, #0
 800aafe:	6078      	str	r0, [r7, #4]
  thread_t *ctp = currp;
 800ab00:	4b3c      	ldr	r3, [pc, #240]	; (800abf4 <chMtxUnlockS+0xfc>)
 800ab02:	699b      	ldr	r3, [r3, #24]
 800ab04:	60fb      	str	r3, [r7, #12]
  mutex_t *lmp;

  chDbgCheckClassS();
 800ab06:	f000 fa6b 	bl	800afe0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 800ab0a:	687b      	ldr	r3, [r7, #4]
 800ab0c:	2b00      	cmp	r3, #0
 800ab0e:	d102      	bne.n	800ab16 <chMtxUnlockS+0x1e>
 800ab10:	4839      	ldr	r0, [pc, #228]	; (800abf8 <chMtxUnlockS+0x100>)
 800ab12:	f000 f975 	bl	800ae00 <chSysHalt>

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 800ab16:	68fb      	ldr	r3, [r7, #12]
 800ab18:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ab1a:	2b00      	cmp	r3, #0
 800ab1c:	d102      	bne.n	800ab24 <chMtxUnlockS+0x2c>
 800ab1e:	4836      	ldr	r0, [pc, #216]	; (800abf8 <chMtxUnlockS+0x100>)
 800ab20:	f000 f96e 	bl	800ae00 <chSysHalt>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 800ab24:	68fb      	ldr	r3, [r7, #12]
 800ab26:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ab28:	689a      	ldr	r2, [r3, #8]
 800ab2a:	68fb      	ldr	r3, [r7, #12]
 800ab2c:	429a      	cmp	r2, r3
 800ab2e:	d002      	beq.n	800ab36 <chMtxUnlockS+0x3e>
 800ab30:	4831      	ldr	r0, [pc, #196]	; (800abf8 <chMtxUnlockS+0x100>)
 800ab32:	f000 f965 	bl	800ae00 <chSysHalt>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");
 800ab36:	687b      	ldr	r3, [r7, #4]
 800ab38:	691b      	ldr	r3, [r3, #16]
 800ab3a:	2b00      	cmp	r3, #0
 800ab3c:	dc02      	bgt.n	800ab44 <chMtxUnlockS+0x4c>
 800ab3e:	482e      	ldr	r0, [pc, #184]	; (800abf8 <chMtxUnlockS+0x100>)
 800ab40:	f000 f95e 	bl	800ae00 <chSysHalt>

  if (--mp->cnt == (cnt_t)0) {
 800ab44:	687b      	ldr	r3, [r7, #4]
 800ab46:	691b      	ldr	r3, [r3, #16]
 800ab48:	1e5a      	subs	r2, r3, #1
 800ab4a:	687b      	ldr	r3, [r7, #4]
 800ab4c:	611a      	str	r2, [r3, #16]
 800ab4e:	687b      	ldr	r3, [r7, #4]
 800ab50:	691b      	ldr	r3, [r3, #16]
 800ab52:	2b00      	cmp	r3, #0
 800ab54:	d14a      	bne.n	800abec <chMtxUnlockS+0xf4>
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 800ab56:	68fb      	ldr	r3, [r7, #12]
 800ab58:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ab5a:	687b      	ldr	r3, [r7, #4]
 800ab5c:	429a      	cmp	r2, r3
 800ab5e:	d002      	beq.n	800ab66 <chMtxUnlockS+0x6e>
 800ab60:	4825      	ldr	r0, [pc, #148]	; (800abf8 <chMtxUnlockS+0x100>)
 800ab62:	f000 f94d 	bl	800ae00 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 800ab66:	687b      	ldr	r3, [r7, #4]
 800ab68:	68da      	ldr	r2, [r3, #12]
 800ab6a:	68fb      	ldr	r3, [r7, #12]
 800ab6c:	62da      	str	r2, [r3, #44]	; 0x2c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800ab6e:	6878      	ldr	r0, [r7, #4]
 800ab70:	f7ff fe7c 	bl	800a86c <chMtxQueueNotEmptyS>
 800ab74:	4603      	mov	r3, r0
 800ab76:	2b00      	cmp	r3, #0
 800ab78:	d035      	beq.n	800abe6 <chMtxUnlockS+0xee>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 800ab7a:	68fb      	ldr	r3, [r7, #12]
 800ab7c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ab7e:	613b      	str	r3, [r7, #16]
      lmp = ctp->mtxlist;
 800ab80:	68fb      	ldr	r3, [r7, #12]
 800ab82:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ab84:	617b      	str	r3, [r7, #20]
 800ab86:	e012      	b.n	800abae <chMtxUnlockS+0xb6>
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800ab88:	6978      	ldr	r0, [r7, #20]
 800ab8a:	f7ff fe6f 	bl	800a86c <chMtxQueueNotEmptyS>
 800ab8e:	4603      	mov	r3, r0
 800ab90:	2b00      	cmp	r3, #0
 800ab92:	d009      	beq.n	800aba8 <chMtxUnlockS+0xb0>
            (lmp->queue.next->prio > newprio)) {
 800ab94:	697b      	ldr	r3, [r7, #20]
 800ab96:	681b      	ldr	r3, [r3, #0]
 800ab98:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800ab9a:	693b      	ldr	r3, [r7, #16]
 800ab9c:	429a      	cmp	r2, r3
 800ab9e:	d903      	bls.n	800aba8 <chMtxUnlockS+0xb0>
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
 800aba0:	697b      	ldr	r3, [r7, #20]
 800aba2:	681b      	ldr	r3, [r3, #0]
 800aba4:	689b      	ldr	r3, [r3, #8]
 800aba6:	613b      	str	r3, [r7, #16]
        }
        lmp = lmp->next;
 800aba8:	697b      	ldr	r3, [r7, #20]
 800abaa:	68db      	ldr	r3, [r3, #12]
 800abac:	617b      	str	r3, [r7, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 800abae:	697b      	ldr	r3, [r7, #20]
 800abb0:	2b00      	cmp	r3, #0
 800abb2:	d1e9      	bne.n	800ab88 <chMtxUnlockS+0x90>
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 800abb4:	68fb      	ldr	r3, [r7, #12]
 800abb6:	693a      	ldr	r2, [r7, #16]
 800abb8:	609a      	str	r2, [r3, #8]

      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
 800abba:	687b      	ldr	r3, [r7, #4]
 800abbc:	2201      	movs	r2, #1
 800abbe:	611a      	str	r2, [r3, #16]
#endif
      tp = queue_fifo_remove(&mp->queue);
 800abc0:	687b      	ldr	r3, [r7, #4]
 800abc2:	4618      	mov	r0, r3
 800abc4:	f000 fc58 	bl	800b478 <queue_fifo_remove>
 800abc8:	60b8      	str	r0, [r7, #8]
      mp->owner = tp;
 800abca:	687b      	ldr	r3, [r7, #4]
 800abcc:	68ba      	ldr	r2, [r7, #8]
 800abce:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 800abd0:	68bb      	ldr	r3, [r7, #8]
 800abd2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800abd4:	687b      	ldr	r3, [r7, #4]
 800abd6:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 800abd8:	68bb      	ldr	r3, [r7, #8]
 800abda:	687a      	ldr	r2, [r7, #4]
 800abdc:	62da      	str	r2, [r3, #44]	; 0x2c
      (void) chSchReadyI(tp);
 800abde:	68b8      	ldr	r0, [r7, #8]
 800abe0:	f000 fc88 	bl	800b4f4 <chSchReadyI>
 800abe4:	e002      	b.n	800abec <chMtxUnlockS+0xf4>
    }
    else {
      mp->owner = NULL;
 800abe6:	687b      	ldr	r3, [r7, #4]
 800abe8:	2200      	movs	r2, #0
 800abea:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 800abec:	3718      	adds	r7, #24
 800abee:	46bd      	mov	sp, r7
 800abf0:	bd80      	pop	{r7, pc}
 800abf2:	bf00      	nop
 800abf4:	20001338 	.word	0x20001338
 800abf8:	0800e9dc 	.word	0x0800e9dc

0800abfc <port_lock.lto_priv.268>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800abfc:	b480      	push	{r7}
 800abfe:	b083      	sub	sp, #12
 800ac00:	af00      	add	r7, sp, #0
 800ac02:	2320      	movs	r3, #32
 800ac04:	607b      	str	r3, [r7, #4]
 800ac06:	687b      	ldr	r3, [r7, #4]
 800ac08:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800ac0c:	370c      	adds	r7, #12
 800ac0e:	46bd      	mov	sp, r7
 800ac10:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ac14:	4770      	bx	lr
 800ac16:	bf00      	nop

0800ac18 <port_unlock.lto_priv.264>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800ac18:	b480      	push	{r7}
 800ac1a:	b083      	sub	sp, #12
 800ac1c:	af00      	add	r7, sp, #0
 800ac1e:	2300      	movs	r3, #0
 800ac20:	607b      	str	r3, [r7, #4]
 800ac22:	687b      	ldr	r3, [r7, #4]
 800ac24:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800ac28:	370c      	adds	r7, #12
 800ac2a:	46bd      	mov	sp, r7
 800ac2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ac30:	4770      	bx	lr
 800ac32:	bf00      	nop

0800ac34 <queue_init.lto_priv.260>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 800ac34:	b480      	push	{r7}
 800ac36:	b083      	sub	sp, #12
 800ac38:	af00      	add	r7, sp, #0
 800ac3a:	6078      	str	r0, [r7, #4]

  tqp->next = (thread_t *)tqp;
 800ac3c:	687b      	ldr	r3, [r7, #4]
 800ac3e:	687a      	ldr	r2, [r7, #4]
 800ac40:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800ac42:	687b      	ldr	r3, [r7, #4]
 800ac44:	687a      	ldr	r2, [r7, #4]
 800ac46:	605a      	str	r2, [r3, #4]
}
 800ac48:	370c      	adds	r7, #12
 800ac4a:	46bd      	mov	sp, r7
 800ac4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ac50:	4770      	bx	lr
 800ac52:	bf00      	nop

0800ac54 <chSysLock.lto_priv.220>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800ac54:	b580      	push	{r7, lr}
 800ac56:	af00      	add	r7, sp, #0

  port_lock();
 800ac58:	f7ff ffd0 	bl	800abfc <port_lock.lto_priv.268>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800ac5c:	f000 f91e 	bl	800ae9c <_dbg_check_lock>
}
 800ac60:	bd80      	pop	{r7, pc}
 800ac62:	bf00      	nop

0800ac64 <chSysUnlock.lto_priv.215>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800ac64:	b580      	push	{r7, lr}
 800ac66:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 800ac68:	f000 f92e 	bl	800aec8 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800ac6c:	4b09      	ldr	r3, [pc, #36]	; (800ac94 <chSysUnlock.lto_priv.215+0x30>)
 800ac6e:	681b      	ldr	r3, [r3, #0]
 800ac70:	4a08      	ldr	r2, [pc, #32]	; (800ac94 <chSysUnlock.lto_priv.215+0x30>)
 800ac72:	4293      	cmp	r3, r2
 800ac74:	d00a      	beq.n	800ac8c <chSysUnlock.lto_priv.215+0x28>
 800ac76:	4b07      	ldr	r3, [pc, #28]	; (800ac94 <chSysUnlock.lto_priv.215+0x30>)
 800ac78:	699b      	ldr	r3, [r3, #24]
 800ac7a:	689a      	ldr	r2, [r3, #8]
 800ac7c:	4b05      	ldr	r3, [pc, #20]	; (800ac94 <chSysUnlock.lto_priv.215+0x30>)
 800ac7e:	681b      	ldr	r3, [r3, #0]
 800ac80:	689b      	ldr	r3, [r3, #8]
 800ac82:	429a      	cmp	r2, r3
 800ac84:	d202      	bcs.n	800ac8c <chSysUnlock.lto_priv.215+0x28>
 800ac86:	4804      	ldr	r0, [pc, #16]	; (800ac98 <chSysUnlock.lto_priv.215+0x34>)
 800ac88:	f000 f8ba 	bl	800ae00 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 800ac8c:	f7ff ffc4 	bl	800ac18 <port_unlock.lto_priv.264>
}
 800ac90:	bd80      	pop	{r7, pc}
 800ac92:	bf00      	nop
 800ac94:	20001338 	.word	0x20001338
 800ac98:	0800e9fc 	.word	0x0800e9fc

0800ac9c <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 800ac9c:	b580      	push	{r7, lr}
 800ac9e:	b082      	sub	sp, #8
 800aca0:	af00      	add	r7, sp, #0
 800aca2:	6078      	str	r0, [r7, #4]

  queue_init(tqp);
 800aca4:	6878      	ldr	r0, [r7, #4]
 800aca6:	f7ff ffc5 	bl	800ac34 <queue_init.lto_priv.260>
}
 800acaa:	3708      	adds	r7, #8
 800acac:	46bd      	mov	sp, r7
 800acae:	bd80      	pop	{r7, pc}

0800acb0 <chMBGetSizeI>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The size of the mailbox.
 *
 * @iclass
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {
 800acb0:	b480      	push	{r7}
 800acb2:	b083      	sub	sp, #12
 800acb4:	af00      	add	r7, sp, #0
 800acb6:	6078      	str	r0, [r7, #4]

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 800acb8:	687b      	ldr	r3, [r7, #4]
 800acba:	685b      	ldr	r3, [r3, #4]
 800acbc:	461a      	mov	r2, r3
 800acbe:	687b      	ldr	r3, [r7, #4]
 800acc0:	681b      	ldr	r3, [r3, #0]
 800acc2:	1ad3      	subs	r3, r2, r3
 800acc4:	109b      	asrs	r3, r3, #2
  /*lint -restore*/
}
 800acc6:	4618      	mov	r0, r3
 800acc8:	370c      	adds	r7, #12
 800acca:	46bd      	mov	sp, r7
 800accc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800acd0:	4770      	bx	lr
 800acd2:	bf00      	nop

0800acd4 <chMBGetUsedCountI.lto_priv.254>:
 * @return              The number of queued messages.
 * @retval QUEUE_RESET  if the queue is in reset state.
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(const mailbox_t *mbp) {
 800acd4:	b580      	push	{r7, lr}
 800acd6:	b082      	sub	sp, #8
 800acd8:	af00      	add	r7, sp, #0
 800acda:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 800acdc:	f000 f96e 	bl	800afbc <chDbgCheckClassI>

  return mbp->cnt;
 800ace0:	687b      	ldr	r3, [r7, #4]
 800ace2:	691b      	ldr	r3, [r3, #16]
}
 800ace4:	4618      	mov	r0, r3
 800ace6:	3708      	adds	r7, #8
 800ace8:	46bd      	mov	sp, r7
 800acea:	bd80      	pop	{r7, pc}

0800acec <chMBGetFreeCountI.lto_priv.255>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {
 800acec:	b590      	push	{r4, r7, lr}
 800acee:	b083      	sub	sp, #12
 800acf0:	af00      	add	r7, sp, #0
 800acf2:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 800acf4:	f000 f962 	bl	800afbc <chDbgCheckClassI>

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800acf8:	6878      	ldr	r0, [r7, #4]
 800acfa:	f7ff ffd9 	bl	800acb0 <chMBGetSizeI>
 800acfe:	4604      	mov	r4, r0
 800ad00:	6878      	ldr	r0, [r7, #4]
 800ad02:	f7ff ffe7 	bl	800acd4 <chMBGetUsedCountI.lto_priv.254>
 800ad06:	4603      	mov	r3, r0
 800ad08:	1ae3      	subs	r3, r4, r3
}
 800ad0a:	4618      	mov	r0, r3
 800ad0c:	370c      	adds	r7, #12
 800ad0e:	46bd      	mov	sp, r7
 800ad10:	bd90      	pop	{r4, r7, pc}
 800ad12:	bf00      	nop

0800ad14 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
 800ad14:	b580      	push	{r7, lr}
 800ad16:	b084      	sub	sp, #16
 800ad18:	af00      	add	r7, sp, #0
 800ad1a:	60f8      	str	r0, [r7, #12]
 800ad1c:	60b9      	str	r1, [r7, #8]
 800ad1e:	607a      	str	r2, [r7, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));
 800ad20:	68fb      	ldr	r3, [r7, #12]
 800ad22:	2b00      	cmp	r3, #0
 800ad24:	d005      	beq.n	800ad32 <chMBObjectInit+0x1e>
 800ad26:	68bb      	ldr	r3, [r7, #8]
 800ad28:	2b00      	cmp	r3, #0
 800ad2a:	d002      	beq.n	800ad32 <chMBObjectInit+0x1e>
 800ad2c:	687b      	ldr	r3, [r7, #4]
 800ad2e:	2b00      	cmp	r3, #0
 800ad30:	dc02      	bgt.n	800ad38 <chMBObjectInit+0x24>
 800ad32:	4812      	ldr	r0, [pc, #72]	; (800ad7c <chMBObjectInit+0x68>)
 800ad34:	f000 f864 	bl	800ae00 <chSysHalt>

  mbp->buffer = buf;
 800ad38:	68fb      	ldr	r3, [r7, #12]
 800ad3a:	68ba      	ldr	r2, [r7, #8]
 800ad3c:	601a      	str	r2, [r3, #0]
  mbp->rdptr  = buf;
 800ad3e:	68fb      	ldr	r3, [r7, #12]
 800ad40:	68ba      	ldr	r2, [r7, #8]
 800ad42:	60da      	str	r2, [r3, #12]
  mbp->wrptr  = buf;
 800ad44:	68fb      	ldr	r3, [r7, #12]
 800ad46:	68ba      	ldr	r2, [r7, #8]
 800ad48:	609a      	str	r2, [r3, #8]
  mbp->top    = &buf[n];
 800ad4a:	687b      	ldr	r3, [r7, #4]
 800ad4c:	009b      	lsls	r3, r3, #2
 800ad4e:	68ba      	ldr	r2, [r7, #8]
 800ad50:	441a      	add	r2, r3
 800ad52:	68fb      	ldr	r3, [r7, #12]
 800ad54:	605a      	str	r2, [r3, #4]
  mbp->cnt    = (cnt_t)0;
 800ad56:	68fb      	ldr	r3, [r7, #12]
 800ad58:	2200      	movs	r2, #0
 800ad5a:	611a      	str	r2, [r3, #16]
  mbp->reset  = false;
 800ad5c:	68fb      	ldr	r3, [r7, #12]
 800ad5e:	2200      	movs	r2, #0
 800ad60:	751a      	strb	r2, [r3, #20]
  chThdQueueObjectInit(&mbp->qw);
 800ad62:	68fb      	ldr	r3, [r7, #12]
 800ad64:	3318      	adds	r3, #24
 800ad66:	4618      	mov	r0, r3
 800ad68:	f7ff ff98 	bl	800ac9c <chThdQueueObjectInit>
  chThdQueueObjectInit(&mbp->qr);
 800ad6c:	68fb      	ldr	r3, [r7, #12]
 800ad6e:	3320      	adds	r3, #32
 800ad70:	4618      	mov	r0, r3
 800ad72:	f7ff ff93 	bl	800ac9c <chThdQueueObjectInit>
}
 800ad76:	3710      	adds	r7, #16
 800ad78:	46bd      	mov	sp, r7
 800ad7a:	bd80      	pop	{r7, pc}
 800ad7c:	0800e9ec 	.word	0x0800e9ec

0800ad80 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 800ad80:	b580      	push	{r7, lr}
 800ad82:	b082      	sub	sp, #8
 800ad84:	af00      	add	r7, sp, #0
 800ad86:	6078      	str	r0, [r7, #4]
 800ad88:	6039      	str	r1, [r7, #0]

  chDbgCheckClassI();
 800ad8a:	f000 f917 	bl	800afbc <chDbgCheckClassI>
  chDbgCheck(mbp != NULL);
 800ad8e:	687b      	ldr	r3, [r7, #4]
 800ad90:	2b00      	cmp	r3, #0
 800ad92:	d102      	bne.n	800ad9a <chMBPostI+0x1a>
 800ad94:	4819      	ldr	r0, [pc, #100]	; (800adfc <chMBPostI+0x7c>)
 800ad96:	f000 f833 	bl	800ae00 <chSysHalt>

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 800ad9a:	687b      	ldr	r3, [r7, #4]
 800ad9c:	7d1b      	ldrb	r3, [r3, #20]
 800ad9e:	2b00      	cmp	r3, #0
 800ada0:	d002      	beq.n	800ada8 <chMBPostI+0x28>
    return MSG_RESET;
 800ada2:	f06f 0301 	mvn.w	r3, #1
 800ada6:	e025      	b.n	800adf4 <chMBPostI+0x74>
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
 800ada8:	6878      	ldr	r0, [r7, #4]
 800adaa:	f7ff ff9f 	bl	800acec <chMBGetFreeCountI.lto_priv.255>
 800adae:	4603      	mov	r3, r0
 800adb0:	2b00      	cmp	r3, #0
 800adb2:	dd1d      	ble.n	800adf0 <chMBPostI+0x70>
    *mbp->wrptr++ = msg;
 800adb4:	687b      	ldr	r3, [r7, #4]
 800adb6:	689b      	ldr	r3, [r3, #8]
 800adb8:	1d19      	adds	r1, r3, #4
 800adba:	687a      	ldr	r2, [r7, #4]
 800adbc:	6091      	str	r1, [r2, #8]
 800adbe:	683a      	ldr	r2, [r7, #0]
 800adc0:	601a      	str	r2, [r3, #0]
    if (mbp->wrptr >= mbp->top) {
 800adc2:	687b      	ldr	r3, [r7, #4]
 800adc4:	689a      	ldr	r2, [r3, #8]
 800adc6:	687b      	ldr	r3, [r7, #4]
 800adc8:	685b      	ldr	r3, [r3, #4]
 800adca:	429a      	cmp	r2, r3
 800adcc:	d303      	bcc.n	800add6 <chMBPostI+0x56>
      mbp->wrptr = mbp->buffer;
 800adce:	687b      	ldr	r3, [r7, #4]
 800add0:	681a      	ldr	r2, [r3, #0]
 800add2:	687b      	ldr	r3, [r7, #4]
 800add4:	609a      	str	r2, [r3, #8]
    }
    mbp->cnt++;
 800add6:	687b      	ldr	r3, [r7, #4]
 800add8:	691b      	ldr	r3, [r3, #16]
 800adda:	1c5a      	adds	r2, r3, #1
 800addc:	687b      	ldr	r3, [r7, #4]
 800adde:	611a      	str	r2, [r3, #16]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 800ade0:	687b      	ldr	r3, [r7, #4]
 800ade2:	3320      	adds	r3, #32
 800ade4:	4618      	mov	r0, r3
 800ade6:	2100      	movs	r1, #0
 800ade8:	f7ff fc1c 	bl	800a624 <chThdDequeueNextI>

    return MSG_OK;
 800adec:	2300      	movs	r3, #0
 800adee:	e001      	b.n	800adf4 <chMBPostI+0x74>
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
 800adf0:	f04f 33ff 	mov.w	r3, #4294967295
}
 800adf4:	4618      	mov	r0, r3
 800adf6:	3708      	adds	r7, #8
 800adf8:	46bd      	mov	sp, r7
 800adfa:	bd80      	pop	{r7, pc}
 800adfc:	0800ea08 	.word	0x0800ea08

0800ae00 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 800ae00:	b580      	push	{r7, lr}
 800ae02:	b082      	sub	sp, #8
 800ae04:	af00      	add	r7, sp, #0
 800ae06:	6078      	str	r0, [r7, #4]

  port_disable();
 800ae08:	f001 fcba 	bl	800c780 <port_disable.lto_priv.335>

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800ae0c:	4a01      	ldr	r2, [pc, #4]	; (800ae14 <chSysHalt+0x14>)
 800ae0e:	687b      	ldr	r3, [r7, #4]
 800ae10:	6293      	str	r3, [r2, #40]	; 0x28
 800ae12:	e7fe      	b.n	800ae12 <chSysHalt+0x12>
 800ae14:	20001338 	.word	0x20001338

0800ae18 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 800ae18:	b580      	push	{r7, lr}
 800ae1a:	af00      	add	r7, sp, #0

  chDbgCheckClassI();
 800ae1c:	f000 f8ce 	bl	800afbc <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
 800ae20:	f001 fd10 	bl	800c844 <chVTDoTickI.lto_priv.334>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 800ae24:	bd80      	pop	{r7, pc}
 800ae26:	bf00      	nop

0800ae28 <port_lock.lto_priv.316>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800ae28:	b480      	push	{r7}
 800ae2a:	b083      	sub	sp, #12
 800ae2c:	af00      	add	r7, sp, #0
 800ae2e:	2320      	movs	r3, #32
 800ae30:	607b      	str	r3, [r7, #4]
 800ae32:	687b      	ldr	r3, [r7, #4]
 800ae34:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800ae38:	370c      	adds	r7, #12
 800ae3a:	46bd      	mov	sp, r7
 800ae3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ae40:	4770      	bx	lr
 800ae42:	bf00      	nop

0800ae44 <port_unlock.lto_priv.313>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800ae44:	b480      	push	{r7}
 800ae46:	b083      	sub	sp, #12
 800ae48:	af00      	add	r7, sp, #0
 800ae4a:	2300      	movs	r3, #0
 800ae4c:	607b      	str	r3, [r7, #4]
 800ae4e:	687b      	ldr	r3, [r7, #4]
 800ae50:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800ae54:	370c      	adds	r7, #12
 800ae56:	46bd      	mov	sp, r7
 800ae58:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ae5c:	4770      	bx	lr
 800ae5e:	bf00      	nop

0800ae60 <port_lock_from_isr.lto_priv.326>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800ae60:	b580      	push	{r7, lr}
 800ae62:	af00      	add	r7, sp, #0

  port_lock();
 800ae64:	f7ff ffe0 	bl	800ae28 <port_lock.lto_priv.316>
}
 800ae68:	bd80      	pop	{r7, pc}
 800ae6a:	bf00      	nop

0800ae6c <port_unlock_from_isr.lto_priv.324>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800ae6c:	b580      	push	{r7, lr}
 800ae6e:	af00      	add	r7, sp, #0

  port_unlock();
 800ae70:	f7ff ffe8 	bl	800ae44 <port_unlock.lto_priv.313>
}
 800ae74:	bd80      	pop	{r7, pc}
 800ae76:	bf00      	nop

0800ae78 <_dbg_check_enable>:
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
 800ae78:	b580      	push	{r7, lr}
 800ae7a:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800ae7c:	4b05      	ldr	r3, [pc, #20]	; (800ae94 <_dbg_check_enable+0x1c>)
 800ae7e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ae80:	2b00      	cmp	r3, #0
 800ae82:	d103      	bne.n	800ae8c <_dbg_check_enable+0x14>
 800ae84:	4b03      	ldr	r3, [pc, #12]	; (800ae94 <_dbg_check_enable+0x1c>)
 800ae86:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ae88:	2b00      	cmp	r3, #0
 800ae8a:	d002      	beq.n	800ae92 <_dbg_check_enable+0x1a>
    chSysHalt("SV#3");
 800ae8c:	4802      	ldr	r0, [pc, #8]	; (800ae98 <_dbg_check_enable+0x20>)
 800ae8e:	f7ff ffb7 	bl	800ae00 <chSysHalt>
  }
}
 800ae92:	bd80      	pop	{r7, pc}
 800ae94:	20001338 	.word	0x20001338
 800ae98:	0800e680 	.word	0x0800e680

0800ae9c <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 800ae9c:	b580      	push	{r7, lr}
 800ae9e:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800aea0:	4b07      	ldr	r3, [pc, #28]	; (800aec0 <_dbg_check_lock+0x24>)
 800aea2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aea4:	2b00      	cmp	r3, #0
 800aea6:	d103      	bne.n	800aeb0 <_dbg_check_lock+0x14>
 800aea8:	4b05      	ldr	r3, [pc, #20]	; (800aec0 <_dbg_check_lock+0x24>)
 800aeaa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800aeac:	2b00      	cmp	r3, #0
 800aeae:	d002      	beq.n	800aeb6 <_dbg_check_lock+0x1a>
    chSysHalt("SV#4");
 800aeb0:	4804      	ldr	r0, [pc, #16]	; (800aec4 <_dbg_check_lock+0x28>)
 800aeb2:	f7ff ffa5 	bl	800ae00 <chSysHalt>
  }
  _dbg_enter_lock();
 800aeb6:	4b02      	ldr	r3, [pc, #8]	; (800aec0 <_dbg_check_lock+0x24>)
 800aeb8:	2201      	movs	r2, #1
 800aeba:	631a      	str	r2, [r3, #48]	; 0x30
}
 800aebc:	bd80      	pop	{r7, pc}
 800aebe:	bf00      	nop
 800aec0:	20001338 	.word	0x20001338
 800aec4:	0800e688 	.word	0x0800e688

0800aec8 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 800aec8:	b580      	push	{r7, lr}
 800aeca:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800aecc:	4b07      	ldr	r3, [pc, #28]	; (800aeec <_dbg_check_unlock+0x24>)
 800aece:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aed0:	2b00      	cmp	r3, #0
 800aed2:	d103      	bne.n	800aedc <_dbg_check_unlock+0x14>
 800aed4:	4b05      	ldr	r3, [pc, #20]	; (800aeec <_dbg_check_unlock+0x24>)
 800aed6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800aed8:	2b00      	cmp	r3, #0
 800aeda:	dc02      	bgt.n	800aee2 <_dbg_check_unlock+0x1a>
    chSysHalt("SV#5");
 800aedc:	4804      	ldr	r0, [pc, #16]	; (800aef0 <_dbg_check_unlock+0x28>)
 800aede:	f7ff ff8f 	bl	800ae00 <chSysHalt>
  }
  _dbg_leave_lock();
 800aee2:	4b02      	ldr	r3, [pc, #8]	; (800aeec <_dbg_check_unlock+0x24>)
 800aee4:	2200      	movs	r2, #0
 800aee6:	631a      	str	r2, [r3, #48]	; 0x30
}
 800aee8:	bd80      	pop	{r7, pc}
 800aeea:	bf00      	nop
 800aeec:	20001338 	.word	0x20001338
 800aef0:	0800e690 	.word	0x0800e690

0800aef4 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
 800aef4:	b580      	push	{r7, lr}
 800aef6:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800aef8:	4b07      	ldr	r3, [pc, #28]	; (800af18 <_dbg_check_lock_from_isr+0x24>)
 800aefa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aefc:	2b00      	cmp	r3, #0
 800aefe:	dd03      	ble.n	800af08 <_dbg_check_lock_from_isr+0x14>
 800af00:	4b05      	ldr	r3, [pc, #20]	; (800af18 <_dbg_check_lock_from_isr+0x24>)
 800af02:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800af04:	2b00      	cmp	r3, #0
 800af06:	d002      	beq.n	800af0e <_dbg_check_lock_from_isr+0x1a>
    chSysHalt("SV#6");
 800af08:	4804      	ldr	r0, [pc, #16]	; (800af1c <_dbg_check_lock_from_isr+0x28>)
 800af0a:	f7ff ff79 	bl	800ae00 <chSysHalt>
  }
  _dbg_enter_lock();
 800af0e:	4b02      	ldr	r3, [pc, #8]	; (800af18 <_dbg_check_lock_from_isr+0x24>)
 800af10:	2201      	movs	r2, #1
 800af12:	631a      	str	r2, [r3, #48]	; 0x30
}
 800af14:	bd80      	pop	{r7, pc}
 800af16:	bf00      	nop
 800af18:	20001338 	.word	0x20001338
 800af1c:	0800e698 	.word	0x0800e698

0800af20 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
 800af20:	b580      	push	{r7, lr}
 800af22:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800af24:	4b07      	ldr	r3, [pc, #28]	; (800af44 <_dbg_check_unlock_from_isr+0x24>)
 800af26:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800af28:	2b00      	cmp	r3, #0
 800af2a:	dd03      	ble.n	800af34 <_dbg_check_unlock_from_isr+0x14>
 800af2c:	4b05      	ldr	r3, [pc, #20]	; (800af44 <_dbg_check_unlock_from_isr+0x24>)
 800af2e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800af30:	2b00      	cmp	r3, #0
 800af32:	dc02      	bgt.n	800af3a <_dbg_check_unlock_from_isr+0x1a>
    chSysHalt("SV#7");
 800af34:	4804      	ldr	r0, [pc, #16]	; (800af48 <_dbg_check_unlock_from_isr+0x28>)
 800af36:	f7ff ff63 	bl	800ae00 <chSysHalt>
  }
  _dbg_leave_lock();
 800af3a:	4b02      	ldr	r3, [pc, #8]	; (800af44 <_dbg_check_unlock_from_isr+0x24>)
 800af3c:	2200      	movs	r2, #0
 800af3e:	631a      	str	r2, [r3, #48]	; 0x30
}
 800af40:	bd80      	pop	{r7, pc}
 800af42:	bf00      	nop
 800af44:	20001338 	.word	0x20001338
 800af48:	0800e6a0 	.word	0x0800e6a0

0800af4c <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
 800af4c:	b580      	push	{r7, lr}
 800af4e:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 800af50:	f7ff ff86 	bl	800ae60 <port_lock_from_isr.lto_priv.326>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800af54:	4b09      	ldr	r3, [pc, #36]	; (800af7c <_dbg_check_enter_isr+0x30>)
 800af56:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800af58:	2b00      	cmp	r3, #0
 800af5a:	db03      	blt.n	800af64 <_dbg_check_enter_isr+0x18>
 800af5c:	4b07      	ldr	r3, [pc, #28]	; (800af7c <_dbg_check_enter_isr+0x30>)
 800af5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800af60:	2b00      	cmp	r3, #0
 800af62:	d002      	beq.n	800af6a <_dbg_check_enter_isr+0x1e>
    chSysHalt("SV#8");
 800af64:	4806      	ldr	r0, [pc, #24]	; (800af80 <_dbg_check_enter_isr+0x34>)
 800af66:	f7ff ff4b 	bl	800ae00 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 800af6a:	4b04      	ldr	r3, [pc, #16]	; (800af7c <_dbg_check_enter_isr+0x30>)
 800af6c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800af6e:	3301      	adds	r3, #1
 800af70:	4a02      	ldr	r2, [pc, #8]	; (800af7c <_dbg_check_enter_isr+0x30>)
 800af72:	62d3      	str	r3, [r2, #44]	; 0x2c
  port_unlock_from_isr();
 800af74:	f7ff ff7a 	bl	800ae6c <port_unlock_from_isr.lto_priv.324>
}
 800af78:	bd80      	pop	{r7, pc}
 800af7a:	bf00      	nop
 800af7c:	20001338 	.word	0x20001338
 800af80:	0800e6a8 	.word	0x0800e6a8

0800af84 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
 800af84:	b580      	push	{r7, lr}
 800af86:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 800af88:	f7ff ff6a 	bl	800ae60 <port_lock_from_isr.lto_priv.326>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800af8c:	4b09      	ldr	r3, [pc, #36]	; (800afb4 <_dbg_check_leave_isr+0x30>)
 800af8e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800af90:	2b00      	cmp	r3, #0
 800af92:	dd03      	ble.n	800af9c <_dbg_check_leave_isr+0x18>
 800af94:	4b07      	ldr	r3, [pc, #28]	; (800afb4 <_dbg_check_leave_isr+0x30>)
 800af96:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800af98:	2b00      	cmp	r3, #0
 800af9a:	d002      	beq.n	800afa2 <_dbg_check_leave_isr+0x1e>
    chSysHalt("SV#9");
 800af9c:	4806      	ldr	r0, [pc, #24]	; (800afb8 <_dbg_check_leave_isr+0x34>)
 800af9e:	f7ff ff2f 	bl	800ae00 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 800afa2:	4b04      	ldr	r3, [pc, #16]	; (800afb4 <_dbg_check_leave_isr+0x30>)
 800afa4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800afa6:	3b01      	subs	r3, #1
 800afa8:	4a02      	ldr	r2, [pc, #8]	; (800afb4 <_dbg_check_leave_isr+0x30>)
 800afaa:	62d3      	str	r3, [r2, #44]	; 0x2c
  port_unlock_from_isr();
 800afac:	f7ff ff5e 	bl	800ae6c <port_unlock_from_isr.lto_priv.324>
}
 800afb0:	bd80      	pop	{r7, pc}
 800afb2:	bf00      	nop
 800afb4:	20001338 	.word	0x20001338
 800afb8:	0800e6b0 	.word	0x0800e6b0

0800afbc <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 800afbc:	b580      	push	{r7, lr}
 800afbe:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800afc0:	4b05      	ldr	r3, [pc, #20]	; (800afd8 <chDbgCheckClassI+0x1c>)
 800afc2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800afc4:	2b00      	cmp	r3, #0
 800afc6:	db03      	blt.n	800afd0 <chDbgCheckClassI+0x14>
 800afc8:	4b03      	ldr	r3, [pc, #12]	; (800afd8 <chDbgCheckClassI+0x1c>)
 800afca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800afcc:	2b00      	cmp	r3, #0
 800afce:	dc02      	bgt.n	800afd6 <chDbgCheckClassI+0x1a>
    chSysHalt("SV#10");
 800afd0:	4802      	ldr	r0, [pc, #8]	; (800afdc <chDbgCheckClassI+0x20>)
 800afd2:	f7ff ff15 	bl	800ae00 <chSysHalt>
  }
}
 800afd6:	bd80      	pop	{r7, pc}
 800afd8:	20001338 	.word	0x20001338
 800afdc:	0800e6b8 	.word	0x0800e6b8

0800afe0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 800afe0:	b580      	push	{r7, lr}
 800afe2:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800afe4:	4b05      	ldr	r3, [pc, #20]	; (800affc <chDbgCheckClassS+0x1c>)
 800afe6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800afe8:	2b00      	cmp	r3, #0
 800afea:	d103      	bne.n	800aff4 <chDbgCheckClassS+0x14>
 800afec:	4b03      	ldr	r3, [pc, #12]	; (800affc <chDbgCheckClassS+0x1c>)
 800afee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800aff0:	2b00      	cmp	r3, #0
 800aff2:	dc02      	bgt.n	800affa <chDbgCheckClassS+0x1a>
    chSysHalt("SV#11");
 800aff4:	4802      	ldr	r0, [pc, #8]	; (800b000 <chDbgCheckClassS+0x20>)
 800aff6:	f7ff ff03 	bl	800ae00 <chSysHalt>
  }
}
 800affa:	bd80      	pop	{r7, pc}
 800affc:	20001338 	.word	0x20001338
 800b000:	0800e6c0 	.word	0x0800e6c0

0800b004 <st_lld_get_counter.lto_priv.311>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 800b004:	b480      	push	{r7}
 800b006:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 800b008:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b00c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b00e:	b29b      	uxth	r3, r3
}
 800b010:	4618      	mov	r0, r3
 800b012:	46bd      	mov	sp, r7
 800b014:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b018:	4770      	bx	lr
 800b01a:	bf00      	nop

0800b01c <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 800b01c:	b580      	push	{r7, lr}
 800b01e:	b082      	sub	sp, #8
 800b020:	af00      	add	r7, sp, #0
 800b022:	4603      	mov	r3, r0
 800b024:	80fb      	strh	r3, [r7, #6]

  stStartAlarm(time);
 800b026:	88fb      	ldrh	r3, [r7, #6]
 800b028:	4618      	mov	r0, r3
 800b02a:	f7fe f997 	bl	800935c <stStartAlarm>
}
 800b02e:	3708      	adds	r7, #8
 800b030:	46bd      	mov	sp, r7
 800b032:	bd80      	pop	{r7, pc}

0800b034 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 800b034:	b580      	push	{r7, lr}
 800b036:	af00      	add	r7, sp, #0

  stStopAlarm();
 800b038:	f7fe f9a6 	bl	8009388 <stStopAlarm>
}
 800b03c:	bd80      	pop	{r7, pc}
 800b03e:	bf00      	nop

0800b040 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 800b040:	b580      	push	{r7, lr}
 800b042:	b082      	sub	sp, #8
 800b044:	af00      	add	r7, sp, #0
 800b046:	4603      	mov	r3, r0
 800b048:	80fb      	strh	r3, [r7, #6]

  stSetAlarm(time);
 800b04a:	88fb      	ldrh	r3, [r7, #6]
 800b04c:	4618      	mov	r0, r3
 800b04e:	f7fe f9a1 	bl	8009394 <stSetAlarm>
}
 800b052:	3708      	adds	r7, #8
 800b054:	46bd      	mov	sp, r7
 800b056:	bd80      	pop	{r7, pc}

0800b058 <port_timer_get_time.lto_priv.309>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 800b058:	b580      	push	{r7, lr}
 800b05a:	af00      	add	r7, sp, #0

  return stGetCounter();
 800b05c:	f7ff ffd2 	bl	800b004 <st_lld_get_counter.lto_priv.311>
 800b060:	4603      	mov	r3, r0
}
 800b062:	4618      	mov	r0, r3
 800b064:	bd80      	pop	{r7, pc}
 800b066:	bf00      	nop

0800b068 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 800b068:	b580      	push	{r7, lr}
 800b06a:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 800b06c:	f7ff fff4 	bl	800b058 <port_timer_get_time.lto_priv.309>
 800b070:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800b072:	4618      	mov	r0, r3
 800b074:	bd80      	pop	{r7, pc}
 800b076:	bf00      	nop

0800b078 <_vt_init>:
 * @brief   Virtual Timers initialization.
 * @note    Internal use only.
 *
 * @notapi
 */
void _vt_init(void) {
 800b078:	b480      	push	{r7}
 800b07a:	af00      	add	r7, sp, #0

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 800b07c:	4b08      	ldr	r3, [pc, #32]	; (800b0a0 <_vt_init+0x28>)
 800b07e:	4a09      	ldr	r2, [pc, #36]	; (800b0a4 <_vt_init+0x2c>)
 800b080:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 800b082:	4b07      	ldr	r3, [pc, #28]	; (800b0a0 <_vt_init+0x28>)
 800b084:	4a07      	ldr	r2, [pc, #28]	; (800b0a4 <_vt_init+0x2c>)
 800b086:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (systime_t)-1;
 800b088:	4b05      	ldr	r3, [pc, #20]	; (800b0a0 <_vt_init+0x28>)
 800b08a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800b08e:	849a      	strh	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 800b090:	4b03      	ldr	r3, [pc, #12]	; (800b0a0 <_vt_init+0x28>)
 800b092:	2200      	movs	r2, #0
 800b094:	84da      	strh	r2, [r3, #38]	; 0x26
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800b096:	46bd      	mov	sp, r7
 800b098:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b09c:	4770      	bx	lr
 800b09e:	bf00      	nop
 800b0a0:	20001338 	.word	0x20001338
 800b0a4:	20001354 	.word	0x20001354

0800b0a8 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 800b0a8:	b580      	push	{r7, lr}
 800b0aa:	b086      	sub	sp, #24
 800b0ac:	af00      	add	r7, sp, #0
 800b0ae:	60f8      	str	r0, [r7, #12]
 800b0b0:	607a      	str	r2, [r7, #4]
 800b0b2:	603b      	str	r3, [r7, #0]
 800b0b4:	460b      	mov	r3, r1
 800b0b6:	817b      	strh	r3, [r7, #10]
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 800b0b8:	f7ff ff80 	bl	800afbc <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 800b0bc:	68fb      	ldr	r3, [r7, #12]
 800b0be:	2b00      	cmp	r3, #0
 800b0c0:	d005      	beq.n	800b0ce <chVTDoSetI+0x26>
 800b0c2:	687b      	ldr	r3, [r7, #4]
 800b0c4:	2b00      	cmp	r3, #0
 800b0c6:	d002      	beq.n	800b0ce <chVTDoSetI+0x26>
 800b0c8:	897b      	ldrh	r3, [r7, #10]
 800b0ca:	2b00      	cmp	r3, #0
 800b0cc:	d102      	bne.n	800b0d4 <chVTDoSetI+0x2c>
 800b0ce:	4847      	ldr	r0, [pc, #284]	; (800b1ec <chVTDoSetI+0x144>)
 800b0d0:	f7ff fe96 	bl	800ae00 <chSysHalt>

  vtp->par = par;
 800b0d4:	68fb      	ldr	r3, [r7, #12]
 800b0d6:	683a      	ldr	r2, [r7, #0]
 800b0d8:	611a      	str	r2, [r3, #16]
  vtp->func = vtfunc;
 800b0da:	68fb      	ldr	r3, [r7, #12]
 800b0dc:	687a      	ldr	r2, [r7, #4]
 800b0de:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 800b0e0:	f7ff ffc2 	bl	800b068 <chVTGetSystemTimeX>
 800b0e4:	4603      	mov	r3, r0
 800b0e6:	823b      	strh	r3, [r7, #16]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800b0e8:	897b      	ldrh	r3, [r7, #10]
 800b0ea:	2b01      	cmp	r3, #1
 800b0ec:	d801      	bhi.n	800b0f2 <chVTDoSetI+0x4a>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 800b0ee:	2302      	movs	r3, #2
 800b0f0:	817b      	strh	r3, [r7, #10]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800b0f2:	4b3f      	ldr	r3, [pc, #252]	; (800b1f0 <chVTDoSetI+0x148>)
 800b0f4:	69db      	ldr	r3, [r3, #28]
 800b0f6:	4a3f      	ldr	r2, [pc, #252]	; (800b1f4 <chVTDoSetI+0x14c>)
 800b0f8:	4293      	cmp	r3, r2
 800b0fa:	d11a      	bne.n	800b132 <chVTDoSetI+0x8a>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 800b0fc:	4a3c      	ldr	r2, [pc, #240]	; (800b1f0 <chVTDoSetI+0x148>)
 800b0fe:	8a3b      	ldrh	r3, [r7, #16]
 800b100:	84d3      	strh	r3, [r2, #38]	; 0x26
      ch.vtlist.next = vtp;
 800b102:	4a3b      	ldr	r2, [pc, #236]	; (800b1f0 <chVTDoSetI+0x148>)
 800b104:	68fb      	ldr	r3, [r7, #12]
 800b106:	61d3      	str	r3, [r2, #28]
      ch.vtlist.prev = vtp;
 800b108:	4a39      	ldr	r2, [pc, #228]	; (800b1f0 <chVTDoSetI+0x148>)
 800b10a:	68fb      	ldr	r3, [r7, #12]
 800b10c:	6213      	str	r3, [r2, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 800b10e:	68fb      	ldr	r3, [r7, #12]
 800b110:	4a38      	ldr	r2, [pc, #224]	; (800b1f4 <chVTDoSetI+0x14c>)
 800b112:	601a      	str	r2, [r3, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 800b114:	68fb      	ldr	r3, [r7, #12]
 800b116:	4a37      	ldr	r2, [pc, #220]	; (800b1f4 <chVTDoSetI+0x14c>)
 800b118:	605a      	str	r2, [r3, #4]
      vtp->delta = delay;
 800b11a:	68fb      	ldr	r3, [r7, #12]
 800b11c:	897a      	ldrh	r2, [r7, #10]
 800b11e:	811a      	strh	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 800b120:	4b33      	ldr	r3, [pc, #204]	; (800b1f0 <chVTDoSetI+0x148>)
 800b122:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800b124:	897b      	ldrh	r3, [r7, #10]
 800b126:	4413      	add	r3, r2
 800b128:	b29b      	uxth	r3, r3
 800b12a:	4618      	mov	r0, r3
 800b12c:	f7ff ff76 	bl	800b01c <port_timer_start_alarm>
 800b130:	e059      	b.n	800b1e6 <chVTDoSetI+0x13e>

      return;
    }

    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;
 800b132:	4b2f      	ldr	r3, [pc, #188]	; (800b1f0 <chVTDoSetI+0x148>)
 800b134:	69db      	ldr	r3, [r3, #28]
 800b136:	617b      	str	r3, [r7, #20]

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;
 800b138:	4b2d      	ldr	r3, [pc, #180]	; (800b1f0 <chVTDoSetI+0x148>)
 800b13a:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 800b13c:	8a3a      	ldrh	r2, [r7, #16]
 800b13e:	1ad3      	subs	r3, r2, r3
 800b140:	b29a      	uxth	r2, r3
 800b142:	897b      	ldrh	r3, [r7, #10]
 800b144:	4413      	add	r3, r2
 800b146:	827b      	strh	r3, [r7, #18]

    if (delta < now - ch.vtlist.lasttime) {
 800b148:	8a7a      	ldrh	r2, [r7, #18]
 800b14a:	8a3b      	ldrh	r3, [r7, #16]
 800b14c:	4928      	ldr	r1, [pc, #160]	; (800b1f0 <chVTDoSetI+0x148>)
 800b14e:	8cc9      	ldrh	r1, [r1, #38]	; 0x26
 800b150:	1a5b      	subs	r3, r3, r1
 800b152:	429a      	cmp	r2, r3
 800b154:	da08      	bge.n	800b168 <chVTDoSetI+0xc0>
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 800b156:	697b      	ldr	r3, [r7, #20]
 800b158:	891b      	ldrh	r3, [r3, #8]
 800b15a:	8a7a      	ldrh	r2, [r7, #18]
 800b15c:	1ad3      	subs	r3, r2, r3
 800b15e:	827b      	strh	r3, [r7, #18]
      p = p->next;
 800b160:	697b      	ldr	r3, [r7, #20]
 800b162:	681b      	ldr	r3, [r3, #0]
 800b164:	617b      	str	r3, [r7, #20]
 800b166:	e01c      	b.n	800b1a2 <chVTDoSetI+0xfa>
    }
    else if (delta < p->delta) {
 800b168:	697b      	ldr	r3, [r7, #20]
 800b16a:	891b      	ldrh	r3, [r3, #8]
 800b16c:	8a7a      	ldrh	r2, [r7, #18]
 800b16e:	429a      	cmp	r2, r3
 800b170:	d217      	bcs.n	800b1a2 <chVTDoSetI+0xfa>
     /* A small delay that will become the first element in the delta list
        and next deadline.*/
      port_timer_set_alarm(ch.vtlist.lasttime + delta);
 800b172:	4b1f      	ldr	r3, [pc, #124]	; (800b1f0 <chVTDoSetI+0x148>)
 800b174:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800b176:	8a7b      	ldrh	r3, [r7, #18]
 800b178:	4413      	add	r3, r2
 800b17a:	b29b      	uxth	r3, r3
 800b17c:	4618      	mov	r0, r3
 800b17e:	f7ff ff5f 	bl	800b040 <port_timer_set_alarm>
 800b182:	e00e      	b.n	800b1a2 <chVTDoSetI+0xfa>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");
 800b184:	697a      	ldr	r2, [r7, #20]
 800b186:	68fb      	ldr	r3, [r7, #12]
 800b188:	429a      	cmp	r2, r3
 800b18a:	d102      	bne.n	800b192 <chVTDoSetI+0xea>
 800b18c:	4817      	ldr	r0, [pc, #92]	; (800b1ec <chVTDoSetI+0x144>)
 800b18e:	f7ff fe37 	bl	800ae00 <chSysHalt>

    delta -= p->delta;
 800b192:	697b      	ldr	r3, [r7, #20]
 800b194:	891b      	ldrh	r3, [r3, #8]
 800b196:	8a7a      	ldrh	r2, [r7, #18]
 800b198:	1ad3      	subs	r3, r2, r3
 800b19a:	827b      	strh	r3, [r7, #18]
    p = p->next;
 800b19c:	697b      	ldr	r3, [r7, #20]
 800b19e:	681b      	ldr	r3, [r3, #0]
 800b1a0:	617b      	str	r3, [r7, #20]
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 800b1a2:	697b      	ldr	r3, [r7, #20]
 800b1a4:	891b      	ldrh	r3, [r3, #8]
 800b1a6:	8a7a      	ldrh	r2, [r7, #18]
 800b1a8:	429a      	cmp	r2, r3
 800b1aa:	d8eb      	bhi.n	800b184 <chVTDoSetI+0xdc>
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 800b1ac:	68fb      	ldr	r3, [r7, #12]
 800b1ae:	697a      	ldr	r2, [r7, #20]
 800b1b0:	601a      	str	r2, [r3, #0]
  vtp->prev = vtp->next->prev;
 800b1b2:	68fb      	ldr	r3, [r7, #12]
 800b1b4:	681b      	ldr	r3, [r3, #0]
 800b1b6:	685a      	ldr	r2, [r3, #4]
 800b1b8:	68fb      	ldr	r3, [r7, #12]
 800b1ba:	605a      	str	r2, [r3, #4]
  vtp->prev->next = vtp;
 800b1bc:	68fb      	ldr	r3, [r7, #12]
 800b1be:	685b      	ldr	r3, [r3, #4]
 800b1c0:	68fa      	ldr	r2, [r7, #12]
 800b1c2:	601a      	str	r2, [r3, #0]
  p->prev = vtp;
 800b1c4:	697b      	ldr	r3, [r7, #20]
 800b1c6:	68fa      	ldr	r2, [r7, #12]
 800b1c8:	605a      	str	r2, [r3, #4]
  vtp->delta = delta;
 800b1ca:	68fb      	ldr	r3, [r7, #12]
 800b1cc:	8a7a      	ldrh	r2, [r7, #18]
 800b1ce:	811a      	strh	r2, [r3, #8]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 800b1d0:	697b      	ldr	r3, [r7, #20]
 800b1d2:	891a      	ldrh	r2, [r3, #8]
 800b1d4:	8a7b      	ldrh	r3, [r7, #18]
 800b1d6:	1ad3      	subs	r3, r2, r3
 800b1d8:	b29a      	uxth	r2, r3
 800b1da:	697b      	ldr	r3, [r7, #20]
 800b1dc:	811a      	strh	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (systime_t)-1;
 800b1de:	4b04      	ldr	r3, [pc, #16]	; (800b1f0 <chVTDoSetI+0x148>)
 800b1e0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800b1e4:	849a      	strh	r2, [r3, #36]	; 0x24
}
 800b1e6:	3718      	adds	r7, #24
 800b1e8:	46bd      	mov	sp, r7
 800b1ea:	bd80      	pop	{r7, pc}
 800b1ec:	0800e87c 	.word	0x0800e87c
 800b1f0:	20001338 	.word	0x20001338
 800b1f4:	20001354 	.word	0x20001354

0800b1f8 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 800b1f8:	b580      	push	{r7, lr}
 800b1fa:	b084      	sub	sp, #16
 800b1fc:	af00      	add	r7, sp, #0
 800b1fe:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 800b200:	f7ff fedc 	bl	800afbc <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 800b204:	687b      	ldr	r3, [r7, #4]
 800b206:	2b00      	cmp	r3, #0
 800b208:	d102      	bne.n	800b210 <chVTDoResetI+0x18>
 800b20a:	4838      	ldr	r0, [pc, #224]	; (800b2ec <chVTDoResetI+0xf4>)
 800b20c:	f7ff fdf8 	bl	800ae00 <chSysHalt>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
 800b210:	687b      	ldr	r3, [r7, #4]
 800b212:	68db      	ldr	r3, [r3, #12]
 800b214:	2b00      	cmp	r3, #0
 800b216:	d102      	bne.n	800b21e <chVTDoResetI+0x26>
 800b218:	4834      	ldr	r0, [pc, #208]	; (800b2ec <chVTDoResetI+0xf4>)
 800b21a:	f7ff fdf1 	bl	800ae00 <chSysHalt>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 800b21e:	4b34      	ldr	r3, [pc, #208]	; (800b2f0 <chVTDoResetI+0xf8>)
 800b220:	69da      	ldr	r2, [r3, #28]
 800b222:	687b      	ldr	r3, [r7, #4]
 800b224:	429a      	cmp	r2, r3
 800b226:	d01c      	beq.n	800b262 <chVTDoResetI+0x6a>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 800b228:	687b      	ldr	r3, [r7, #4]
 800b22a:	685b      	ldr	r3, [r3, #4]
 800b22c:	687a      	ldr	r2, [r7, #4]
 800b22e:	6812      	ldr	r2, [r2, #0]
 800b230:	601a      	str	r2, [r3, #0]
    vtp->next->prev = vtp->prev;
 800b232:	687b      	ldr	r3, [r7, #4]
 800b234:	681b      	ldr	r3, [r3, #0]
 800b236:	687a      	ldr	r2, [r7, #4]
 800b238:	6852      	ldr	r2, [r2, #4]
 800b23a:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 800b23c:	687b      	ldr	r3, [r7, #4]
 800b23e:	2200      	movs	r2, #0
 800b240:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800b242:	687b      	ldr	r3, [r7, #4]
 800b244:	681b      	ldr	r3, [r3, #0]
 800b246:	4a2b      	ldr	r2, [pc, #172]	; (800b2f4 <chVTDoResetI+0xfc>)
 800b248:	4293      	cmp	r3, r2
 800b24a:	d04b      	beq.n	800b2e4 <chVTDoResetI+0xec>
      vtp->next->delta += vtp->delta;
 800b24c:	687b      	ldr	r3, [r7, #4]
 800b24e:	681b      	ldr	r3, [r3, #0]
 800b250:	687a      	ldr	r2, [r7, #4]
 800b252:	6812      	ldr	r2, [r2, #0]
 800b254:	8911      	ldrh	r1, [r2, #8]
 800b256:	687a      	ldr	r2, [r7, #4]
 800b258:	8912      	ldrh	r2, [r2, #8]
 800b25a:	440a      	add	r2, r1
 800b25c:	b292      	uxth	r2, r2
 800b25e:	811a      	strh	r2, [r3, #8]
 800b260:	e040      	b.n	800b2e4 <chVTDoResetI+0xec>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 800b262:	687b      	ldr	r3, [r7, #4]
 800b264:	681b      	ldr	r3, [r3, #0]
 800b266:	4a22      	ldr	r2, [pc, #136]	; (800b2f0 <chVTDoResetI+0xf8>)
 800b268:	61d3      	str	r3, [r2, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 800b26a:	4b21      	ldr	r3, [pc, #132]	; (800b2f0 <chVTDoResetI+0xf8>)
 800b26c:	69db      	ldr	r3, [r3, #28]
 800b26e:	4a21      	ldr	r2, [pc, #132]	; (800b2f4 <chVTDoResetI+0xfc>)
 800b270:	605a      	str	r2, [r3, #4]
  vtp->func = NULL;
 800b272:	687b      	ldr	r3, [r7, #4]
 800b274:	2200      	movs	r2, #0
 800b276:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800b278:	4b1d      	ldr	r3, [pc, #116]	; (800b2f0 <chVTDoResetI+0xf8>)
 800b27a:	69db      	ldr	r3, [r3, #28]
 800b27c:	4a1d      	ldr	r2, [pc, #116]	; (800b2f4 <chVTDoResetI+0xfc>)
 800b27e:	4293      	cmp	r3, r2
 800b280:	d102      	bne.n	800b288 <chVTDoResetI+0x90>
    port_timer_stop_alarm();
 800b282:	f7ff fed7 	bl	800b034 <port_timer_stop_alarm>
 800b286:	e02d      	b.n	800b2e4 <chVTDoResetI+0xec>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 800b288:	4b19      	ldr	r3, [pc, #100]	; (800b2f0 <chVTDoResetI+0xf8>)
 800b28a:	69db      	ldr	r3, [r3, #28]
 800b28c:	4a18      	ldr	r2, [pc, #96]	; (800b2f0 <chVTDoResetI+0xf8>)
 800b28e:	69d2      	ldr	r2, [r2, #28]
 800b290:	8911      	ldrh	r1, [r2, #8]
 800b292:	687a      	ldr	r2, [r7, #4]
 800b294:	8912      	ldrh	r2, [r2, #8]
 800b296:	440a      	add	r2, r1
 800b298:	b292      	uxth	r2, r2
 800b29a:	811a      	strh	r2, [r3, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 800b29c:	f7ff fee4 	bl	800b068 <chVTGetSystemTimeX>
 800b2a0:	4603      	mov	r3, r0
 800b2a2:	461a      	mov	r2, r3
 800b2a4:	4b12      	ldr	r3, [pc, #72]	; (800b2f0 <chVTDoResetI+0xf8>)
 800b2a6:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 800b2a8:	1ad3      	subs	r3, r2, r3
 800b2aa:	81bb      	strh	r3, [r7, #12]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 800b2ac:	4b10      	ldr	r3, [pc, #64]	; (800b2f0 <chVTDoResetI+0xf8>)
 800b2ae:	69db      	ldr	r3, [r3, #28]
 800b2b0:	891b      	ldrh	r3, [r3, #8]
 800b2b2:	89ba      	ldrh	r2, [r7, #12]
 800b2b4:	429a      	cmp	r2, r3
 800b2b6:	d215      	bcs.n	800b2e4 <chVTDoResetI+0xec>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 800b2b8:	4b0d      	ldr	r3, [pc, #52]	; (800b2f0 <chVTDoResetI+0xf8>)
 800b2ba:	69db      	ldr	r3, [r3, #28]
 800b2bc:	891a      	ldrh	r2, [r3, #8]
 800b2be:	89bb      	ldrh	r3, [r7, #12]
 800b2c0:	1ad3      	subs	r3, r2, r3
 800b2c2:	81fb      	strh	r3, [r7, #14]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800b2c4:	89fb      	ldrh	r3, [r7, #14]
 800b2c6:	2b01      	cmp	r3, #1
 800b2c8:	d801      	bhi.n	800b2ce <chVTDoResetI+0xd6>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800b2ca:	2302      	movs	r3, #2
 800b2cc:	81fb      	strh	r3, [r7, #14]
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
 800b2ce:	4b08      	ldr	r3, [pc, #32]	; (800b2f0 <chVTDoResetI+0xf8>)
 800b2d0:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800b2d2:	89bb      	ldrh	r3, [r7, #12]
 800b2d4:	4413      	add	r3, r2
 800b2d6:	b29a      	uxth	r2, r3
 800b2d8:	89fb      	ldrh	r3, [r7, #14]
 800b2da:	4413      	add	r3, r2
 800b2dc:	b29b      	uxth	r3, r3
 800b2de:	4618      	mov	r0, r3
 800b2e0:	f7ff feae 	bl	800b040 <port_timer_set_alarm>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800b2e4:	3710      	adds	r7, #16
 800b2e6:	46bd      	mov	sp, r7
 800b2e8:	bd80      	pop	{r7, pc}
 800b2ea:	bf00      	nop
 800b2ec:	0800e888 	.word	0x0800e888
 800b2f0:	20001338 	.word	0x20001338
 800b2f4:	20001354 	.word	0x20001354

0800b2f8 <port_lock.lto_priv.317>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800b2f8:	b480      	push	{r7}
 800b2fa:	b083      	sub	sp, #12
 800b2fc:	af00      	add	r7, sp, #0
 800b2fe:	2320      	movs	r3, #32
 800b300:	607b      	str	r3, [r7, #4]
 800b302:	687b      	ldr	r3, [r7, #4]
 800b304:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b308:	370c      	adds	r7, #12
 800b30a:	46bd      	mov	sp, r7
 800b30c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b310:	4770      	bx	lr
 800b312:	bf00      	nop

0800b314 <port_unlock.lto_priv.314>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800b314:	b480      	push	{r7}
 800b316:	b083      	sub	sp, #12
 800b318:	af00      	add	r7, sp, #0
 800b31a:	2300      	movs	r3, #0
 800b31c:	607b      	str	r3, [r7, #4]
 800b31e:	687b      	ldr	r3, [r7, #4]
 800b320:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b324:	370c      	adds	r7, #12
 800b326:	46bd      	mov	sp, r7
 800b328:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b32c:	4770      	bx	lr
 800b32e:	bf00      	nop

0800b330 <port_lock_from_isr.lto_priv.327>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800b330:	b580      	push	{r7, lr}
 800b332:	af00      	add	r7, sp, #0

  port_lock();
 800b334:	f7ff ffe0 	bl	800b2f8 <port_lock.lto_priv.317>
}
 800b338:	bd80      	pop	{r7, pc}
 800b33a:	bf00      	nop

0800b33c <port_unlock_from_isr.lto_priv.325>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800b33c:	b580      	push	{r7, lr}
 800b33e:	af00      	add	r7, sp, #0

  port_unlock();
 800b340:	f7ff ffe8 	bl	800b314 <port_unlock.lto_priv.314>
}
 800b344:	bd80      	pop	{r7, pc}
 800b346:	bf00      	nop

0800b348 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 800b348:	b480      	push	{r7}
 800b34a:	b083      	sub	sp, #12
 800b34c:	af00      	add	r7, sp, #0
 800b34e:	6078      	str	r0, [r7, #4]

  tqp->next = (thread_t *)tqp;
 800b350:	687b      	ldr	r3, [r7, #4]
 800b352:	687a      	ldr	r2, [r7, #4]
 800b354:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800b356:	687b      	ldr	r3, [r7, #4]
 800b358:	687a      	ldr	r2, [r7, #4]
 800b35a:	605a      	str	r2, [r3, #4]
}
 800b35c:	370c      	adds	r7, #12
 800b35e:	46bd      	mov	sp, r7
 800b360:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b364:	4770      	bx	lr
 800b366:	bf00      	nop

0800b368 <chSchIsRescRequiredI>:
 * @retval false        if rescheduling is not necessary.
 * @retval true         if there is a ready thread at higher priority.
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {
 800b368:	b580      	push	{r7, lr}
 800b36a:	af00      	add	r7, sp, #0

  chDbgCheckClassI();
 800b36c:	f7ff fe26 	bl	800afbc <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 800b370:	4b06      	ldr	r3, [pc, #24]	; (800b38c <chSchIsRescRequiredI+0x24>)
 800b372:	681b      	ldr	r3, [r3, #0]
 800b374:	689a      	ldr	r2, [r3, #8]
 800b376:	4b05      	ldr	r3, [pc, #20]	; (800b38c <chSchIsRescRequiredI+0x24>)
 800b378:	699b      	ldr	r3, [r3, #24]
 800b37a:	689b      	ldr	r3, [r3, #8]
 800b37c:	429a      	cmp	r2, r3
 800b37e:	bf8c      	ite	hi
 800b380:	2301      	movhi	r3, #1
 800b382:	2300      	movls	r3, #0
 800b384:	b2db      	uxtb	r3, r3
}
 800b386:	4618      	mov	r0, r3
 800b388:	bd80      	pop	{r7, pc}
 800b38a:	bf00      	nop
 800b38c:	20001338 	.word	0x20001338

0800b390 <chSysLockFromISR.lto_priv.323>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800b390:	b580      	push	{r7, lr}
 800b392:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 800b394:	f7ff ffcc 	bl	800b330 <port_lock_from_isr.lto_priv.327>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800b398:	f7ff fdac 	bl	800aef4 <_dbg_check_lock_from_isr>
}
 800b39c:	bd80      	pop	{r7, pc}
 800b39e:	bf00      	nop

0800b3a0 <chSysUnlockFromISR.lto_priv.321>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800b3a0:	b580      	push	{r7, lr}
 800b3a2:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
 800b3a4:	f7ff fdbc 	bl	800af20 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800b3a8:	f7ff ffc8 	bl	800b33c <port_unlock_from_isr.lto_priv.325>
}
 800b3ac:	bd80      	pop	{r7, pc}
 800b3ae:	bf00      	nop

0800b3b0 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 800b3b0:	b580      	push	{r7, lr}
 800b3b2:	b082      	sub	sp, #8
 800b3b4:	af00      	add	r7, sp, #0
 800b3b6:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 800b3b8:	f7ff fe00 	bl	800afbc <chDbgCheckClassI>

  return (bool)(vtp->func != NULL);
 800b3bc:	687b      	ldr	r3, [r7, #4]
 800b3be:	68db      	ldr	r3, [r3, #12]
 800b3c0:	2b00      	cmp	r3, #0
 800b3c2:	bf14      	ite	ne
 800b3c4:	2301      	movne	r3, #1
 800b3c6:	2300      	moveq	r3, #0
 800b3c8:	b2db      	uxtb	r3, r3
}
 800b3ca:	4618      	mov	r0, r3
 800b3cc:	3708      	adds	r7, #8
 800b3ce:	46bd      	mov	sp, r7
 800b3d0:	bd80      	pop	{r7, pc}
 800b3d2:	bf00      	nop

0800b3d4 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 800b3d4:	b580      	push	{r7, lr}
 800b3d6:	af00      	add	r7, sp, #0

  queue_init(&ch.rlist.queue);
 800b3d8:	4806      	ldr	r0, [pc, #24]	; (800b3f4 <_scheduler_init+0x20>)
 800b3da:	f7ff ffb5 	bl	800b348 <queue_init>
  ch.rlist.prio = NOPRIO;
 800b3de:	4b05      	ldr	r3, [pc, #20]	; (800b3f4 <_scheduler_init+0x20>)
 800b3e0:	2200      	movs	r2, #0
 800b3e2:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 800b3e4:	4b03      	ldr	r3, [pc, #12]	; (800b3f4 <_scheduler_init+0x20>)
 800b3e6:	4a03      	ldr	r2, [pc, #12]	; (800b3f4 <_scheduler_init+0x20>)
 800b3e8:	611a      	str	r2, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 800b3ea:	4b02      	ldr	r3, [pc, #8]	; (800b3f4 <_scheduler_init+0x20>)
 800b3ec:	4a01      	ldr	r2, [pc, #4]	; (800b3f4 <_scheduler_init+0x20>)
 800b3ee:	615a      	str	r2, [r3, #20]
#endif
}
 800b3f0:	bd80      	pop	{r7, pc}
 800b3f2:	bf00      	nop
 800b3f4:	20001338 	.word	0x20001338

0800b3f8 <queue_prio_insert>:
 * @param[in] tp        the pointer to the thread to be inserted in the list
 * @param[in] tqp       the pointer to the threads list header
 *
 * @notapi
 */
void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 800b3f8:	b480      	push	{r7}
 800b3fa:	b085      	sub	sp, #20
 800b3fc:	af00      	add	r7, sp, #0
 800b3fe:	6078      	str	r0, [r7, #4]
 800b400:	6039      	str	r1, [r7, #0]

  thread_t *cp = (thread_t *)tqp;
 800b402:	683b      	ldr	r3, [r7, #0]
 800b404:	60fb      	str	r3, [r7, #12]
  do {
    cp = cp->queue.next;
 800b406:	68fb      	ldr	r3, [r7, #12]
 800b408:	681b      	ldr	r3, [r3, #0]
 800b40a:	60fb      	str	r3, [r7, #12]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800b40c:	68fa      	ldr	r2, [r7, #12]
 800b40e:	683b      	ldr	r3, [r7, #0]
 800b410:	429a      	cmp	r2, r3
 800b412:	d005      	beq.n	800b420 <queue_prio_insert+0x28>
 800b414:	68fb      	ldr	r3, [r7, #12]
 800b416:	689a      	ldr	r2, [r3, #8]
 800b418:	687b      	ldr	r3, [r7, #4]
 800b41a:	689b      	ldr	r3, [r3, #8]
 800b41c:	429a      	cmp	r2, r3
 800b41e:	d2f2      	bcs.n	800b406 <queue_prio_insert+0xe>
  tp->queue.next             = cp;
 800b420:	687b      	ldr	r3, [r7, #4]
 800b422:	68fa      	ldr	r2, [r7, #12]
 800b424:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 800b426:	68fb      	ldr	r3, [r7, #12]
 800b428:	685a      	ldr	r2, [r3, #4]
 800b42a:	687b      	ldr	r3, [r7, #4]
 800b42c:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800b42e:	687b      	ldr	r3, [r7, #4]
 800b430:	685b      	ldr	r3, [r3, #4]
 800b432:	687a      	ldr	r2, [r7, #4]
 800b434:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 800b436:	68fb      	ldr	r3, [r7, #12]
 800b438:	687a      	ldr	r2, [r7, #4]
 800b43a:	605a      	str	r2, [r3, #4]
}
 800b43c:	3714      	adds	r7, #20
 800b43e:	46bd      	mov	sp, r7
 800b440:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b444:	4770      	bx	lr
 800b446:	bf00      	nop

0800b448 <queue_insert>:
 * @param[in] tp        the pointer to the thread to be inserted in the list
 * @param[in] tqp       the pointer to the threads list header
 *
 * @notapi
 */
void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 800b448:	b480      	push	{r7}
 800b44a:	b083      	sub	sp, #12
 800b44c:	af00      	add	r7, sp, #0
 800b44e:	6078      	str	r0, [r7, #4]
 800b450:	6039      	str	r1, [r7, #0]

  tp->queue.next             = (thread_t *)tqp;
 800b452:	687b      	ldr	r3, [r7, #4]
 800b454:	683a      	ldr	r2, [r7, #0]
 800b456:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = tqp->prev;
 800b458:	683b      	ldr	r3, [r7, #0]
 800b45a:	685a      	ldr	r2, [r3, #4]
 800b45c:	687b      	ldr	r3, [r7, #4]
 800b45e:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800b460:	687b      	ldr	r3, [r7, #4]
 800b462:	685b      	ldr	r3, [r3, #4]
 800b464:	687a      	ldr	r2, [r7, #4]
 800b466:	601a      	str	r2, [r3, #0]
  tqp->prev                  = tp;
 800b468:	683b      	ldr	r3, [r7, #0]
 800b46a:	687a      	ldr	r2, [r7, #4]
 800b46c:	605a      	str	r2, [r3, #4]
}
 800b46e:	370c      	adds	r7, #12
 800b470:	46bd      	mov	sp, r7
 800b472:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b476:	4770      	bx	lr

0800b478 <queue_fifo_remove>:
 * @param[in] tqp       the pointer to the threads list header
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 800b478:	b480      	push	{r7}
 800b47a:	b085      	sub	sp, #20
 800b47c:	af00      	add	r7, sp, #0
 800b47e:	6078      	str	r0, [r7, #4]
  thread_t *tp = tqp->next;
 800b480:	687b      	ldr	r3, [r7, #4]
 800b482:	681b      	ldr	r3, [r3, #0]
 800b484:	60fb      	str	r3, [r7, #12]

  tqp->next             = tp->queue.next;
 800b486:	68fb      	ldr	r3, [r7, #12]
 800b488:	681a      	ldr	r2, [r3, #0]
 800b48a:	687b      	ldr	r3, [r7, #4]
 800b48c:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b48e:	687b      	ldr	r3, [r7, #4]
 800b490:	681b      	ldr	r3, [r3, #0]
 800b492:	687a      	ldr	r2, [r7, #4]
 800b494:	605a      	str	r2, [r3, #4]

  return tp;
 800b496:	68fb      	ldr	r3, [r7, #12]
}
 800b498:	4618      	mov	r0, r3
 800b49a:	3714      	adds	r7, #20
 800b49c:	46bd      	mov	sp, r7
 800b49e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b4a2:	4770      	bx	lr

0800b4a4 <queue_dequeue>:
 * @param[in] tp        the pointer to the thread to be removed from the queue
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *queue_dequeue(thread_t *tp) {
 800b4a4:	b480      	push	{r7}
 800b4a6:	b083      	sub	sp, #12
 800b4a8:	af00      	add	r7, sp, #0
 800b4aa:	6078      	str	r0, [r7, #4]

  tp->queue.prev->queue.next = tp->queue.next;
 800b4ac:	687b      	ldr	r3, [r7, #4]
 800b4ae:	685b      	ldr	r3, [r3, #4]
 800b4b0:	687a      	ldr	r2, [r7, #4]
 800b4b2:	6812      	ldr	r2, [r2, #0]
 800b4b4:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800b4b6:	687b      	ldr	r3, [r7, #4]
 800b4b8:	681b      	ldr	r3, [r3, #0]
 800b4ba:	687a      	ldr	r2, [r7, #4]
 800b4bc:	6852      	ldr	r2, [r2, #4]
 800b4be:	605a      	str	r2, [r3, #4]

  return tp;
 800b4c0:	687b      	ldr	r3, [r7, #4]
}
 800b4c2:	4618      	mov	r0, r3
 800b4c4:	370c      	adds	r7, #12
 800b4c6:	46bd      	mov	sp, r7
 800b4c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b4cc:	4770      	bx	lr
 800b4ce:	bf00      	nop

0800b4d0 <list_remove>:
 * @param[in] tlp       the pointer to the threads list header
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *list_remove(threads_list_t *tlp) {
 800b4d0:	b480      	push	{r7}
 800b4d2:	b085      	sub	sp, #20
 800b4d4:	af00      	add	r7, sp, #0
 800b4d6:	6078      	str	r0, [r7, #4]

  thread_t *tp = tlp->next;
 800b4d8:	687b      	ldr	r3, [r7, #4]
 800b4da:	681b      	ldr	r3, [r3, #0]
 800b4dc:	60fb      	str	r3, [r7, #12]
  tlp->next = tp->queue.next;
 800b4de:	68fb      	ldr	r3, [r7, #12]
 800b4e0:	681a      	ldr	r2, [r3, #0]
 800b4e2:	687b      	ldr	r3, [r7, #4]
 800b4e4:	601a      	str	r2, [r3, #0]

  return tp;
 800b4e6:	68fb      	ldr	r3, [r7, #12]
}
 800b4e8:	4618      	mov	r0, r3
 800b4ea:	3714      	adds	r7, #20
 800b4ec:	46bd      	mov	sp, r7
 800b4ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b4f2:	4770      	bx	lr

0800b4f4 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 800b4f4:	b580      	push	{r7, lr}
 800b4f6:	b084      	sub	sp, #16
 800b4f8:	af00      	add	r7, sp, #0
 800b4fa:	6078      	str	r0, [r7, #4]
  thread_t *cp;

  chDbgCheckClassI();
 800b4fc:	f7ff fd5e 	bl	800afbc <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800b500:	687b      	ldr	r3, [r7, #4]
 800b502:	2b00      	cmp	r3, #0
 800b504:	d102      	bne.n	800b50c <chSchReadyI+0x18>
 800b506:	4819      	ldr	r0, [pc, #100]	; (800b56c <chSchReadyI+0x78>)
 800b508:	f7ff fc7a 	bl	800ae00 <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800b50c:	687b      	ldr	r3, [r7, #4]
 800b50e:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b512:	2b00      	cmp	r3, #0
 800b514:	d004      	beq.n	800b520 <chSchReadyI+0x2c>
 800b516:	687b      	ldr	r3, [r7, #4]
 800b518:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b51c:	2b0f      	cmp	r3, #15
 800b51e:	d102      	bne.n	800b526 <chSchReadyI+0x32>
 800b520:	4812      	ldr	r0, [pc, #72]	; (800b56c <chSchReadyI+0x78>)
 800b522:	f7ff fc6d 	bl	800ae00 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800b526:	687b      	ldr	r3, [r7, #4]
 800b528:	2200      	movs	r2, #0
 800b52a:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
 800b52e:	4b10      	ldr	r3, [pc, #64]	; (800b570 <chSchReadyI+0x7c>)
 800b530:	60fb      	str	r3, [r7, #12]
  do {
    cp = cp->queue.next;
 800b532:	68fb      	ldr	r3, [r7, #12]
 800b534:	681b      	ldr	r3, [r3, #0]
 800b536:	60fb      	str	r3, [r7, #12]
  } while (cp->prio >= tp->prio);
 800b538:	68fb      	ldr	r3, [r7, #12]
 800b53a:	689a      	ldr	r2, [r3, #8]
 800b53c:	687b      	ldr	r3, [r7, #4]
 800b53e:	689b      	ldr	r3, [r3, #8]
 800b540:	429a      	cmp	r2, r3
 800b542:	d2f6      	bcs.n	800b532 <chSchReadyI+0x3e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800b544:	687b      	ldr	r3, [r7, #4]
 800b546:	68fa      	ldr	r2, [r7, #12]
 800b548:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 800b54a:	68fb      	ldr	r3, [r7, #12]
 800b54c:	685a      	ldr	r2, [r3, #4]
 800b54e:	687b      	ldr	r3, [r7, #4]
 800b550:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800b552:	687b      	ldr	r3, [r7, #4]
 800b554:	685b      	ldr	r3, [r3, #4]
 800b556:	687a      	ldr	r2, [r7, #4]
 800b558:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 800b55a:	68fb      	ldr	r3, [r7, #12]
 800b55c:	687a      	ldr	r2, [r7, #4]
 800b55e:	605a      	str	r2, [r3, #4]

  return tp;
 800b560:	687b      	ldr	r3, [r7, #4]
}
 800b562:	4618      	mov	r0, r3
 800b564:	3710      	adds	r7, #16
 800b566:	46bd      	mov	sp, r7
 800b568:	bd80      	pop	{r7, pc}
 800b56a:	bf00      	nop
 800b56c:	0800e898 	.word	0x0800e898
 800b570:	20001338 	.word	0x20001338

0800b574 <chSchReadyAheadI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
 800b574:	b580      	push	{r7, lr}
 800b576:	b084      	sub	sp, #16
 800b578:	af00      	add	r7, sp, #0
 800b57a:	6078      	str	r0, [r7, #4]
  thread_t *cp;

  chDbgCheckClassI();
 800b57c:	f7ff fd1e 	bl	800afbc <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800b580:	687b      	ldr	r3, [r7, #4]
 800b582:	2b00      	cmp	r3, #0
 800b584:	d102      	bne.n	800b58c <chSchReadyAheadI+0x18>
 800b586:	4819      	ldr	r0, [pc, #100]	; (800b5ec <chSchReadyAheadI+0x78>)
 800b588:	f7ff fc3a 	bl	800ae00 <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800b58c:	687b      	ldr	r3, [r7, #4]
 800b58e:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b592:	2b00      	cmp	r3, #0
 800b594:	d004      	beq.n	800b5a0 <chSchReadyAheadI+0x2c>
 800b596:	687b      	ldr	r3, [r7, #4]
 800b598:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b59c:	2b0f      	cmp	r3, #15
 800b59e:	d102      	bne.n	800b5a6 <chSchReadyAheadI+0x32>
 800b5a0:	4812      	ldr	r0, [pc, #72]	; (800b5ec <chSchReadyAheadI+0x78>)
 800b5a2:	f7ff fc2d 	bl	800ae00 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800b5a6:	687b      	ldr	r3, [r7, #4]
 800b5a8:	2200      	movs	r2, #0
 800b5aa:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
 800b5ae:	4b10      	ldr	r3, [pc, #64]	; (800b5f0 <chSchReadyAheadI+0x7c>)
 800b5b0:	60fb      	str	r3, [r7, #12]
  do {
    cp = cp->queue.next;
 800b5b2:	68fb      	ldr	r3, [r7, #12]
 800b5b4:	681b      	ldr	r3, [r3, #0]
 800b5b6:	60fb      	str	r3, [r7, #12]
  } while (cp->prio > tp->prio);
 800b5b8:	68fb      	ldr	r3, [r7, #12]
 800b5ba:	689a      	ldr	r2, [r3, #8]
 800b5bc:	687b      	ldr	r3, [r7, #4]
 800b5be:	689b      	ldr	r3, [r3, #8]
 800b5c0:	429a      	cmp	r2, r3
 800b5c2:	d8f6      	bhi.n	800b5b2 <chSchReadyAheadI+0x3e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800b5c4:	687b      	ldr	r3, [r7, #4]
 800b5c6:	68fa      	ldr	r2, [r7, #12]
 800b5c8:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 800b5ca:	68fb      	ldr	r3, [r7, #12]
 800b5cc:	685a      	ldr	r2, [r3, #4]
 800b5ce:	687b      	ldr	r3, [r7, #4]
 800b5d0:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800b5d2:	687b      	ldr	r3, [r7, #4]
 800b5d4:	685b      	ldr	r3, [r3, #4]
 800b5d6:	687a      	ldr	r2, [r7, #4]
 800b5d8:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 800b5da:	68fb      	ldr	r3, [r7, #12]
 800b5dc:	687a      	ldr	r2, [r7, #4]
 800b5de:	605a      	str	r2, [r3, #4]

  return tp;
 800b5e0:	687b      	ldr	r3, [r7, #4]
}
 800b5e2:	4618      	mov	r0, r3
 800b5e4:	3710      	adds	r7, #16
 800b5e6:	46bd      	mov	sp, r7
 800b5e8:	bd80      	pop	{r7, pc}
 800b5ea:	bf00      	nop
 800b5ec:	0800e8a4 	.word	0x0800e8a4
 800b5f0:	20001338 	.word	0x20001338

0800b5f4 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 800b5f4:	b590      	push	{r4, r7, lr}
 800b5f6:	b085      	sub	sp, #20
 800b5f8:	af00      	add	r7, sp, #0
 800b5fa:	4603      	mov	r3, r0
 800b5fc:	71fb      	strb	r3, [r7, #7]
  thread_t *otp = currp;
 800b5fe:	4b16      	ldr	r3, [pc, #88]	; (800b658 <chSchGoSleepS+0x64>)
 800b600:	699b      	ldr	r3, [r3, #24]
 800b602:	60fb      	str	r3, [r7, #12]

  chDbgCheckClassS();
 800b604:	f7ff fcec 	bl	800afe0 <chDbgCheckClassS>

  /* New state.*/
  otp->state = newstate;
 800b608:	68fb      	ldr	r3, [r7, #12]
 800b60a:	79fa      	ldrb	r2, [r7, #7]
 800b60c:	f883 2020 	strb.w	r2, [r3, #32]
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800b610:	4811      	ldr	r0, [pc, #68]	; (800b658 <chSchGoSleepS+0x64>)
 800b612:	f7ff ff31 	bl	800b478 <queue_fifo_remove>
 800b616:	4602      	mov	r2, r0
 800b618:	4b0f      	ldr	r3, [pc, #60]	; (800b658 <chSchGoSleepS+0x64>)
 800b61a:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800b61c:	4b0e      	ldr	r3, [pc, #56]	; (800b658 <chSchGoSleepS+0x64>)
 800b61e:	699b      	ldr	r3, [r3, #24]
 800b620:	2201      	movs	r2, #1
 800b622:	f883 2020 	strb.w	r2, [r3, #32]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800b626:	f3ef 8309 	mrs	r3, PSP
 800b62a:	461c      	mov	r4, r3
  return(result);
 800b62c:	4623      	mov	r3, r4
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800b62e:	60bb      	str	r3, [r7, #8]
 800b630:	68bb      	ldr	r3, [r7, #8]
 800b632:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800b636:	68fb      	ldr	r3, [r7, #12]
 800b638:	69db      	ldr	r3, [r3, #28]
 800b63a:	429a      	cmp	r2, r3
 800b63c:	d202      	bcs.n	800b644 <chSchGoSleepS+0x50>
 800b63e:	4807      	ldr	r0, [pc, #28]	; (800b65c <chSchGoSleepS+0x68>)
 800b640:	f7ff fbde 	bl	800ae00 <chSysHalt>
 800b644:	4b04      	ldr	r3, [pc, #16]	; (800b658 <chSchGoSleepS+0x64>)
 800b646:	699b      	ldr	r3, [r3, #24]
 800b648:	4618      	mov	r0, r3
 800b64a:	68f9      	ldr	r1, [r7, #12]
 800b64c:	f7f7 fe2a 	bl	80032a4 <_port_switch>
}
 800b650:	3714      	adds	r7, #20
 800b652:	46bd      	mov	sp, r7
 800b654:	bd90      	pop	{r4, r7, pc}
 800b656:	bf00      	nop
 800b658:	20001338 	.word	0x20001338
 800b65c:	0800e6c8 	.word	0x0800e6c8

0800b660 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 800b660:	b580      	push	{r7, lr}
 800b662:	b084      	sub	sp, #16
 800b664:	af00      	add	r7, sp, #0
 800b666:	6078      	str	r0, [r7, #4]
  thread_t *tp = (thread_t *)p;
 800b668:	687b      	ldr	r3, [r7, #4]
 800b66a:	60fb      	str	r3, [r7, #12]

  chSysLockFromISR();
 800b66c:	f7ff fe90 	bl	800b390 <chSysLockFromISR.lto_priv.323>
  switch (tp->state) {
 800b670:	68fb      	ldr	r3, [r7, #12]
 800b672:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b676:	2b03      	cmp	r3, #3
 800b678:	d006      	beq.n	800b688 <wakeup+0x28>
 800b67a:	2b04      	cmp	r3, #4
 800b67c:	d009      	beq.n	800b692 <wakeup+0x32>
 800b67e:	2b00      	cmp	r3, #0
 800b680:	d10a      	bne.n	800b698 <wakeup+0x38>
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 800b682:	f7ff fe8d 	bl	800b3a0 <chSysUnlockFromISR.lto_priv.321>
 800b686:	e010      	b.n	800b6aa <wakeup+0x4a>
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 800b688:	68fb      	ldr	r3, [r7, #12]
 800b68a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b68c:	2200      	movs	r2, #0
 800b68e:	601a      	str	r2, [r3, #0]
 800b690:	e002      	b.n	800b698 <wakeup+0x38>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 800b692:	68f8      	ldr	r0, [r7, #12]
 800b694:	f7ff ff06 	bl	800b4a4 <queue_dequeue>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 800b698:	68fb      	ldr	r3, [r7, #12]
 800b69a:	f04f 32ff 	mov.w	r2, #4294967295
 800b69e:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800b6a0:	68f8      	ldr	r0, [r7, #12]
 800b6a2:	f7ff ff27 	bl	800b4f4 <chSchReadyI>
  chSysUnlockFromISR();
 800b6a6:	f7ff fe7b 	bl	800b3a0 <chSysUnlockFromISR.lto_priv.321>
}
 800b6aa:	3710      	adds	r7, #16
 800b6ac:	46bd      	mov	sp, r7
 800b6ae:	bd80      	pop	{r7, pc}

0800b6b0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 800b6b0:	b580      	push	{r7, lr}
 800b6b2:	b088      	sub	sp, #32
 800b6b4:	af00      	add	r7, sp, #0
 800b6b6:	4603      	mov	r3, r0
 800b6b8:	460a      	mov	r2, r1
 800b6ba:	71fb      	strb	r3, [r7, #7]
 800b6bc:	4613      	mov	r3, r2
 800b6be:	80bb      	strh	r3, [r7, #4]

  chDbgCheckClassS();
 800b6c0:	f7ff fc8e 	bl	800afe0 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 800b6c4:	88bb      	ldrh	r3, [r7, #4]
 800b6c6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800b6ca:	4293      	cmp	r3, r2
 800b6cc:	d01b      	beq.n	800b706 <chSchGoSleepTimeoutS+0x56>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 800b6ce:	4b13      	ldr	r3, [pc, #76]	; (800b71c <chSchGoSleepTimeoutS+0x6c>)
 800b6d0:	699b      	ldr	r3, [r3, #24]
 800b6d2:	f107 010c 	add.w	r1, r7, #12
 800b6d6:	88ba      	ldrh	r2, [r7, #4]
 800b6d8:	4608      	mov	r0, r1
 800b6da:	4611      	mov	r1, r2
 800b6dc:	4a10      	ldr	r2, [pc, #64]	; (800b720 <chSchGoSleepTimeoutS+0x70>)
 800b6de:	f7ff fce3 	bl	800b0a8 <chVTDoSetI>
    chSchGoSleepS(newstate);
 800b6e2:	79fb      	ldrb	r3, [r7, #7]
 800b6e4:	4618      	mov	r0, r3
 800b6e6:	f7ff ff85 	bl	800b5f4 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800b6ea:	f107 030c 	add.w	r3, r7, #12
 800b6ee:	4618      	mov	r0, r3
 800b6f0:	f7ff fe5e 	bl	800b3b0 <chVTIsArmedI>
 800b6f4:	4603      	mov	r3, r0
 800b6f6:	2b00      	cmp	r3, #0
 800b6f8:	d009      	beq.n	800b70e <chSchGoSleepTimeoutS+0x5e>
      chVTDoResetI(&vt);
 800b6fa:	f107 030c 	add.w	r3, r7, #12
 800b6fe:	4618      	mov	r0, r3
 800b700:	f7ff fd7a 	bl	800b1f8 <chVTDoResetI>
 800b704:	e003      	b.n	800b70e <chSchGoSleepTimeoutS+0x5e>
    }
  }
  else {
    chSchGoSleepS(newstate);
 800b706:	79fb      	ldrb	r3, [r7, #7]
 800b708:	4618      	mov	r0, r3
 800b70a:	f7ff ff73 	bl	800b5f4 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 800b70e:	4b03      	ldr	r3, [pc, #12]	; (800b71c <chSchGoSleepTimeoutS+0x6c>)
 800b710:	699b      	ldr	r3, [r3, #24]
 800b712:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800b714:	4618      	mov	r0, r3
 800b716:	3720      	adds	r7, #32
 800b718:	46bd      	mov	sp, r7
 800b71a:	bd80      	pop	{r7, pc}
 800b71c:	20001338 	.word	0x20001338
 800b720:	0800b661 	.word	0x0800b661

0800b724 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 800b724:	b590      	push	{r4, r7, lr}
 800b726:	b085      	sub	sp, #20
 800b728:	af00      	add	r7, sp, #0
 800b72a:	6078      	str	r0, [r7, #4]
 800b72c:	6039      	str	r1, [r7, #0]
  thread_t *otp = currp;
 800b72e:	4b21      	ldr	r3, [pc, #132]	; (800b7b4 <chSchWakeupS+0x90>)
 800b730:	699b      	ldr	r3, [r3, #24]
 800b732:	60fb      	str	r3, [r7, #12]

  chDbgCheckClassS();
 800b734:	f7ff fc54 	bl	800afe0 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800b738:	4b1e      	ldr	r3, [pc, #120]	; (800b7b4 <chSchWakeupS+0x90>)
 800b73a:	681b      	ldr	r3, [r3, #0]
 800b73c:	4a1d      	ldr	r2, [pc, #116]	; (800b7b4 <chSchWakeupS+0x90>)
 800b73e:	4293      	cmp	r3, r2
 800b740:	d00a      	beq.n	800b758 <chSchWakeupS+0x34>
 800b742:	4b1c      	ldr	r3, [pc, #112]	; (800b7b4 <chSchWakeupS+0x90>)
 800b744:	699b      	ldr	r3, [r3, #24]
 800b746:	689a      	ldr	r2, [r3, #8]
 800b748:	4b1a      	ldr	r3, [pc, #104]	; (800b7b4 <chSchWakeupS+0x90>)
 800b74a:	681b      	ldr	r3, [r3, #0]
 800b74c:	689b      	ldr	r3, [r3, #8]
 800b74e:	429a      	cmp	r2, r3
 800b750:	d202      	bcs.n	800b758 <chSchWakeupS+0x34>
 800b752:	4819      	ldr	r0, [pc, #100]	; (800b7b8 <chSchWakeupS+0x94>)
 800b754:	f7ff fb54 	bl	800ae00 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 800b758:	687b      	ldr	r3, [r7, #4]
 800b75a:	683a      	ldr	r2, [r7, #0]
 800b75c:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 800b75e:	687b      	ldr	r3, [r7, #4]
 800b760:	689a      	ldr	r2, [r3, #8]
 800b762:	68fb      	ldr	r3, [r7, #12]
 800b764:	689b      	ldr	r3, [r3, #8]
 800b766:	429a      	cmp	r2, r3
 800b768:	d803      	bhi.n	800b772 <chSchWakeupS+0x4e>
    (void) chSchReadyI(ntp);
 800b76a:	6878      	ldr	r0, [r7, #4]
 800b76c:	f7ff fec2 	bl	800b4f4 <chSchReadyI>
 800b770:	e01d      	b.n	800b7ae <chSchWakeupS+0x8a>
  }
  else {
    otp = chSchReadyI(otp);
 800b772:	68f8      	ldr	r0, [r7, #12]
 800b774:	f7ff febe 	bl	800b4f4 <chSchReadyI>
 800b778:	60f8      	str	r0, [r7, #12]
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 800b77a:	4a0e      	ldr	r2, [pc, #56]	; (800b7b4 <chSchWakeupS+0x90>)
 800b77c:	687b      	ldr	r3, [r7, #4]
 800b77e:	6193      	str	r3, [r2, #24]
    ntp->state = CH_STATE_CURRENT;
 800b780:	687b      	ldr	r3, [r7, #4]
 800b782:	2201      	movs	r2, #1
 800b784:	f883 2020 	strb.w	r2, [r3, #32]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800b788:	f3ef 8309 	mrs	r3, PSP
 800b78c:	461c      	mov	r4, r3
  return(result);
 800b78e:	4623      	mov	r3, r4

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 800b790:	60bb      	str	r3, [r7, #8]
 800b792:	68bb      	ldr	r3, [r7, #8]
 800b794:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800b798:	68fb      	ldr	r3, [r7, #12]
 800b79a:	69db      	ldr	r3, [r3, #28]
 800b79c:	429a      	cmp	r2, r3
 800b79e:	d202      	bcs.n	800b7a6 <chSchWakeupS+0x82>
 800b7a0:	4806      	ldr	r0, [pc, #24]	; (800b7bc <chSchWakeupS+0x98>)
 800b7a2:	f7ff fb2d 	bl	800ae00 <chSysHalt>
 800b7a6:	6878      	ldr	r0, [r7, #4]
 800b7a8:	68f9      	ldr	r1, [r7, #12]
 800b7aa:	f7f7 fd7b 	bl	80032a4 <_port_switch>
  }
}
 800b7ae:	3714      	adds	r7, #20
 800b7b0:	46bd      	mov	sp, r7
 800b7b2:	bd90      	pop	{r4, r7, pc}
 800b7b4:	20001338 	.word	0x20001338
 800b7b8:	0800e8b8 	.word	0x0800e8b8
 800b7bc:	0800e6c8 	.word	0x0800e6c8

0800b7c0 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 800b7c0:	b580      	push	{r7, lr}
 800b7c2:	af00      	add	r7, sp, #0

  chDbgCheckClassS();
 800b7c4:	f7ff fc0c 	bl	800afe0 <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
 800b7c8:	f7ff fdce 	bl	800b368 <chSchIsRescRequiredI>
 800b7cc:	4603      	mov	r3, r0
 800b7ce:	2b00      	cmp	r3, #0
 800b7d0:	d001      	beq.n	800b7d6 <chSchRescheduleS+0x16>
    chSchDoRescheduleAhead();
 800b7d2:	f000 f81b 	bl	800b80c <chSchDoRescheduleAhead>
  }
}
 800b7d6:	bd80      	pop	{r7, pc}

0800b7d8 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 800b7d8:	b480      	push	{r7}
 800b7da:	b083      	sub	sp, #12
 800b7dc:	af00      	add	r7, sp, #0
  tprio_t p1 = firstprio(&ch.rlist.queue);
 800b7de:	4b0a      	ldr	r3, [pc, #40]	; (800b808 <chSchIsPreemptionRequired+0x30>)
 800b7e0:	681b      	ldr	r3, [r3, #0]
 800b7e2:	689b      	ldr	r3, [r3, #8]
 800b7e4:	607b      	str	r3, [r7, #4]
  tprio_t p2 = currp->prio;
 800b7e6:	4b08      	ldr	r3, [pc, #32]	; (800b808 <chSchIsPreemptionRequired+0x30>)
 800b7e8:	699b      	ldr	r3, [r3, #24]
 800b7ea:	689b      	ldr	r3, [r3, #8]
 800b7ec:	603b      	str	r3, [r7, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 800b7ee:	687a      	ldr	r2, [r7, #4]
 800b7f0:	683b      	ldr	r3, [r7, #0]
 800b7f2:	429a      	cmp	r2, r3
 800b7f4:	bf8c      	ite	hi
 800b7f6:	2301      	movhi	r3, #1
 800b7f8:	2300      	movls	r3, #0
 800b7fa:	b2db      	uxtb	r3, r3
#endif
}
 800b7fc:	4618      	mov	r0, r3
 800b7fe:	370c      	adds	r7, #12
 800b800:	46bd      	mov	sp, r7
 800b802:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b806:	4770      	bx	lr
 800b808:	20001338 	.word	0x20001338

0800b80c <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 800b80c:	b590      	push	{r4, r7, lr}
 800b80e:	b083      	sub	sp, #12
 800b810:	af00      	add	r7, sp, #0
  thread_t *otp = currp;
 800b812:	4b15      	ldr	r3, [pc, #84]	; (800b868 <chSchDoRescheduleAhead+0x5c>)
 800b814:	699b      	ldr	r3, [r3, #24]
 800b816:	607b      	str	r3, [r7, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800b818:	4813      	ldr	r0, [pc, #76]	; (800b868 <chSchDoRescheduleAhead+0x5c>)
 800b81a:	f7ff fe2d 	bl	800b478 <queue_fifo_remove>
 800b81e:	4602      	mov	r2, r0
 800b820:	4b11      	ldr	r3, [pc, #68]	; (800b868 <chSchDoRescheduleAhead+0x5c>)
 800b822:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800b824:	4b10      	ldr	r3, [pc, #64]	; (800b868 <chSchDoRescheduleAhead+0x5c>)
 800b826:	699b      	ldr	r3, [r3, #24]
 800b828:	2201      	movs	r2, #1
 800b82a:	f883 2020 	strb.w	r2, [r3, #32]
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
 800b82e:	6878      	ldr	r0, [r7, #4]
 800b830:	f7ff fea0 	bl	800b574 <chSchReadyAheadI>
 800b834:	6078      	str	r0, [r7, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800b836:	f3ef 8309 	mrs	r3, PSP
 800b83a:	461c      	mov	r4, r3
  return(result);
 800b83c:	4623      	mov	r3, r4

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800b83e:	603b      	str	r3, [r7, #0]
 800b840:	683b      	ldr	r3, [r7, #0]
 800b842:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800b846:	687b      	ldr	r3, [r7, #4]
 800b848:	69db      	ldr	r3, [r3, #28]
 800b84a:	429a      	cmp	r2, r3
 800b84c:	d202      	bcs.n	800b854 <chSchDoRescheduleAhead+0x48>
 800b84e:	4807      	ldr	r0, [pc, #28]	; (800b86c <chSchDoRescheduleAhead+0x60>)
 800b850:	f7ff fad6 	bl	800ae00 <chSysHalt>
 800b854:	4b04      	ldr	r3, [pc, #16]	; (800b868 <chSchDoRescheduleAhead+0x5c>)
 800b856:	699b      	ldr	r3, [r3, #24]
 800b858:	4618      	mov	r0, r3
 800b85a:	6879      	ldr	r1, [r7, #4]
 800b85c:	f7f7 fd22 	bl	80032a4 <_port_switch>
}
 800b860:	370c      	adds	r7, #12
 800b862:	46bd      	mov	sp, r7
 800b864:	bd90      	pop	{r4, r7, pc}
 800b866:	bf00      	nop
 800b868:	20001338 	.word	0x20001338
 800b86c:	0800e6c8 	.word	0x0800e6c8

0800b870 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 800b870:	b590      	push	{r4, r7, lr}
 800b872:	b083      	sub	sp, #12
 800b874:	af00      	add	r7, sp, #0
  thread_t *otp = currp;
 800b876:	4b15      	ldr	r3, [pc, #84]	; (800b8cc <chSchDoReschedule+0x5c>)
 800b878:	699b      	ldr	r3, [r3, #24]
 800b87a:	607b      	str	r3, [r7, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800b87c:	4813      	ldr	r0, [pc, #76]	; (800b8cc <chSchDoReschedule+0x5c>)
 800b87e:	f7ff fdfb 	bl	800b478 <queue_fifo_remove>
 800b882:	4602      	mov	r2, r0
 800b884:	4b11      	ldr	r3, [pc, #68]	; (800b8cc <chSchDoReschedule+0x5c>)
 800b886:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800b888:	4b10      	ldr	r3, [pc, #64]	; (800b8cc <chSchDoReschedule+0x5c>)
 800b88a:	699b      	ldr	r3, [r3, #24]
 800b88c:	2201      	movs	r2, #1
 800b88e:	f883 2020 	strb.w	r2, [r3, #32]
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
 800b892:	6878      	ldr	r0, [r7, #4]
 800b894:	f7ff fe6e 	bl	800b574 <chSchReadyAheadI>
 800b898:	6078      	str	r0, [r7, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800b89a:	f3ef 8309 	mrs	r3, PSP
 800b89e:	461c      	mov	r4, r3
  return(result);
 800b8a0:	4623      	mov	r3, r4
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800b8a2:	603b      	str	r3, [r7, #0]
 800b8a4:	683b      	ldr	r3, [r7, #0]
 800b8a6:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800b8aa:	687b      	ldr	r3, [r7, #4]
 800b8ac:	69db      	ldr	r3, [r3, #28]
 800b8ae:	429a      	cmp	r2, r3
 800b8b0:	d202      	bcs.n	800b8b8 <chSchDoReschedule+0x48>
 800b8b2:	4807      	ldr	r0, [pc, #28]	; (800b8d0 <chSchDoReschedule+0x60>)
 800b8b4:	f7ff faa4 	bl	800ae00 <chSysHalt>
 800b8b8:	4b04      	ldr	r3, [pc, #16]	; (800b8cc <chSchDoReschedule+0x5c>)
 800b8ba:	699b      	ldr	r3, [r3, #24]
 800b8bc:	4618      	mov	r0, r3
 800b8be:	6879      	ldr	r1, [r7, #4]
 800b8c0:	f7f7 fcf0 	bl	80032a4 <_port_switch>
}
 800b8c4:	370c      	adds	r7, #12
 800b8c6:	46bd      	mov	sp, r7
 800b8c8:	bd90      	pop	{r4, r7, pc}
 800b8ca:	bf00      	nop
 800b8cc:	20001338 	.word	0x20001338
 800b8d0:	0800e6c8 	.word	0x0800e6c8

0800b8d4 <port_lock.lto_priv.318>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800b8d4:	b480      	push	{r7}
 800b8d6:	b083      	sub	sp, #12
 800b8d8:	af00      	add	r7, sp, #0
 800b8da:	2320      	movs	r3, #32
 800b8dc:	607b      	str	r3, [r7, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800b8de:	687b      	ldr	r3, [r7, #4]
 800b8e0:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b8e4:	370c      	adds	r7, #12
 800b8e6:	46bd      	mov	sp, r7
 800b8e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b8ec:	4770      	bx	lr
 800b8ee:	bf00      	nop

0800b8f0 <port_unlock.lto_priv.315>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800b8f0:	b480      	push	{r7}
 800b8f2:	b083      	sub	sp, #12
 800b8f4:	af00      	add	r7, sp, #0
 800b8f6:	2300      	movs	r3, #0
 800b8f8:	607b      	str	r3, [r7, #4]
 800b8fa:	687b      	ldr	r3, [r7, #4]
 800b8fc:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b900:	370c      	adds	r7, #12
 800b902:	46bd      	mov	sp, r7
 800b904:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b908:	4770      	bx	lr
 800b90a:	bf00      	nop

0800b90c <list_init>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 800b90c:	b480      	push	{r7}
 800b90e:	b083      	sub	sp, #12
 800b910:	af00      	add	r7, sp, #0
 800b912:	6078      	str	r0, [r7, #4]

  tlp->next = (thread_t *)tlp;
 800b914:	687b      	ldr	r3, [r7, #4]
 800b916:	687a      	ldr	r2, [r7, #4]
 800b918:	601a      	str	r2, [r3, #0]
}
 800b91a:	370c      	adds	r7, #12
 800b91c:	46bd      	mov	sp, r7
 800b91e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b922:	4770      	bx	lr

0800b924 <list_notempty.lto_priv.305>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 800b924:	b480      	push	{r7}
 800b926:	b083      	sub	sp, #12
 800b928:	af00      	add	r7, sp, #0
 800b92a:	6078      	str	r0, [r7, #4]

  return (bool)(tlp->next != (thread_t *)tlp);
 800b92c:	687b      	ldr	r3, [r7, #4]
 800b92e:	681a      	ldr	r2, [r3, #0]
 800b930:	687b      	ldr	r3, [r7, #4]
 800b932:	429a      	cmp	r2, r3
 800b934:	bf14      	ite	ne
 800b936:	2301      	movne	r3, #1
 800b938:	2300      	moveq	r3, #0
 800b93a:	b2db      	uxtb	r3, r3
}
 800b93c:	4618      	mov	r0, r3
 800b93e:	370c      	adds	r7, #12
 800b940:	46bd      	mov	sp, r7
 800b942:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b946:	4770      	bx	lr

0800b948 <queue_notempty.lto_priv.282>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 800b948:	b480      	push	{r7}
 800b94a:	b083      	sub	sp, #12
 800b94c:	af00      	add	r7, sp, #0
 800b94e:	6078      	str	r0, [r7, #4]

  return (bool)(tqp->next != (const thread_t *)tqp);
 800b950:	687b      	ldr	r3, [r7, #4]
 800b952:	681a      	ldr	r2, [r3, #0]
 800b954:	687b      	ldr	r3, [r7, #4]
 800b956:	429a      	cmp	r2, r3
 800b958:	bf14      	ite	ne
 800b95a:	2301      	movne	r3, #1
 800b95c:	2300      	moveq	r3, #0
 800b95e:	b2db      	uxtb	r3, r3
}
 800b960:	4618      	mov	r0, r3
 800b962:	370c      	adds	r7, #12
 800b964:	46bd      	mov	sp, r7
 800b966:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b96a:	4770      	bx	lr

0800b96c <chSysLock.lto_priv.274>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800b96c:	b580      	push	{r7, lr}
 800b96e:	af00      	add	r7, sp, #0

  port_lock();
 800b970:	f7ff ffb0 	bl	800b8d4 <port_lock.lto_priv.318>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800b974:	f7ff fa92 	bl	800ae9c <_dbg_check_lock>
}
 800b978:	bd80      	pop	{r7, pc}
 800b97a:	bf00      	nop

0800b97c <chSysUnlock.lto_priv.270>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800b97c:	b580      	push	{r7, lr}
 800b97e:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 800b980:	f7ff faa2 	bl	800aec8 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800b984:	4b09      	ldr	r3, [pc, #36]	; (800b9ac <chSysUnlock.lto_priv.270+0x30>)
 800b986:	681b      	ldr	r3, [r3, #0]
 800b988:	4a08      	ldr	r2, [pc, #32]	; (800b9ac <chSysUnlock.lto_priv.270+0x30>)
 800b98a:	4293      	cmp	r3, r2
 800b98c:	d00a      	beq.n	800b9a4 <chSysUnlock.lto_priv.270+0x28>
 800b98e:	4b07      	ldr	r3, [pc, #28]	; (800b9ac <chSysUnlock.lto_priv.270+0x30>)
 800b990:	699b      	ldr	r3, [r3, #24]
 800b992:	689a      	ldr	r2, [r3, #8]
 800b994:	4b05      	ldr	r3, [pc, #20]	; (800b9ac <chSysUnlock.lto_priv.270+0x30>)
 800b996:	681b      	ldr	r3, [r3, #0]
 800b998:	689b      	ldr	r3, [r3, #8]
 800b99a:	429a      	cmp	r2, r3
 800b99c:	d202      	bcs.n	800b9a4 <chSysUnlock.lto_priv.270+0x28>
 800b99e:	4804      	ldr	r0, [pc, #16]	; (800b9b0 <chSysUnlock.lto_priv.270+0x34>)
 800b9a0:	f7ff fa2e 	bl	800ae00 <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 800b9a4:	f7ff ffa4 	bl	800b8f0 <port_unlock.lto_priv.315>
}
 800b9a8:	bd80      	pop	{r7, pc}
 800b9aa:	bf00      	nop
 800b9ac:	20001338 	.word	0x20001338
 800b9b0:	0800e8e0 	.word	0x0800e8e0

0800b9b4 <chThdGetSelfX.lto_priv.300>:
  *
  * @return             A pointer to the current thread.
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {
 800b9b4:	b480      	push	{r7}
 800b9b6:	af00      	add	r7, sp, #0

  return ch.rlist.current;
 800b9b8:	4b03      	ldr	r3, [pc, #12]	; (800b9c8 <chThdGetSelfX.lto_priv.300+0x14>)
 800b9ba:	699b      	ldr	r3, [r3, #24]
}
 800b9bc:	4618      	mov	r0, r3
 800b9be:	46bd      	mov	sp, r7
 800b9c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b9c4:	4770      	bx	lr
 800b9c6:	bf00      	nop
 800b9c8:	20001338 	.word	0x20001338

0800b9cc <chThdGetWorkingAreaX.lto_priv.285>:
 * @param[in] tp        pointer to the thread
 * @return              The working area base pointer.
 *
 * @xclass
 */
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 800b9cc:	b480      	push	{r7}
 800b9ce:	b083      	sub	sp, #12
 800b9d0:	af00      	add	r7, sp, #0
 800b9d2:	6078      	str	r0, [r7, #4]

  return tp->wabase;
 800b9d4:	687b      	ldr	r3, [r7, #4]
 800b9d6:	69db      	ldr	r3, [r3, #28]
}
 800b9d8:	4618      	mov	r0, r3
 800b9da:	370c      	adds	r7, #12
 800b9dc:	46bd      	mov	sp, r7
 800b9de:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b9e2:	4770      	bx	lr

0800b9e4 <chThdDoDequeueNextI.lto_priv.299>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 800b9e4:	b580      	push	{r7, lr}
 800b9e6:	b084      	sub	sp, #16
 800b9e8:	af00      	add	r7, sp, #0
 800b9ea:	6078      	str	r0, [r7, #4]
 800b9ec:	6039      	str	r1, [r7, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
 800b9ee:	6878      	ldr	r0, [r7, #4]
 800b9f0:	f7ff ffaa 	bl	800b948 <queue_notempty.lto_priv.282>
 800b9f4:	4603      	mov	r3, r0
 800b9f6:	f083 0301 	eor.w	r3, r3, #1
 800b9fa:	b2db      	uxtb	r3, r3
 800b9fc:	2b00      	cmp	r3, #0
 800b9fe:	d002      	beq.n	800ba06 <chThdDoDequeueNextI.lto_priv.299+0x22>
 800ba00:	480b      	ldr	r0, [pc, #44]	; (800ba30 <chThdDoDequeueNextI.lto_priv.299+0x4c>)
 800ba02:	f7ff f9fd 	bl	800ae00 <chSysHalt>

  tp = queue_fifo_remove(tqp);
 800ba06:	6878      	ldr	r0, [r7, #4]
 800ba08:	f7ff fd36 	bl	800b478 <queue_fifo_remove>
 800ba0c:	60f8      	str	r0, [r7, #12]

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 800ba0e:	68fb      	ldr	r3, [r7, #12]
 800ba10:	f893 3020 	ldrb.w	r3, [r3, #32]
 800ba14:	2b04      	cmp	r3, #4
 800ba16:	d002      	beq.n	800ba1e <chThdDoDequeueNextI.lto_priv.299+0x3a>
 800ba18:	4805      	ldr	r0, [pc, #20]	; (800ba30 <chThdDoDequeueNextI.lto_priv.299+0x4c>)
 800ba1a:	f7ff f9f1 	bl	800ae00 <chSysHalt>

  tp->u.rdymsg = msg;
 800ba1e:	68fb      	ldr	r3, [r7, #12]
 800ba20:	683a      	ldr	r2, [r7, #0]
 800ba22:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800ba24:	68f8      	ldr	r0, [r7, #12]
 800ba26:	f7ff fd65 	bl	800b4f4 <chSchReadyI>
}
 800ba2a:	3710      	adds	r7, #16
 800ba2c:	46bd      	mov	sp, r7
 800ba2e:	bd80      	pop	{r7, pc}
 800ba30:	0800e960 	.word	0x0800e960

0800ba34 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
 800ba34:	b580      	push	{r7, lr}
 800ba36:	b084      	sub	sp, #16
 800ba38:	af00      	add	r7, sp, #0
 800ba3a:	60f8      	str	r0, [r7, #12]
 800ba3c:	60b9      	str	r1, [r7, #8]
 800ba3e:	607a      	str	r2, [r7, #4]

  tp->prio      = prio;
 800ba40:	68fb      	ldr	r3, [r7, #12]
 800ba42:	687a      	ldr	r2, [r7, #4]
 800ba44:	609a      	str	r2, [r3, #8]
  tp->state     = CH_STATE_WTSTART;
 800ba46:	68fb      	ldr	r3, [r7, #12]
 800ba48:	2202      	movs	r2, #2
 800ba4a:	f883 2020 	strb.w	r2, [r3, #32]
  tp->flags     = CH_FLAG_MODE_STATIC;
 800ba4e:	68fb      	ldr	r3, [r7, #12]
 800ba50:	2200      	movs	r2, #0
 800ba52:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 800ba56:	68fb      	ldr	r3, [r7, #12]
 800ba58:	687a      	ldr	r2, [r7, #4]
 800ba5a:	631a      	str	r2, [r3, #48]	; 0x30
  tp->mtxlist   = NULL;
 800ba5c:	68fb      	ldr	r3, [r7, #12]
 800ba5e:	2200      	movs	r2, #0
 800ba60:	62da      	str	r2, [r3, #44]	; 0x2c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800ba62:	68fb      	ldr	r3, [r7, #12]
 800ba64:	2201      	movs	r2, #1
 800ba66:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  tp->name      = name;
 800ba6a:	68fb      	ldr	r3, [r7, #12]
 800ba6c:	68ba      	ldr	r2, [r7, #8]
 800ba6e:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 800ba70:	68fb      	ldr	r3, [r7, #12]
 800ba72:	4a0b      	ldr	r2, [pc, #44]	; (800baa0 <_thread_init+0x6c>)
 800ba74:	611a      	str	r2, [r3, #16]
 800ba76:	4b0a      	ldr	r3, [pc, #40]	; (800baa0 <_thread_init+0x6c>)
 800ba78:	695a      	ldr	r2, [r3, #20]
 800ba7a:	68fb      	ldr	r3, [r7, #12]
 800ba7c:	615a      	str	r2, [r3, #20]
 800ba7e:	68fb      	ldr	r3, [r7, #12]
 800ba80:	695b      	ldr	r3, [r3, #20]
 800ba82:	68fa      	ldr	r2, [r7, #12]
 800ba84:	611a      	str	r2, [r3, #16]
 800ba86:	4a06      	ldr	r2, [pc, #24]	; (800baa0 <_thread_init+0x6c>)
 800ba88:	68fb      	ldr	r3, [r7, #12]
 800ba8a:	6153      	str	r3, [r2, #20]
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 800ba8c:	68fb      	ldr	r3, [r7, #12]
 800ba8e:	3328      	adds	r3, #40	; 0x28
 800ba90:	4618      	mov	r0, r3
 800ba92:	f7ff ff3b 	bl	800b90c <list_init>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 800ba96:	68fb      	ldr	r3, [r7, #12]
}
 800ba98:	4618      	mov	r0, r3
 800ba9a:	3710      	adds	r7, #16
 800ba9c:	46bd      	mov	sp, r7
 800ba9e:	bd80      	pop	{r7, pc}
 800baa0:	20001338 	.word	0x20001338

0800baa4 <_thread_memfill>:
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
 800baa4:	b480      	push	{r7}
 800baa6:	b085      	sub	sp, #20
 800baa8:	af00      	add	r7, sp, #0
 800baaa:	60f8      	str	r0, [r7, #12]
 800baac:	60b9      	str	r1, [r7, #8]
 800baae:	4613      	mov	r3, r2
 800bab0:	71fb      	strb	r3, [r7, #7]
 800bab2:	e004      	b.n	800babe <_thread_memfill+0x1a>

  while (startp < endp) {
    *startp++ = v;
 800bab4:	68fb      	ldr	r3, [r7, #12]
 800bab6:	1c5a      	adds	r2, r3, #1
 800bab8:	60fa      	str	r2, [r7, #12]
 800baba:	79fa      	ldrb	r2, [r7, #7]
 800babc:	701a      	strb	r2, [r3, #0]
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 800babe:	68fa      	ldr	r2, [r7, #12]
 800bac0:	68bb      	ldr	r3, [r7, #8]
 800bac2:	429a      	cmp	r2, r3
 800bac4:	d3f6      	bcc.n	800bab4 <_thread_memfill+0x10>
    *startp++ = v;
  }
}
 800bac6:	3714      	adds	r7, #20
 800bac8:	46bd      	mov	sp, r7
 800baca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bace:	4770      	bx	lr

0800bad0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 800bad0:	b580      	push	{r7, lr}
 800bad2:	b084      	sub	sp, #16
 800bad4:	af00      	add	r7, sp, #0
 800bad6:	6078      	str	r0, [r7, #4]
  thread_t *tp;

  chDbgCheckClassI();
 800bad8:	f7ff fa70 	bl	800afbc <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 800badc:	687b      	ldr	r3, [r7, #4]
 800bade:	2b00      	cmp	r3, #0
 800bae0:	d102      	bne.n	800bae8 <chThdCreateSuspendedI+0x18>
 800bae2:	482a      	ldr	r0, [pc, #168]	; (800bb8c <chThdCreateSuspendedI+0xbc>)
 800bae4:	f7ff f98c 	bl	800ae00 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 800bae8:	687b      	ldr	r3, [r7, #4]
 800baea:	685b      	ldr	r3, [r3, #4]
 800baec:	f003 0307 	and.w	r3, r3, #7
 800baf0:	2b00      	cmp	r3, #0
 800baf2:	d113      	bne.n	800bb1c <chThdCreateSuspendedI+0x4c>
 800baf4:	687b      	ldr	r3, [r7, #4]
 800baf6:	689b      	ldr	r3, [r3, #8]
 800baf8:	f003 0307 	and.w	r3, r3, #7
 800bafc:	2b00      	cmp	r3, #0
 800bafe:	d10d      	bne.n	800bb1c <chThdCreateSuspendedI+0x4c>
 800bb00:	687b      	ldr	r3, [r7, #4]
 800bb02:	689a      	ldr	r2, [r3, #8]
 800bb04:	687b      	ldr	r3, [r7, #4]
 800bb06:	685b      	ldr	r3, [r3, #4]
 800bb08:	429a      	cmp	r2, r3
 800bb0a:	d907      	bls.n	800bb1c <chThdCreateSuspendedI+0x4c>
 800bb0c:	687b      	ldr	r3, [r7, #4]
 800bb0e:	689b      	ldr	r3, [r3, #8]
 800bb10:	461a      	mov	r2, r3
 800bb12:	687b      	ldr	r3, [r7, #4]
 800bb14:	685b      	ldr	r3, [r3, #4]
 800bb16:	1ad3      	subs	r3, r2, r3
 800bb18:	2bbf      	cmp	r3, #191	; 0xbf
 800bb1a:	d802      	bhi.n	800bb22 <chThdCreateSuspendedI+0x52>
 800bb1c:	481b      	ldr	r0, [pc, #108]	; (800bb8c <chThdCreateSuspendedI+0xbc>)
 800bb1e:	f7ff f96f 	bl	800ae00 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 800bb22:	687b      	ldr	r3, [r7, #4]
 800bb24:	68db      	ldr	r3, [r3, #12]
 800bb26:	2bff      	cmp	r3, #255	; 0xff
 800bb28:	d803      	bhi.n	800bb32 <chThdCreateSuspendedI+0x62>
 800bb2a:	687b      	ldr	r3, [r7, #4]
 800bb2c:	691b      	ldr	r3, [r3, #16]
 800bb2e:	2b00      	cmp	r3, #0
 800bb30:	d102      	bne.n	800bb38 <chThdCreateSuspendedI+0x68>
 800bb32:	4816      	ldr	r0, [pc, #88]	; (800bb8c <chThdCreateSuspendedI+0xbc>)
 800bb34:	f7ff f964 	bl	800ae00 <chSysHalt>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 800bb38:	687b      	ldr	r3, [r7, #4]
 800bb3a:	689b      	ldr	r3, [r3, #8]
 800bb3c:	3b38      	subs	r3, #56	; 0x38
 800bb3e:	60fb      	str	r3, [r7, #12]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 800bb40:	687b      	ldr	r3, [r7, #4]
 800bb42:	685a      	ldr	r2, [r3, #4]
 800bb44:	68fb      	ldr	r3, [r7, #12]
 800bb46:	61da      	str	r2, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800bb48:	68fb      	ldr	r3, [r7, #12]
 800bb4a:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800bb4e:	68fb      	ldr	r3, [r7, #12]
 800bb50:	60da      	str	r2, [r3, #12]
 800bb52:	68fb      	ldr	r3, [r7, #12]
 800bb54:	68db      	ldr	r3, [r3, #12]
 800bb56:	687a      	ldr	r2, [r7, #4]
 800bb58:	6912      	ldr	r2, [r2, #16]
 800bb5a:	601a      	str	r2, [r3, #0]
 800bb5c:	68fb      	ldr	r3, [r7, #12]
 800bb5e:	68db      	ldr	r3, [r3, #12]
 800bb60:	687a      	ldr	r2, [r7, #4]
 800bb62:	6952      	ldr	r2, [r2, #20]
 800bb64:	605a      	str	r2, [r3, #4]
 800bb66:	68fb      	ldr	r3, [r7, #12]
 800bb68:	68db      	ldr	r3, [r3, #12]
 800bb6a:	4a09      	ldr	r2, [pc, #36]	; (800bb90 <chThdCreateSuspendedI+0xc0>)
 800bb6c:	621a      	str	r2, [r3, #32]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 800bb6e:	687b      	ldr	r3, [r7, #4]
 800bb70:	681a      	ldr	r2, [r3, #0]
 800bb72:	687b      	ldr	r3, [r7, #4]
 800bb74:	68db      	ldr	r3, [r3, #12]
 800bb76:	68f8      	ldr	r0, [r7, #12]
 800bb78:	4611      	mov	r1, r2
 800bb7a:	461a      	mov	r2, r3
 800bb7c:	f7ff ff5a 	bl	800ba34 <_thread_init>
 800bb80:	4603      	mov	r3, r0
}
 800bb82:	4618      	mov	r0, r3
 800bb84:	3710      	adds	r7, #16
 800bb86:	46bd      	mov	sp, r7
 800bb88:	bd80      	pop	{r7, pc}
 800bb8a:	bf00      	nop
 800bb8c:	0800e8c8 	.word	0x0800e8c8
 800bb90:	080032b5 	.word	0x080032b5

0800bb94 <_decode_uavcan_protocol_dynamic_node_id_Allocation>:
            canardEncodeScalar(buffer, 0, 8, &msg->unique_id[i]);
            chunk_cb(buffer, 8, ctx);
    }
}

void _decode_uavcan_protocol_dynamic_node_id_Allocation(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_dynamic_node_id_Allocation_s* msg, bool tao) {
 800bb94:	b580      	push	{r7, lr}
 800bb96:	b088      	sub	sp, #32
 800bb98:	af02      	add	r7, sp, #8
 800bb9a:	60f8      	str	r0, [r7, #12]
 800bb9c:	60b9      	str	r1, [r7, #8]
 800bb9e:	607a      	str	r2, [r7, #4]
 800bba0:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 7, false, &msg->node_id);
 800bba2:	68bb      	ldr	r3, [r7, #8]
 800bba4:	681a      	ldr	r2, [r3, #0]
 800bba6:	687b      	ldr	r3, [r7, #4]
 800bba8:	9300      	str	r3, [sp, #0]
 800bbaa:	68f8      	ldr	r0, [r7, #12]
 800bbac:	4611      	mov	r1, r2
 800bbae:	2207      	movs	r2, #7
 800bbb0:	2300      	movs	r3, #0
 800bbb2:	f001 fb1b 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 7;
 800bbb6:	68bb      	ldr	r3, [r7, #8]
 800bbb8:	681b      	ldr	r3, [r3, #0]
 800bbba:	1dda      	adds	r2, r3, #7
 800bbbc:	68bb      	ldr	r3, [r7, #8]
 800bbbe:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 1, false, &msg->first_part_of_unique_id);
 800bbc0:	68bb      	ldr	r3, [r7, #8]
 800bbc2:	681a      	ldr	r2, [r3, #0]
 800bbc4:	687b      	ldr	r3, [r7, #4]
 800bbc6:	3301      	adds	r3, #1
 800bbc8:	9300      	str	r3, [sp, #0]
 800bbca:	68f8      	ldr	r0, [r7, #12]
 800bbcc:	4611      	mov	r1, r2
 800bbce:	2201      	movs	r2, #1
 800bbd0:	2300      	movs	r3, #0
 800bbd2:	f001 fb0b 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 1;
 800bbd6:	68bb      	ldr	r3, [r7, #8]
 800bbd8:	681b      	ldr	r3, [r3, #0]
 800bbda:	1c5a      	adds	r2, r3, #1
 800bbdc:	68bb      	ldr	r3, [r7, #8]
 800bbde:	601a      	str	r2, [r3, #0]

    if (!tao) {
 800bbe0:	78fb      	ldrb	r3, [r7, #3]
 800bbe2:	f083 0301 	eor.w	r3, r3, #1
 800bbe6:	b2db      	uxtb	r3, r3
 800bbe8:	2b00      	cmp	r3, #0
 800bbea:	d010      	beq.n	800bc0e <_decode_uavcan_protocol_dynamic_node_id_Allocation+0x7a>
        canardDecodeScalar(transfer, *bit_ofs, 5, false, &msg->unique_id_len);
 800bbec:	68bb      	ldr	r3, [r7, #8]
 800bbee:	681a      	ldr	r2, [r3, #0]
 800bbf0:	687b      	ldr	r3, [r7, #4]
 800bbf2:	3302      	adds	r3, #2
 800bbf4:	9300      	str	r3, [sp, #0]
 800bbf6:	68f8      	ldr	r0, [r7, #12]
 800bbf8:	4611      	mov	r1, r2
 800bbfa:	2205      	movs	r2, #5
 800bbfc:	2300      	movs	r3, #0
 800bbfe:	f001 faf5 	bl	800d1ec <canardDecodeScalar>
        *bit_ofs += 5;
 800bc02:	68bb      	ldr	r3, [r7, #8]
 800bc04:	681b      	ldr	r3, [r3, #0]
 800bc06:	1d5a      	adds	r2, r3, #5
 800bc08:	68bb      	ldr	r3, [r7, #8]
 800bc0a:	601a      	str	r2, [r3, #0]
 800bc0c:	e00a      	b.n	800bc24 <_decode_uavcan_protocol_dynamic_node_id_Allocation+0x90>
    } else {
        msg->unique_id_len = ((transfer->payload_len*8)-*bit_ofs)/8;
 800bc0e:	68fb      	ldr	r3, [r7, #12]
 800bc10:	8a9b      	ldrh	r3, [r3, #20]
 800bc12:	00db      	lsls	r3, r3, #3
 800bc14:	461a      	mov	r2, r3
 800bc16:	68bb      	ldr	r3, [r7, #8]
 800bc18:	681b      	ldr	r3, [r3, #0]
 800bc1a:	1ad3      	subs	r3, r2, r3
 800bc1c:	08db      	lsrs	r3, r3, #3
 800bc1e:	b2da      	uxtb	r2, r3
 800bc20:	687b      	ldr	r3, [r7, #4]
 800bc22:	709a      	strb	r2, [r3, #2]
    }

    for (size_t i=0; i < msg->unique_id_len; i++) {
 800bc24:	2300      	movs	r3, #0
 800bc26:	617b      	str	r3, [r7, #20]
 800bc28:	e014      	b.n	800bc54 <_decode_uavcan_protocol_dynamic_node_id_Allocation+0xc0>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->unique_id[i]);
 800bc2a:	68bb      	ldr	r3, [r7, #8]
 800bc2c:	6819      	ldr	r1, [r3, #0]
 800bc2e:	687a      	ldr	r2, [r7, #4]
 800bc30:	697b      	ldr	r3, [r7, #20]
 800bc32:	4413      	add	r3, r2
 800bc34:	3303      	adds	r3, #3
 800bc36:	9300      	str	r3, [sp, #0]
 800bc38:	68f8      	ldr	r0, [r7, #12]
 800bc3a:	2208      	movs	r2, #8
 800bc3c:	2300      	movs	r3, #0
 800bc3e:	f001 fad5 	bl	800d1ec <canardDecodeScalar>
        *bit_ofs += 8;
 800bc42:	68bb      	ldr	r3, [r7, #8]
 800bc44:	681b      	ldr	r3, [r3, #0]
 800bc46:	f103 0208 	add.w	r2, r3, #8
 800bc4a:	68bb      	ldr	r3, [r7, #8]
 800bc4c:	601a      	str	r2, [r3, #0]
        *bit_ofs += 5;
    } else {
        msg->unique_id_len = ((transfer->payload_len*8)-*bit_ofs)/8;
    }

    for (size_t i=0; i < msg->unique_id_len; i++) {
 800bc4e:	697b      	ldr	r3, [r7, #20]
 800bc50:	3301      	adds	r3, #1
 800bc52:	617b      	str	r3, [r7, #20]
 800bc54:	687b      	ldr	r3, [r7, #4]
 800bc56:	789b      	ldrb	r3, [r3, #2]
 800bc58:	461a      	mov	r2, r3
 800bc5a:	697b      	ldr	r3, [r7, #20]
 800bc5c:	429a      	cmp	r2, r3
 800bc5e:	d8e4      	bhi.n	800bc2a <_decode_uavcan_protocol_dynamic_node_id_Allocation+0x96>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->unique_id[i]);
        *bit_ofs += 8;
    }

}
 800bc60:	3718      	adds	r7, #24
 800bc62:	46bd      	mov	sp, r7
 800bc64:	bd80      	pop	{r7, pc}
 800bc66:	bf00      	nop

0800bc68 <_encode_uavcan_protocol_debug_LogLevel>:
    uint32_t bit_ofs = 0;
    _decode_uavcan_protocol_debug_LogLevel(transfer, &bit_ofs, msg, true);
    return (bit_ofs+7)/8;
}

void _encode_uavcan_protocol_debug_LogLevel(uint8_t* buffer, struct uavcan_protocol_debug_LogLevel_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800bc68:	b580      	push	{r7, lr}
 800bc6a:	b084      	sub	sp, #16
 800bc6c:	af00      	add	r7, sp, #0
 800bc6e:	60f8      	str	r0, [r7, #12]
 800bc70:	60b9      	str	r1, [r7, #8]
 800bc72:	607a      	str	r2, [r7, #4]
 800bc74:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
 800bc76:	68f8      	ldr	r0, [r7, #12]
 800bc78:	2100      	movs	r1, #0
 800bc7a:	2208      	movs	r2, #8
 800bc7c:	f002 fca6 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 3, &msg->value);
 800bc80:	68bb      	ldr	r3, [r7, #8]
 800bc82:	68f8      	ldr	r0, [r7, #12]
 800bc84:	2100      	movs	r1, #0
 800bc86:	2203      	movs	r2, #3
 800bc88:	f001 fc28 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 3, ctx);
 800bc8c:	687b      	ldr	r3, [r7, #4]
 800bc8e:	68f8      	ldr	r0, [r7, #12]
 800bc90:	2103      	movs	r1, #3
 800bc92:	683a      	ldr	r2, [r7, #0]
 800bc94:	4798      	blx	r3
}
 800bc96:	3710      	adds	r7, #16
 800bc98:	46bd      	mov	sp, r7
 800bc9a:	bd80      	pop	{r7, pc}

0800bc9c <_decode_uavcan_protocol_debug_LogLevel>:

void _decode_uavcan_protocol_debug_LogLevel(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_debug_LogLevel_s* msg, bool tao) {
 800bc9c:	b580      	push	{r7, lr}
 800bc9e:	b086      	sub	sp, #24
 800bca0:	af02      	add	r7, sp, #8
 800bca2:	60f8      	str	r0, [r7, #12]
 800bca4:	60b9      	str	r1, [r7, #8]
 800bca6:	607a      	str	r2, [r7, #4]
 800bca8:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 3, false, &msg->value);
 800bcaa:	68bb      	ldr	r3, [r7, #8]
 800bcac:	681a      	ldr	r2, [r3, #0]
 800bcae:	687b      	ldr	r3, [r7, #4]
 800bcb0:	9300      	str	r3, [sp, #0]
 800bcb2:	68f8      	ldr	r0, [r7, #12]
 800bcb4:	4611      	mov	r1, r2
 800bcb6:	2203      	movs	r2, #3
 800bcb8:	2300      	movs	r3, #0
 800bcba:	f001 fa97 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 3;
 800bcbe:	68bb      	ldr	r3, [r7, #8]
 800bcc0:	681b      	ldr	r3, [r3, #0]
 800bcc2:	1cda      	adds	r2, r3, #3
 800bcc4:	68bb      	ldr	r3, [r7, #8]
 800bcc6:	601a      	str	r2, [r3, #0]

}
 800bcc8:	3710      	adds	r7, #16
 800bcca:	46bd      	mov	sp, r7
 800bccc:	bd80      	pop	{r7, pc}
 800bcce:	bf00      	nop

0800bcd0 <encode_func.lto_priv.52>:
#include <uavcan.protocol.debug.LogMessage.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800bcd0:	b580      	push	{r7, lr}
 800bcd2:	b084      	sub	sp, #16
 800bcd4:	af00      	add	r7, sp, #0
 800bcd6:	60f8      	str	r0, [r7, #12]
 800bcd8:	60b9      	str	r1, [r7, #8]
 800bcda:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_debug_LogMessage(msg, chunk_cb, ctx);
 800bcdc:	68f8      	ldr	r0, [r7, #12]
 800bcde:	68b9      	ldr	r1, [r7, #8]
 800bce0:	687a      	ldr	r2, [r7, #4]
 800bce2:	f000 f811 	bl	800bd08 <encode_uavcan_protocol_debug_LogMessage>
}
 800bce6:	3710      	adds	r7, #16
 800bce8:	46bd      	mov	sp, r7
 800bcea:	bd80      	pop	{r7, pc}

0800bcec <decode_func.lto_priv.60>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800bcec:	b580      	push	{r7, lr}
 800bcee:	b082      	sub	sp, #8
 800bcf0:	af00      	add	r7, sp, #0
 800bcf2:	6078      	str	r0, [r7, #4]
 800bcf4:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_debug_LogMessage(transfer, msg);
 800bcf6:	6878      	ldr	r0, [r7, #4]
 800bcf8:	6839      	ldr	r1, [r7, #0]
 800bcfa:	f000 f819 	bl	800bd30 <decode_uavcan_protocol_debug_LogMessage>
 800bcfe:	4603      	mov	r3, r0
}
 800bd00:	4618      	mov	r0, r3
 800bd02:	3708      	adds	r7, #8
 800bd04:	46bd      	mov	sp, r7
 800bd06:	bd80      	pop	{r7, pc}

0800bd08 <encode_uavcan_protocol_debug_LogMessage>:
    encode_func,
    decode_func,
    NULL
};

void encode_uavcan_protocol_debug_LogMessage(struct uavcan_protocol_debug_LogMessage_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800bd08:	b580      	push	{r7, lr}
 800bd0a:	b088      	sub	sp, #32
 800bd0c:	af02      	add	r7, sp, #8
 800bd0e:	60f8      	str	r0, [r7, #12]
 800bd10:	60b9      	str	r1, [r7, #8]
 800bd12:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_debug_LogMessage(buffer, msg, chunk_cb, ctx, true);
 800bd14:	f107 0210 	add.w	r2, r7, #16
 800bd18:	2301      	movs	r3, #1
 800bd1a:	9300      	str	r3, [sp, #0]
 800bd1c:	4610      	mov	r0, r2
 800bd1e:	68f9      	ldr	r1, [r7, #12]
 800bd20:	68ba      	ldr	r2, [r7, #8]
 800bd22:	687b      	ldr	r3, [r7, #4]
 800bd24:	f000 f81a 	bl	800bd5c <_encode_uavcan_protocol_debug_LogMessage>
}
 800bd28:	3718      	adds	r7, #24
 800bd2a:	46bd      	mov	sp, r7
 800bd2c:	bd80      	pop	{r7, pc}
 800bd2e:	bf00      	nop

0800bd30 <decode_uavcan_protocol_debug_LogMessage>:

uint32_t decode_uavcan_protocol_debug_LogMessage(const CanardRxTransfer* transfer, struct uavcan_protocol_debug_LogMessage_s* msg) {
 800bd30:	b580      	push	{r7, lr}
 800bd32:	b084      	sub	sp, #16
 800bd34:	af00      	add	r7, sp, #0
 800bd36:	6078      	str	r0, [r7, #4]
 800bd38:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800bd3a:	2300      	movs	r3, #0
 800bd3c:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_debug_LogMessage(transfer, &bit_ofs, msg, true);
 800bd3e:	f107 030c 	add.w	r3, r7, #12
 800bd42:	6878      	ldr	r0, [r7, #4]
 800bd44:	4619      	mov	r1, r3
 800bd46:	683a      	ldr	r2, [r7, #0]
 800bd48:	2301      	movs	r3, #1
 800bd4a:	f000 f883 	bl	800be54 <_decode_uavcan_protocol_debug_LogMessage>
    return (bit_ofs+7)/8;
 800bd4e:	68fb      	ldr	r3, [r7, #12]
 800bd50:	3307      	adds	r3, #7
 800bd52:	08db      	lsrs	r3, r3, #3
}
 800bd54:	4618      	mov	r0, r3
 800bd56:	3710      	adds	r7, #16
 800bd58:	46bd      	mov	sp, r7
 800bd5a:	bd80      	pop	{r7, pc}

0800bd5c <_encode_uavcan_protocol_debug_LogMessage>:

void _encode_uavcan_protocol_debug_LogMessage(uint8_t* buffer, struct uavcan_protocol_debug_LogMessage_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800bd5c:	b580      	push	{r7, lr}
 800bd5e:	b088      	sub	sp, #32
 800bd60:	af02      	add	r7, sp, #8
 800bd62:	60f8      	str	r0, [r7, #12]
 800bd64:	60b9      	str	r1, [r7, #8]
 800bd66:	607a      	str	r2, [r7, #4]
 800bd68:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    _encode_uavcan_protocol_debug_LogLevel(buffer, &msg->level, chunk_cb, ctx, false);
 800bd6a:	68ba      	ldr	r2, [r7, #8]
 800bd6c:	2300      	movs	r3, #0
 800bd6e:	9300      	str	r3, [sp, #0]
 800bd70:	68f8      	ldr	r0, [r7, #12]
 800bd72:	4611      	mov	r1, r2
 800bd74:	687a      	ldr	r2, [r7, #4]
 800bd76:	683b      	ldr	r3, [r7, #0]
 800bd78:	f7ff ff76 	bl	800bc68 <_encode_uavcan_protocol_debug_LogLevel>
    memset(buffer,0,8);
 800bd7c:	68f8      	ldr	r0, [r7, #12]
 800bd7e:	2100      	movs	r1, #0
 800bd80:	2208      	movs	r2, #8
 800bd82:	f002 fc23 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 5, &msg->source_len);
 800bd86:	68bb      	ldr	r3, [r7, #8]
 800bd88:	3301      	adds	r3, #1
 800bd8a:	68f8      	ldr	r0, [r7, #12]
 800bd8c:	2100      	movs	r1, #0
 800bd8e:	2205      	movs	r2, #5
 800bd90:	f001 fba4 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 5, ctx);
 800bd94:	687b      	ldr	r3, [r7, #4]
 800bd96:	68f8      	ldr	r0, [r7, #12]
 800bd98:	2105      	movs	r1, #5
 800bd9a:	683a      	ldr	r2, [r7, #0]
 800bd9c:	4798      	blx	r3
    for (size_t i=0; i < msg->source_len; i++) {
 800bd9e:	2300      	movs	r3, #0
 800bda0:	617b      	str	r3, [r7, #20]
 800bda2:	e015      	b.n	800bdd0 <_encode_uavcan_protocol_debug_LogMessage+0x74>
            memset(buffer,0,8);
 800bda4:	68f8      	ldr	r0, [r7, #12]
 800bda6:	2100      	movs	r1, #0
 800bda8:	2208      	movs	r2, #8
 800bdaa:	f002 fc0f 	bl	800e5cc <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->source[i]);
 800bdae:	68ba      	ldr	r2, [r7, #8]
 800bdb0:	697b      	ldr	r3, [r7, #20]
 800bdb2:	4413      	add	r3, r2
 800bdb4:	3302      	adds	r3, #2
 800bdb6:	68f8      	ldr	r0, [r7, #12]
 800bdb8:	2100      	movs	r1, #0
 800bdba:	2208      	movs	r2, #8
 800bdbc:	f001 fb8e 	bl	800d4dc <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800bdc0:	687b      	ldr	r3, [r7, #4]
 800bdc2:	68f8      	ldr	r0, [r7, #12]
 800bdc4:	2108      	movs	r1, #8
 800bdc6:	683a      	ldr	r2, [r7, #0]
 800bdc8:	4798      	blx	r3

    _encode_uavcan_protocol_debug_LogLevel(buffer, &msg->level, chunk_cb, ctx, false);
    memset(buffer,0,8);
    canardEncodeScalar(buffer, 0, 5, &msg->source_len);
    chunk_cb(buffer, 5, ctx);
    for (size_t i=0; i < msg->source_len; i++) {
 800bdca:	697b      	ldr	r3, [r7, #20]
 800bdcc:	3301      	adds	r3, #1
 800bdce:	617b      	str	r3, [r7, #20]
 800bdd0:	68bb      	ldr	r3, [r7, #8]
 800bdd2:	785b      	ldrb	r3, [r3, #1]
 800bdd4:	461a      	mov	r2, r3
 800bdd6:	697b      	ldr	r3, [r7, #20]
 800bdd8:	429a      	cmp	r2, r3
 800bdda:	d8e3      	bhi.n	800bda4 <_encode_uavcan_protocol_debug_LogMessage+0x48>
            memset(buffer,0,8);
            canardEncodeScalar(buffer, 0, 8, &msg->source[i]);
            chunk_cb(buffer, 8, ctx);
    }
    if (!tao) {
 800bddc:	f897 3020 	ldrb.w	r3, [r7, #32]
 800bde0:	f083 0301 	eor.w	r3, r3, #1
 800bde4:	b2db      	uxtb	r3, r3
 800bde6:	2b00      	cmp	r3, #0
 800bde8:	d010      	beq.n	800be0c <_encode_uavcan_protocol_debug_LogMessage+0xb0>
        memset(buffer,0,8);
 800bdea:	68f8      	ldr	r0, [r7, #12]
 800bdec:	2100      	movs	r1, #0
 800bdee:	2208      	movs	r2, #8
 800bdf0:	f002 fbec 	bl	800e5cc <memset>
        canardEncodeScalar(buffer, 0, 7, &msg->text_len);
 800bdf4:	68bb      	ldr	r3, [r7, #8]
 800bdf6:	3321      	adds	r3, #33	; 0x21
 800bdf8:	68f8      	ldr	r0, [r7, #12]
 800bdfa:	2100      	movs	r1, #0
 800bdfc:	2207      	movs	r2, #7
 800bdfe:	f001 fb6d 	bl	800d4dc <canardEncodeScalar>
        chunk_cb(buffer, 7, ctx);
 800be02:	687b      	ldr	r3, [r7, #4]
 800be04:	68f8      	ldr	r0, [r7, #12]
 800be06:	2107      	movs	r1, #7
 800be08:	683a      	ldr	r2, [r7, #0]
 800be0a:	4798      	blx	r3
    }
    for (size_t i=0; i < msg->text_len; i++) {
 800be0c:	2300      	movs	r3, #0
 800be0e:	613b      	str	r3, [r7, #16]
 800be10:	e016      	b.n	800be40 <_encode_uavcan_protocol_debug_LogMessage+0xe4>
            memset(buffer,0,8);
 800be12:	68f8      	ldr	r0, [r7, #12]
 800be14:	2100      	movs	r1, #0
 800be16:	2208      	movs	r2, #8
 800be18:	f002 fbd8 	bl	800e5cc <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->text[i]);
 800be1c:	693b      	ldr	r3, [r7, #16]
 800be1e:	3320      	adds	r3, #32
 800be20:	68ba      	ldr	r2, [r7, #8]
 800be22:	4413      	add	r3, r2
 800be24:	3302      	adds	r3, #2
 800be26:	68f8      	ldr	r0, [r7, #12]
 800be28:	2100      	movs	r1, #0
 800be2a:	2208      	movs	r2, #8
 800be2c:	f001 fb56 	bl	800d4dc <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800be30:	687b      	ldr	r3, [r7, #4]
 800be32:	68f8      	ldr	r0, [r7, #12]
 800be34:	2108      	movs	r1, #8
 800be36:	683a      	ldr	r2, [r7, #0]
 800be38:	4798      	blx	r3
    if (!tao) {
        memset(buffer,0,8);
        canardEncodeScalar(buffer, 0, 7, &msg->text_len);
        chunk_cb(buffer, 7, ctx);
    }
    for (size_t i=0; i < msg->text_len; i++) {
 800be3a:	693b      	ldr	r3, [r7, #16]
 800be3c:	3301      	adds	r3, #1
 800be3e:	613b      	str	r3, [r7, #16]
 800be40:	68bb      	ldr	r3, [r7, #8]
 800be42:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800be46:	461a      	mov	r2, r3
 800be48:	693b      	ldr	r3, [r7, #16]
 800be4a:	429a      	cmp	r2, r3
 800be4c:	d8e1      	bhi.n	800be12 <_encode_uavcan_protocol_debug_LogMessage+0xb6>
            memset(buffer,0,8);
            canardEncodeScalar(buffer, 0, 8, &msg->text[i]);
            chunk_cb(buffer, 8, ctx);
    }
}
 800be4e:	3718      	adds	r7, #24
 800be50:	46bd      	mov	sp, r7
 800be52:	bd80      	pop	{r7, pc}

0800be54 <_decode_uavcan_protocol_debug_LogMessage>:

void _decode_uavcan_protocol_debug_LogMessage(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_debug_LogMessage_s* msg, bool tao) {
 800be54:	b580      	push	{r7, lr}
 800be56:	b088      	sub	sp, #32
 800be58:	af02      	add	r7, sp, #8
 800be5a:	60f8      	str	r0, [r7, #12]
 800be5c:	60b9      	str	r1, [r7, #8]
 800be5e:	607a      	str	r2, [r7, #4]
 800be60:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    _decode_uavcan_protocol_debug_LogLevel(transfer, bit_ofs, &msg->level, false);
 800be62:	687b      	ldr	r3, [r7, #4]
 800be64:	68f8      	ldr	r0, [r7, #12]
 800be66:	68b9      	ldr	r1, [r7, #8]
 800be68:	461a      	mov	r2, r3
 800be6a:	2300      	movs	r3, #0
 800be6c:	f7ff ff16 	bl	800bc9c <_decode_uavcan_protocol_debug_LogLevel>

    canardDecodeScalar(transfer, *bit_ofs, 5, false, &msg->source_len);
 800be70:	68bb      	ldr	r3, [r7, #8]
 800be72:	681a      	ldr	r2, [r3, #0]
 800be74:	687b      	ldr	r3, [r7, #4]
 800be76:	3301      	adds	r3, #1
 800be78:	9300      	str	r3, [sp, #0]
 800be7a:	68f8      	ldr	r0, [r7, #12]
 800be7c:	4611      	mov	r1, r2
 800be7e:	2205      	movs	r2, #5
 800be80:	2300      	movs	r3, #0
 800be82:	f001 f9b3 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 5;
 800be86:	68bb      	ldr	r3, [r7, #8]
 800be88:	681b      	ldr	r3, [r3, #0]
 800be8a:	1d5a      	adds	r2, r3, #5
 800be8c:	68bb      	ldr	r3, [r7, #8]
 800be8e:	601a      	str	r2, [r3, #0]
    for (size_t i=0; i < msg->source_len; i++) {
 800be90:	2300      	movs	r3, #0
 800be92:	617b      	str	r3, [r7, #20]
 800be94:	e014      	b.n	800bec0 <_decode_uavcan_protocol_debug_LogMessage+0x6c>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->source[i]);
 800be96:	68bb      	ldr	r3, [r7, #8]
 800be98:	6819      	ldr	r1, [r3, #0]
 800be9a:	687a      	ldr	r2, [r7, #4]
 800be9c:	697b      	ldr	r3, [r7, #20]
 800be9e:	4413      	add	r3, r2
 800bea0:	3302      	adds	r3, #2
 800bea2:	9300      	str	r3, [sp, #0]
 800bea4:	68f8      	ldr	r0, [r7, #12]
 800bea6:	2208      	movs	r2, #8
 800bea8:	2300      	movs	r3, #0
 800beaa:	f001 f99f 	bl	800d1ec <canardDecodeScalar>
        *bit_ofs += 8;
 800beae:	68bb      	ldr	r3, [r7, #8]
 800beb0:	681b      	ldr	r3, [r3, #0]
 800beb2:	f103 0208 	add.w	r2, r3, #8
 800beb6:	68bb      	ldr	r3, [r7, #8]
 800beb8:	601a      	str	r2, [r3, #0]

    _decode_uavcan_protocol_debug_LogLevel(transfer, bit_ofs, &msg->level, false);

    canardDecodeScalar(transfer, *bit_ofs, 5, false, &msg->source_len);
    *bit_ofs += 5;
    for (size_t i=0; i < msg->source_len; i++) {
 800beba:	697b      	ldr	r3, [r7, #20]
 800bebc:	3301      	adds	r3, #1
 800bebe:	617b      	str	r3, [r7, #20]
 800bec0:	687b      	ldr	r3, [r7, #4]
 800bec2:	785b      	ldrb	r3, [r3, #1]
 800bec4:	461a      	mov	r2, r3
 800bec6:	697b      	ldr	r3, [r7, #20]
 800bec8:	429a      	cmp	r2, r3
 800beca:	d8e4      	bhi.n	800be96 <_decode_uavcan_protocol_debug_LogMessage+0x42>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->source[i]);
        *bit_ofs += 8;
    }

    if (!tao) {
 800becc:	78fb      	ldrb	r3, [r7, #3]
 800bece:	f083 0301 	eor.w	r3, r3, #1
 800bed2:	b2db      	uxtb	r3, r3
 800bed4:	2b00      	cmp	r3, #0
 800bed6:	d010      	beq.n	800befa <_decode_uavcan_protocol_debug_LogMessage+0xa6>
        canardDecodeScalar(transfer, *bit_ofs, 7, false, &msg->text_len);
 800bed8:	68bb      	ldr	r3, [r7, #8]
 800beda:	681a      	ldr	r2, [r3, #0]
 800bedc:	687b      	ldr	r3, [r7, #4]
 800bede:	3321      	adds	r3, #33	; 0x21
 800bee0:	9300      	str	r3, [sp, #0]
 800bee2:	68f8      	ldr	r0, [r7, #12]
 800bee4:	4611      	mov	r1, r2
 800bee6:	2207      	movs	r2, #7
 800bee8:	2300      	movs	r3, #0
 800beea:	f001 f97f 	bl	800d1ec <canardDecodeScalar>
        *bit_ofs += 7;
 800beee:	68bb      	ldr	r3, [r7, #8]
 800bef0:	681b      	ldr	r3, [r3, #0]
 800bef2:	1dda      	adds	r2, r3, #7
 800bef4:	68bb      	ldr	r3, [r7, #8]
 800bef6:	601a      	str	r2, [r3, #0]
 800bef8:	e00b      	b.n	800bf12 <_decode_uavcan_protocol_debug_LogMessage+0xbe>
    } else {
        msg->text_len = ((transfer->payload_len*8)-*bit_ofs)/8;
 800befa:	68fb      	ldr	r3, [r7, #12]
 800befc:	8a9b      	ldrh	r3, [r3, #20]
 800befe:	00db      	lsls	r3, r3, #3
 800bf00:	461a      	mov	r2, r3
 800bf02:	68bb      	ldr	r3, [r7, #8]
 800bf04:	681b      	ldr	r3, [r3, #0]
 800bf06:	1ad3      	subs	r3, r2, r3
 800bf08:	08db      	lsrs	r3, r3, #3
 800bf0a:	b2da      	uxtb	r2, r3
 800bf0c:	687b      	ldr	r3, [r7, #4]
 800bf0e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
    }

    for (size_t i=0; i < msg->text_len; i++) {
 800bf12:	2300      	movs	r3, #0
 800bf14:	613b      	str	r3, [r7, #16]
 800bf16:	e015      	b.n	800bf44 <_decode_uavcan_protocol_debug_LogMessage+0xf0>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->text[i]);
 800bf18:	68bb      	ldr	r3, [r7, #8]
 800bf1a:	6819      	ldr	r1, [r3, #0]
 800bf1c:	693b      	ldr	r3, [r7, #16]
 800bf1e:	3320      	adds	r3, #32
 800bf20:	687a      	ldr	r2, [r7, #4]
 800bf22:	4413      	add	r3, r2
 800bf24:	3302      	adds	r3, #2
 800bf26:	9300      	str	r3, [sp, #0]
 800bf28:	68f8      	ldr	r0, [r7, #12]
 800bf2a:	2208      	movs	r2, #8
 800bf2c:	2300      	movs	r3, #0
 800bf2e:	f001 f95d 	bl	800d1ec <canardDecodeScalar>
        *bit_ofs += 8;
 800bf32:	68bb      	ldr	r3, [r7, #8]
 800bf34:	681b      	ldr	r3, [r3, #0]
 800bf36:	f103 0208 	add.w	r2, r3, #8
 800bf3a:	68bb      	ldr	r3, [r7, #8]
 800bf3c:	601a      	str	r2, [r3, #0]
        *bit_ofs += 7;
    } else {
        msg->text_len = ((transfer->payload_len*8)-*bit_ofs)/8;
    }

    for (size_t i=0; i < msg->text_len; i++) {
 800bf3e:	693b      	ldr	r3, [r7, #16]
 800bf40:	3301      	adds	r3, #1
 800bf42:	613b      	str	r3, [r7, #16]
 800bf44:	687b      	ldr	r3, [r7, #4]
 800bf46:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800bf4a:	461a      	mov	r2, r3
 800bf4c:	693b      	ldr	r3, [r7, #16]
 800bf4e:	429a      	cmp	r2, r3
 800bf50:	d8e2      	bhi.n	800bf18 <_decode_uavcan_protocol_debug_LogMessage+0xc4>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->text[i]);
        *bit_ofs += 8;
    }

}
 800bf52:	3718      	adds	r7, #24
 800bf54:	46bd      	mov	sp, r7
 800bf56:	bd80      	pop	{r7, pc}

0800bf58 <encode_func.lto_priv.54>:
#include <uavcan.protocol.GetNodeInfo_res.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800bf58:	b580      	push	{r7, lr}
 800bf5a:	b084      	sub	sp, #16
 800bf5c:	af00      	add	r7, sp, #0
 800bf5e:	60f8      	str	r0, [r7, #12]
 800bf60:	60b9      	str	r1, [r7, #8]
 800bf62:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_GetNodeInfo_res(msg, chunk_cb, ctx);
 800bf64:	68f8      	ldr	r0, [r7, #12]
 800bf66:	68b9      	ldr	r1, [r7, #8]
 800bf68:	687a      	ldr	r2, [r7, #4]
 800bf6a:	f000 f811 	bl	800bf90 <encode_uavcan_protocol_GetNodeInfo_res>
}
 800bf6e:	3710      	adds	r7, #16
 800bf70:	46bd      	mov	sp, r7
 800bf72:	bd80      	pop	{r7, pc}

0800bf74 <decode_func.lto_priv.62>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800bf74:	b580      	push	{r7, lr}
 800bf76:	b082      	sub	sp, #8
 800bf78:	af00      	add	r7, sp, #0
 800bf7a:	6078      	str	r0, [r7, #4]
 800bf7c:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_GetNodeInfo_res(transfer, msg);
 800bf7e:	6878      	ldr	r0, [r7, #4]
 800bf80:	6839      	ldr	r1, [r7, #0]
 800bf82:	f000 f819 	bl	800bfb8 <decode_uavcan_protocol_GetNodeInfo_res>
 800bf86:	4603      	mov	r3, r0
}
 800bf88:	4618      	mov	r0, r3
 800bf8a:	3708      	adds	r7, #8
 800bf8c:	46bd      	mov	sp, r7
 800bf8e:	bd80      	pop	{r7, pc}

0800bf90 <encode_uavcan_protocol_GetNodeInfo_res>:
    encode_func,
    decode_func,
    NULL
};

void encode_uavcan_protocol_GetNodeInfo_res(struct uavcan_protocol_GetNodeInfo_res_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800bf90:	b580      	push	{r7, lr}
 800bf92:	b088      	sub	sp, #32
 800bf94:	af02      	add	r7, sp, #8
 800bf96:	60f8      	str	r0, [r7, #12]
 800bf98:	60b9      	str	r1, [r7, #8]
 800bf9a:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_GetNodeInfo_res(buffer, msg, chunk_cb, ctx, true);
 800bf9c:	f107 0210 	add.w	r2, r7, #16
 800bfa0:	2301      	movs	r3, #1
 800bfa2:	9300      	str	r3, [sp, #0]
 800bfa4:	4610      	mov	r0, r2
 800bfa6:	68f9      	ldr	r1, [r7, #12]
 800bfa8:	68ba      	ldr	r2, [r7, #8]
 800bfaa:	687b      	ldr	r3, [r7, #4]
 800bfac:	f000 f81a 	bl	800bfe4 <_encode_uavcan_protocol_GetNodeInfo_res>
}
 800bfb0:	3718      	adds	r7, #24
 800bfb2:	46bd      	mov	sp, r7
 800bfb4:	bd80      	pop	{r7, pc}
 800bfb6:	bf00      	nop

0800bfb8 <decode_uavcan_protocol_GetNodeInfo_res>:

uint32_t decode_uavcan_protocol_GetNodeInfo_res(const CanardRxTransfer* transfer, struct uavcan_protocol_GetNodeInfo_res_s* msg) {
 800bfb8:	b580      	push	{r7, lr}
 800bfba:	b084      	sub	sp, #16
 800bfbc:	af00      	add	r7, sp, #0
 800bfbe:	6078      	str	r0, [r7, #4]
 800bfc0:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800bfc2:	2300      	movs	r3, #0
 800bfc4:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_GetNodeInfo_res(transfer, &bit_ofs, msg, true);
 800bfc6:	f107 030c 	add.w	r3, r7, #12
 800bfca:	6878      	ldr	r0, [r7, #4]
 800bfcc:	4619      	mov	r1, r3
 800bfce:	683a      	ldr	r2, [r7, #0]
 800bfd0:	2301      	movs	r3, #1
 800bfd2:	f000 f86b 	bl	800c0ac <_decode_uavcan_protocol_GetNodeInfo_res>
    return (bit_ofs+7)/8;
 800bfd6:	68fb      	ldr	r3, [r7, #12]
 800bfd8:	3307      	adds	r3, #7
 800bfda:	08db      	lsrs	r3, r3, #3
}
 800bfdc:	4618      	mov	r0, r3
 800bfde:	3710      	adds	r7, #16
 800bfe0:	46bd      	mov	sp, r7
 800bfe2:	bd80      	pop	{r7, pc}

0800bfe4 <_encode_uavcan_protocol_GetNodeInfo_res>:

void _encode_uavcan_protocol_GetNodeInfo_res(uint8_t* buffer, struct uavcan_protocol_GetNodeInfo_res_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800bfe4:	b580      	push	{r7, lr}
 800bfe6:	b088      	sub	sp, #32
 800bfe8:	af02      	add	r7, sp, #8
 800bfea:	60f8      	str	r0, [r7, #12]
 800bfec:	60b9      	str	r1, [r7, #8]
 800bfee:	607a      	str	r2, [r7, #4]
 800bff0:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    _encode_uavcan_protocol_NodeStatus(buffer, &msg->status, chunk_cb, ctx, false);
 800bff2:	68ba      	ldr	r2, [r7, #8]
 800bff4:	2300      	movs	r3, #0
 800bff6:	9300      	str	r3, [sp, #0]
 800bff8:	68f8      	ldr	r0, [r7, #12]
 800bffa:	4611      	mov	r1, r2
 800bffc:	687a      	ldr	r2, [r7, #4]
 800bffe:	683b      	ldr	r3, [r7, #0]
 800c000:	f002 f858 	bl	800e0b4 <_encode_uavcan_protocol_NodeStatus>
    _encode_uavcan_protocol_SoftwareVersion(buffer, &msg->software_version, chunk_cb, ctx, false);
 800c004:	68bb      	ldr	r3, [r7, #8]
 800c006:	f103 0210 	add.w	r2, r3, #16
 800c00a:	2300      	movs	r3, #0
 800c00c:	9300      	str	r3, [sp, #0]
 800c00e:	68f8      	ldr	r0, [r7, #12]
 800c010:	4611      	mov	r1, r2
 800c012:	687a      	ldr	r2, [r7, #4]
 800c014:	683b      	ldr	r3, [r7, #0]
 800c016:	f000 f9b7 	bl	800c388 <_encode_uavcan_protocol_SoftwareVersion>
    _encode_uavcan_protocol_HardwareVersion(buffer, &msg->hardware_version, chunk_cb, ctx, false);
 800c01a:	68bb      	ldr	r3, [r7, #8]
 800c01c:	f103 0220 	add.w	r2, r3, #32
 800c020:	2300      	movs	r3, #0
 800c022:	9300      	str	r3, [sp, #0]
 800c024:	68f8      	ldr	r0, [r7, #12]
 800c026:	4611      	mov	r1, r2
 800c028:	687a      	ldr	r2, [r7, #4]
 800c02a:	683b      	ldr	r3, [r7, #0]
 800c02c:	f000 f8a4 	bl	800c178 <_encode_uavcan_protocol_HardwareVersion>
    if (!tao) {
 800c030:	f897 3020 	ldrb.w	r3, [r7, #32]
 800c034:	f083 0301 	eor.w	r3, r3, #1
 800c038:	b2db      	uxtb	r3, r3
 800c03a:	2b00      	cmp	r3, #0
 800c03c:	d011      	beq.n	800c062 <_encode_uavcan_protocol_GetNodeInfo_res+0x7e>
        memset(buffer,0,8);
 800c03e:	68f8      	ldr	r0, [r7, #12]
 800c040:	2100      	movs	r1, #0
 800c042:	2208      	movs	r2, #8
 800c044:	f002 fac2 	bl	800e5cc <memset>
        canardEncodeScalar(buffer, 0, 7, &msg->name_len);
 800c048:	68bb      	ldr	r3, [r7, #8]
 800c04a:	f503 7399 	add.w	r3, r3, #306	; 0x132
 800c04e:	68f8      	ldr	r0, [r7, #12]
 800c050:	2100      	movs	r1, #0
 800c052:	2207      	movs	r2, #7
 800c054:	f001 fa42 	bl	800d4dc <canardEncodeScalar>
        chunk_cb(buffer, 7, ctx);
 800c058:	687b      	ldr	r3, [r7, #4]
 800c05a:	68f8      	ldr	r0, [r7, #12]
 800c05c:	2107      	movs	r1, #7
 800c05e:	683a      	ldr	r2, [r7, #0]
 800c060:	4798      	blx	r3
    }
    for (size_t i=0; i < msg->name_len; i++) {
 800c062:	2300      	movs	r3, #0
 800c064:	617b      	str	r3, [r7, #20]
 800c066:	e017      	b.n	800c098 <_encode_uavcan_protocol_GetNodeInfo_res+0xb4>
            memset(buffer,0,8);
 800c068:	68f8      	ldr	r0, [r7, #12]
 800c06a:	2100      	movs	r1, #0
 800c06c:	2208      	movs	r2, #8
 800c06e:	f002 faad 	bl	800e5cc <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->name[i]);
 800c072:	697b      	ldr	r3, [r7, #20]
 800c074:	f503 7398 	add.w	r3, r3, #304	; 0x130
 800c078:	68ba      	ldr	r2, [r7, #8]
 800c07a:	4413      	add	r3, r2
 800c07c:	3303      	adds	r3, #3
 800c07e:	68f8      	ldr	r0, [r7, #12]
 800c080:	2100      	movs	r1, #0
 800c082:	2208      	movs	r2, #8
 800c084:	f001 fa2a 	bl	800d4dc <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800c088:	687b      	ldr	r3, [r7, #4]
 800c08a:	68f8      	ldr	r0, [r7, #12]
 800c08c:	2108      	movs	r1, #8
 800c08e:	683a      	ldr	r2, [r7, #0]
 800c090:	4798      	blx	r3
    if (!tao) {
        memset(buffer,0,8);
        canardEncodeScalar(buffer, 0, 7, &msg->name_len);
        chunk_cb(buffer, 7, ctx);
    }
    for (size_t i=0; i < msg->name_len; i++) {
 800c092:	697b      	ldr	r3, [r7, #20]
 800c094:	3301      	adds	r3, #1
 800c096:	617b      	str	r3, [r7, #20]
 800c098:	68bb      	ldr	r3, [r7, #8]
 800c09a:	f893 3132 	ldrb.w	r3, [r3, #306]	; 0x132
 800c09e:	461a      	mov	r2, r3
 800c0a0:	697b      	ldr	r3, [r7, #20]
 800c0a2:	429a      	cmp	r2, r3
 800c0a4:	d8e0      	bhi.n	800c068 <_encode_uavcan_protocol_GetNodeInfo_res+0x84>
            memset(buffer,0,8);
            canardEncodeScalar(buffer, 0, 8, &msg->name[i]);
            chunk_cb(buffer, 8, ctx);
    }
}
 800c0a6:	3718      	adds	r7, #24
 800c0a8:	46bd      	mov	sp, r7
 800c0aa:	bd80      	pop	{r7, pc}

0800c0ac <_decode_uavcan_protocol_GetNodeInfo_res>:

void _decode_uavcan_protocol_GetNodeInfo_res(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_GetNodeInfo_res_s* msg, bool tao) {
 800c0ac:	b580      	push	{r7, lr}
 800c0ae:	b088      	sub	sp, #32
 800c0b0:	af02      	add	r7, sp, #8
 800c0b2:	60f8      	str	r0, [r7, #12]
 800c0b4:	60b9      	str	r1, [r7, #8]
 800c0b6:	607a      	str	r2, [r7, #4]
 800c0b8:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    _decode_uavcan_protocol_NodeStatus(transfer, bit_ofs, &msg->status, false);
 800c0ba:	687b      	ldr	r3, [r7, #4]
 800c0bc:	68f8      	ldr	r0, [r7, #12]
 800c0be:	68b9      	ldr	r1, [r7, #8]
 800c0c0:	461a      	mov	r2, r3
 800c0c2:	2300      	movs	r3, #0
 800c0c4:	f002 f854 	bl	800e170 <_decode_uavcan_protocol_NodeStatus>

    _decode_uavcan_protocol_SoftwareVersion(transfer, bit_ofs, &msg->software_version, false);
 800c0c8:	687b      	ldr	r3, [r7, #4]
 800c0ca:	3310      	adds	r3, #16
 800c0cc:	68f8      	ldr	r0, [r7, #12]
 800c0ce:	68b9      	ldr	r1, [r7, #8]
 800c0d0:	461a      	mov	r2, r3
 800c0d2:	2300      	movs	r3, #0
 800c0d4:	f000 f9b6 	bl	800c444 <_decode_uavcan_protocol_SoftwareVersion>

    _decode_uavcan_protocol_HardwareVersion(transfer, bit_ofs, &msg->hardware_version, false);
 800c0d8:	687b      	ldr	r3, [r7, #4]
 800c0da:	3320      	adds	r3, #32
 800c0dc:	68f8      	ldr	r0, [r7, #12]
 800c0de:	68b9      	ldr	r1, [r7, #8]
 800c0e0:	461a      	mov	r2, r3
 800c0e2:	2300      	movs	r3, #0
 800c0e4:	f000 f8c8 	bl	800c278 <_decode_uavcan_protocol_HardwareVersion>

    if (!tao) {
 800c0e8:	78fb      	ldrb	r3, [r7, #3]
 800c0ea:	f083 0301 	eor.w	r3, r3, #1
 800c0ee:	b2db      	uxtb	r3, r3
 800c0f0:	2b00      	cmp	r3, #0
 800c0f2:	d011      	beq.n	800c118 <_decode_uavcan_protocol_GetNodeInfo_res+0x6c>
        canardDecodeScalar(transfer, *bit_ofs, 7, false, &msg->name_len);
 800c0f4:	68bb      	ldr	r3, [r7, #8]
 800c0f6:	681a      	ldr	r2, [r3, #0]
 800c0f8:	687b      	ldr	r3, [r7, #4]
 800c0fa:	f503 7399 	add.w	r3, r3, #306	; 0x132
 800c0fe:	9300      	str	r3, [sp, #0]
 800c100:	68f8      	ldr	r0, [r7, #12]
 800c102:	4611      	mov	r1, r2
 800c104:	2207      	movs	r2, #7
 800c106:	2300      	movs	r3, #0
 800c108:	f001 f870 	bl	800d1ec <canardDecodeScalar>
        *bit_ofs += 7;
 800c10c:	68bb      	ldr	r3, [r7, #8]
 800c10e:	681b      	ldr	r3, [r3, #0]
 800c110:	1dda      	adds	r2, r3, #7
 800c112:	68bb      	ldr	r3, [r7, #8]
 800c114:	601a      	str	r2, [r3, #0]
 800c116:	e00b      	b.n	800c130 <_decode_uavcan_protocol_GetNodeInfo_res+0x84>
    } else {
        msg->name_len = ((transfer->payload_len*8)-*bit_ofs)/8;
 800c118:	68fb      	ldr	r3, [r7, #12]
 800c11a:	8a9b      	ldrh	r3, [r3, #20]
 800c11c:	00db      	lsls	r3, r3, #3
 800c11e:	461a      	mov	r2, r3
 800c120:	68bb      	ldr	r3, [r7, #8]
 800c122:	681b      	ldr	r3, [r3, #0]
 800c124:	1ad3      	subs	r3, r2, r3
 800c126:	08db      	lsrs	r3, r3, #3
 800c128:	b2da      	uxtb	r2, r3
 800c12a:	687b      	ldr	r3, [r7, #4]
 800c12c:	f883 2132 	strb.w	r2, [r3, #306]	; 0x132
    }

    for (size_t i=0; i < msg->name_len; i++) {
 800c130:	2300      	movs	r3, #0
 800c132:	617b      	str	r3, [r7, #20]
 800c134:	e016      	b.n	800c164 <_decode_uavcan_protocol_GetNodeInfo_res+0xb8>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->name[i]);
 800c136:	68bb      	ldr	r3, [r7, #8]
 800c138:	6819      	ldr	r1, [r3, #0]
 800c13a:	697b      	ldr	r3, [r7, #20]
 800c13c:	f503 7398 	add.w	r3, r3, #304	; 0x130
 800c140:	687a      	ldr	r2, [r7, #4]
 800c142:	4413      	add	r3, r2
 800c144:	3303      	adds	r3, #3
 800c146:	9300      	str	r3, [sp, #0]
 800c148:	68f8      	ldr	r0, [r7, #12]
 800c14a:	2208      	movs	r2, #8
 800c14c:	2300      	movs	r3, #0
 800c14e:	f001 f84d 	bl	800d1ec <canardDecodeScalar>
        *bit_ofs += 8;
 800c152:	68bb      	ldr	r3, [r7, #8]
 800c154:	681b      	ldr	r3, [r3, #0]
 800c156:	f103 0208 	add.w	r2, r3, #8
 800c15a:	68bb      	ldr	r3, [r7, #8]
 800c15c:	601a      	str	r2, [r3, #0]
        *bit_ofs += 7;
    } else {
        msg->name_len = ((transfer->payload_len*8)-*bit_ofs)/8;
    }

    for (size_t i=0; i < msg->name_len; i++) {
 800c15e:	697b      	ldr	r3, [r7, #20]
 800c160:	3301      	adds	r3, #1
 800c162:	617b      	str	r3, [r7, #20]
 800c164:	687b      	ldr	r3, [r7, #4]
 800c166:	f893 3132 	ldrb.w	r3, [r3, #306]	; 0x132
 800c16a:	461a      	mov	r2, r3
 800c16c:	697b      	ldr	r3, [r7, #20]
 800c16e:	429a      	cmp	r2, r3
 800c170:	d8e1      	bhi.n	800c136 <_decode_uavcan_protocol_GetNodeInfo_res+0x8a>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->name[i]);
        *bit_ofs += 8;
    }

}
 800c172:	3718      	adds	r7, #24
 800c174:	46bd      	mov	sp, r7
 800c176:	bd80      	pop	{r7, pc}

0800c178 <_encode_uavcan_protocol_HardwareVersion>:
    uint32_t bit_ofs = 0;
    _decode_uavcan_protocol_HardwareVersion(transfer, &bit_ofs, msg, true);
    return (bit_ofs+7)/8;
}

void _encode_uavcan_protocol_HardwareVersion(uint8_t* buffer, struct uavcan_protocol_HardwareVersion_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800c178:	b580      	push	{r7, lr}
 800c17a:	b086      	sub	sp, #24
 800c17c:	af00      	add	r7, sp, #0
 800c17e:	60f8      	str	r0, [r7, #12]
 800c180:	60b9      	str	r1, [r7, #8]
 800c182:	607a      	str	r2, [r7, #4]
 800c184:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
 800c186:	68f8      	ldr	r0, [r7, #12]
 800c188:	2100      	movs	r1, #0
 800c18a:	2208      	movs	r2, #8
 800c18c:	f002 fa1e 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->major);
 800c190:	68bb      	ldr	r3, [r7, #8]
 800c192:	68f8      	ldr	r0, [r7, #12]
 800c194:	2100      	movs	r1, #0
 800c196:	2208      	movs	r2, #8
 800c198:	f001 f9a0 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800c19c:	687b      	ldr	r3, [r7, #4]
 800c19e:	68f8      	ldr	r0, [r7, #12]
 800c1a0:	2108      	movs	r1, #8
 800c1a2:	683a      	ldr	r2, [r7, #0]
 800c1a4:	4798      	blx	r3
    memset(buffer,0,8);
 800c1a6:	68f8      	ldr	r0, [r7, #12]
 800c1a8:	2100      	movs	r1, #0
 800c1aa:	2208      	movs	r2, #8
 800c1ac:	f002 fa0e 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->minor);
 800c1b0:	68bb      	ldr	r3, [r7, #8]
 800c1b2:	3301      	adds	r3, #1
 800c1b4:	68f8      	ldr	r0, [r7, #12]
 800c1b6:	2100      	movs	r1, #0
 800c1b8:	2208      	movs	r2, #8
 800c1ba:	f001 f98f 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800c1be:	687b      	ldr	r3, [r7, #4]
 800c1c0:	68f8      	ldr	r0, [r7, #12]
 800c1c2:	2108      	movs	r1, #8
 800c1c4:	683a      	ldr	r2, [r7, #0]
 800c1c6:	4798      	blx	r3
    for (size_t i=0; i < 16; i++) {
 800c1c8:	2300      	movs	r3, #0
 800c1ca:	617b      	str	r3, [r7, #20]
 800c1cc:	e015      	b.n	800c1fa <_encode_uavcan_protocol_HardwareVersion+0x82>
            memset(buffer,0,8);
 800c1ce:	68f8      	ldr	r0, [r7, #12]
 800c1d0:	2100      	movs	r1, #0
 800c1d2:	2208      	movs	r2, #8
 800c1d4:	f002 f9fa 	bl	800e5cc <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->unique_id[i]);
 800c1d8:	68ba      	ldr	r2, [r7, #8]
 800c1da:	697b      	ldr	r3, [r7, #20]
 800c1dc:	4413      	add	r3, r2
 800c1de:	3302      	adds	r3, #2
 800c1e0:	68f8      	ldr	r0, [r7, #12]
 800c1e2:	2100      	movs	r1, #0
 800c1e4:	2208      	movs	r2, #8
 800c1e6:	f001 f979 	bl	800d4dc <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800c1ea:	687b      	ldr	r3, [r7, #4]
 800c1ec:	68f8      	ldr	r0, [r7, #12]
 800c1ee:	2108      	movs	r1, #8
 800c1f0:	683a      	ldr	r2, [r7, #0]
 800c1f2:	4798      	blx	r3
    canardEncodeScalar(buffer, 0, 8, &msg->major);
    chunk_cb(buffer, 8, ctx);
    memset(buffer,0,8);
    canardEncodeScalar(buffer, 0, 8, &msg->minor);
    chunk_cb(buffer, 8, ctx);
    for (size_t i=0; i < 16; i++) {
 800c1f4:	697b      	ldr	r3, [r7, #20]
 800c1f6:	3301      	adds	r3, #1
 800c1f8:	617b      	str	r3, [r7, #20]
 800c1fa:	697b      	ldr	r3, [r7, #20]
 800c1fc:	2b0f      	cmp	r3, #15
 800c1fe:	d9e6      	bls.n	800c1ce <_encode_uavcan_protocol_HardwareVersion+0x56>
            memset(buffer,0,8);
            canardEncodeScalar(buffer, 0, 8, &msg->unique_id[i]);
            chunk_cb(buffer, 8, ctx);
    }
    if (!tao) {
 800c200:	f897 3020 	ldrb.w	r3, [r7, #32]
 800c204:	f083 0301 	eor.w	r3, r3, #1
 800c208:	b2db      	uxtb	r3, r3
 800c20a:	2b00      	cmp	r3, #0
 800c20c:	d010      	beq.n	800c230 <_encode_uavcan_protocol_HardwareVersion+0xb8>
        memset(buffer,0,8);
 800c20e:	68f8      	ldr	r0, [r7, #12]
 800c210:	2100      	movs	r1, #0
 800c212:	2208      	movs	r2, #8
 800c214:	f002 f9da 	bl	800e5cc <memset>
        canardEncodeScalar(buffer, 0, 8, &msg->certificate_of_authenticity_len);
 800c218:	68bb      	ldr	r3, [r7, #8]
 800c21a:	3312      	adds	r3, #18
 800c21c:	68f8      	ldr	r0, [r7, #12]
 800c21e:	2100      	movs	r1, #0
 800c220:	2208      	movs	r2, #8
 800c222:	f001 f95b 	bl	800d4dc <canardEncodeScalar>
        chunk_cb(buffer, 8, ctx);
 800c226:	687b      	ldr	r3, [r7, #4]
 800c228:	68f8      	ldr	r0, [r7, #12]
 800c22a:	2108      	movs	r1, #8
 800c22c:	683a      	ldr	r2, [r7, #0]
 800c22e:	4798      	blx	r3
    }
    for (size_t i=0; i < msg->certificate_of_authenticity_len; i++) {
 800c230:	2300      	movs	r3, #0
 800c232:	613b      	str	r3, [r7, #16]
 800c234:	e016      	b.n	800c264 <_encode_uavcan_protocol_HardwareVersion+0xec>
            memset(buffer,0,8);
 800c236:	68f8      	ldr	r0, [r7, #12]
 800c238:	2100      	movs	r1, #0
 800c23a:	2208      	movs	r2, #8
 800c23c:	f002 f9c6 	bl	800e5cc <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->certificate_of_authenticity[i]);
 800c240:	693b      	ldr	r3, [r7, #16]
 800c242:	3310      	adds	r3, #16
 800c244:	68ba      	ldr	r2, [r7, #8]
 800c246:	4413      	add	r3, r2
 800c248:	3303      	adds	r3, #3
 800c24a:	68f8      	ldr	r0, [r7, #12]
 800c24c:	2100      	movs	r1, #0
 800c24e:	2208      	movs	r2, #8
 800c250:	f001 f944 	bl	800d4dc <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800c254:	687b      	ldr	r3, [r7, #4]
 800c256:	68f8      	ldr	r0, [r7, #12]
 800c258:	2108      	movs	r1, #8
 800c25a:	683a      	ldr	r2, [r7, #0]
 800c25c:	4798      	blx	r3
    if (!tao) {
        memset(buffer,0,8);
        canardEncodeScalar(buffer, 0, 8, &msg->certificate_of_authenticity_len);
        chunk_cb(buffer, 8, ctx);
    }
    for (size_t i=0; i < msg->certificate_of_authenticity_len; i++) {
 800c25e:	693b      	ldr	r3, [r7, #16]
 800c260:	3301      	adds	r3, #1
 800c262:	613b      	str	r3, [r7, #16]
 800c264:	68bb      	ldr	r3, [r7, #8]
 800c266:	7c9b      	ldrb	r3, [r3, #18]
 800c268:	461a      	mov	r2, r3
 800c26a:	693b      	ldr	r3, [r7, #16]
 800c26c:	429a      	cmp	r2, r3
 800c26e:	d8e2      	bhi.n	800c236 <_encode_uavcan_protocol_HardwareVersion+0xbe>
            memset(buffer,0,8);
            canardEncodeScalar(buffer, 0, 8, &msg->certificate_of_authenticity[i]);
            chunk_cb(buffer, 8, ctx);
    }
}
 800c270:	3718      	adds	r7, #24
 800c272:	46bd      	mov	sp, r7
 800c274:	bd80      	pop	{r7, pc}
 800c276:	bf00      	nop

0800c278 <_decode_uavcan_protocol_HardwareVersion>:

void _decode_uavcan_protocol_HardwareVersion(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_HardwareVersion_s* msg, bool tao) {
 800c278:	b580      	push	{r7, lr}
 800c27a:	b088      	sub	sp, #32
 800c27c:	af02      	add	r7, sp, #8
 800c27e:	60f8      	str	r0, [r7, #12]
 800c280:	60b9      	str	r1, [r7, #8]
 800c282:	607a      	str	r2, [r7, #4]
 800c284:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->major);
 800c286:	68bb      	ldr	r3, [r7, #8]
 800c288:	681a      	ldr	r2, [r3, #0]
 800c28a:	687b      	ldr	r3, [r7, #4]
 800c28c:	9300      	str	r3, [sp, #0]
 800c28e:	68f8      	ldr	r0, [r7, #12]
 800c290:	4611      	mov	r1, r2
 800c292:	2208      	movs	r2, #8
 800c294:	2300      	movs	r3, #0
 800c296:	f000 ffa9 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 8;
 800c29a:	68bb      	ldr	r3, [r7, #8]
 800c29c:	681b      	ldr	r3, [r3, #0]
 800c29e:	f103 0208 	add.w	r2, r3, #8
 800c2a2:	68bb      	ldr	r3, [r7, #8]
 800c2a4:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->minor);
 800c2a6:	68bb      	ldr	r3, [r7, #8]
 800c2a8:	681a      	ldr	r2, [r3, #0]
 800c2aa:	687b      	ldr	r3, [r7, #4]
 800c2ac:	3301      	adds	r3, #1
 800c2ae:	9300      	str	r3, [sp, #0]
 800c2b0:	68f8      	ldr	r0, [r7, #12]
 800c2b2:	4611      	mov	r1, r2
 800c2b4:	2208      	movs	r2, #8
 800c2b6:	2300      	movs	r3, #0
 800c2b8:	f000 ff98 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 8;
 800c2bc:	68bb      	ldr	r3, [r7, #8]
 800c2be:	681b      	ldr	r3, [r3, #0]
 800c2c0:	f103 0208 	add.w	r2, r3, #8
 800c2c4:	68bb      	ldr	r3, [r7, #8]
 800c2c6:	601a      	str	r2, [r3, #0]

    for (size_t i=0; i < 16; i++) {
 800c2c8:	2300      	movs	r3, #0
 800c2ca:	617b      	str	r3, [r7, #20]
 800c2cc:	e014      	b.n	800c2f8 <_decode_uavcan_protocol_HardwareVersion+0x80>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->unique_id[i]);
 800c2ce:	68bb      	ldr	r3, [r7, #8]
 800c2d0:	6819      	ldr	r1, [r3, #0]
 800c2d2:	687a      	ldr	r2, [r7, #4]
 800c2d4:	697b      	ldr	r3, [r7, #20]
 800c2d6:	4413      	add	r3, r2
 800c2d8:	3302      	adds	r3, #2
 800c2da:	9300      	str	r3, [sp, #0]
 800c2dc:	68f8      	ldr	r0, [r7, #12]
 800c2de:	2208      	movs	r2, #8
 800c2e0:	2300      	movs	r3, #0
 800c2e2:	f000 ff83 	bl	800d1ec <canardDecodeScalar>
        *bit_ofs += 8;
 800c2e6:	68bb      	ldr	r3, [r7, #8]
 800c2e8:	681b      	ldr	r3, [r3, #0]
 800c2ea:	f103 0208 	add.w	r2, r3, #8
 800c2ee:	68bb      	ldr	r3, [r7, #8]
 800c2f0:	601a      	str	r2, [r3, #0]
    *bit_ofs += 8;

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->minor);
    *bit_ofs += 8;

    for (size_t i=0; i < 16; i++) {
 800c2f2:	697b      	ldr	r3, [r7, #20]
 800c2f4:	3301      	adds	r3, #1
 800c2f6:	617b      	str	r3, [r7, #20]
 800c2f8:	697b      	ldr	r3, [r7, #20]
 800c2fa:	2b0f      	cmp	r3, #15
 800c2fc:	d9e7      	bls.n	800c2ce <_decode_uavcan_protocol_HardwareVersion+0x56>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->unique_id[i]);
        *bit_ofs += 8;
    }

    if (!tao) {
 800c2fe:	78fb      	ldrb	r3, [r7, #3]
 800c300:	f083 0301 	eor.w	r3, r3, #1
 800c304:	b2db      	uxtb	r3, r3
 800c306:	2b00      	cmp	r3, #0
 800c308:	d011      	beq.n	800c32e <_decode_uavcan_protocol_HardwareVersion+0xb6>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->certificate_of_authenticity_len);
 800c30a:	68bb      	ldr	r3, [r7, #8]
 800c30c:	681a      	ldr	r2, [r3, #0]
 800c30e:	687b      	ldr	r3, [r7, #4]
 800c310:	3312      	adds	r3, #18
 800c312:	9300      	str	r3, [sp, #0]
 800c314:	68f8      	ldr	r0, [r7, #12]
 800c316:	4611      	mov	r1, r2
 800c318:	2208      	movs	r2, #8
 800c31a:	2300      	movs	r3, #0
 800c31c:	f000 ff66 	bl	800d1ec <canardDecodeScalar>
        *bit_ofs += 8;
 800c320:	68bb      	ldr	r3, [r7, #8]
 800c322:	681b      	ldr	r3, [r3, #0]
 800c324:	f103 0208 	add.w	r2, r3, #8
 800c328:	68bb      	ldr	r3, [r7, #8]
 800c32a:	601a      	str	r2, [r3, #0]
 800c32c:	e00a      	b.n	800c344 <_decode_uavcan_protocol_HardwareVersion+0xcc>
    } else {
        msg->certificate_of_authenticity_len = ((transfer->payload_len*8)-*bit_ofs)/8;
 800c32e:	68fb      	ldr	r3, [r7, #12]
 800c330:	8a9b      	ldrh	r3, [r3, #20]
 800c332:	00db      	lsls	r3, r3, #3
 800c334:	461a      	mov	r2, r3
 800c336:	68bb      	ldr	r3, [r7, #8]
 800c338:	681b      	ldr	r3, [r3, #0]
 800c33a:	1ad3      	subs	r3, r2, r3
 800c33c:	08db      	lsrs	r3, r3, #3
 800c33e:	b2da      	uxtb	r2, r3
 800c340:	687b      	ldr	r3, [r7, #4]
 800c342:	749a      	strb	r2, [r3, #18]
    }

    for (size_t i=0; i < msg->certificate_of_authenticity_len; i++) {
 800c344:	2300      	movs	r3, #0
 800c346:	613b      	str	r3, [r7, #16]
 800c348:	e015      	b.n	800c376 <_decode_uavcan_protocol_HardwareVersion+0xfe>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->certificate_of_authenticity[i]);
 800c34a:	68bb      	ldr	r3, [r7, #8]
 800c34c:	6819      	ldr	r1, [r3, #0]
 800c34e:	693b      	ldr	r3, [r7, #16]
 800c350:	3310      	adds	r3, #16
 800c352:	687a      	ldr	r2, [r7, #4]
 800c354:	4413      	add	r3, r2
 800c356:	3303      	adds	r3, #3
 800c358:	9300      	str	r3, [sp, #0]
 800c35a:	68f8      	ldr	r0, [r7, #12]
 800c35c:	2208      	movs	r2, #8
 800c35e:	2300      	movs	r3, #0
 800c360:	f000 ff44 	bl	800d1ec <canardDecodeScalar>
        *bit_ofs += 8;
 800c364:	68bb      	ldr	r3, [r7, #8]
 800c366:	681b      	ldr	r3, [r3, #0]
 800c368:	f103 0208 	add.w	r2, r3, #8
 800c36c:	68bb      	ldr	r3, [r7, #8]
 800c36e:	601a      	str	r2, [r3, #0]
        *bit_ofs += 8;
    } else {
        msg->certificate_of_authenticity_len = ((transfer->payload_len*8)-*bit_ofs)/8;
    }

    for (size_t i=0; i < msg->certificate_of_authenticity_len; i++) {
 800c370:	693b      	ldr	r3, [r7, #16]
 800c372:	3301      	adds	r3, #1
 800c374:	613b      	str	r3, [r7, #16]
 800c376:	687b      	ldr	r3, [r7, #4]
 800c378:	7c9b      	ldrb	r3, [r3, #18]
 800c37a:	461a      	mov	r2, r3
 800c37c:	693b      	ldr	r3, [r7, #16]
 800c37e:	429a      	cmp	r2, r3
 800c380:	d8e3      	bhi.n	800c34a <_decode_uavcan_protocol_HardwareVersion+0xd2>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->certificate_of_authenticity[i]);
        *bit_ofs += 8;
    }

}
 800c382:	3718      	adds	r7, #24
 800c384:	46bd      	mov	sp, r7
 800c386:	bd80      	pop	{r7, pc}

0800c388 <_encode_uavcan_protocol_SoftwareVersion>:
    uint32_t bit_ofs = 0;
    _decode_uavcan_protocol_SoftwareVersion(transfer, &bit_ofs, msg, true);
    return (bit_ofs+7)/8;
}

void _encode_uavcan_protocol_SoftwareVersion(uint8_t* buffer, struct uavcan_protocol_SoftwareVersion_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800c388:	b580      	push	{r7, lr}
 800c38a:	b084      	sub	sp, #16
 800c38c:	af00      	add	r7, sp, #0
 800c38e:	60f8      	str	r0, [r7, #12]
 800c390:	60b9      	str	r1, [r7, #8]
 800c392:	607a      	str	r2, [r7, #4]
 800c394:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
 800c396:	68f8      	ldr	r0, [r7, #12]
 800c398:	2100      	movs	r1, #0
 800c39a:	2208      	movs	r2, #8
 800c39c:	f002 f916 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->major);
 800c3a0:	68bb      	ldr	r3, [r7, #8]
 800c3a2:	68f8      	ldr	r0, [r7, #12]
 800c3a4:	2100      	movs	r1, #0
 800c3a6:	2208      	movs	r2, #8
 800c3a8:	f001 f898 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800c3ac:	687b      	ldr	r3, [r7, #4]
 800c3ae:	68f8      	ldr	r0, [r7, #12]
 800c3b0:	2108      	movs	r1, #8
 800c3b2:	683a      	ldr	r2, [r7, #0]
 800c3b4:	4798      	blx	r3
    memset(buffer,0,8);
 800c3b6:	68f8      	ldr	r0, [r7, #12]
 800c3b8:	2100      	movs	r1, #0
 800c3ba:	2208      	movs	r2, #8
 800c3bc:	f002 f906 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->minor);
 800c3c0:	68bb      	ldr	r3, [r7, #8]
 800c3c2:	3301      	adds	r3, #1
 800c3c4:	68f8      	ldr	r0, [r7, #12]
 800c3c6:	2100      	movs	r1, #0
 800c3c8:	2208      	movs	r2, #8
 800c3ca:	f001 f887 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800c3ce:	687b      	ldr	r3, [r7, #4]
 800c3d0:	68f8      	ldr	r0, [r7, #12]
 800c3d2:	2108      	movs	r1, #8
 800c3d4:	683a      	ldr	r2, [r7, #0]
 800c3d6:	4798      	blx	r3
    memset(buffer,0,8);
 800c3d8:	68f8      	ldr	r0, [r7, #12]
 800c3da:	2100      	movs	r1, #0
 800c3dc:	2208      	movs	r2, #8
 800c3de:	f002 f8f5 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->optional_field_flags);
 800c3e2:	68bb      	ldr	r3, [r7, #8]
 800c3e4:	3302      	adds	r3, #2
 800c3e6:	68f8      	ldr	r0, [r7, #12]
 800c3e8:	2100      	movs	r1, #0
 800c3ea:	2208      	movs	r2, #8
 800c3ec:	f001 f876 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800c3f0:	687b      	ldr	r3, [r7, #4]
 800c3f2:	68f8      	ldr	r0, [r7, #12]
 800c3f4:	2108      	movs	r1, #8
 800c3f6:	683a      	ldr	r2, [r7, #0]
 800c3f8:	4798      	blx	r3
    memset(buffer,0,8);
 800c3fa:	68f8      	ldr	r0, [r7, #12]
 800c3fc:	2100      	movs	r1, #0
 800c3fe:	2208      	movs	r2, #8
 800c400:	f002 f8e4 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 32, &msg->vcs_commit);
 800c404:	68bb      	ldr	r3, [r7, #8]
 800c406:	3304      	adds	r3, #4
 800c408:	68f8      	ldr	r0, [r7, #12]
 800c40a:	2100      	movs	r1, #0
 800c40c:	2220      	movs	r2, #32
 800c40e:	f001 f865 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 32, ctx);
 800c412:	687b      	ldr	r3, [r7, #4]
 800c414:	68f8      	ldr	r0, [r7, #12]
 800c416:	2120      	movs	r1, #32
 800c418:	683a      	ldr	r2, [r7, #0]
 800c41a:	4798      	blx	r3
    memset(buffer,0,8);
 800c41c:	68f8      	ldr	r0, [r7, #12]
 800c41e:	2100      	movs	r1, #0
 800c420:	2208      	movs	r2, #8
 800c422:	f002 f8d3 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 64, &msg->image_crc);
 800c426:	68bb      	ldr	r3, [r7, #8]
 800c428:	3308      	adds	r3, #8
 800c42a:	68f8      	ldr	r0, [r7, #12]
 800c42c:	2100      	movs	r1, #0
 800c42e:	2240      	movs	r2, #64	; 0x40
 800c430:	f001 f854 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 64, ctx);
 800c434:	687b      	ldr	r3, [r7, #4]
 800c436:	68f8      	ldr	r0, [r7, #12]
 800c438:	2140      	movs	r1, #64	; 0x40
 800c43a:	683a      	ldr	r2, [r7, #0]
 800c43c:	4798      	blx	r3
}
 800c43e:	3710      	adds	r7, #16
 800c440:	46bd      	mov	sp, r7
 800c442:	bd80      	pop	{r7, pc}

0800c444 <_decode_uavcan_protocol_SoftwareVersion>:

void _decode_uavcan_protocol_SoftwareVersion(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_SoftwareVersion_s* msg, bool tao) {
 800c444:	b580      	push	{r7, lr}
 800c446:	b086      	sub	sp, #24
 800c448:	af02      	add	r7, sp, #8
 800c44a:	60f8      	str	r0, [r7, #12]
 800c44c:	60b9      	str	r1, [r7, #8]
 800c44e:	607a      	str	r2, [r7, #4]
 800c450:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->major);
 800c452:	68bb      	ldr	r3, [r7, #8]
 800c454:	681a      	ldr	r2, [r3, #0]
 800c456:	687b      	ldr	r3, [r7, #4]
 800c458:	9300      	str	r3, [sp, #0]
 800c45a:	68f8      	ldr	r0, [r7, #12]
 800c45c:	4611      	mov	r1, r2
 800c45e:	2208      	movs	r2, #8
 800c460:	2300      	movs	r3, #0
 800c462:	f000 fec3 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 8;
 800c466:	68bb      	ldr	r3, [r7, #8]
 800c468:	681b      	ldr	r3, [r3, #0]
 800c46a:	f103 0208 	add.w	r2, r3, #8
 800c46e:	68bb      	ldr	r3, [r7, #8]
 800c470:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->minor);
 800c472:	68bb      	ldr	r3, [r7, #8]
 800c474:	681a      	ldr	r2, [r3, #0]
 800c476:	687b      	ldr	r3, [r7, #4]
 800c478:	3301      	adds	r3, #1
 800c47a:	9300      	str	r3, [sp, #0]
 800c47c:	68f8      	ldr	r0, [r7, #12]
 800c47e:	4611      	mov	r1, r2
 800c480:	2208      	movs	r2, #8
 800c482:	2300      	movs	r3, #0
 800c484:	f000 feb2 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 8;
 800c488:	68bb      	ldr	r3, [r7, #8]
 800c48a:	681b      	ldr	r3, [r3, #0]
 800c48c:	f103 0208 	add.w	r2, r3, #8
 800c490:	68bb      	ldr	r3, [r7, #8]
 800c492:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->optional_field_flags);
 800c494:	68bb      	ldr	r3, [r7, #8]
 800c496:	681a      	ldr	r2, [r3, #0]
 800c498:	687b      	ldr	r3, [r7, #4]
 800c49a:	3302      	adds	r3, #2
 800c49c:	9300      	str	r3, [sp, #0]
 800c49e:	68f8      	ldr	r0, [r7, #12]
 800c4a0:	4611      	mov	r1, r2
 800c4a2:	2208      	movs	r2, #8
 800c4a4:	2300      	movs	r3, #0
 800c4a6:	f000 fea1 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 8;
 800c4aa:	68bb      	ldr	r3, [r7, #8]
 800c4ac:	681b      	ldr	r3, [r3, #0]
 800c4ae:	f103 0208 	add.w	r2, r3, #8
 800c4b2:	68bb      	ldr	r3, [r7, #8]
 800c4b4:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 32, false, &msg->vcs_commit);
 800c4b6:	68bb      	ldr	r3, [r7, #8]
 800c4b8:	681a      	ldr	r2, [r3, #0]
 800c4ba:	687b      	ldr	r3, [r7, #4]
 800c4bc:	3304      	adds	r3, #4
 800c4be:	9300      	str	r3, [sp, #0]
 800c4c0:	68f8      	ldr	r0, [r7, #12]
 800c4c2:	4611      	mov	r1, r2
 800c4c4:	2220      	movs	r2, #32
 800c4c6:	2300      	movs	r3, #0
 800c4c8:	f000 fe90 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 32;
 800c4cc:	68bb      	ldr	r3, [r7, #8]
 800c4ce:	681b      	ldr	r3, [r3, #0]
 800c4d0:	f103 0220 	add.w	r2, r3, #32
 800c4d4:	68bb      	ldr	r3, [r7, #8]
 800c4d6:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 64, false, &msg->image_crc);
 800c4d8:	68bb      	ldr	r3, [r7, #8]
 800c4da:	681a      	ldr	r2, [r3, #0]
 800c4dc:	687b      	ldr	r3, [r7, #4]
 800c4de:	3308      	adds	r3, #8
 800c4e0:	9300      	str	r3, [sp, #0]
 800c4e2:	68f8      	ldr	r0, [r7, #12]
 800c4e4:	4611      	mov	r1, r2
 800c4e6:	2240      	movs	r2, #64	; 0x40
 800c4e8:	2300      	movs	r3, #0
 800c4ea:	f000 fe7f 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 64;
 800c4ee:	68bb      	ldr	r3, [r7, #8]
 800c4f0:	681b      	ldr	r3, [r3, #0]
 800c4f2:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800c4f6:	68bb      	ldr	r3, [r7, #8]
 800c4f8:	601a      	str	r2, [r3, #0]

}
 800c4fa:	3710      	adds	r7, #16
 800c4fc:	46bd      	mov	sp, r7
 800c4fe:	bd80      	pop	{r7, pc}

0800c500 <encode_func.lto_priv.55>:
#include <uavcan.protocol.GetNodeInfo_req.h>
#include <uavcan.protocol.GetNodeInfo_res.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800c500:	b580      	push	{r7, lr}
 800c502:	b084      	sub	sp, #16
 800c504:	af00      	add	r7, sp, #0
 800c506:	60f8      	str	r0, [r7, #12]
 800c508:	60b9      	str	r1, [r7, #8]
 800c50a:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_GetNodeInfo_req(msg, chunk_cb, ctx);
 800c50c:	68f8      	ldr	r0, [r7, #12]
 800c50e:	68b9      	ldr	r1, [r7, #8]
 800c510:	687a      	ldr	r2, [r7, #4]
 800c512:	f000 f811 	bl	800c538 <encode_uavcan_protocol_GetNodeInfo_req>
}
 800c516:	3710      	adds	r7, #16
 800c518:	46bd      	mov	sp, r7
 800c51a:	bd80      	pop	{r7, pc}

0800c51c <decode_func.lto_priv.63>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800c51c:	b580      	push	{r7, lr}
 800c51e:	b082      	sub	sp, #8
 800c520:	af00      	add	r7, sp, #0
 800c522:	6078      	str	r0, [r7, #4]
 800c524:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_GetNodeInfo_req(transfer, msg);
 800c526:	6878      	ldr	r0, [r7, #4]
 800c528:	6839      	ldr	r1, [r7, #0]
 800c52a:	f000 f819 	bl	800c560 <decode_uavcan_protocol_GetNodeInfo_req>
 800c52e:	4603      	mov	r3, r0
}
 800c530:	4618      	mov	r0, r3
 800c532:	3708      	adds	r7, #8
 800c534:	46bd      	mov	sp, r7
 800c536:	bd80      	pop	{r7, pc}

0800c538 <encode_uavcan_protocol_GetNodeInfo_req>:
    encode_func,
    decode_func,
    &uavcan_protocol_GetNodeInfo_res_descriptor
};

void encode_uavcan_protocol_GetNodeInfo_req(struct uavcan_protocol_GetNodeInfo_req_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800c538:	b580      	push	{r7, lr}
 800c53a:	b088      	sub	sp, #32
 800c53c:	af02      	add	r7, sp, #8
 800c53e:	60f8      	str	r0, [r7, #12]
 800c540:	60b9      	str	r1, [r7, #8]
 800c542:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_GetNodeInfo_req(buffer, msg, chunk_cb, ctx, true);
 800c544:	f107 0210 	add.w	r2, r7, #16
 800c548:	2301      	movs	r3, #1
 800c54a:	9300      	str	r3, [sp, #0]
 800c54c:	4610      	mov	r0, r2
 800c54e:	68f9      	ldr	r1, [r7, #12]
 800c550:	68ba      	ldr	r2, [r7, #8]
 800c552:	687b      	ldr	r3, [r7, #4]
 800c554:	f000 f81a 	bl	800c58c <_encode_uavcan_protocol_GetNodeInfo_req>
}
 800c558:	3718      	adds	r7, #24
 800c55a:	46bd      	mov	sp, r7
 800c55c:	bd80      	pop	{r7, pc}
 800c55e:	bf00      	nop

0800c560 <decode_uavcan_protocol_GetNodeInfo_req>:

uint32_t decode_uavcan_protocol_GetNodeInfo_req(const CanardRxTransfer* transfer, struct uavcan_protocol_GetNodeInfo_req_s* msg) {
 800c560:	b580      	push	{r7, lr}
 800c562:	b084      	sub	sp, #16
 800c564:	af00      	add	r7, sp, #0
 800c566:	6078      	str	r0, [r7, #4]
 800c568:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800c56a:	2300      	movs	r3, #0
 800c56c:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_GetNodeInfo_req(transfer, &bit_ofs, msg, true);
 800c56e:	f107 030c 	add.w	r3, r7, #12
 800c572:	6878      	ldr	r0, [r7, #4]
 800c574:	4619      	mov	r1, r3
 800c576:	683a      	ldr	r2, [r7, #0]
 800c578:	2301      	movs	r3, #1
 800c57a:	f000 f813 	bl	800c5a4 <_decode_uavcan_protocol_GetNodeInfo_req>
    return (bit_ofs+7)/8;
 800c57e:	68fb      	ldr	r3, [r7, #12]
 800c580:	3307      	adds	r3, #7
 800c582:	08db      	lsrs	r3, r3, #3
}
 800c584:	4618      	mov	r0, r3
 800c586:	3710      	adds	r7, #16
 800c588:	46bd      	mov	sp, r7
 800c58a:	bd80      	pop	{r7, pc}

0800c58c <_encode_uavcan_protocol_GetNodeInfo_req>:

void _encode_uavcan_protocol_GetNodeInfo_req(uint8_t* buffer, struct uavcan_protocol_GetNodeInfo_req_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800c58c:	b480      	push	{r7}
 800c58e:	b085      	sub	sp, #20
 800c590:	af00      	add	r7, sp, #0
 800c592:	60f8      	str	r0, [r7, #12]
 800c594:	60b9      	str	r1, [r7, #8]
 800c596:	607a      	str	r2, [r7, #4]
 800c598:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

}
 800c59a:	3714      	adds	r7, #20
 800c59c:	46bd      	mov	sp, r7
 800c59e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c5a2:	4770      	bx	lr

0800c5a4 <_decode_uavcan_protocol_GetNodeInfo_req>:

void _decode_uavcan_protocol_GetNodeInfo_req(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_GetNodeInfo_req_s* msg, bool tao) {
 800c5a4:	b480      	push	{r7}
 800c5a6:	b085      	sub	sp, #20
 800c5a8:	af00      	add	r7, sp, #0
 800c5aa:	60f8      	str	r0, [r7, #12]
 800c5ac:	60b9      	str	r1, [r7, #8]
 800c5ae:	607a      	str	r2, [r7, #4]
 800c5b0:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

}
 800c5b2:	3714      	adds	r7, #20
 800c5b4:	46bd      	mov	sp, r7
 800c5b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c5ba:	4770      	bx	lr

0800c5bc <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 800c5bc:	b480      	push	{r7}
 800c5be:	af00      	add	r7, sp, #0

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 800c5c0:	46bd      	mov	sp, r7
 800c5c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c5c6:	4770      	bx	lr

0800c5c8 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 800c5c8:	b480      	push	{r7}
 800c5ca:	af00      	add	r7, sp, #0
 800c5cc:	46bd      	mov	sp, r7
 800c5ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c5d2:	4770      	bx	lr

0800c5d4 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 800c5d4:	b480      	push	{r7}
 800c5d6:	af00      	add	r7, sp, #0
 800c5d8:	e7fe      	b.n	800c5d8 <__default_exit+0x4>
 800c5da:	bf00      	nop

0800c5dc <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 800c5dc:	b480      	push	{r7}
 800c5de:	b085      	sub	sp, #20
 800c5e0:	af00      	add	r7, sp, #0
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 800c5e2:	4b18      	ldr	r3, [pc, #96]	; (800c644 <__init_ram_areas+0x68>)
 800c5e4:	60fb      	str	r3, [r7, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 800c5e6:	68fb      	ldr	r3, [r7, #12]
 800c5e8:	681b      	ldr	r3, [r3, #0]
 800c5ea:	60bb      	str	r3, [r7, #8]
    uint32_t *p = rap->init_area;
 800c5ec:	68fb      	ldr	r3, [r7, #12]
 800c5ee:	685b      	ldr	r3, [r3, #4]
 800c5f0:	607b      	str	r3, [r7, #4]
 800c5f2:	e009      	b.n	800c608 <__init_ram_areas+0x2c>

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 800c5f4:	68bb      	ldr	r3, [r7, #8]
 800c5f6:	681a      	ldr	r2, [r3, #0]
 800c5f8:	687b      	ldr	r3, [r7, #4]
 800c5fa:	601a      	str	r2, [r3, #0]
      p++;
 800c5fc:	687b      	ldr	r3, [r7, #4]
 800c5fe:	3304      	adds	r3, #4
 800c600:	607b      	str	r3, [r7, #4]
      tp++;
 800c602:	68bb      	ldr	r3, [r7, #8]
 800c604:	3304      	adds	r3, #4
 800c606:	60bb      	str	r3, [r7, #8]
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800c608:	68fb      	ldr	r3, [r7, #12]
 800c60a:	689a      	ldr	r2, [r3, #8]
 800c60c:	687b      	ldr	r3, [r7, #4]
 800c60e:	429a      	cmp	r2, r3
 800c610:	d8f0      	bhi.n	800c5f4 <__init_ram_areas+0x18>
 800c612:	e005      	b.n	800c620 <__init_ram_areas+0x44>
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 800c614:	687b      	ldr	r3, [r7, #4]
 800c616:	2200      	movs	r2, #0
 800c618:	601a      	str	r2, [r3, #0]
      p++;
 800c61a:	687b      	ldr	r3, [r7, #4]
 800c61c:	3304      	adds	r3, #4
 800c61e:	607b      	str	r3, [r7, #4]
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800c620:	68fb      	ldr	r3, [r7, #12]
 800c622:	68da      	ldr	r2, [r3, #12]
 800c624:	687b      	ldr	r3, [r7, #4]
 800c626:	429a      	cmp	r2, r3
 800c628:	d8f4      	bhi.n	800c614 <__init_ram_areas+0x38>
      *p = 0;
      p++;
    }
    rap++;
 800c62a:	68fb      	ldr	r3, [r7, #12]
 800c62c:	3310      	adds	r3, #16
 800c62e:	60fb      	str	r3, [r7, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800c630:	68fb      	ldr	r3, [r7, #12]
 800c632:	4a05      	ldr	r2, [pc, #20]	; (800c648 <__init_ram_areas+0x6c>)
 800c634:	4293      	cmp	r3, r2
 800c636:	d3d6      	bcc.n	800c5e6 <__init_ram_areas+0xa>
#endif
}
 800c638:	3714      	adds	r7, #20
 800c63a:	46bd      	mov	sp, r7
 800c63c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c640:	4770      	bx	lr
 800c642:	bf00      	nop
 800c644:	0800e7d8 	.word	0x0800e7d8
 800c648:	0800e858 	.word	0x0800e858

0800c64c <BusFault_Handler>:
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
__attribute__((weak))
void _unhandled_exception(void) {
 800c64c:	b480      	push	{r7}
 800c64e:	af00      	add	r7, sp, #0
 800c650:	e7fe      	b.n	800c650 <BusFault_Handler+0x4>
 800c652:	bf00      	nop

0800c654 <NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800c654:	b480      	push	{r7}
 800c656:	b085      	sub	sp, #20
 800c658:	af00      	add	r7, sp, #0
 800c65a:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800c65c:	687b      	ldr	r3, [r7, #4]
 800c65e:	f003 0307 	and.w	r3, r3, #7
 800c662:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800c664:	4b0c      	ldr	r3, [pc, #48]	; (800c698 <NVIC_SetPriorityGrouping+0x44>)
 800c666:	68db      	ldr	r3, [r3, #12]
 800c668:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800c66a:	68ba      	ldr	r2, [r7, #8]
 800c66c:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800c670:	4013      	ands	r3, r2
 800c672:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 800c674:	68fb      	ldr	r3, [r7, #12]
 800c676:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800c678:	68bb      	ldr	r3, [r7, #8]
 800c67a:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 800c67c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800c680:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800c684:	60bb      	str	r3, [r7, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800c686:	4a04      	ldr	r2, [pc, #16]	; (800c698 <NVIC_SetPriorityGrouping+0x44>)
 800c688:	68bb      	ldr	r3, [r7, #8]
 800c68a:	60d3      	str	r3, [r2, #12]
}
 800c68c:	3714      	adds	r7, #20
 800c68e:	46bd      	mov	sp, r7
 800c690:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c694:	4770      	bx	lr
 800c696:	bf00      	nop
 800c698:	e000ed00 	.word	0xe000ed00

0800c69c <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800c69c:	b480      	push	{r7}
 800c69e:	b083      	sub	sp, #12
 800c6a0:	af00      	add	r7, sp, #0
 800c6a2:	4603      	mov	r3, r0
 800c6a4:	6039      	str	r1, [r7, #0]
 800c6a6:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) < 0)
 800c6a8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800c6ac:	2b00      	cmp	r3, #0
 800c6ae:	da0b      	bge.n	800c6c8 <NVIC_SetPriority+0x2c>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800c6b0:	490d      	ldr	r1, [pc, #52]	; (800c6e8 <NVIC_SetPriority+0x4c>)
 800c6b2:	79fb      	ldrb	r3, [r7, #7]
 800c6b4:	f003 030f 	and.w	r3, r3, #15
 800c6b8:	3b04      	subs	r3, #4
 800c6ba:	683a      	ldr	r2, [r7, #0]
 800c6bc:	b2d2      	uxtb	r2, r2
 800c6be:	0112      	lsls	r2, r2, #4
 800c6c0:	b2d2      	uxtb	r2, r2
 800c6c2:	440b      	add	r3, r1
 800c6c4:	761a      	strb	r2, [r3, #24]
 800c6c6:	e009      	b.n	800c6dc <NVIC_SetPriority+0x40>
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800c6c8:	4908      	ldr	r1, [pc, #32]	; (800c6ec <NVIC_SetPriority+0x50>)
 800c6ca:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800c6ce:	683a      	ldr	r2, [r7, #0]
 800c6d0:	b2d2      	uxtb	r2, r2
 800c6d2:	0112      	lsls	r2, r2, #4
 800c6d4:	b2d2      	uxtb	r2, r2
 800c6d6:	440b      	add	r3, r1
 800c6d8:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 800c6dc:	370c      	adds	r7, #12
 800c6de:	46bd      	mov	sp, r7
 800c6e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c6e4:	4770      	bx	lr
 800c6e6:	bf00      	nop
 800c6e8:	e000ed00 	.word	0xe000ed00
 800c6ec:	e000e100 	.word	0xe000e100

0800c6f0 <port_init>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 800c6f0:	b580      	push	{r7, lr}
 800c6f2:	af00      	add	r7, sp, #0

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 800c6f4:	2003      	movs	r0, #3
 800c6f6:	f7ff ffad 	bl	800c654 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800c6fa:	4a0b      	ldr	r2, [pc, #44]	; (800c728 <port_init+0x38>)
 800c6fc:	4b0a      	ldr	r3, [pc, #40]	; (800c728 <port_init+0x38>)
 800c6fe:	68db      	ldr	r3, [r3, #12]
 800c700:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800c704:	60d3      	str	r3, [r2, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800c706:	4a09      	ldr	r2, [pc, #36]	; (800c72c <port_init+0x3c>)
 800c708:	4b08      	ldr	r3, [pc, #32]	; (800c72c <port_init+0x3c>)
 800c70a:	681b      	ldr	r3, [r3, #0]
 800c70c:	f043 0301 	orr.w	r3, r3, #1
 800c710:	6013      	str	r3, [r2, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 800c712:	f06f 0004 	mvn.w	r0, #4
 800c716:	2101      	movs	r1, #1
 800c718:	f7ff ffc0 	bl	800c69c <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 800c71c:	f06f 0001 	mvn.w	r0, #1
 800c720:	2102      	movs	r1, #2
 800c722:	f7ff ffbb 	bl	800c69c <NVIC_SetPriority>

    /* MPU is enabled.*/
    mpuEnable(MPU_CTRL_PRIVDEFENA);
  }
#endif
}
 800c726:	bd80      	pop	{r7, pc}
 800c728:	e000edf0 	.word	0xe000edf0
 800c72c:	e0001000 	.word	0xe0001000

0800c730 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800c730:	b480      	push	{r7}
 800c732:	b083      	sub	sp, #12
 800c734:	af00      	add	r7, sp, #0
 800c736:	2320      	movs	r3, #32
 800c738:	607b      	str	r3, [r7, #4]
 800c73a:	687b      	ldr	r3, [r7, #4]
 800c73c:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c740:	370c      	adds	r7, #12
 800c742:	46bd      	mov	sp, r7
 800c744:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c748:	4770      	bx	lr
 800c74a:	bf00      	nop

0800c74c <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800c74c:	b480      	push	{r7}
 800c74e:	b083      	sub	sp, #12
 800c750:	af00      	add	r7, sp, #0
 800c752:	2300      	movs	r3, #0
 800c754:	607b      	str	r3, [r7, #4]
 800c756:	687b      	ldr	r3, [r7, #4]
 800c758:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c75c:	370c      	adds	r7, #12
 800c75e:	46bd      	mov	sp, r7
 800c760:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c764:	4770      	bx	lr
 800c766:	bf00      	nop

0800c768 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800c768:	b580      	push	{r7, lr}
 800c76a:	af00      	add	r7, sp, #0

  port_lock();
 800c76c:	f7ff ffe0 	bl	800c730 <port_lock>
}
 800c770:	bd80      	pop	{r7, pc}
 800c772:	bf00      	nop

0800c774 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800c774:	b580      	push	{r7, lr}
 800c776:	af00      	add	r7, sp, #0

  port_unlock();
 800c778:	f7ff ffe8 	bl	800c74c <port_unlock>
}
 800c77c:	bd80      	pop	{r7, pc}
 800c77e:	bf00      	nop

0800c780 <port_disable.lto_priv.335>:
/**
 * @brief   Disables all the interrupt sources.
 * @note    In this port it disables all the interrupt sources by raising
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {
 800c780:	b480      	push	{r7}
 800c782:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800c784:	b672      	cpsid	i

  __disable_irq();
}
 800c786:	46bd      	mov	sp, r7
 800c788:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c78c:	4770      	bx	lr
 800c78e:	bf00      	nop

0800c790 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 800c790:	b480      	push	{r7}
 800c792:	b083      	sub	sp, #12
 800c794:	af00      	add	r7, sp, #0
 800c796:	2300      	movs	r3, #0
 800c798:	607b      	str	r3, [r7, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800c79a:	687b      	ldr	r3, [r7, #4]
 800c79c:	f383 8811 	msr	BASEPRI, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800c7a0:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 800c7a2:	370c      	adds	r7, #12
 800c7a4:	46bd      	mov	sp, r7
 800c7a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7aa:	4770      	bx	lr

0800c7ac <port_wait_for_interrupt>:
 *          The simplest implementation is an empty function or macro but this
 *          would not take advantage of architecture-specific power saving
 *          modes.
 * @note    Implemented as an inlined @p WFI instruction.
 */
static inline void port_wait_for_interrupt(void) {
 800c7ac:	b480      	push	{r7}
 800c7ae:	af00      	add	r7, sp, #0

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 800c7b0:	46bd      	mov	sp, r7
 800c7b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7b6:	4770      	bx	lr

0800c7b8 <st_lld_get_counter>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 800c7b8:	b480      	push	{r7}
 800c7ba:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 800c7bc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800c7c0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c7c2:	b29b      	uxth	r3, r3
}
 800c7c4:	4618      	mov	r0, r3
 800c7c6:	46bd      	mov	sp, r7
 800c7c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7cc:	4770      	bx	lr
 800c7ce:	bf00      	nop

0800c7d0 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 800c7d0:	b580      	push	{r7, lr}
 800c7d2:	af00      	add	r7, sp, #0

  stStopAlarm();
 800c7d4:	f7fc fdd8 	bl	8009388 <stStopAlarm>
}
 800c7d8:	bd80      	pop	{r7, pc}
 800c7da:	bf00      	nop

0800c7dc <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 800c7dc:	b580      	push	{r7, lr}
 800c7de:	b082      	sub	sp, #8
 800c7e0:	af00      	add	r7, sp, #0
 800c7e2:	4603      	mov	r3, r0
 800c7e4:	80fb      	strh	r3, [r7, #6]

  stSetAlarm(time);
 800c7e6:	88fb      	ldrh	r3, [r7, #6]
 800c7e8:	4618      	mov	r0, r3
 800c7ea:	f7fc fdd3 	bl	8009394 <stSetAlarm>
}
 800c7ee:	3708      	adds	r7, #8
 800c7f0:	46bd      	mov	sp, r7
 800c7f2:	bd80      	pop	{r7, pc}

0800c7f4 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 800c7f4:	b580      	push	{r7, lr}
 800c7f6:	af00      	add	r7, sp, #0

  return stGetCounter();
 800c7f8:	f7ff ffde 	bl	800c7b8 <st_lld_get_counter>
 800c7fc:	4603      	mov	r3, r0
}
 800c7fe:	4618      	mov	r0, r3
 800c800:	bd80      	pop	{r7, pc}
 800c802:	bf00      	nop

0800c804 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 800c804:	b580      	push	{r7, lr}
 800c806:	af00      	add	r7, sp, #0

  _dbg_check_enable();
 800c808:	f7fe fb36 	bl	800ae78 <_dbg_check_enable>
  port_enable();
 800c80c:	f7ff ffc0 	bl	800c790 <port_enable>
}
 800c810:	bd80      	pop	{r7, pc}
 800c812:	bf00      	nop

0800c814 <chSysLockFromISR.lto_priv.322>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800c814:	b580      	push	{r7, lr}
 800c816:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 800c818:	f7ff ffa6 	bl	800c768 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800c81c:	f7fe fb6a 	bl	800aef4 <_dbg_check_lock_from_isr>
}
 800c820:	bd80      	pop	{r7, pc}
 800c822:	bf00      	nop

0800c824 <chSysUnlockFromISR.lto_priv.320>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800c824:	b580      	push	{r7, lr}
 800c826:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
 800c828:	f7fe fb7a 	bl	800af20 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800c82c:	f7ff ffa2 	bl	800c774 <port_unlock_from_isr>
}
 800c830:	bd80      	pop	{r7, pc}
 800c832:	bf00      	nop

0800c834 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 800c834:	b580      	push	{r7, lr}
 800c836:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 800c838:	f7ff ffdc 	bl	800c7f4 <port_timer_get_time>
 800c83c:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800c83e:	4618      	mov	r0, r3
 800c840:	bd80      	pop	{r7, pc}
 800c842:	bf00      	nop

0800c844 <chVTDoTickI.lto_priv.334>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 800c844:	b580      	push	{r7, lr}
 800c846:	b084      	sub	sp, #16
 800c848:	af00      	add	r7, sp, #0

  chDbgCheckClassI();
 800c84a:	f7fe fbb7 	bl	800afbc <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 800c84e:	4b36      	ldr	r3, [pc, #216]	; (800c928 <chVTDoTickI.lto_priv.334+0xe4>)
 800c850:	69db      	ldr	r3, [r3, #28]
 800c852:	60fb      	str	r3, [r7, #12]
  now = chVTGetSystemTimeX();
 800c854:	f7ff ffee 	bl	800c834 <chVTGetSystemTimeX>
 800c858:	4603      	mov	r3, r0
 800c85a:	817b      	strh	r3, [r7, #10]
 800c85c:	e02c      	b.n	800c8b8 <chVTDoTickI.lto_priv.334+0x74>
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 800c85e:	4b32      	ldr	r3, [pc, #200]	; (800c928 <chVTDoTickI.lto_priv.334+0xe4>)
 800c860:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800c862:	68fb      	ldr	r3, [r7, #12]
 800c864:	891b      	ldrh	r3, [r3, #8]
 800c866:	4413      	add	r3, r2
 800c868:	b29a      	uxth	r2, r3
 800c86a:	4b2f      	ldr	r3, [pc, #188]	; (800c928 <chVTDoTickI.lto_priv.334+0xe4>)
 800c86c:	84da      	strh	r2, [r3, #38]	; 0x26

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800c86e:	68fb      	ldr	r3, [r7, #12]
 800c870:	681b      	ldr	r3, [r3, #0]
 800c872:	4a2e      	ldr	r2, [pc, #184]	; (800c92c <chVTDoTickI.lto_priv.334+0xe8>)
 800c874:	605a      	str	r2, [r3, #4]
    ch.vtlist.next = vtp->next;
 800c876:	68fb      	ldr	r3, [r7, #12]
 800c878:	681b      	ldr	r3, [r3, #0]
 800c87a:	4a2b      	ldr	r2, [pc, #172]	; (800c928 <chVTDoTickI.lto_priv.334+0xe4>)
 800c87c:	61d3      	str	r3, [r2, #28]
    fn = vtp->func;
 800c87e:	68fb      	ldr	r3, [r7, #12]
 800c880:	68db      	ldr	r3, [r3, #12]
 800c882:	607b      	str	r3, [r7, #4]
    vtp->func = NULL;
 800c884:	68fb      	ldr	r3, [r7, #12]
 800c886:	2200      	movs	r2, #0
 800c888:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800c88a:	4b27      	ldr	r3, [pc, #156]	; (800c928 <chVTDoTickI.lto_priv.334+0xe4>)
 800c88c:	69db      	ldr	r3, [r3, #28]
 800c88e:	4a27      	ldr	r2, [pc, #156]	; (800c92c <chVTDoTickI.lto_priv.334+0xe8>)
 800c890:	4293      	cmp	r3, r2
 800c892:	d101      	bne.n	800c898 <chVTDoTickI.lto_priv.334+0x54>
      port_timer_stop_alarm();
 800c894:	f7ff ff9c 	bl	800c7d0 <port_timer_stop_alarm>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
 800c898:	f7ff ffc4 	bl	800c824 <chSysUnlockFromISR.lto_priv.320>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 800c89c:	68fb      	ldr	r3, [r7, #12]
 800c89e:	691a      	ldr	r2, [r3, #16]
 800c8a0:	687b      	ldr	r3, [r7, #4]
 800c8a2:	4610      	mov	r0, r2
 800c8a4:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
 800c8a6:	f7ff ffb5 	bl	800c814 <chSysLockFromISR.lto_priv.322>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 800c8aa:	4b1f      	ldr	r3, [pc, #124]	; (800c928 <chVTDoTickI.lto_priv.334+0xe4>)
 800c8ac:	69db      	ldr	r3, [r3, #28]
 800c8ae:	60fb      	str	r3, [r7, #12]
    now = chVTGetSystemTimeX();
 800c8b0:	f7ff ffc0 	bl	800c834 <chVTGetSystemTimeX>
 800c8b4:	4603      	mov	r3, r0
 800c8b6:	817b      	strh	r3, [r7, #10]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 800c8b8:	68fb      	ldr	r3, [r7, #12]
 800c8ba:	891a      	ldrh	r2, [r3, #8]
 800c8bc:	4b1a      	ldr	r3, [pc, #104]	; (800c928 <chVTDoTickI.lto_priv.334+0xe4>)
 800c8be:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 800c8c0:	8979      	ldrh	r1, [r7, #10]
 800c8c2:	1acb      	subs	r3, r1, r3
 800c8c4:	b29b      	uxth	r3, r3
 800c8c6:	429a      	cmp	r2, r3
 800c8c8:	d9c9      	bls.n	800c85e <chVTDoTickI.lto_priv.334+0x1a>
    vtp = ch.vtlist.next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800c8ca:	4b17      	ldr	r3, [pc, #92]	; (800c928 <chVTDoTickI.lto_priv.334+0xe4>)
 800c8cc:	69db      	ldr	r3, [r3, #28]
 800c8ce:	4a17      	ldr	r2, [pc, #92]	; (800c92c <chVTDoTickI.lto_priv.334+0xe8>)
 800c8d0:	4293      	cmp	r3, r2
 800c8d2:	d026      	beq.n	800c922 <chVTDoTickI.lto_priv.334+0xde>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 800c8d4:	4b14      	ldr	r3, [pc, #80]	; (800c928 <chVTDoTickI.lto_priv.334+0xe4>)
 800c8d6:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800c8d8:	68fb      	ldr	r3, [r7, #12]
 800c8da:	891b      	ldrh	r3, [r3, #8]
 800c8dc:	4413      	add	r3, r2
 800c8de:	b29a      	uxth	r2, r3
 800c8e0:	897b      	ldrh	r3, [r7, #10]
 800c8e2:	1ad3      	subs	r3, r2, r3
 800c8e4:	813b      	strh	r3, [r7, #8]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800c8e6:	893b      	ldrh	r3, [r7, #8]
 800c8e8:	2b01      	cmp	r3, #1
 800c8ea:	d801      	bhi.n	800c8f0 <chVTDoTickI.lto_priv.334+0xac>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800c8ec:	2302      	movs	r3, #2
 800c8ee:	813b      	strh	r3, [r7, #8]
  }
  port_timer_set_alarm(now + delta);
 800c8f0:	897a      	ldrh	r2, [r7, #10]
 800c8f2:	893b      	ldrh	r3, [r7, #8]
 800c8f4:	4413      	add	r3, r2
 800c8f6:	b29b      	uxth	r3, r3
 800c8f8:	4618      	mov	r0, r3
 800c8fa:	f7ff ff6f 	bl	800c7dc <port_timer_set_alarm>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.lasttime) <=
 800c8fe:	f7ff ff99 	bl	800c834 <chVTGetSystemTimeX>
 800c902:	4603      	mov	r3, r0
 800c904:	461a      	mov	r2, r3
 800c906:	4b08      	ldr	r3, [pc, #32]	; (800c928 <chVTDoTickI.lto_priv.334+0xe4>)
 800c908:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 800c90a:	1ad2      	subs	r2, r2, r3
 800c90c:	8979      	ldrh	r1, [r7, #10]
 800c90e:	893b      	ldrh	r3, [r7, #8]
 800c910:	440b      	add	r3, r1
 800c912:	4905      	ldr	r1, [pc, #20]	; (800c928 <chVTDoTickI.lto_priv.334+0xe4>)
 800c914:	8cc9      	ldrh	r1, [r1, #38]	; 0x26
 800c916:	1a5b      	subs	r3, r3, r1
 800c918:	429a      	cmp	r2, r3
 800c91a:	dd02      	ble.n	800c922 <chVTDoTickI.lto_priv.334+0xde>
 800c91c:	4804      	ldr	r0, [pc, #16]	; (800c930 <chVTDoTickI.lto_priv.334+0xec>)
 800c91e:	f7fe fa6f 	bl	800ae00 <chSysHalt>
              (now + delta - ch.vtlist.lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800c922:	3710      	adds	r7, #16
 800c924:	46bd      	mov	sp, r7
 800c926:	bd80      	pop	{r7, pc}
 800c928:	20001338 	.word	0x20001338
 800c92c:	20001354 	.word	0x20001354
 800c930:	0800e870 	.word	0x0800e870

0800c934 <_idle_thread.lto_priv.47>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 800c934:	b580      	push	{r7, lr}
 800c936:	b082      	sub	sp, #8
 800c938:	af00      	add	r7, sp, #0
 800c93a:	6078      	str	r0, [r7, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 800c93c:	f7ff ff36 	bl	800c7ac <port_wait_for_interrupt>
 800c940:	e7fc      	b.n	800c93c <_idle_thread.lto_priv.47+0x8>
 800c942:	bf00      	nop

0800c944 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 800c944:	b580      	push	{r7, lr}
 800c946:	af00      	add	r7, sp, #0

  _scheduler_init();
 800c948:	f7fe fd44 	bl	800b3d4 <_scheduler_init>
  _vt_init();
 800c94c:	f7fe fb94 	bl	800b078 <_vt_init>
  _trace_init();

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
 800c950:	4b10      	ldr	r3, [pc, #64]	; (800c994 <chSysInit+0x50>)
 800c952:	2200      	movs	r2, #0
 800c954:	62da      	str	r2, [r3, #44]	; 0x2c
  ch.dbg.lock_cnt = (cnt_t)0;
 800c956:	4b0f      	ldr	r3, [pc, #60]	; (800c994 <chSysInit+0x50>)
 800c958:	2200      	movs	r2, #0
 800c95a:	631a      	str	r2, [r3, #48]	; 0x30
#endif
#if CH_CFG_USE_TM == TRUE
  _tm_init();
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 800c95c:	f7fd fa04 	bl	8009d68 <_core_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 800c960:	480d      	ldr	r0, [pc, #52]	; (800c998 <chSysInit+0x54>)
 800c962:	490e      	ldr	r1, [pc, #56]	; (800c99c <chSysInit+0x58>)
 800c964:	2280      	movs	r2, #128	; 0x80
 800c966:	f7ff f865 	bl	800ba34 <_thread_init>
 800c96a:	4602      	mov	r2, r0
 800c96c:	4b09      	ldr	r3, [pc, #36]	; (800c994 <chSysInit+0x50>)
 800c96e:	619a      	str	r2, [r3, #24]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 800c970:	4b08      	ldr	r3, [pc, #32]	; (800c994 <chSysInit+0x50>)
 800c972:	699b      	ldr	r3, [r3, #24]
 800c974:	4a0a      	ldr	r2, [pc, #40]	; (800c9a0 <chSysInit+0x5c>)
 800c976:	61da      	str	r2, [r3, #28]
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 800c978:	4b06      	ldr	r3, [pc, #24]	; (800c994 <chSysInit+0x50>)
 800c97a:	699b      	ldr	r3, [r3, #24]
 800c97c:	2201      	movs	r2, #1
 800c97e:	f883 2020 	strb.w	r2, [r3, #32]

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
 800c982:	f7ff feb5 	bl	800c6f0 <port_init>
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->stats);
#endif

  /* It is alive now.*/
  chSysEnable();
 800c986:	f7ff ff3d 	bl	800c804 <chSysEnable>
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
 800c98a:	4806      	ldr	r0, [pc, #24]	; (800c9a4 <chSysInit+0x60>)
 800c98c:	f7fd fcc0 	bl	800a310 <chThdCreate>
  }
#endif
}
 800c990:	bd80      	pop	{r7, pc}
 800c992:	bf00      	nop
 800c994:	20001338 	.word	0x20001338
 800c998:	2000136c 	.word	0x2000136c
 800c99c:	0800e974 	.word	0x0800e974
 800c9a0:	20000500 	.word	0x20000500
 800c9a4:	0800e858 	.word	0x0800e858

0800c9a8 <_local_ctor_4>:
#include <modules/pubsub/pubsub.h>
#include <modules/worker_thread/worker_thread.h>

WORKER_THREAD_TAKEOVER_MAIN(lpwork_thread, LOWPRIO)
 800c9a8:	b580      	push	{r7, lr}
 800c9aa:	af00      	add	r7, sp, #0
 800c9ac:	4802      	ldr	r0, [pc, #8]	; (800c9b8 <_local_ctor_4+0x10>)
 800c9ae:	4903      	ldr	r1, [pc, #12]	; (800c9bc <_local_ctor_4+0x14>)
 800c9b0:	2202      	movs	r2, #2
 800c9b2:	f7fb ff5b 	bl	800886c <worker_thread_init>
 800c9b6:	bd80      	pop	{r7, pc}
 800c9b8:	20000a20 	.word	0x20000a20
 800c9bc:	0800e6d8 	.word	0x0800e6d8

0800c9c0 <main>:
 800c9c0:	b580      	push	{r7, lr}
 800c9c2:	af00      	add	r7, sp, #0
 800c9c4:	4802      	ldr	r0, [pc, #8]	; (800c9d0 <main+0x10>)
 800c9c6:	f7f9 fff3 	bl	80069b0 <worker_thread_takeover>
 800c9ca:	2300      	movs	r3, #0
 800c9cc:	4618      	mov	r0, r3
 800c9ce:	bd80      	pop	{r7, pc}
 800c9d0:	20000a20 	.word	0x20000a20

0800c9d4 <_local_ctor_5>:
WORKER_THREAD_SPAWN(can_thread, LOWPRIO, 4096)
 800c9d4:	b580      	push	{r7, lr}
 800c9d6:	af00      	add	r7, sp, #0
 800c9d8:	4805      	ldr	r0, [pc, #20]	; (800c9f0 <_local_ctor_5+0x1c>)
 800c9da:	4906      	ldr	r1, [pc, #24]	; (800c9f4 <_local_ctor_5+0x20>)
 800c9dc:	2202      	movs	r2, #2
 800c9de:	f7fb ff45 	bl	800886c <worker_thread_init>
 800c9e2:	4803      	ldr	r0, [pc, #12]	; (800c9f0 <_local_ctor_5+0x1c>)
 800c9e4:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800c9e8:	f7fb ff66 	bl	80088b8 <worker_thread_start>
 800c9ec:	bd80      	pop	{r7, pc}
 800c9ee:	bf00      	nop
 800c9f0:	20000a3c 	.word	0x20000a3c
 800c9f4:	0800e6e8 	.word	0x0800e6e8

0800c9f8 <_local_ctor_7>:

PUBSUB_TOPIC_GROUP_CREATE(default_topic_group, 2048)
 800c9f8:	b580      	push	{r7, lr}
 800c9fa:	af00      	add	r7, sp, #0
 800c9fc:	4803      	ldr	r0, [pc, #12]	; (800ca0c <_local_ctor_7+0x14>)
 800c9fe:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800ca02:	4a03      	ldr	r2, [pc, #12]	; (800ca10 <_local_ctor_7+0x18>)
 800ca04:	f7fb fbfe 	bl	8008204 <pubsub_create_topic_group>
 800ca08:	bd80      	pop	{r7, pc}
 800ca0a:	bf00      	nop
 800ca0c:	20000a58 	.word	0x20000a58
 800ca10:	20000a68 	.word	0x20000a68

0800ca14 <canardInit>:
                void* mem_arena,
                size_t mem_arena_size,
                CanardOnTransferReception on_reception,
                CanardShouldAcceptTransfer should_accept,
                void* user_reference)
{
 800ca14:	b580      	push	{r7, lr}
 800ca16:	b086      	sub	sp, #24
 800ca18:	af00      	add	r7, sp, #0
 800ca1a:	60f8      	str	r0, [r7, #12]
 800ca1c:	60b9      	str	r1, [r7, #8]
 800ca1e:	607a      	str	r2, [r7, #4]
 800ca20:	603b      	str	r3, [r7, #0]
     * If your application fails here, make sure it's not built in 64-bit mode.
     * Refer to the design documentation for more info.
     */
    CANARD_ASSERT(CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE >= 6);

    memset(out_ins, 0, sizeof(*out_ins));
 800ca22:	68f8      	ldr	r0, [r7, #12]
 800ca24:	2100      	movs	r1, #0
 800ca26:	2224      	movs	r2, #36	; 0x24
 800ca28:	f001 fdd0 	bl	800e5cc <memset>

    out_ins->node_id = CANARD_BROADCAST_NODE_ID;
 800ca2c:	68fb      	ldr	r3, [r7, #12]
 800ca2e:	2200      	movs	r2, #0
 800ca30:	701a      	strb	r2, [r3, #0]
    out_ins->on_reception = on_reception;
 800ca32:	68fb      	ldr	r3, [r7, #12]
 800ca34:	683a      	ldr	r2, [r7, #0]
 800ca36:	609a      	str	r2, [r3, #8]
    out_ins->should_accept = should_accept;
 800ca38:	68fb      	ldr	r3, [r7, #12]
 800ca3a:	6a3a      	ldr	r2, [r7, #32]
 800ca3c:	605a      	str	r2, [r3, #4]
    out_ins->rx_states = NULL;
 800ca3e:	68fb      	ldr	r3, [r7, #12]
 800ca40:	2200      	movs	r2, #0
 800ca42:	619a      	str	r2, [r3, #24]
    out_ins->tx_queue = NULL;
 800ca44:	68fb      	ldr	r3, [r7, #12]
 800ca46:	2200      	movs	r2, #0
 800ca48:	61da      	str	r2, [r3, #28]
    out_ins->user_reference = user_reference;
 800ca4a:	68fb      	ldr	r3, [r7, #12]
 800ca4c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800ca4e:	621a      	str	r2, [r3, #32]

    size_t pool_capacity = mem_arena_size / CANARD_MEM_BLOCK_SIZE;
 800ca50:	687b      	ldr	r3, [r7, #4]
 800ca52:	095b      	lsrs	r3, r3, #5
 800ca54:	617b      	str	r3, [r7, #20]
    if (pool_capacity > 0xFFFFU)
 800ca56:	697b      	ldr	r3, [r7, #20]
 800ca58:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800ca5c:	d302      	bcc.n	800ca64 <canardInit+0x50>
    {
        pool_capacity = 0xFFFFU;
 800ca5e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800ca62:	617b      	str	r3, [r7, #20]
    }

    initPoolAllocator(&out_ins->allocator, mem_arena, (uint16_t)pool_capacity);
 800ca64:	68fb      	ldr	r3, [r7, #12]
 800ca66:	f103 020c 	add.w	r2, r3, #12
 800ca6a:	697b      	ldr	r3, [r7, #20]
 800ca6c:	b29b      	uxth	r3, r3
 800ca6e:	4610      	mov	r0, r2
 800ca70:	68b9      	ldr	r1, [r7, #8]
 800ca72:	461a      	mov	r2, r3
 800ca74:	f001 fa66 	bl	800df44 <initPoolAllocator>
}
 800ca78:	3718      	adds	r7, #24
 800ca7a:	46bd      	mov	sp, r7
 800ca7c:	bd80      	pop	{r7, pc}
 800ca7e:	bf00      	nop

0800ca80 <canardGetUserReference>:

void* canardGetUserReference(CanardInstance* ins)
{
 800ca80:	b480      	push	{r7}
 800ca82:	b083      	sub	sp, #12
 800ca84:	af00      	add	r7, sp, #0
 800ca86:	6078      	str	r0, [r7, #4]
    CANARD_ASSERT(ins != NULL);
    return ins->user_reference;
 800ca88:	687b      	ldr	r3, [r7, #4]
 800ca8a:	6a1b      	ldr	r3, [r3, #32]
}
 800ca8c:	4618      	mov	r0, r3
 800ca8e:	370c      	adds	r7, #12
 800ca90:	46bd      	mov	sp, r7
 800ca92:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ca96:	4770      	bx	lr

0800ca98 <canardSetLocalNodeID>:

void canardSetLocalNodeID(CanardInstance* ins, uint8_t self_node_id)
{
 800ca98:	b480      	push	{r7}
 800ca9a:	b083      	sub	sp, #12
 800ca9c:	af00      	add	r7, sp, #0
 800ca9e:	6078      	str	r0, [r7, #4]
 800caa0:	460b      	mov	r3, r1
 800caa2:	70fb      	strb	r3, [r7, #3]
    CANARD_ASSERT(ins != NULL);

    if ((ins->node_id == CANARD_BROADCAST_NODE_ID) &&
 800caa4:	687b      	ldr	r3, [r7, #4]
 800caa6:	781b      	ldrb	r3, [r3, #0]
 800caa8:	2b00      	cmp	r3, #0
 800caaa:	d109      	bne.n	800cac0 <canardSetLocalNodeID+0x28>
 800caac:	78fb      	ldrb	r3, [r7, #3]
 800caae:	2b00      	cmp	r3, #0
 800cab0:	d006      	beq.n	800cac0 <canardSetLocalNodeID+0x28>
        (self_node_id >= CANARD_MIN_NODE_ID) &&
        (self_node_id <= CANARD_MAX_NODE_ID))
 800cab2:	78fb      	ldrb	r3, [r7, #3]
void canardSetLocalNodeID(CanardInstance* ins, uint8_t self_node_id)
{
    CANARD_ASSERT(ins != NULL);

    if ((ins->node_id == CANARD_BROADCAST_NODE_ID) &&
        (self_node_id >= CANARD_MIN_NODE_ID) &&
 800cab4:	b25b      	sxtb	r3, r3
 800cab6:	2b00      	cmp	r3, #0
 800cab8:	db02      	blt.n	800cac0 <canardSetLocalNodeID+0x28>
        (self_node_id <= CANARD_MAX_NODE_ID))
    {
        ins->node_id = self_node_id;
 800caba:	687b      	ldr	r3, [r7, #4]
 800cabc:	78fa      	ldrb	r2, [r7, #3]
 800cabe:	701a      	strb	r2, [r3, #0]
    }
    else
    {
        CANARD_ASSERT(false);
    }
}
 800cac0:	370c      	adds	r7, #12
 800cac2:	46bd      	mov	sp, r7
 800cac4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cac8:	4770      	bx	lr
 800caca:	bf00      	nop

0800cacc <canardGetLocalNodeID>:

uint8_t canardGetLocalNodeID(const CanardInstance* ins)
{
 800cacc:	b480      	push	{r7}
 800cace:	b083      	sub	sp, #12
 800cad0:	af00      	add	r7, sp, #0
 800cad2:	6078      	str	r0, [r7, #4]
    return ins->node_id;
 800cad4:	687b      	ldr	r3, [r7, #4]
 800cad6:	781b      	ldrb	r3, [r3, #0]
}
 800cad8:	4618      	mov	r0, r3
 800cada:	370c      	adds	r7, #12
 800cadc:	46bd      	mov	sp, r7
 800cade:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cae2:	4770      	bx	lr

0800cae4 <canardHandleRxFrame>:
    ins->tx_queue = item->next;
    freeBlock(&ins->allocator, item);
}

void canardHandleRxFrame(CanardInstance* ins, const CanardCANFrame* frame, uint64_t timestamp_usec)
{
 800cae4:	b5b0      	push	{r4, r5, r7, lr}
 800cae6:	b0a0      	sub	sp, #128	; 0x80
 800cae8:	af02      	add	r7, sp, #8
 800caea:	60f8      	str	r0, [r7, #12]
 800caec:	60b9      	str	r1, [r7, #8]
 800caee:	e9c7 2300 	strd	r2, r3, [r7]
    const CanardTransferType transfer_type = extractTransferType(frame->id);
 800caf2:	68bb      	ldr	r3, [r7, #8]
 800caf4:	681b      	ldr	r3, [r3, #0]
 800caf6:	4618      	mov	r0, r3
 800caf8:	f000 fdfe 	bl	800d6f8 <extractTransferType>
 800cafc:	4603      	mov	r3, r0
 800cafe:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
    const uint8_t destination_node_id = (transfer_type == CanardTransferTypeBroadcast) ?
 800cb02:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800cb06:	2b02      	cmp	r3, #2
 800cb08:	d007      	beq.n	800cb1a <canardHandleRxFrame+0x36>
                                        (uint8_t)CANARD_BROADCAST_NODE_ID :
                                        DEST_ID_FROM_ID(frame->id);
 800cb0a:	68bb      	ldr	r3, [r7, #8]
 800cb0c:	681b      	ldr	r3, [r3, #0]
 800cb0e:	0a1b      	lsrs	r3, r3, #8
}

void canardHandleRxFrame(CanardInstance* ins, const CanardCANFrame* frame, uint64_t timestamp_usec)
{
    const CanardTransferType transfer_type = extractTransferType(frame->id);
    const uint8_t destination_node_id = (transfer_type == CanardTransferTypeBroadcast) ?
 800cb10:	b2db      	uxtb	r3, r3
 800cb12:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800cb16:	b2db      	uxtb	r3, r3
 800cb18:	e000      	b.n	800cb1c <canardHandleRxFrame+0x38>
 800cb1a:	2300      	movs	r3, #0
 800cb1c:	f887 305e 	strb.w	r3, [r7, #94]	; 0x5e
                                        (uint8_t)CANARD_BROADCAST_NODE_ID :
                                        DEST_ID_FROM_ID(frame->id);

    // TODO: This function should maintain statistics of transfer errors and such.

    if ((frame->id & CANARD_CAN_FRAME_EFF) == 0 ||
 800cb20:	68bb      	ldr	r3, [r7, #8]
 800cb22:	681b      	ldr	r3, [r3, #0]
 800cb24:	2b00      	cmp	r3, #0
 800cb26:	f280 8308 	bge.w	800d13a <canardHandleRxFrame+0x656>
        (frame->id & CANARD_CAN_FRAME_RTR) != 0 ||
 800cb2a:	68bb      	ldr	r3, [r7, #8]
 800cb2c:	681b      	ldr	r3, [r3, #0]
 800cb2e:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
                                        (uint8_t)CANARD_BROADCAST_NODE_ID :
                                        DEST_ID_FROM_ID(frame->id);

    // TODO: This function should maintain statistics of transfer errors and such.

    if ((frame->id & CANARD_CAN_FRAME_EFF) == 0 ||
 800cb32:	2b00      	cmp	r3, #0
 800cb34:	f040 8301 	bne.w	800d13a <canardHandleRxFrame+0x656>
        (frame->id & CANARD_CAN_FRAME_RTR) != 0 ||
        (frame->id & CANARD_CAN_FRAME_ERR) != 0 ||
 800cb38:	68bb      	ldr	r3, [r7, #8]
 800cb3a:	681b      	ldr	r3, [r3, #0]
 800cb3c:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
                                        DEST_ID_FROM_ID(frame->id);

    // TODO: This function should maintain statistics of transfer errors and such.

    if ((frame->id & CANARD_CAN_FRAME_EFF) == 0 ||
        (frame->id & CANARD_CAN_FRAME_RTR) != 0 ||
 800cb40:	2b00      	cmp	r3, #0
 800cb42:	f040 82fa 	bne.w	800d13a <canardHandleRxFrame+0x656>
        (frame->id & CANARD_CAN_FRAME_ERR) != 0 ||
        (frame->data_len < 1))
 800cb46:	68bb      	ldr	r3, [r7, #8]
 800cb48:	7b1b      	ldrb	r3, [r3, #12]

    // TODO: This function should maintain statistics of transfer errors and such.

    if ((frame->id & CANARD_CAN_FRAME_EFF) == 0 ||
        (frame->id & CANARD_CAN_FRAME_RTR) != 0 ||
        (frame->id & CANARD_CAN_FRAME_ERR) != 0 ||
 800cb4a:	2b00      	cmp	r3, #0
 800cb4c:	f000 82f5 	beq.w	800d13a <canardHandleRxFrame+0x656>
        (frame->data_len < 1))
    {
        return;     // Unsupported frame, not UAVCAN - ignore
    }

    if (transfer_type != CanardTransferTypeBroadcast &&
 800cb50:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800cb54:	2b02      	cmp	r3, #2
 800cb56:	d009      	beq.n	800cb6c <canardHandleRxFrame+0x88>
        destination_node_id != canardGetLocalNodeID(ins))
 800cb58:	68f8      	ldr	r0, [r7, #12]
 800cb5a:	f7ff ffb7 	bl	800cacc <canardGetLocalNodeID>
 800cb5e:	4603      	mov	r3, r0
 800cb60:	461a      	mov	r2, r3
        (frame->data_len < 1))
    {
        return;     // Unsupported frame, not UAVCAN - ignore
    }

    if (transfer_type != CanardTransferTypeBroadcast &&
 800cb62:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
 800cb66:	4293      	cmp	r3, r2
 800cb68:	f040 82e7 	bne.w	800d13a <canardHandleRxFrame+0x656>
        destination_node_id != canardGetLocalNodeID(ins))
    {
        return;     // Address mismatch
    }

    const uint8_t priority = PRIORITY_FROM_ID(frame->id);
 800cb6c:	68bb      	ldr	r3, [r7, #8]
 800cb6e:	681b      	ldr	r3, [r3, #0]
 800cb70:	0e1b      	lsrs	r3, r3, #24
 800cb72:	b2db      	uxtb	r3, r3
 800cb74:	f003 031f 	and.w	r3, r3, #31
 800cb78:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
    const uint8_t source_node_id = SOURCE_ID_FROM_ID(frame->id);
 800cb7c:	68bb      	ldr	r3, [r7, #8]
 800cb7e:	681b      	ldr	r3, [r3, #0]
 800cb80:	b2db      	uxtb	r3, r3
 800cb82:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800cb86:	f887 305c 	strb.w	r3, [r7, #92]	; 0x5c
    const uint16_t data_type_id = extractDataType(frame->id);
 800cb8a:	68bb      	ldr	r3, [r7, #8]
 800cb8c:	681b      	ldr	r3, [r3, #0]
 800cb8e:	4618      	mov	r0, r3
 800cb90:	f000 fd90 	bl	800d6b4 <extractDataType>
 800cb94:	4603      	mov	r3, r0
 800cb96:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
    const uint32_t transfer_descriptor =
            MAKE_TRANSFER_DESCRIPTOR(data_type_id, transfer_type, source_node_id, destination_node_id);
 800cb9a:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 800cb9e:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800cba2:	041b      	lsls	r3, r3, #16
 800cba4:	431a      	orrs	r2, r3
 800cba6:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 800cbaa:	049b      	lsls	r3, r3, #18
 800cbac:	431a      	orrs	r2, r3
 800cbae:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
 800cbb2:	065b      	lsls	r3, r3, #25
    }

    const uint8_t priority = PRIORITY_FROM_ID(frame->id);
    const uint8_t source_node_id = SOURCE_ID_FROM_ID(frame->id);
    const uint16_t data_type_id = extractDataType(frame->id);
    const uint32_t transfer_descriptor =
 800cbb4:	4313      	orrs	r3, r2
 800cbb6:	657b      	str	r3, [r7, #84]	; 0x54
            MAKE_TRANSFER_DESCRIPTOR(data_type_id, transfer_type, source_node_id, destination_node_id);

    const uint8_t tail_byte = frame->data[frame->data_len - 1];
 800cbb8:	68bb      	ldr	r3, [r7, #8]
 800cbba:	7b1b      	ldrb	r3, [r3, #12]
 800cbbc:	3b01      	subs	r3, #1
 800cbbe:	68ba      	ldr	r2, [r7, #8]
 800cbc0:	4413      	add	r3, r2
 800cbc2:	791b      	ldrb	r3, [r3, #4]
 800cbc4:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53

    CanardRxState* rx_state = NULL;
 800cbc8:	2300      	movs	r3, #0
 800cbca:	677b      	str	r3, [r7, #116]	; 0x74

    if (IS_START_OF_TRANSFER(tail_byte))
 800cbcc:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cbd0:	09db      	lsrs	r3, r3, #7
 800cbd2:	b2db      	uxtb	r3, r3
 800cbd4:	f003 0301 	and.w	r3, r3, #1
 800cbd8:	2b00      	cmp	r3, #0
 800cbda:	d02b      	beq.n	800cc34 <canardHandleRxFrame+0x150>
    {
        uint64_t data_type_signature = 0;
 800cbdc:	f04f 0200 	mov.w	r2, #0
 800cbe0:	f04f 0300 	mov.w	r3, #0
 800cbe4:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30

        if (ins->should_accept(ins, &data_type_signature, data_type_id, transfer_type, source_node_id))
 800cbe8:	68fb      	ldr	r3, [r7, #12]
 800cbea:	685c      	ldr	r4, [r3, #4]
 800cbec:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800cbf0:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 800cbf4:	f897 505f 	ldrb.w	r5, [r7, #95]	; 0x5f
 800cbf8:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 800cbfc:	9300      	str	r3, [sp, #0]
 800cbfe:	68f8      	ldr	r0, [r7, #12]
 800cc00:	462b      	mov	r3, r5
 800cc02:	47a0      	blx	r4
 800cc04:	4603      	mov	r3, r0
 800cc06:	2b00      	cmp	r3, #0
 800cc08:	f000 8296 	beq.w	800d138 <canardHandleRxFrame+0x654>
        {
            rx_state = traverseRxStates(ins, transfer_descriptor);
 800cc0c:	68f8      	ldr	r0, [r7, #12]
 800cc0e:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800cc10:	f000 fd96 	bl	800d740 <traverseRxStates>
 800cc14:	6778      	str	r0, [r7, #116]	; 0x74

            if(rx_state == NULL)
 800cc16:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cc18:	2b00      	cmp	r3, #0
 800cc1a:	f000 828d 	beq.w	800d138 <canardHandleRxFrame+0x654>
            {
                return; // No allocator room for this frame
            }

            rx_state->calculated_crc = crcAddSignature(0xFFFFU, data_type_signature);
 800cc1e:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 800cc22:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800cc26:	f001 f93f 	bl	800dea8 <crcAddSignature>
 800cc2a:	4603      	mov	r3, r0
 800cc2c:	461a      	mov	r2, r3
 800cc2e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cc30:	82da      	strh	r2, [r3, #22]
 800cc32:	e00a      	b.n	800cc4a <canardHandleRxFrame+0x166>
            return;     // The application doesn't want this transfer
        }
    }
    else
    {
        rx_state = findRxState(ins->rx_states, transfer_descriptor);
 800cc34:	68fb      	ldr	r3, [r7, #12]
 800cc36:	699b      	ldr	r3, [r3, #24]
 800cc38:	4618      	mov	r0, r3
 800cc3a:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800cc3c:	f000 fdb0 	bl	800d7a0 <findRxState>
 800cc40:	6778      	str	r0, [r7, #116]	; 0x74

        if (rx_state == NULL)
 800cc42:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cc44:	2b00      	cmp	r3, #0
 800cc46:	f000 8278 	beq.w	800d13a <canardHandleRxFrame+0x656>
    }

    CANARD_ASSERT(rx_state != NULL);    // All paths that lead to NULL should be terminated with return above

    // Resolving the state flags:
    const bool not_initialized = rx_state->timestamp_usec == 0;
 800cc4a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cc4c:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800cc50:	4313      	orrs	r3, r2
 800cc52:	2b00      	cmp	r3, #0
 800cc54:	bf0c      	ite	eq
 800cc56:	2301      	moveq	r3, #1
 800cc58:	2300      	movne	r3, #0
 800cc5a:	f887 3052 	strb.w	r3, [r7, #82]	; 0x52
    const bool tid_timed_out = (timestamp_usec - rx_state->timestamp_usec) > TRANSFER_TIMEOUT_USEC;
 800cc5e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cc60:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800cc64:	e9d7 0100 	ldrd	r0, r1, [r7]
 800cc68:	1a82      	subs	r2, r0, r2
 800cc6a:	eb61 0303 	sbc.w	r3, r1, r3
 800cc6e:	48b7      	ldr	r0, [pc, #732]	; (800cf4c <canardHandleRxFrame+0x468>)
 800cc70:	f04f 0100 	mov.w	r1, #0
 800cc74:	4299      	cmp	r1, r3
 800cc76:	bf08      	it	eq
 800cc78:	4290      	cmpeq	r0, r2
 800cc7a:	bf34      	ite	cc
 800cc7c:	2301      	movcc	r3, #1
 800cc7e:	2300      	movcs	r3, #0
 800cc80:	f887 3051 	strb.w	r3, [r7, #81]	; 0x51
    const bool first_frame = IS_START_OF_TRANSFER(tail_byte);
 800cc84:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cc88:	09db      	lsrs	r3, r3, #7
 800cc8a:	b2db      	uxtb	r3, r3
 800cc8c:	f003 0301 	and.w	r3, r3, #1
 800cc90:	2b00      	cmp	r3, #0
 800cc92:	bf14      	ite	ne
 800cc94:	2301      	movne	r3, #1
 800cc96:	2300      	moveq	r3, #0
 800cc98:	f887 3050 	strb.w	r3, [r7, #80]	; 0x50
    const bool not_previous_tid =
        computeTransferIDForwardDistance((uint8_t) rx_state->transfer_id, TRANSFER_ID_FROM_TAIL_BYTE(tail_byte)) > 1;
 800cc9c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cc9e:	7e5b      	ldrb	r3, [r3, #25]
 800cca0:	f3c3 0384 	ubfx	r3, r3, #2, #5
 800cca4:	b2db      	uxtb	r3, r3
 800cca6:	461a      	mov	r2, r3
 800cca8:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800ccac:	f003 031f 	and.w	r3, r3, #31
 800ccb0:	b2db      	uxtb	r3, r3
 800ccb2:	4610      	mov	r0, r2
 800ccb4:	4619      	mov	r1, r3
 800ccb6:	f000 fcc1 	bl	800d63c <computeTransferIDForwardDistance>
 800ccba:	4603      	mov	r3, r0

    // Resolving the state flags:
    const bool not_initialized = rx_state->timestamp_usec == 0;
    const bool tid_timed_out = (timestamp_usec - rx_state->timestamp_usec) > TRANSFER_TIMEOUT_USEC;
    const bool first_frame = IS_START_OF_TRANSFER(tail_byte);
    const bool not_previous_tid =
 800ccbc:	2b01      	cmp	r3, #1
 800ccbe:	bfcc      	ite	gt
 800ccc0:	2301      	movgt	r3, #1
 800ccc2:	2300      	movle	r3, #0
 800ccc4:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
        computeTransferIDForwardDistance((uint8_t) rx_state->transfer_id, TRANSFER_ID_FROM_TAIL_BYTE(tail_byte)) > 1;

    const bool need_restart =
            (not_initialized) ||
            (tid_timed_out) ||
 800ccc8:	f897 3052 	ldrb.w	r3, [r7, #82]	; 0x52
 800cccc:	2b00      	cmp	r3, #0
 800ccce:	d10b      	bne.n	800cce8 <canardHandleRxFrame+0x204>
    const bool first_frame = IS_START_OF_TRANSFER(tail_byte);
    const bool not_previous_tid =
        computeTransferIDForwardDistance((uint8_t) rx_state->transfer_id, TRANSFER_ID_FROM_TAIL_BYTE(tail_byte)) > 1;

    const bool need_restart =
            (not_initialized) ||
 800ccd0:	f897 3051 	ldrb.w	r3, [r7, #81]	; 0x51
 800ccd4:	2b00      	cmp	r3, #0
 800ccd6:	d107      	bne.n	800cce8 <canardHandleRxFrame+0x204>
            (tid_timed_out) ||
 800ccd8:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
 800ccdc:	2b00      	cmp	r3, #0
 800ccde:	d005      	beq.n	800ccec <canardHandleRxFrame+0x208>
            (first_frame && not_previous_tid);
 800cce0:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 800cce4:	2b00      	cmp	r3, #0
 800cce6:	d001      	beq.n	800ccec <canardHandleRxFrame+0x208>
    const bool not_previous_tid =
        computeTransferIDForwardDistance((uint8_t) rx_state->transfer_id, TRANSFER_ID_FROM_TAIL_BYTE(tail_byte)) > 1;

    const bool need_restart =
            (not_initialized) ||
            (tid_timed_out) ||
 800cce8:	2301      	movs	r3, #1
 800ccea:	e000      	b.n	800ccee <canardHandleRxFrame+0x20a>
 800ccec:	2300      	movs	r3, #0
    const bool tid_timed_out = (timestamp_usec - rx_state->timestamp_usec) > TRANSFER_TIMEOUT_USEC;
    const bool first_frame = IS_START_OF_TRANSFER(tail_byte);
    const bool not_previous_tid =
        computeTransferIDForwardDistance((uint8_t) rx_state->transfer_id, TRANSFER_ID_FROM_TAIL_BYTE(tail_byte)) > 1;

    const bool need_restart =
 800ccee:	f887 304e 	strb.w	r3, [r7, #78]	; 0x4e
 800ccf2:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 800ccf6:	f003 0301 	and.w	r3, r3, #1
 800ccfa:	f887 304e 	strb.w	r3, [r7, #78]	; 0x4e
            (not_initialized) ||
            (tid_timed_out) ||
            (first_frame && not_previous_tid);

    if (need_restart)
 800ccfe:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 800cd02:	2b00      	cmp	r3, #0
 800cd04:	d02a      	beq.n	800cd5c <canardHandleRxFrame+0x278>
    {
        rx_state->transfer_id = TRANSFER_ID_FROM_TAIL_BYTE(tail_byte);
 800cd06:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cd0a:	f003 031f 	and.w	r3, r3, #31
 800cd0e:	b2d9      	uxtb	r1, r3
 800cd10:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800cd12:	7e53      	ldrb	r3, [r2, #25]
 800cd14:	f361 0386 	bfi	r3, r1, #2, #5
 800cd18:	7653      	strb	r3, [r2, #25]
        rx_state->next_toggle = 0;
 800cd1a:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800cd1c:	7e53      	ldrb	r3, [r2, #25]
 800cd1e:	f36f 13c7 	bfc	r3, #7, #1
 800cd22:	7653      	strb	r3, [r2, #25]
        releaseStatePayload(ins, rx_state);
 800cd24:	68f8      	ldr	r0, [r7, #12]
 800cd26:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800cd28:	f000 fda8 	bl	800d87c <releaseStatePayload>
        if (!IS_START_OF_TRANSFER(tail_byte)) // missed the first frame
 800cd2c:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cd30:	09db      	lsrs	r3, r3, #7
 800cd32:	b2db      	uxtb	r3, r3
 800cd34:	f003 0301 	and.w	r3, r3, #1
 800cd38:	2b00      	cmp	r3, #0
 800cd3a:	d10f      	bne.n	800cd5c <canardHandleRxFrame+0x278>
        {
            rx_state->transfer_id += 1;
 800cd3c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cd3e:	7e5b      	ldrb	r3, [r3, #25]
 800cd40:	f3c3 0384 	ubfx	r3, r3, #2, #5
 800cd44:	b2db      	uxtb	r3, r3
 800cd46:	3301      	adds	r3, #1
 800cd48:	b2db      	uxtb	r3, r3
 800cd4a:	f003 031f 	and.w	r3, r3, #31
 800cd4e:	b2d9      	uxtb	r1, r3
 800cd50:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800cd52:	7e53      	ldrb	r3, [r2, #25]
 800cd54:	f361 0386 	bfi	r3, r1, #2, #5
 800cd58:	7653      	strb	r3, [r2, #25]
 800cd5a:	e1ee      	b.n	800d13a <canardHandleRxFrame+0x656>
            return;
        }
    }

    if (IS_START_OF_TRANSFER(tail_byte) && IS_END_OF_TRANSFER(tail_byte)) // single frame transfer
 800cd5c:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cd60:	09db      	lsrs	r3, r3, #7
 800cd62:	b2db      	uxtb	r3, r3
 800cd64:	f003 0301 	and.w	r3, r3, #1
 800cd68:	2b00      	cmp	r3, #0
 800cd6a:	d054      	beq.n	800ce16 <canardHandleRxFrame+0x332>
 800cd6c:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cd70:	099b      	lsrs	r3, r3, #6
 800cd72:	b2db      	uxtb	r3, r3
 800cd74:	f003 0301 	and.w	r3, r3, #1
 800cd78:	2b00      	cmp	r3, #0
 800cd7a:	d04c      	beq.n	800ce16 <canardHandleRxFrame+0x332>
    {
        rx_state->timestamp_usec = timestamp_usec;
 800cd7c:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800cd7e:	e9d7 2300 	ldrd	r2, r3, [r7]
 800cd82:	e9c1 2302 	strd	r2, r3, [r1, #8]
        CanardRxTransfer rx_transfer = {
 800cd86:	f107 0310 	add.w	r3, r7, #16
 800cd8a:	2200      	movs	r2, #0
 800cd8c:	601a      	str	r2, [r3, #0]
 800cd8e:	3304      	adds	r3, #4
 800cd90:	2200      	movs	r2, #0
 800cd92:	601a      	str	r2, [r3, #0]
 800cd94:	3304      	adds	r3, #4
 800cd96:	2200      	movs	r2, #0
 800cd98:	601a      	str	r2, [r3, #0]
 800cd9a:	3304      	adds	r3, #4
 800cd9c:	2200      	movs	r2, #0
 800cd9e:	601a      	str	r2, [r3, #0]
 800cda0:	3304      	adds	r3, #4
 800cda2:	2200      	movs	r2, #0
 800cda4:	601a      	str	r2, [r3, #0]
 800cda6:	3304      	adds	r3, #4
 800cda8:	2200      	movs	r2, #0
 800cdaa:	601a      	str	r2, [r3, #0]
 800cdac:	3304      	adds	r3, #4
 800cdae:	2200      	movs	r2, #0
 800cdb0:	601a      	str	r2, [r3, #0]
 800cdb2:	3304      	adds	r3, #4
 800cdb4:	2200      	movs	r2, #0
 800cdb6:	601a      	str	r2, [r3, #0]
 800cdb8:	3304      	adds	r3, #4
 800cdba:	e9d7 2300 	ldrd	r2, r3, [r7]
 800cdbe:	e9c7 2304 	strd	r2, r3, [r7, #16]
            .timestamp_usec = timestamp_usec,
            .payload_head = frame->data,
 800cdc2:	68bb      	ldr	r3, [r7, #8]
 800cdc4:	3304      	adds	r3, #4
    }

    if (IS_START_OF_TRANSFER(tail_byte) && IS_END_OF_TRANSFER(tail_byte)) // single frame transfer
    {
        rx_state->timestamp_usec = timestamp_usec;
        CanardRxTransfer rx_transfer = {
 800cdc6:	61bb      	str	r3, [r7, #24]
            .timestamp_usec = timestamp_usec,
            .payload_head = frame->data,
            .payload_len = (uint8_t)(frame->data_len - 1U),
 800cdc8:	68bb      	ldr	r3, [r7, #8]
 800cdca:	7b1b      	ldrb	r3, [r3, #12]
 800cdcc:	3b01      	subs	r3, #1
 800cdce:	b2db      	uxtb	r3, r3
    }

    if (IS_START_OF_TRANSFER(tail_byte) && IS_END_OF_TRANSFER(tail_byte)) // single frame transfer
    {
        rx_state->timestamp_usec = timestamp_usec;
        CanardRxTransfer rx_transfer = {
 800cdd0:	b29b      	uxth	r3, r3
 800cdd2:	84bb      	strh	r3, [r7, #36]	; 0x24
 800cdd4:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 800cdd8:	84fb      	strh	r3, [r7, #38]	; 0x26
 800cdda:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800cdde:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
            .timestamp_usec = timestamp_usec,
            .payload_head = frame->data,
            .payload_len = (uint8_t)(frame->data_len - 1U),
            .data_type_id = data_type_id,
            .transfer_type = transfer_type,
            .transfer_id = TRANSFER_ID_FROM_TAIL_BYTE(tail_byte),
 800cde2:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cde6:	f003 031f 	and.w	r3, r3, #31
 800cdea:	b2db      	uxtb	r3, r3
    }

    if (IS_START_OF_TRANSFER(tail_byte) && IS_END_OF_TRANSFER(tail_byte)) // single frame transfer
    {
        rx_state->timestamp_usec = timestamp_usec;
        CanardRxTransfer rx_transfer = {
 800cdec:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
 800cdf0:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 800cdf4:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
 800cdf8:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 800cdfc:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
            .transfer_id = TRANSFER_ID_FROM_TAIL_BYTE(tail_byte),
            .priority = priority,
            .source_node_id = source_node_id
        };

        ins->on_reception(ins, &rx_transfer);
 800ce00:	68fb      	ldr	r3, [r7, #12]
 800ce02:	689b      	ldr	r3, [r3, #8]
 800ce04:	f107 0210 	add.w	r2, r7, #16
 800ce08:	68f8      	ldr	r0, [r7, #12]
 800ce0a:	4611      	mov	r1, r2
 800ce0c:	4798      	blx	r3

        prepareForNextTransfer(rx_state);
 800ce0e:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800ce10:	f000 fc2e 	bl	800d670 <prepareForNextTransfer>
 800ce14:	e191      	b.n	800d13a <canardHandleRxFrame+0x656>
        return;
    }

    if (TOGGLE_BIT(tail_byte) != rx_state->next_toggle)
 800ce16:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800ce1a:	095b      	lsrs	r3, r3, #5
 800ce1c:	b2db      	uxtb	r3, r3
 800ce1e:	f003 0301 	and.w	r3, r3, #1
 800ce22:	2b00      	cmp	r3, #0
 800ce24:	bf14      	ite	ne
 800ce26:	2301      	movne	r3, #1
 800ce28:	2300      	moveq	r3, #0
 800ce2a:	b2db      	uxtb	r3, r3
 800ce2c:	461a      	mov	r2, r3
 800ce2e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ce30:	7e5b      	ldrb	r3, [r3, #25]
 800ce32:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800ce36:	b2db      	uxtb	r3, r3
 800ce38:	429a      	cmp	r2, r3
 800ce3a:	f040 817e 	bne.w	800d13a <canardHandleRxFrame+0x656>
    {
        return; // wrong toggle
    }

    if (TRANSFER_ID_FROM_TAIL_BYTE(tail_byte) != rx_state->transfer_id)
 800ce3e:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800ce42:	f003 031f 	and.w	r3, r3, #31
 800ce46:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800ce48:	7e52      	ldrb	r2, [r2, #25]
 800ce4a:	f3c2 0284 	ubfx	r2, r2, #2, #5
 800ce4e:	b2d2      	uxtb	r2, r2
 800ce50:	4293      	cmp	r3, r2
 800ce52:	f040 8172 	bne.w	800d13a <canardHandleRxFrame+0x656>
    {
        return; // unexpected tid
    }

    if (IS_START_OF_TRANSFER(tail_byte) && !IS_END_OF_TRANSFER(tail_byte))      // Beginning of multi frame transfer
 800ce56:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800ce5a:	09db      	lsrs	r3, r3, #7
 800ce5c:	b2db      	uxtb	r3, r3
 800ce5e:	f003 0301 	and.w	r3, r3, #1
 800ce62:	2b00      	cmp	r3, #0
 800ce64:	d048      	beq.n	800cef8 <canardHandleRxFrame+0x414>
 800ce66:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800ce6a:	099b      	lsrs	r3, r3, #6
 800ce6c:	b2db      	uxtb	r3, r3
 800ce6e:	f003 0301 	and.w	r3, r3, #1
 800ce72:	2b00      	cmp	r3, #0
 800ce74:	d140      	bne.n	800cef8 <canardHandleRxFrame+0x414>
    {
        if (frame->data_len <= 3)
 800ce76:	68bb      	ldr	r3, [r7, #8]
 800ce78:	7b1b      	ldrb	r3, [r3, #12]
 800ce7a:	2b03      	cmp	r3, #3
 800ce7c:	f240 815d 	bls.w	800d13a <canardHandleRxFrame+0x656>
        {
            return;     // Not enough data
        }

        // take off the crc and store the payload
        rx_state->timestamp_usec = timestamp_usec;
 800ce80:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800ce82:	e9d7 2300 	ldrd	r2, r3, [r7]
 800ce86:	e9c1 2302 	strd	r2, r3, [r1, #8]
        const int ret = bufferBlockPushBytes(&ins->allocator, rx_state, frame->data + 2,
 800ce8a:	68fb      	ldr	r3, [r7, #12]
 800ce8c:	f103 010c 	add.w	r1, r3, #12
 800ce90:	68bb      	ldr	r3, [r7, #8]
 800ce92:	1d9a      	adds	r2, r3, #6
                                             (uint8_t) (frame->data_len - 3));
 800ce94:	68bb      	ldr	r3, [r7, #8]
 800ce96:	7b1b      	ldrb	r3, [r3, #12]
            return;     // Not enough data
        }

        // take off the crc and store the payload
        rx_state->timestamp_usec = timestamp_usec;
        const int ret = bufferBlockPushBytes(&ins->allocator, rx_state, frame->data + 2,
 800ce98:	3b03      	subs	r3, #3
 800ce9a:	b2db      	uxtb	r3, r3
 800ce9c:	4608      	mov	r0, r1
 800ce9e:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800cea0:	f000 fd14 	bl	800d8cc <bufferBlockPushBytes>
 800cea4:	64b8      	str	r0, [r7, #72]	; 0x48
                                             (uint8_t) (frame->data_len - 3));
        if (ret < 0)
 800cea6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800cea8:	2b00      	cmp	r3, #0
 800ceaa:	da07      	bge.n	800cebc <canardHandleRxFrame+0x3d8>
        {
            releaseStatePayload(ins, rx_state);
 800ceac:	68f8      	ldr	r0, [r7, #12]
 800ceae:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800ceb0:	f000 fce4 	bl	800d87c <releaseStatePayload>
            prepareForNextTransfer(rx_state);
 800ceb4:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800ceb6:	f000 fbdb 	bl	800d670 <prepareForNextTransfer>
 800ceba:	e13e      	b.n	800d13a <canardHandleRxFrame+0x656>
            return;
        }
        rx_state->payload_crc = ((uint16_t) frame->data[0]) | ((uint16_t) frame->data[1] << 8);
 800cebc:	68bb      	ldr	r3, [r7, #8]
 800cebe:	791b      	ldrb	r3, [r3, #4]
 800cec0:	b29a      	uxth	r2, r3
 800cec2:	68bb      	ldr	r3, [r7, #8]
 800cec4:	795b      	ldrb	r3, [r3, #5]
 800cec6:	021b      	lsls	r3, r3, #8
 800cec8:	b29b      	uxth	r3, r3
 800ceca:	4313      	orrs	r3, r2
 800cecc:	b29b      	uxth	r3, r3
 800cece:	b29a      	uxth	r2, r3
 800ced0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ced2:	829a      	strh	r2, [r3, #20]
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc,
 800ced4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ced6:	8ad9      	ldrh	r1, [r3, #22]
 800ced8:	68bb      	ldr	r3, [r7, #8]
 800ceda:	1d9a      	adds	r2, r3, #6
                                          frame->data + 2, (uint8_t)(frame->data_len - 3));
 800cedc:	68bb      	ldr	r3, [r7, #8]
 800cede:	7b1b      	ldrb	r3, [r3, #12]
 800cee0:	3b03      	subs	r3, #3
 800cee2:	b2db      	uxtb	r3, r3
            releaseStatePayload(ins, rx_state);
            prepareForNextTransfer(rx_state);
            return;
        }
        rx_state->payload_crc = ((uint16_t) frame->data[0]) | ((uint16_t) frame->data[1] << 8);
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc,
 800cee4:	4608      	mov	r0, r1
 800cee6:	4611      	mov	r1, r2
 800cee8:	461a      	mov	r2, r3
 800ceea:	f001 f80d 	bl	800df08 <crcAdd>
 800ceee:	4603      	mov	r3, r0
 800cef0:	461a      	mov	r2, r3
 800cef2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cef4:	82da      	strh	r2, [r3, #22]
 800cef6:	e10e      	b.n	800d116 <canardHandleRxFrame+0x632>
                                          frame->data + 2, (uint8_t)(frame->data_len - 3));
    }
    else if (!IS_START_OF_TRANSFER(tail_byte) && !IS_END_OF_TRANSFER(tail_byte))    // Middle of a multi-frame transfer
 800cef8:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cefc:	09db      	lsrs	r3, r3, #7
 800cefe:	b2db      	uxtb	r3, r3
 800cf00:	f003 0301 	and.w	r3, r3, #1
 800cf04:	2b00      	cmp	r3, #0
 800cf06:	d135      	bne.n	800cf74 <canardHandleRxFrame+0x490>
 800cf08:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cf0c:	099b      	lsrs	r3, r3, #6
 800cf0e:	b2db      	uxtb	r3, r3
 800cf10:	f003 0301 	and.w	r3, r3, #1
 800cf14:	2b00      	cmp	r3, #0
 800cf16:	d12d      	bne.n	800cf74 <canardHandleRxFrame+0x490>
    {
        const int ret = bufferBlockPushBytes(&ins->allocator, rx_state, frame->data,
 800cf18:	68fb      	ldr	r3, [r7, #12]
 800cf1a:	f103 010c 	add.w	r1, r3, #12
 800cf1e:	68bb      	ldr	r3, [r7, #8]
 800cf20:	1d1a      	adds	r2, r3, #4
                                             (uint8_t) (frame->data_len - 1));
 800cf22:	68bb      	ldr	r3, [r7, #8]
 800cf24:	7b1b      	ldrb	r3, [r3, #12]
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc,
                                          frame->data + 2, (uint8_t)(frame->data_len - 3));
    }
    else if (!IS_START_OF_TRANSFER(tail_byte) && !IS_END_OF_TRANSFER(tail_byte))    // Middle of a multi-frame transfer
    {
        const int ret = bufferBlockPushBytes(&ins->allocator, rx_state, frame->data,
 800cf26:	3b01      	subs	r3, #1
 800cf28:	b2db      	uxtb	r3, r3
 800cf2a:	4608      	mov	r0, r1
 800cf2c:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800cf2e:	f000 fccd 	bl	800d8cc <bufferBlockPushBytes>
 800cf32:	6478      	str	r0, [r7, #68]	; 0x44
                                             (uint8_t) (frame->data_len - 1));
        if (ret < 0)
 800cf34:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800cf36:	2b00      	cmp	r3, #0
 800cf38:	da0a      	bge.n	800cf50 <canardHandleRxFrame+0x46c>
        {
            releaseStatePayload(ins, rx_state);
 800cf3a:	68f8      	ldr	r0, [r7, #12]
 800cf3c:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800cf3e:	f000 fc9d 	bl	800d87c <releaseStatePayload>
            prepareForNextTransfer(rx_state);
 800cf42:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800cf44:	f000 fb94 	bl	800d670 <prepareForNextTransfer>
 800cf48:	e0f7      	b.n	800d13a <canardHandleRxFrame+0x656>
 800cf4a:	bf00      	nop
 800cf4c:	001e8480 	.word	0x001e8480
            return;
        }
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc,
 800cf50:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cf52:	8ad9      	ldrh	r1, [r3, #22]
                                          frame->data, (uint8_t)(frame->data_len - 1));
 800cf54:	68bb      	ldr	r3, [r7, #8]
 800cf56:	1d1a      	adds	r2, r3, #4
 800cf58:	68bb      	ldr	r3, [r7, #8]
 800cf5a:	7b1b      	ldrb	r3, [r3, #12]
 800cf5c:	3b01      	subs	r3, #1
 800cf5e:	b2db      	uxtb	r3, r3
        {
            releaseStatePayload(ins, rx_state);
            prepareForNextTransfer(rx_state);
            return;
        }
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc,
 800cf60:	4608      	mov	r0, r1
 800cf62:	4611      	mov	r1, r2
 800cf64:	461a      	mov	r2, r3
 800cf66:	f000 ffcf 	bl	800df08 <crcAdd>
 800cf6a:	4603      	mov	r3, r0
 800cf6c:	461a      	mov	r2, r3
 800cf6e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cf70:	82da      	strh	r2, [r3, #22]
 800cf72:	e0d0      	b.n	800d116 <canardHandleRxFrame+0x632>
                                          frame->data, (uint8_t)(frame->data_len - 1));
    }
    else                                                                            // End of a multi-frame transfer
    {
        const uint8_t frame_payload_size = (uint8_t)(frame->data_len - 1);
 800cf74:	68bb      	ldr	r3, [r7, #8]
 800cf76:	7b1b      	ldrb	r3, [r3, #12]
 800cf78:	3b01      	subs	r3, #1
 800cf7a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43

        uint8_t tail_offset = 0;
 800cf7e:	2300      	movs	r3, #0
 800cf80:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73

        if (rx_state->payload_len < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE)
 800cf84:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cf86:	8b1b      	ldrh	r3, [r3, #24]
 800cf88:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800cf8c:	b29b      	uxth	r3, r3
 800cf8e:	2b05      	cmp	r3, #5
 800cf90:	d823      	bhi.n	800cfda <canardHandleRxFrame+0x4f6>
        {
            // Copy the beginning of the frame into the head, point the tail pointer to the remainder
            for (size_t i = rx_state->payload_len;
 800cf92:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cf94:	8b1b      	ldrh	r3, [r3, #24]
 800cf96:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800cf9a:	b29b      	uxth	r3, r3
 800cf9c:	66fb      	str	r3, [r7, #108]	; 0x6c
 800cf9e:	e012      	b.n	800cfc6 <canardHandleRxFrame+0x4e2>
                 (i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) && (tail_offset < frame_payload_size);
                 i++, tail_offset++)
            {
                rx_state->buffer_head[i] = frame->data[tail_offset];
 800cfa0:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800cfa4:	68ba      	ldr	r2, [r7, #8]
 800cfa6:	4413      	add	r3, r2
 800cfa8:	7919      	ldrb	r1, [r3, #4]
 800cfaa:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800cfac:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800cfae:	4413      	add	r3, r2
 800cfb0:	3318      	adds	r3, #24
 800cfb2:	460a      	mov	r2, r1
 800cfb4:	709a      	strb	r2, [r3, #2]
        if (rx_state->payload_len < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE)
        {
            // Copy the beginning of the frame into the head, point the tail pointer to the remainder
            for (size_t i = rx_state->payload_len;
                 (i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) && (tail_offset < frame_payload_size);
                 i++, tail_offset++)
 800cfb6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800cfb8:	3301      	adds	r3, #1
 800cfba:	66fb      	str	r3, [r7, #108]	; 0x6c
 800cfbc:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800cfc0:	3301      	adds	r3, #1
 800cfc2:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
        uint8_t tail_offset = 0;

        if (rx_state->payload_len < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE)
        {
            // Copy the beginning of the frame into the head, point the tail pointer to the remainder
            for (size_t i = rx_state->payload_len;
 800cfc6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800cfc8:	2b05      	cmp	r3, #5
 800cfca:	d840      	bhi.n	800d04e <canardHandleRxFrame+0x56a>
                 (i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) && (tail_offset < frame_payload_size);
 800cfcc:	f897 2073 	ldrb.w	r2, [r7, #115]	; 0x73
 800cfd0:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800cfd4:	429a      	cmp	r2, r3
 800cfd6:	d3e3      	bcc.n	800cfa0 <canardHandleRxFrame+0x4bc>
 800cfd8:	e039      	b.n	800d04e <canardHandleRxFrame+0x56a>
            }
        }
        else
        {
            // Like above, except that the beginning goes into the last block of the storage
            CanardBufferBlock* block = rx_state->buffer_blocks;
 800cfda:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cfdc:	685b      	ldr	r3, [r3, #4]
 800cfde:	66bb      	str	r3, [r7, #104]	; 0x68
            if (block != NULL)          // If there's no middle, that's fine, we'll use only head and tail
 800cfe0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800cfe2:	2b00      	cmp	r3, #0
 800cfe4:	d033      	beq.n	800d04e <canardHandleRxFrame+0x56a>
            {
                size_t offset = CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE;    // Payload offset of the first block
 800cfe6:	2306      	movs	r3, #6
 800cfe8:	667b      	str	r3, [r7, #100]	; 0x64
 800cfea:	e005      	b.n	800cff8 <canardHandleRxFrame+0x514>
                while (block->next != NULL)
                {
                    block = block->next;
 800cfec:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800cfee:	681b      	ldr	r3, [r3, #0]
 800cff0:	66bb      	str	r3, [r7, #104]	; 0x68
                    offset += CANARD_BUFFER_BLOCK_DATA_SIZE;
 800cff2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800cff4:	331c      	adds	r3, #28
 800cff6:	667b      	str	r3, [r7, #100]	; 0x64
            // Like above, except that the beginning goes into the last block of the storage
            CanardBufferBlock* block = rx_state->buffer_blocks;
            if (block != NULL)          // If there's no middle, that's fine, we'll use only head and tail
            {
                size_t offset = CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE;    // Payload offset of the first block
                while (block->next != NULL)
 800cff8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800cffa:	681b      	ldr	r3, [r3, #0]
 800cffc:	2b00      	cmp	r3, #0
 800cffe:	d1f5      	bne.n	800cfec <canardHandleRxFrame+0x508>
                    block = block->next;
                    offset += CANARD_BUFFER_BLOCK_DATA_SIZE;
                }
                CANARD_ASSERT(block != NULL);

                const size_t offset_within_block = rx_state->payload_len - offset;
 800d000:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d002:	8b1b      	ldrh	r3, [r3, #24]
 800d004:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d008:	b29b      	uxth	r3, r3
 800d00a:	461a      	mov	r2, r3
 800d00c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d00e:	1ad3      	subs	r3, r2, r3
 800d010:	63fb      	str	r3, [r7, #60]	; 0x3c
                CANARD_ASSERT(offset_within_block < CANARD_BUFFER_BLOCK_DATA_SIZE);

                for (size_t i = offset_within_block;
 800d012:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d014:	663b      	str	r3, [r7, #96]	; 0x60
 800d016:	e011      	b.n	800d03c <canardHandleRxFrame+0x558>
                     (i < CANARD_BUFFER_BLOCK_DATA_SIZE) && (tail_offset < frame_payload_size);
                     i++, tail_offset++)
                {
                    block->data[i] = frame->data[tail_offset];
 800d018:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800d01c:	68ba      	ldr	r2, [r7, #8]
 800d01e:	4413      	add	r3, r2
 800d020:	7919      	ldrb	r1, [r3, #4]
 800d022:	6eba      	ldr	r2, [r7, #104]	; 0x68
 800d024:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d026:	4413      	add	r3, r2
 800d028:	460a      	mov	r2, r1
 800d02a:	711a      	strb	r2, [r3, #4]
                const size_t offset_within_block = rx_state->payload_len - offset;
                CANARD_ASSERT(offset_within_block < CANARD_BUFFER_BLOCK_DATA_SIZE);

                for (size_t i = offset_within_block;
                     (i < CANARD_BUFFER_BLOCK_DATA_SIZE) && (tail_offset < frame_payload_size);
                     i++, tail_offset++)
 800d02c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d02e:	3301      	adds	r3, #1
 800d030:	663b      	str	r3, [r7, #96]	; 0x60
 800d032:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800d036:	3301      	adds	r3, #1
 800d038:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
                CANARD_ASSERT(block != NULL);

                const size_t offset_within_block = rx_state->payload_len - offset;
                CANARD_ASSERT(offset_within_block < CANARD_BUFFER_BLOCK_DATA_SIZE);

                for (size_t i = offset_within_block;
 800d03c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d03e:	2b1b      	cmp	r3, #27
 800d040:	d805      	bhi.n	800d04e <canardHandleRxFrame+0x56a>
                     (i < CANARD_BUFFER_BLOCK_DATA_SIZE) && (tail_offset < frame_payload_size);
 800d042:	f897 2073 	ldrb.w	r2, [r7, #115]	; 0x73
 800d046:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800d04a:	429a      	cmp	r2, r3
 800d04c:	d3e4      	bcc.n	800d018 <canardHandleRxFrame+0x534>
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
 800d04e:	e9d7 2300 	ldrd	r2, r3, [r7]
 800d052:	e9c7 2304 	strd	r2, r3, [r7, #16]
            .timestamp_usec = timestamp_usec,
            .payload_head = rx_state->buffer_head,
 800d056:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d058:	331a      	adds	r3, #26
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
 800d05a:	61bb      	str	r3, [r7, #24]
            .timestamp_usec = timestamp_usec,
            .payload_head = rx_state->buffer_head,
            .payload_middle = rx_state->buffer_blocks,
 800d05c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d05e:	685b      	ldr	r3, [r3, #4]
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
 800d060:	61fb      	str	r3, [r7, #28]
            .timestamp_usec = timestamp_usec,
            .payload_head = rx_state->buffer_head,
            .payload_middle = rx_state->buffer_blocks,
            .payload_tail = (tail_offset >= frame_payload_size) ? NULL : (&frame->data[tail_offset]),
 800d062:	f897 2073 	ldrb.w	r2, [r7, #115]	; 0x73
 800d066:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800d06a:	429a      	cmp	r2, r3
 800d06c:	d205      	bcs.n	800d07a <canardHandleRxFrame+0x596>
 800d06e:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800d072:	68ba      	ldr	r2, [r7, #8]
 800d074:	4413      	add	r3, r2
 800d076:	3304      	adds	r3, #4
 800d078:	e000      	b.n	800d07c <canardHandleRxFrame+0x598>
 800d07a:	2300      	movs	r3, #0
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
 800d07c:	623b      	str	r3, [r7, #32]
            .timestamp_usec = timestamp_usec,
            .payload_head = rx_state->buffer_head,
            .payload_middle = rx_state->buffer_blocks,
            .payload_tail = (tail_offset >= frame_payload_size) ? NULL : (&frame->data[tail_offset]),
            .payload_len = (uint16_t)(rx_state->payload_len + frame_payload_size),
 800d07e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d080:	8b1b      	ldrh	r3, [r3, #24]
 800d082:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d086:	b29b      	uxth	r3, r3
 800d088:	461a      	mov	r2, r3
 800d08a:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800d08e:	b29b      	uxth	r3, r3
 800d090:	4413      	add	r3, r2
 800d092:	b29b      	uxth	r3, r3
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
 800d094:	84bb      	strh	r3, [r7, #36]	; 0x24
 800d096:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 800d09a:	84fb      	strh	r3, [r7, #38]	; 0x26
 800d09c:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800d0a0:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
            .payload_middle = rx_state->buffer_blocks,
            .payload_tail = (tail_offset >= frame_payload_size) ? NULL : (&frame->data[tail_offset]),
            .payload_len = (uint16_t)(rx_state->payload_len + frame_payload_size),
            .data_type_id = data_type_id,
            .transfer_type = transfer_type,
            .transfer_id = TRANSFER_ID_FROM_TAIL_BYTE(tail_byte),
 800d0a4:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800d0a8:	f003 031f 	and.w	r3, r3, #31
 800d0ac:	b2db      	uxtb	r3, r3
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
 800d0ae:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
 800d0b2:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 800d0b6:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
 800d0ba:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 800d0be:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
            .transfer_id = TRANSFER_ID_FROM_TAIL_BYTE(tail_byte),
            .priority = priority,
            .source_node_id = source_node_id
        };

        rx_state->buffer_blocks = NULL;     // Block list ownership has been transferred to rx_transfer!
 800d0c2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d0c4:	2200      	movs	r2, #0
 800d0c6:	605a      	str	r2, [r3, #4]

        // CRC validation
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc, frame->data, frame->data_len - 1U);
 800d0c8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d0ca:	8ad9      	ldrh	r1, [r3, #22]
 800d0cc:	68bb      	ldr	r3, [r7, #8]
 800d0ce:	1d1a      	adds	r2, r3, #4
 800d0d0:	68bb      	ldr	r3, [r7, #8]
 800d0d2:	7b1b      	ldrb	r3, [r3, #12]
 800d0d4:	3b01      	subs	r3, #1
 800d0d6:	4608      	mov	r0, r1
 800d0d8:	4611      	mov	r1, r2
 800d0da:	461a      	mov	r2, r3
 800d0dc:	f000 ff14 	bl	800df08 <crcAdd>
 800d0e0:	4603      	mov	r3, r0
 800d0e2:	461a      	mov	r2, r3
 800d0e4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d0e6:	82da      	strh	r2, [r3, #22]
        if (rx_state->calculated_crc == rx_state->payload_crc)
 800d0e8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d0ea:	8ada      	ldrh	r2, [r3, #22]
 800d0ec:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d0ee:	8a9b      	ldrh	r3, [r3, #20]
 800d0f0:	429a      	cmp	r2, r3
 800d0f2:	d106      	bne.n	800d102 <canardHandleRxFrame+0x61e>
        {
            ins->on_reception(ins, &rx_transfer);
 800d0f4:	68fb      	ldr	r3, [r7, #12]
 800d0f6:	689b      	ldr	r3, [r3, #8]
 800d0f8:	f107 0210 	add.w	r2, r7, #16
 800d0fc:	68f8      	ldr	r0, [r7, #12]
 800d0fe:	4611      	mov	r1, r2
 800d100:	4798      	blx	r3
        }

        // Making sure the payload is released even if the application didn't bother with it
        canardReleaseRxTransferPayload(ins, &rx_transfer);
 800d102:	f107 0310 	add.w	r3, r7, #16
 800d106:	68f8      	ldr	r0, [r7, #12]
 800d108:	4619      	mov	r1, r3
 800d10a:	f000 fa6d 	bl	800d5e8 <canardReleaseRxTransferPayload>
        prepareForNextTransfer(rx_state);
 800d10e:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800d110:	f000 faae 	bl	800d670 <prepareForNextTransfer>
 800d114:	e011      	b.n	800d13a <canardHandleRxFrame+0x656>
        return;
    }

    rx_state->next_toggle ^= 1;
 800d116:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d118:	7e5b      	ldrb	r3, [r3, #25]
 800d11a:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800d11e:	b2db      	uxtb	r3, r3
 800d120:	f083 0301 	eor.w	r3, r3, #1
 800d124:	b2db      	uxtb	r3, r3
 800d126:	f003 0301 	and.w	r3, r3, #1
 800d12a:	b2d9      	uxtb	r1, r3
 800d12c:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800d12e:	7e53      	ldrb	r3, [r2, #25]
 800d130:	f361 13c7 	bfi	r3, r1, #7, #1
 800d134:	7653      	strb	r3, [r2, #25]
 800d136:	e000      	b.n	800d13a <canardHandleRxFrame+0x656>
        {
            rx_state = traverseRxStates(ins, transfer_descriptor);

            if(rx_state == NULL)
            {
                return; // No allocator room for this frame
 800d138:	bf00      	nop
        prepareForNextTransfer(rx_state);
        return;
    }

    rx_state->next_toggle ^= 1;
}
 800d13a:	3778      	adds	r7, #120	; 0x78
 800d13c:	46bd      	mov	sp, r7
 800d13e:	bdb0      	pop	{r4, r5, r7, pc}

0800d140 <canardCleanupStaleTransfers>:

void canardCleanupStaleTransfers(CanardInstance* ins, uint64_t current_time_usec)
{
 800d140:	b580      	push	{r7, lr}
 800d142:	b086      	sub	sp, #24
 800d144:	af00      	add	r7, sp, #0
 800d146:	60f8      	str	r0, [r7, #12]
 800d148:	e9c7 2300 	strd	r2, r3, [r7]
    CanardRxState* prev = ins->rx_states, * state = ins->rx_states;
 800d14c:	68fb      	ldr	r3, [r7, #12]
 800d14e:	699b      	ldr	r3, [r3, #24]
 800d150:	617b      	str	r3, [r7, #20]
 800d152:	68fb      	ldr	r3, [r7, #12]
 800d154:	699b      	ldr	r3, [r3, #24]
 800d156:	613b      	str	r3, [r7, #16]
 800d158:	e03f      	b.n	800d1da <canardCleanupStaleTransfers+0x9a>

    while (state != NULL)
    {
        if ((current_time_usec - state->timestamp_usec) > TRANSFER_TIMEOUT_USEC)
 800d15a:	693b      	ldr	r3, [r7, #16]
 800d15c:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800d160:	e9d7 0100 	ldrd	r0, r1, [r7]
 800d164:	1a82      	subs	r2, r0, r2
 800d166:	eb61 0303 	sbc.w	r3, r1, r3
 800d16a:	481f      	ldr	r0, [pc, #124]	; (800d1e8 <canardCleanupStaleTransfers+0xa8>)
 800d16c:	f04f 0100 	mov.w	r1, #0
 800d170:	4299      	cmp	r1, r3
 800d172:	bf08      	it	eq
 800d174:	4290      	cmpeq	r0, r2
 800d176:	d22b      	bcs.n	800d1d0 <canardCleanupStaleTransfers+0x90>
        {
            if (state == ins->rx_states)
 800d178:	68fb      	ldr	r3, [r7, #12]
 800d17a:	699a      	ldr	r2, [r3, #24]
 800d17c:	693b      	ldr	r3, [r7, #16]
 800d17e:	429a      	cmp	r2, r3
 800d180:	d114      	bne.n	800d1ac <canardCleanupStaleTransfers+0x6c>
            {
                releaseStatePayload(ins, state);
 800d182:	68f8      	ldr	r0, [r7, #12]
 800d184:	6939      	ldr	r1, [r7, #16]
 800d186:	f000 fb79 	bl	800d87c <releaseStatePayload>
                ins->rx_states = ins->rx_states->next;
 800d18a:	68fb      	ldr	r3, [r7, #12]
 800d18c:	699b      	ldr	r3, [r3, #24]
 800d18e:	681a      	ldr	r2, [r3, #0]
 800d190:	68fb      	ldr	r3, [r7, #12]
 800d192:	619a      	str	r2, [r3, #24]
                freeBlock(&ins->allocator, state);
 800d194:	68fb      	ldr	r3, [r7, #12]
 800d196:	330c      	adds	r3, #12
 800d198:	4618      	mov	r0, r3
 800d19a:	6939      	ldr	r1, [r7, #16]
 800d19c:	f000 ff2a 	bl	800dff4 <freeBlock>
                state = ins->rx_states;
 800d1a0:	68fb      	ldr	r3, [r7, #12]
 800d1a2:	699b      	ldr	r3, [r3, #24]
 800d1a4:	613b      	str	r3, [r7, #16]
                prev = state;
 800d1a6:	693b      	ldr	r3, [r7, #16]
 800d1a8:	617b      	str	r3, [r7, #20]
            else
            {
                releaseStatePayload(ins, state);
                prev->next = state->next;
                freeBlock(&ins->allocator, state);
                state = prev->next;
 800d1aa:	e016      	b.n	800d1da <canardCleanupStaleTransfers+0x9a>
                state = ins->rx_states;
                prev = state;
            }
            else
            {
                releaseStatePayload(ins, state);
 800d1ac:	68f8      	ldr	r0, [r7, #12]
 800d1ae:	6939      	ldr	r1, [r7, #16]
 800d1b0:	f000 fb64 	bl	800d87c <releaseStatePayload>
                prev->next = state->next;
 800d1b4:	693b      	ldr	r3, [r7, #16]
 800d1b6:	681a      	ldr	r2, [r3, #0]
 800d1b8:	697b      	ldr	r3, [r7, #20]
 800d1ba:	601a      	str	r2, [r3, #0]
                freeBlock(&ins->allocator, state);
 800d1bc:	68fb      	ldr	r3, [r7, #12]
 800d1be:	330c      	adds	r3, #12
 800d1c0:	4618      	mov	r0, r3
 800d1c2:	6939      	ldr	r1, [r7, #16]
 800d1c4:	f000 ff16 	bl	800dff4 <freeBlock>
                state = prev->next;
 800d1c8:	697b      	ldr	r3, [r7, #20]
 800d1ca:	681b      	ldr	r3, [r3, #0]
 800d1cc:	613b      	str	r3, [r7, #16]
 800d1ce:	e004      	b.n	800d1da <canardCleanupStaleTransfers+0x9a>
            }
        }
        else
        {
            prev = state;
 800d1d0:	693b      	ldr	r3, [r7, #16]
 800d1d2:	617b      	str	r3, [r7, #20]
            state = state->next;
 800d1d4:	693b      	ldr	r3, [r7, #16]
 800d1d6:	681b      	ldr	r3, [r3, #0]
 800d1d8:	613b      	str	r3, [r7, #16]

void canardCleanupStaleTransfers(CanardInstance* ins, uint64_t current_time_usec)
{
    CanardRxState* prev = ins->rx_states, * state = ins->rx_states;

    while (state != NULL)
 800d1da:	693b      	ldr	r3, [r7, #16]
 800d1dc:	2b00      	cmp	r3, #0
 800d1de:	d1bc      	bne.n	800d15a <canardCleanupStaleTransfers+0x1a>
        {
            prev = state;
            state = state->next;
        }
    }
}
 800d1e0:	3718      	adds	r7, #24
 800d1e2:	46bd      	mov	sp, r7
 800d1e4:	bd80      	pop	{r7, pc}
 800d1e6:	bf00      	nop
 800d1e8:	001e8480 	.word	0x001e8480

0800d1ec <canardDecodeScalar>:
int canardDecodeScalar(const CanardRxTransfer* transfer,
                       uint32_t bit_offset,
                       uint8_t bit_length,
                       bool value_is_signed,
                       void* out_value)
{
 800d1ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800d1f0:	b089      	sub	sp, #36	; 0x24
 800d1f2:	af00      	add	r7, sp, #0
 800d1f4:	60f8      	str	r0, [r7, #12]
 800d1f6:	60b9      	str	r1, [r7, #8]
 800d1f8:	4611      	mov	r1, r2
 800d1fa:	461a      	mov	r2, r3
 800d1fc:	460b      	mov	r3, r1
 800d1fe:	71fb      	strb	r3, [r7, #7]
 800d200:	4613      	mov	r3, r2
 800d202:	71bb      	strb	r3, [r7, #6]
    if (transfer == NULL || out_value == NULL)
 800d204:	68fb      	ldr	r3, [r7, #12]
 800d206:	2b00      	cmp	r3, #0
 800d208:	d002      	beq.n	800d210 <canardDecodeScalar+0x24>
 800d20a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d20c:	2b00      	cmp	r3, #0
 800d20e:	d102      	bne.n	800d216 <canardDecodeScalar+0x2a>
    {
        return -CANARD_ERROR_INVALID_ARGUMENT;
 800d210:	f06f 0301 	mvn.w	r3, #1
 800d214:	e15d      	b.n	800d4d2 <canardDecodeScalar+0x2e6>
    }

    if (bit_length < 1 || bit_length > 64)
 800d216:	79fb      	ldrb	r3, [r7, #7]
 800d218:	2b00      	cmp	r3, #0
 800d21a:	d002      	beq.n	800d222 <canardDecodeScalar+0x36>
 800d21c:	79fb      	ldrb	r3, [r7, #7]
 800d21e:	2b40      	cmp	r3, #64	; 0x40
 800d220:	d902      	bls.n	800d228 <canardDecodeScalar+0x3c>
    {
        return -CANARD_ERROR_INVALID_ARGUMENT;
 800d222:	f06f 0301 	mvn.w	r3, #1
 800d226:	e154      	b.n	800d4d2 <canardDecodeScalar+0x2e6>
    }

    if (bit_length == 1 && value_is_signed)
 800d228:	79fb      	ldrb	r3, [r7, #7]
 800d22a:	2b01      	cmp	r3, #1
 800d22c:	d105      	bne.n	800d23a <canardDecodeScalar+0x4e>
 800d22e:	79bb      	ldrb	r3, [r7, #6]
 800d230:	2b00      	cmp	r3, #0
 800d232:	d002      	beq.n	800d23a <canardDecodeScalar+0x4e>
    {
        return -CANARD_ERROR_INVALID_ARGUMENT;
 800d234:	f06f 0301 	mvn.w	r3, #1
 800d238:	e14b      	b.n	800d4d2 <canardDecodeScalar+0x2e6>
        uint64_t u64;
        int64_t  s64;           ///< Also double, possibly float, possibly long double (depends on implementation)
        uint8_t bytes[8];
    } storage;

    memset(&storage, 0, sizeof(storage));   // This is important
 800d23a:	f107 0310 	add.w	r3, r7, #16
 800d23e:	4618      	mov	r0, r3
 800d240:	2100      	movs	r1, #0
 800d242:	2208      	movs	r2, #8
 800d244:	f001 f9c2 	bl	800e5cc <memset>

    const int result = descatterTransferPayload(transfer, bit_offset, bit_length, &storage.bytes[0]);
 800d248:	79fa      	ldrb	r2, [r7, #7]
 800d24a:	f107 0310 	add.w	r3, r7, #16
 800d24e:	68f8      	ldr	r0, [r7, #12]
 800d250:	68b9      	ldr	r1, [r7, #8]
 800d252:	f000 fcc9 	bl	800dbe8 <descatterTransferPayload>
 800d256:	61b8      	str	r0, [r7, #24]
    if (result <= 0)
 800d258:	69bb      	ldr	r3, [r7, #24]
 800d25a:	2b00      	cmp	r3, #0
 800d25c:	dc01      	bgt.n	800d262 <canardDecodeScalar+0x76>
    {
        return result;
 800d25e:	69bb      	ldr	r3, [r7, #24]
 800d260:	e137      	b.n	800d4d2 <canardDecodeScalar+0x2e6>
     * The bit copy algorithm assumes that more significant bits have lower index, so we need to shift some.
     * Extra most significant bits will be filled with zeroes, which is fine.
     * Coverity Scan mistakenly believes that the array may be overrun if bit_length == 64; however, this branch will
     * not be taken if bit_length == 64, because 64 % 8 == 0.
     */
    if ((bit_length % 8) != 0)
 800d262:	79fb      	ldrb	r3, [r7, #7]
 800d264:	f003 0307 	and.w	r3, r3, #7
 800d268:	b2db      	uxtb	r3, r3
 800d26a:	2b00      	cmp	r3, #0
 800d26c:	d018      	beq.n	800d2a0 <canardDecodeScalar+0xb4>
    {
        // coverity[overrun-local]
        storage.bytes[bit_length / 8] = (uint8_t)(storage.bytes[bit_length / 8] >> ((8 - (bit_length % 8)) & 7));
 800d26e:	79fb      	ldrb	r3, [r7, #7]
 800d270:	08db      	lsrs	r3, r3, #3
 800d272:	b2db      	uxtb	r3, r3
 800d274:	4619      	mov	r1, r3
 800d276:	79fb      	ldrb	r3, [r7, #7]
 800d278:	08db      	lsrs	r3, r3, #3
 800d27a:	b2db      	uxtb	r3, r3
 800d27c:	f107 0220 	add.w	r2, r7, #32
 800d280:	4413      	add	r3, r2
 800d282:	f813 3c10 	ldrb.w	r3, [r3, #-16]
 800d286:	461a      	mov	r2, r3
 800d288:	79fb      	ldrb	r3, [r7, #7]
 800d28a:	425b      	negs	r3, r3
 800d28c:	f003 0307 	and.w	r3, r3, #7
 800d290:	fa42 f303 	asr.w	r3, r2, r3
 800d294:	b2da      	uxtb	r2, r3
 800d296:	f107 0320 	add.w	r3, r7, #32
 800d29a:	440b      	add	r3, r1
 800d29c:	f803 2c10 	strb.w	r2, [r3, #-16]
    }

    /*
     * Determining the closest standard byte length - this will be needed for byte reordering and sign bit extension.
     */
    uint8_t std_byte_length = 0;
 800d2a0:	2300      	movs	r3, #0
 800d2a2:	77fb      	strb	r3, [r7, #31]
    if      (bit_length == 1)   { std_byte_length = sizeof(bool); }
 800d2a4:	79fb      	ldrb	r3, [r7, #7]
 800d2a6:	2b01      	cmp	r3, #1
 800d2a8:	d102      	bne.n	800d2b0 <canardDecodeScalar+0xc4>
 800d2aa:	2301      	movs	r3, #1
 800d2ac:	77fb      	strb	r3, [r7, #31]
 800d2ae:	e01a      	b.n	800d2e6 <canardDecodeScalar+0xfa>
    else if (bit_length <= 8)   { std_byte_length = 1; }
 800d2b0:	79fb      	ldrb	r3, [r7, #7]
 800d2b2:	2b08      	cmp	r3, #8
 800d2b4:	d802      	bhi.n	800d2bc <canardDecodeScalar+0xd0>
 800d2b6:	2301      	movs	r3, #1
 800d2b8:	77fb      	strb	r3, [r7, #31]
 800d2ba:	e014      	b.n	800d2e6 <canardDecodeScalar+0xfa>
    else if (bit_length <= 16)  { std_byte_length = 2; }
 800d2bc:	79fb      	ldrb	r3, [r7, #7]
 800d2be:	2b10      	cmp	r3, #16
 800d2c0:	d802      	bhi.n	800d2c8 <canardDecodeScalar+0xdc>
 800d2c2:	2302      	movs	r3, #2
 800d2c4:	77fb      	strb	r3, [r7, #31]
 800d2c6:	e00e      	b.n	800d2e6 <canardDecodeScalar+0xfa>
    else if (bit_length <= 32)  { std_byte_length = 4; }
 800d2c8:	79fb      	ldrb	r3, [r7, #7]
 800d2ca:	2b20      	cmp	r3, #32
 800d2cc:	d802      	bhi.n	800d2d4 <canardDecodeScalar+0xe8>
 800d2ce:	2304      	movs	r3, #4
 800d2d0:	77fb      	strb	r3, [r7, #31]
 800d2d2:	e008      	b.n	800d2e6 <canardDecodeScalar+0xfa>
    else if (bit_length <= 64)  { std_byte_length = 8; }
 800d2d4:	79fb      	ldrb	r3, [r7, #7]
 800d2d6:	2b40      	cmp	r3, #64	; 0x40
 800d2d8:	d802      	bhi.n	800d2e0 <canardDecodeScalar+0xf4>
 800d2da:	2308      	movs	r3, #8
 800d2dc:	77fb      	strb	r3, [r7, #31]
 800d2de:	e002      	b.n	800d2e6 <canardDecodeScalar+0xfa>
    else
    {
        CANARD_ASSERT(false);
        return -CANARD_ERROR_INTERNAL;
 800d2e0:	f06f 0308 	mvn.w	r3, #8
 800d2e4:	e0f5      	b.n	800d4d2 <canardDecodeScalar+0x2e6>
    CANARD_ASSERT((std_byte_length > 0) && (std_byte_length <= 8));

    /*
     * Flipping the byte order if needed.
     */
    if (isBigEndian())
 800d2e6:	f000 fd6f 	bl	800ddc8 <isBigEndian>
 800d2ea:	4603      	mov	r3, r0
 800d2ec:	2b00      	cmp	r3, #0
 800d2ee:	d006      	beq.n	800d2fe <canardDecodeScalar+0x112>
    {
        swapByteOrder(&storage.bytes[0], std_byte_length);
 800d2f0:	7ffb      	ldrb	r3, [r7, #31]
 800d2f2:	f107 0210 	add.w	r2, r7, #16
 800d2f6:	4610      	mov	r0, r2
 800d2f8:	4619      	mov	r1, r3
 800d2fa:	f000 fd77 	bl	800ddec <swapByteOrder>
    }

    /*
     * Extending the sign bit if needed. I miss templates.
     */
    if (value_is_signed && (std_byte_length * 8 != bit_length))
 800d2fe:	79bb      	ldrb	r3, [r7, #6]
 800d300:	2b00      	cmp	r3, #0
 800d302:	f000 8099 	beq.w	800d438 <canardDecodeScalar+0x24c>
 800d306:	7ffb      	ldrb	r3, [r7, #31]
 800d308:	00da      	lsls	r2, r3, #3
 800d30a:	79fb      	ldrb	r3, [r7, #7]
 800d30c:	429a      	cmp	r2, r3
 800d30e:	f000 8093 	beq.w	800d438 <canardDecodeScalar+0x24c>
    {
        if (bit_length <= 8)
 800d312:	79fb      	ldrb	r3, [r7, #7]
 800d314:	2b08      	cmp	r3, #8
 800d316:	d818      	bhi.n	800d34a <canardDecodeScalar+0x15e>
        {
            if ((storage.s8 & (1U << (bit_length - 1))) != 0)                           // If the sign bit is set...
 800d318:	7c3b      	ldrb	r3, [r7, #16]
 800d31a:	b25a      	sxtb	r2, r3
 800d31c:	79fb      	ldrb	r3, [r7, #7]
 800d31e:	3b01      	subs	r3, #1
 800d320:	fa22 f303 	lsr.w	r3, r2, r3
 800d324:	f003 0301 	and.w	r3, r3, #1
 800d328:	2b00      	cmp	r3, #0
 800d32a:	f000 8085 	beq.w	800d438 <canardDecodeScalar+0x24c>
            {
                storage.s8 |= (uint8_t) 0xFFU & (uint8_t) ~((1U << bit_length) - 1U);   // ...set all bits above it.
 800d32e:	7c39      	ldrb	r1, [r7, #16]
 800d330:	79fb      	ldrb	r3, [r7, #7]
 800d332:	2201      	movs	r2, #1
 800d334:	fa02 f303 	lsl.w	r3, r2, r3
 800d338:	b2db      	uxtb	r3, r3
 800d33a:	425b      	negs	r3, r3
 800d33c:	b2db      	uxtb	r3, r3
 800d33e:	b2db      	uxtb	r3, r3
 800d340:	460a      	mov	r2, r1
 800d342:	4313      	orrs	r3, r2
 800d344:	b2db      	uxtb	r3, r3
 800d346:	743b      	strb	r3, [r7, #16]
 800d348:	e076      	b.n	800d438 <canardDecodeScalar+0x24c>
            }
        }
        else if (bit_length <= 16)
 800d34a:	79fb      	ldrb	r3, [r7, #7]
 800d34c:	2b10      	cmp	r3, #16
 800d34e:	d817      	bhi.n	800d380 <canardDecodeScalar+0x194>
        {
            if ((storage.s16 & (1U << (bit_length - 1))) != 0)
 800d350:	8a3b      	ldrh	r3, [r7, #16]
 800d352:	b21a      	sxth	r2, r3
 800d354:	79fb      	ldrb	r3, [r7, #7]
 800d356:	3b01      	subs	r3, #1
 800d358:	fa22 f303 	lsr.w	r3, r2, r3
 800d35c:	f003 0301 	and.w	r3, r3, #1
 800d360:	2b00      	cmp	r3, #0
 800d362:	d069      	beq.n	800d438 <canardDecodeScalar+0x24c>
            {
                storage.s16 |= (uint16_t) 0xFFFFU & (uint16_t) ~((1U << bit_length) - 1U);
 800d364:	8a39      	ldrh	r1, [r7, #16]
 800d366:	79fb      	ldrb	r3, [r7, #7]
 800d368:	2201      	movs	r2, #1
 800d36a:	fa02 f303 	lsl.w	r3, r2, r3
 800d36e:	b29b      	uxth	r3, r3
 800d370:	425b      	negs	r3, r3
 800d372:	b29b      	uxth	r3, r3
 800d374:	b29b      	uxth	r3, r3
 800d376:	460a      	mov	r2, r1
 800d378:	4313      	orrs	r3, r2
 800d37a:	b29b      	uxth	r3, r3
 800d37c:	823b      	strh	r3, [r7, #16]
 800d37e:	e05b      	b.n	800d438 <canardDecodeScalar+0x24c>
            }
        }
        else if (bit_length <= 32)
 800d380:	79fb      	ldrb	r3, [r7, #7]
 800d382:	2b20      	cmp	r3, #32
 800d384:	d813      	bhi.n	800d3ae <canardDecodeScalar+0x1c2>
        {
            if ((storage.s32 & (((uint32_t) 1) << (bit_length - 1))) != 0)
 800d386:	693b      	ldr	r3, [r7, #16]
 800d388:	461a      	mov	r2, r3
 800d38a:	79fb      	ldrb	r3, [r7, #7]
 800d38c:	3b01      	subs	r3, #1
 800d38e:	fa22 f303 	lsr.w	r3, r2, r3
 800d392:	f003 0301 	and.w	r3, r3, #1
 800d396:	2b00      	cmp	r3, #0
 800d398:	d04e      	beq.n	800d438 <canardDecodeScalar+0x24c>
            {
                storage.s32 |= (uint32_t) 0xFFFFFFFFUL & (uint32_t) ~((((uint32_t) 1) << bit_length) - 1U);
 800d39a:	693b      	ldr	r3, [r7, #16]
 800d39c:	4619      	mov	r1, r3
 800d39e:	79fb      	ldrb	r3, [r7, #7]
 800d3a0:	2201      	movs	r2, #1
 800d3a2:	fa02 f303 	lsl.w	r3, r2, r3
 800d3a6:	425b      	negs	r3, r3
 800d3a8:	430b      	orrs	r3, r1
 800d3aa:	613b      	str	r3, [r7, #16]
 800d3ac:	e044      	b.n	800d438 <canardDecodeScalar+0x24c>
            }
        }
        else if (bit_length < 64)   // Strictly less, this is not a typo
 800d3ae:	79fb      	ldrb	r3, [r7, #7]
 800d3b0:	2b3f      	cmp	r3, #63	; 0x3f
 800d3b2:	d83e      	bhi.n	800d432 <canardDecodeScalar+0x246>
        {
            if ((storage.s64 & (((uint64_t) 1) << (bit_length - 1))) != 0)
 800d3b4:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800d3b8:	79f9      	ldrb	r1, [r7, #7]
 800d3ba:	3901      	subs	r1, #1
 800d3bc:	f1c1 0620 	rsb	r6, r1, #32
 800d3c0:	f1a1 0020 	sub.w	r0, r1, #32
 800d3c4:	fa22 f801 	lsr.w	r8, r2, r1
 800d3c8:	fa03 f606 	lsl.w	r6, r3, r6
 800d3cc:	ea48 0806 	orr.w	r8, r8, r6
 800d3d0:	fa23 f000 	lsr.w	r0, r3, r0
 800d3d4:	ea48 0800 	orr.w	r8, r8, r0
 800d3d8:	fa23 f901 	lsr.w	r9, r3, r1
 800d3dc:	f04f 0201 	mov.w	r2, #1
 800d3e0:	f04f 0300 	mov.w	r3, #0
 800d3e4:	ea02 0208 	and.w	r2, r2, r8
 800d3e8:	ea03 0309 	and.w	r3, r3, r9
 800d3ec:	4313      	orrs	r3, r2
 800d3ee:	d023      	beq.n	800d438 <canardDecodeScalar+0x24c>
            {
                storage.s64 |= (uint64_t) 0xFFFFFFFFFFFFFFFFULL & (uint64_t) ~((((uint64_t) 1) << bit_length) - 1U);
 800d3f0:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800d3f4:	4690      	mov	r8, r2
 800d3f6:	4699      	mov	r9, r3
 800d3f8:	79f9      	ldrb	r1, [r7, #7]
 800d3fa:	f04f 0201 	mov.w	r2, #1
 800d3fe:	f04f 0300 	mov.w	r3, #0
 800d402:	f1a1 0620 	sub.w	r6, r1, #32
 800d406:	f1c1 0020 	rsb	r0, r1, #32
 800d40a:	fa03 f501 	lsl.w	r5, r3, r1
 800d40e:	fa02 f606 	lsl.w	r6, r2, r6
 800d412:	4335      	orrs	r5, r6
 800d414:	fa22 f000 	lsr.w	r0, r2, r0
 800d418:	4305      	orrs	r5, r0
 800d41a:	fa02 f401 	lsl.w	r4, r2, r1
 800d41e:	4262      	negs	r2, r4
 800d420:	eb65 0345 	sbc.w	r3, r5, r5, lsl #1
 800d424:	ea42 0208 	orr.w	r2, r2, r8
 800d428:	ea43 0309 	orr.w	r3, r3, r9
 800d42c:	e9c7 2304 	strd	r2, r3, [r7, #16]
 800d430:	e002      	b.n	800d438 <canardDecodeScalar+0x24c>
            }
        }
        else
        {
            CANARD_ASSERT(false);
            return -CANARD_ERROR_INTERNAL;
 800d432:	f06f 0308 	mvn.w	r3, #8
 800d436:	e04c      	b.n	800d4d2 <canardDecodeScalar+0x2e6>
    }

    /*
     * Copying the result out.
     */
    if (value_is_signed)
 800d438:	79bb      	ldrb	r3, [r7, #6]
 800d43a:	2b00      	cmp	r3, #0
 800d43c:	d020      	beq.n	800d480 <canardDecodeScalar+0x294>
    {
        if      (bit_length <= 8)   { *( (int8_t*) out_value) = storage.s8;  }
 800d43e:	79fb      	ldrb	r3, [r7, #7]
 800d440:	2b08      	cmp	r3, #8
 800d442:	d803      	bhi.n	800d44c <canardDecodeScalar+0x260>
 800d444:	7c3a      	ldrb	r2, [r7, #16]
 800d446:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d448:	701a      	strb	r2, [r3, #0]
 800d44a:	e041      	b.n	800d4d0 <canardDecodeScalar+0x2e4>
        else if (bit_length <= 16)  { *((int16_t*) out_value) = storage.s16; }
 800d44c:	79fb      	ldrb	r3, [r7, #7]
 800d44e:	2b10      	cmp	r3, #16
 800d450:	d803      	bhi.n	800d45a <canardDecodeScalar+0x26e>
 800d452:	8a3a      	ldrh	r2, [r7, #16]
 800d454:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d456:	801a      	strh	r2, [r3, #0]
 800d458:	e03a      	b.n	800d4d0 <canardDecodeScalar+0x2e4>
        else if (bit_length <= 32)  { *((int32_t*) out_value) = storage.s32; }
 800d45a:	79fb      	ldrb	r3, [r7, #7]
 800d45c:	2b20      	cmp	r3, #32
 800d45e:	d803      	bhi.n	800d468 <canardDecodeScalar+0x27c>
 800d460:	693a      	ldr	r2, [r7, #16]
 800d462:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d464:	601a      	str	r2, [r3, #0]
 800d466:	e033      	b.n	800d4d0 <canardDecodeScalar+0x2e4>
        else if (bit_length <= 64)  { *((int64_t*) out_value) = storage.s64; }
 800d468:	79fb      	ldrb	r3, [r7, #7]
 800d46a:	2b40      	cmp	r3, #64	; 0x40
 800d46c:	d805      	bhi.n	800d47a <canardDecodeScalar+0x28e>
 800d46e:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800d472:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800d474:	e9c1 2300 	strd	r2, r3, [r1]
 800d478:	e02a      	b.n	800d4d0 <canardDecodeScalar+0x2e4>
        else
        {
            CANARD_ASSERT(false);
            return -CANARD_ERROR_INTERNAL;
 800d47a:	f06f 0308 	mvn.w	r3, #8
 800d47e:	e028      	b.n	800d4d2 <canardDecodeScalar+0x2e6>
        }
    }
    else
    {
        if      (bit_length == 1)   { *(    (bool*) out_value) = storage.boolean; }
 800d480:	79fb      	ldrb	r3, [r7, #7]
 800d482:	2b01      	cmp	r3, #1
 800d484:	d103      	bne.n	800d48e <canardDecodeScalar+0x2a2>
 800d486:	7c3a      	ldrb	r2, [r7, #16]
 800d488:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d48a:	701a      	strb	r2, [r3, #0]
 800d48c:	e020      	b.n	800d4d0 <canardDecodeScalar+0x2e4>
        else if (bit_length <= 8)   { *( (uint8_t*) out_value) = storage.u8;  }
 800d48e:	79fb      	ldrb	r3, [r7, #7]
 800d490:	2b08      	cmp	r3, #8
 800d492:	d803      	bhi.n	800d49c <canardDecodeScalar+0x2b0>
 800d494:	7c3a      	ldrb	r2, [r7, #16]
 800d496:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d498:	701a      	strb	r2, [r3, #0]
 800d49a:	e019      	b.n	800d4d0 <canardDecodeScalar+0x2e4>
        else if (bit_length <= 16)  { *((uint16_t*) out_value) = storage.u16; }
 800d49c:	79fb      	ldrb	r3, [r7, #7]
 800d49e:	2b10      	cmp	r3, #16
 800d4a0:	d803      	bhi.n	800d4aa <canardDecodeScalar+0x2be>
 800d4a2:	8a3a      	ldrh	r2, [r7, #16]
 800d4a4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d4a6:	801a      	strh	r2, [r3, #0]
 800d4a8:	e012      	b.n	800d4d0 <canardDecodeScalar+0x2e4>
        else if (bit_length <= 32)  { *((uint32_t*) out_value) = storage.u32; }
 800d4aa:	79fb      	ldrb	r3, [r7, #7]
 800d4ac:	2b20      	cmp	r3, #32
 800d4ae:	d803      	bhi.n	800d4b8 <canardDecodeScalar+0x2cc>
 800d4b0:	693a      	ldr	r2, [r7, #16]
 800d4b2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d4b4:	601a      	str	r2, [r3, #0]
 800d4b6:	e00b      	b.n	800d4d0 <canardDecodeScalar+0x2e4>
        else if (bit_length <= 64)  { *((uint64_t*) out_value) = storage.u64; }
 800d4b8:	79fb      	ldrb	r3, [r7, #7]
 800d4ba:	2b40      	cmp	r3, #64	; 0x40
 800d4bc:	d805      	bhi.n	800d4ca <canardDecodeScalar+0x2de>
 800d4be:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800d4c2:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800d4c4:	e9c1 2300 	strd	r2, r3, [r1]
 800d4c8:	e002      	b.n	800d4d0 <canardDecodeScalar+0x2e4>
        else
        {
            CANARD_ASSERT(false);
            return -CANARD_ERROR_INTERNAL;
 800d4ca:	f06f 0308 	mvn.w	r3, #8
 800d4ce:	e000      	b.n	800d4d2 <canardDecodeScalar+0x2e6>
        }
    }

    CANARD_ASSERT(result <= bit_length);
    CANARD_ASSERT(result > 0);
    return result;
 800d4d0:	69bb      	ldr	r3, [r7, #24]
}
 800d4d2:	4618      	mov	r0, r3
 800d4d4:	3724      	adds	r7, #36	; 0x24
 800d4d6:	46bd      	mov	sp, r7
 800d4d8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800d4dc <canardEncodeScalar>:

void canardEncodeScalar(void* destination,
                        uint32_t bit_offset,
                        uint8_t bit_length,
                        const void* value)
{
 800d4dc:	b580      	push	{r7, lr}
 800d4de:	b08a      	sub	sp, #40	; 0x28
 800d4e0:	af02      	add	r7, sp, #8
 800d4e2:	60f8      	str	r0, [r7, #12]
 800d4e4:	60b9      	str	r1, [r7, #8]
 800d4e6:	603b      	str	r3, [r7, #0]
 800d4e8:	4613      	mov	r3, r2
 800d4ea:	71fb      	strb	r3, [r7, #7]
     * Maybe not the best solution, but it simplifies the API.
     */
    CANARD_ASSERT(destination != NULL);
    CANARD_ASSERT(value != NULL);

    if (bit_length > 64)
 800d4ec:	79fb      	ldrb	r3, [r7, #7]
 800d4ee:	2b40      	cmp	r3, #64	; 0x40
 800d4f0:	d901      	bls.n	800d4f6 <canardEncodeScalar+0x1a>
    {
        CANARD_ASSERT(false);
        bit_length = 64;
 800d4f2:	2340      	movs	r3, #64	; 0x40
 800d4f4:	71fb      	strb	r3, [r7, #7]
    }

    if (bit_length < 1)
 800d4f6:	79fb      	ldrb	r3, [r7, #7]
 800d4f8:	2b00      	cmp	r3, #0
 800d4fa:	d101      	bne.n	800d500 <canardEncodeScalar+0x24>
    {
        CANARD_ASSERT(false);
        bit_length = 1;
 800d4fc:	2301      	movs	r3, #1
 800d4fe:	71fb      	strb	r3, [r7, #7]
        uint32_t u32;
        uint64_t u64;
        uint8_t bytes[8];
    } storage;

    memset(&storage, 0, sizeof(storage));
 800d500:	f107 0310 	add.w	r3, r7, #16
 800d504:	4618      	mov	r0, r3
 800d506:	2100      	movs	r1, #0
 800d508:	2208      	movs	r2, #8
 800d50a:	f001 f85f 	bl	800e5cc <memset>

    uint8_t std_byte_length = 0;
 800d50e:	2300      	movs	r3, #0
 800d510:	77fb      	strb	r3, [r7, #31]

    // Extra most significant bits can be safely ignored here.
    if      (bit_length == 1)   { std_byte_length = sizeof(bool);   storage.boolean = (*((bool*) value) != 0); }
 800d512:	79fb      	ldrb	r3, [r7, #7]
 800d514:	2b01      	cmp	r3, #1
 800d516:	d10a      	bne.n	800d52e <canardEncodeScalar+0x52>
 800d518:	2301      	movs	r3, #1
 800d51a:	77fb      	strb	r3, [r7, #31]
 800d51c:	683b      	ldr	r3, [r7, #0]
 800d51e:	781b      	ldrb	r3, [r3, #0]
 800d520:	2b00      	cmp	r3, #0
 800d522:	bf14      	ite	ne
 800d524:	2301      	movne	r3, #1
 800d526:	2300      	moveq	r3, #0
 800d528:	b2db      	uxtb	r3, r3
 800d52a:	743b      	strb	r3, [r7, #16]
 800d52c:	e024      	b.n	800d578 <canardEncodeScalar+0x9c>
    else if (bit_length <= 8)   { std_byte_length = 1;              storage.u8  = *((uint8_t*) value);  }
 800d52e:	79fb      	ldrb	r3, [r7, #7]
 800d530:	2b08      	cmp	r3, #8
 800d532:	d805      	bhi.n	800d540 <canardEncodeScalar+0x64>
 800d534:	2301      	movs	r3, #1
 800d536:	77fb      	strb	r3, [r7, #31]
 800d538:	683b      	ldr	r3, [r7, #0]
 800d53a:	781b      	ldrb	r3, [r3, #0]
 800d53c:	743b      	strb	r3, [r7, #16]
 800d53e:	e01b      	b.n	800d578 <canardEncodeScalar+0x9c>
    else if (bit_length <= 16)  { std_byte_length = 2;              storage.u16 = *((uint16_t*) value); }
 800d540:	79fb      	ldrb	r3, [r7, #7]
 800d542:	2b10      	cmp	r3, #16
 800d544:	d805      	bhi.n	800d552 <canardEncodeScalar+0x76>
 800d546:	2302      	movs	r3, #2
 800d548:	77fb      	strb	r3, [r7, #31]
 800d54a:	683b      	ldr	r3, [r7, #0]
 800d54c:	881b      	ldrh	r3, [r3, #0]
 800d54e:	823b      	strh	r3, [r7, #16]
 800d550:	e012      	b.n	800d578 <canardEncodeScalar+0x9c>
    else if (bit_length <= 32)  { std_byte_length = 4;              storage.u32 = *((uint32_t*) value); }
 800d552:	79fb      	ldrb	r3, [r7, #7]
 800d554:	2b20      	cmp	r3, #32
 800d556:	d805      	bhi.n	800d564 <canardEncodeScalar+0x88>
 800d558:	2304      	movs	r3, #4
 800d55a:	77fb      	strb	r3, [r7, #31]
 800d55c:	683b      	ldr	r3, [r7, #0]
 800d55e:	681b      	ldr	r3, [r3, #0]
 800d560:	613b      	str	r3, [r7, #16]
 800d562:	e009      	b.n	800d578 <canardEncodeScalar+0x9c>
    else if (bit_length <= 64)  { std_byte_length = 8;              storage.u64 = *((uint64_t*) value); }
 800d564:	79fb      	ldrb	r3, [r7, #7]
 800d566:	2b40      	cmp	r3, #64	; 0x40
 800d568:	d806      	bhi.n	800d578 <canardEncodeScalar+0x9c>
 800d56a:	2308      	movs	r3, #8
 800d56c:	77fb      	strb	r3, [r7, #31]
 800d56e:	683b      	ldr	r3, [r7, #0]
 800d570:	e9d3 2300 	ldrd	r2, r3, [r3]
 800d574:	e9c7 2304 	strd	r2, r3, [r7, #16]
        CANARD_ASSERT(false);
    }

    CANARD_ASSERT(std_byte_length > 0);

    if (isBigEndian())
 800d578:	f000 fc26 	bl	800ddc8 <isBigEndian>
 800d57c:	4603      	mov	r3, r0
 800d57e:	2b00      	cmp	r3, #0
 800d580:	d006      	beq.n	800d590 <canardEncodeScalar+0xb4>
    {
        swapByteOrder(&storage.bytes[0], std_byte_length);
 800d582:	7ffb      	ldrb	r3, [r7, #31]
 800d584:	f107 0210 	add.w	r2, r7, #16
 800d588:	4610      	mov	r0, r2
 800d58a:	4619      	mov	r1, r3
 800d58c:	f000 fc2e 	bl	800ddec <swapByteOrder>
     * Extra least significant bits will be filled with zeroes, which is fine.
     * Extra most significant bits will be discarded here.
     * Coverity Scan mistakenly believes that the array may be overrun if bit_length == 64; however, this branch will
     * not be taken if bit_length == 64, because 64 % 8 == 0.
     */
    if ((bit_length % 8) != 0)
 800d590:	79fb      	ldrb	r3, [r7, #7]
 800d592:	f003 0307 	and.w	r3, r3, #7
 800d596:	b2db      	uxtb	r3, r3
 800d598:	2b00      	cmp	r3, #0
 800d59a:	d018      	beq.n	800d5ce <canardEncodeScalar+0xf2>
    {
        // coverity[overrun-local]
        storage.bytes[bit_length / 8] = (uint8_t)(storage.bytes[bit_length / 8] << ((8 - (bit_length % 8)) & 7));
 800d59c:	79fb      	ldrb	r3, [r7, #7]
 800d59e:	08db      	lsrs	r3, r3, #3
 800d5a0:	b2db      	uxtb	r3, r3
 800d5a2:	4619      	mov	r1, r3
 800d5a4:	79fb      	ldrb	r3, [r7, #7]
 800d5a6:	08db      	lsrs	r3, r3, #3
 800d5a8:	b2db      	uxtb	r3, r3
 800d5aa:	f107 0220 	add.w	r2, r7, #32
 800d5ae:	4413      	add	r3, r2
 800d5b0:	f813 3c10 	ldrb.w	r3, [r3, #-16]
 800d5b4:	461a      	mov	r2, r3
 800d5b6:	79fb      	ldrb	r3, [r7, #7]
 800d5b8:	425b      	negs	r3, r3
 800d5ba:	f003 0307 	and.w	r3, r3, #7
 800d5be:	fa02 f303 	lsl.w	r3, r2, r3
 800d5c2:	b2da      	uxtb	r2, r3
 800d5c4:	f107 0320 	add.w	r3, r7, #32
 800d5c8:	440b      	add	r3, r1
 800d5ca:	f803 2c10 	strb.w	r2, [r3, #-16]
    }

    /*
     * Now, the storage contains properly serialized scalar. Copying it out.
     */
    copyBitArray(&storage.bytes[0], 0, bit_length, (uint8_t*) destination, bit_offset);
 800d5ce:	79fa      	ldrb	r2, [r7, #7]
 800d5d0:	f107 0110 	add.w	r1, r7, #16
 800d5d4:	68bb      	ldr	r3, [r7, #8]
 800d5d6:	9300      	str	r3, [sp, #0]
 800d5d8:	4608      	mov	r0, r1
 800d5da:	2100      	movs	r1, #0
 800d5dc:	68fb      	ldr	r3, [r7, #12]
 800d5de:	f000 fa89 	bl	800daf4 <copyBitArray>
}
 800d5e2:	3720      	adds	r7, #32
 800d5e4:	46bd      	mov	sp, r7
 800d5e6:	bd80      	pop	{r7, pc}

0800d5e8 <canardReleaseRxTransferPayload>:

void canardReleaseRxTransferPayload(CanardInstance* ins, CanardRxTransfer* transfer)
{
 800d5e8:	b580      	push	{r7, lr}
 800d5ea:	b084      	sub	sp, #16
 800d5ec:	af00      	add	r7, sp, #0
 800d5ee:	6078      	str	r0, [r7, #4]
 800d5f0:	6039      	str	r1, [r7, #0]
 800d5f2:	e00f      	b.n	800d614 <canardReleaseRxTransferPayload+0x2c>
    while (transfer->payload_middle != NULL)
    {
        CanardBufferBlock* const temp = transfer->payload_middle->next;
 800d5f4:	683b      	ldr	r3, [r7, #0]
 800d5f6:	68db      	ldr	r3, [r3, #12]
 800d5f8:	681b      	ldr	r3, [r3, #0]
 800d5fa:	60fb      	str	r3, [r7, #12]
        freeBlock(&ins->allocator, transfer->payload_middle);
 800d5fc:	687b      	ldr	r3, [r7, #4]
 800d5fe:	f103 020c 	add.w	r2, r3, #12
 800d602:	683b      	ldr	r3, [r7, #0]
 800d604:	68db      	ldr	r3, [r3, #12]
 800d606:	4610      	mov	r0, r2
 800d608:	4619      	mov	r1, r3
 800d60a:	f000 fcf3 	bl	800dff4 <freeBlock>
        transfer->payload_middle = temp;
 800d60e:	683b      	ldr	r3, [r7, #0]
 800d610:	68fa      	ldr	r2, [r7, #12]
 800d612:	60da      	str	r2, [r3, #12]
    copyBitArray(&storage.bytes[0], 0, bit_length, (uint8_t*) destination, bit_offset);
}

void canardReleaseRxTransferPayload(CanardInstance* ins, CanardRxTransfer* transfer)
{
    while (transfer->payload_middle != NULL)
 800d614:	683b      	ldr	r3, [r7, #0]
 800d616:	68db      	ldr	r3, [r3, #12]
 800d618:	2b00      	cmp	r3, #0
 800d61a:	d1eb      	bne.n	800d5f4 <canardReleaseRxTransferPayload+0xc>
        CanardBufferBlock* const temp = transfer->payload_middle->next;
        freeBlock(&ins->allocator, transfer->payload_middle);
        transfer->payload_middle = temp;
    }

    transfer->payload_middle = NULL;
 800d61c:	683b      	ldr	r3, [r7, #0]
 800d61e:	2200      	movs	r2, #0
 800d620:	60da      	str	r2, [r3, #12]
    transfer->payload_head = NULL;
 800d622:	683b      	ldr	r3, [r7, #0]
 800d624:	2200      	movs	r2, #0
 800d626:	609a      	str	r2, [r3, #8]
    transfer->payload_tail = NULL;
 800d628:	683b      	ldr	r3, [r7, #0]
 800d62a:	2200      	movs	r2, #0
 800d62c:	611a      	str	r2, [r3, #16]
    transfer->payload_len = 0;
 800d62e:	683b      	ldr	r3, [r7, #0]
 800d630:	2200      	movs	r2, #0
 800d632:	829a      	strh	r2, [r3, #20]
}
 800d634:	3710      	adds	r7, #16
 800d636:	46bd      	mov	sp, r7
 800d638:	bd80      	pop	{r7, pc}
 800d63a:	bf00      	nop

0800d63c <computeTransferIDForwardDistance>:

/*
 * Internal (static functions)
 */
CANARD_INTERNAL int computeTransferIDForwardDistance(uint8_t a, uint8_t b)
{
 800d63c:	b480      	push	{r7}
 800d63e:	b085      	sub	sp, #20
 800d640:	af00      	add	r7, sp, #0
 800d642:	4603      	mov	r3, r0
 800d644:	460a      	mov	r2, r1
 800d646:	71fb      	strb	r3, [r7, #7]
 800d648:	4613      	mov	r3, r2
 800d64a:	71bb      	strb	r3, [r7, #6]
    int d = b - a;
 800d64c:	79ba      	ldrb	r2, [r7, #6]
 800d64e:	79fb      	ldrb	r3, [r7, #7]
 800d650:	1ad3      	subs	r3, r2, r3
 800d652:	60fb      	str	r3, [r7, #12]
    if (d < 0)
 800d654:	68fb      	ldr	r3, [r7, #12]
 800d656:	2b00      	cmp	r3, #0
 800d658:	da02      	bge.n	800d660 <computeTransferIDForwardDistance+0x24>
    {
        d += 1 << TRANSFER_ID_BIT_LEN;
 800d65a:	68fb      	ldr	r3, [r7, #12]
 800d65c:	3320      	adds	r3, #32
 800d65e:	60fb      	str	r3, [r7, #12]
    }
    return d;
 800d660:	68fb      	ldr	r3, [r7, #12]
}
 800d662:	4618      	mov	r0, r3
 800d664:	3714      	adds	r7, #20
 800d666:	46bd      	mov	sp, r7
 800d668:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d66c:	4770      	bx	lr
 800d66e:	bf00      	nop

0800d670 <prepareForNextTransfer>:

/**
 * preps the rx state for the next transfer. does not delete the state
 */
CANARD_INTERNAL void prepareForNextTransfer(CanardRxState* state)
{
 800d670:	b480      	push	{r7}
 800d672:	b083      	sub	sp, #12
 800d674:	af00      	add	r7, sp, #0
 800d676:	6078      	str	r0, [r7, #4]
    CANARD_ASSERT(state->buffer_blocks == NULL);
    state->transfer_id += 1;
 800d678:	687b      	ldr	r3, [r7, #4]
 800d67a:	7e5b      	ldrb	r3, [r3, #25]
 800d67c:	f3c3 0384 	ubfx	r3, r3, #2, #5
 800d680:	b2db      	uxtb	r3, r3
 800d682:	3301      	adds	r3, #1
 800d684:	b2db      	uxtb	r3, r3
 800d686:	f003 031f 	and.w	r3, r3, #31
 800d68a:	b2d9      	uxtb	r1, r3
 800d68c:	687a      	ldr	r2, [r7, #4]
 800d68e:	7e53      	ldrb	r3, [r2, #25]
 800d690:	f361 0386 	bfi	r3, r1, #2, #5
 800d694:	7653      	strb	r3, [r2, #25]
    state->payload_len = 0;
 800d696:	687a      	ldr	r2, [r7, #4]
 800d698:	8b13      	ldrh	r3, [r2, #24]
 800d69a:	f36f 0309 	bfc	r3, #0, #10
 800d69e:	8313      	strh	r3, [r2, #24]
    state->next_toggle = 0;
 800d6a0:	687a      	ldr	r2, [r7, #4]
 800d6a2:	7e53      	ldrb	r3, [r2, #25]
 800d6a4:	f36f 13c7 	bfc	r3, #7, #1
 800d6a8:	7653      	strb	r3, [r2, #25]
}
 800d6aa:	370c      	adds	r7, #12
 800d6ac:	46bd      	mov	sp, r7
 800d6ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d6b2:	4770      	bx	lr

0800d6b4 <extractDataType>:

/**
 * returns data type from id
 */
CANARD_INTERNAL uint16_t extractDataType(uint32_t id)
{
 800d6b4:	b580      	push	{r7, lr}
 800d6b6:	b084      	sub	sp, #16
 800d6b8:	af00      	add	r7, sp, #0
 800d6ba:	6078      	str	r0, [r7, #4]
    if (extractTransferType(id) == CanardTransferTypeBroadcast)
 800d6bc:	6878      	ldr	r0, [r7, #4]
 800d6be:	f000 f81b 	bl	800d6f8 <extractTransferType>
 800d6c2:	4603      	mov	r3, r0
 800d6c4:	2b02      	cmp	r3, #2
 800d6c6:	d10e      	bne.n	800d6e6 <extractDataType+0x32>
    {
        uint16_t dtid = MSG_TYPE_FROM_ID(id);
 800d6c8:	687b      	ldr	r3, [r7, #4]
 800d6ca:	0a1b      	lsrs	r3, r3, #8
 800d6cc:	81fb      	strh	r3, [r7, #14]
        if (SOURCE_ID_FROM_ID(id) == CANARD_BROADCAST_NODE_ID)
 800d6ce:	687b      	ldr	r3, [r7, #4]
 800d6d0:	b2db      	uxtb	r3, r3
 800d6d2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800d6d6:	2b00      	cmp	r3, #0
 800d6d8:	d103      	bne.n	800d6e2 <extractDataType+0x2e>
        {
            dtid &= (1U << ANON_MSG_DATA_TYPE_ID_BIT_LEN) - 1U;
 800d6da:	89fb      	ldrh	r3, [r7, #14]
 800d6dc:	f003 0303 	and.w	r3, r3, #3
 800d6e0:	81fb      	strh	r3, [r7, #14]
        }
        return dtid;
 800d6e2:	89fb      	ldrh	r3, [r7, #14]
 800d6e4:	e003      	b.n	800d6ee <extractDataType+0x3a>
    }
    else
    {
        return (uint16_t) SRV_TYPE_FROM_ID(id);
 800d6e6:	687b      	ldr	r3, [r7, #4]
 800d6e8:	0c1b      	lsrs	r3, r3, #16
 800d6ea:	b2db      	uxtb	r3, r3
 800d6ec:	b29b      	uxth	r3, r3
    }
}
 800d6ee:	4618      	mov	r0, r3
 800d6f0:	3710      	adds	r7, #16
 800d6f2:	46bd      	mov	sp, r7
 800d6f4:	bd80      	pop	{r7, pc}
 800d6f6:	bf00      	nop

0800d6f8 <extractTransferType>:

/**
 * returns transfer type from id
 */
CANARD_INTERNAL CanardTransferType extractTransferType(uint32_t id)
{
 800d6f8:	b480      	push	{r7}
 800d6fa:	b085      	sub	sp, #20
 800d6fc:	af00      	add	r7, sp, #0
 800d6fe:	6078      	str	r0, [r7, #4]
    const bool is_service = SERVICE_NOT_MSG_FROM_ID(id);
 800d700:	687b      	ldr	r3, [r7, #4]
 800d702:	09db      	lsrs	r3, r3, #7
 800d704:	f003 0301 	and.w	r3, r3, #1
 800d708:	2b00      	cmp	r3, #0
 800d70a:	bf14      	ite	ne
 800d70c:	2301      	movne	r3, #1
 800d70e:	2300      	moveq	r3, #0
 800d710:	73fb      	strb	r3, [r7, #15]
    if (!is_service)
 800d712:	7bfb      	ldrb	r3, [r7, #15]
 800d714:	f083 0301 	eor.w	r3, r3, #1
 800d718:	b2db      	uxtb	r3, r3
 800d71a:	2b00      	cmp	r3, #0
 800d71c:	d001      	beq.n	800d722 <extractTransferType+0x2a>
    {
        return CanardTransferTypeBroadcast;
 800d71e:	2302      	movs	r3, #2
 800d720:	e008      	b.n	800d734 <extractTransferType+0x3c>
    }
    else if (REQUEST_NOT_RESPONSE_FROM_ID(id) == 1)
 800d722:	687b      	ldr	r3, [r7, #4]
 800d724:	0bdb      	lsrs	r3, r3, #15
 800d726:	f003 0301 	and.w	r3, r3, #1
 800d72a:	2b00      	cmp	r3, #0
 800d72c:	d001      	beq.n	800d732 <extractTransferType+0x3a>
    {
        return CanardTransferTypeRequest;
 800d72e:	2301      	movs	r3, #1
 800d730:	e000      	b.n	800d734 <extractTransferType+0x3c>
    }
    else
    {
        return CanardTransferTypeResponse;
 800d732:	2300      	movs	r3, #0
    }
}
 800d734:	4618      	mov	r0, r3
 800d736:	3714      	adds	r7, #20
 800d738:	46bd      	mov	sp, r7
 800d73a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d73e:	4770      	bx	lr

0800d740 <traverseRxStates>:
/**
 * Traverses the list of CanardRxState's and returns a pointer to the CanardRxState
 * with either the Id or a new one at the end
 */
CANARD_INTERNAL CanardRxState* traverseRxStates(CanardInstance* ins, uint32_t transfer_descriptor)
{
 800d740:	b580      	push	{r7, lr}
 800d742:	b084      	sub	sp, #16
 800d744:	af00      	add	r7, sp, #0
 800d746:	6078      	str	r0, [r7, #4]
 800d748:	6039      	str	r1, [r7, #0]
    CanardRxState* states = ins->rx_states;
 800d74a:	687b      	ldr	r3, [r7, #4]
 800d74c:	699b      	ldr	r3, [r3, #24]
 800d74e:	60fb      	str	r3, [r7, #12]

    if (states == NULL) // initialize CanardRxStates
 800d750:	68fb      	ldr	r3, [r7, #12]
 800d752:	2b00      	cmp	r3, #0
 800d754:	d110      	bne.n	800d778 <traverseRxStates+0x38>
    {
        states = createRxState(&ins->allocator, transfer_descriptor);
 800d756:	687b      	ldr	r3, [r7, #4]
 800d758:	330c      	adds	r3, #12
 800d75a:	4618      	mov	r0, r3
 800d75c:	6839      	ldr	r1, [r7, #0]
 800d75e:	f000 f857 	bl	800d810 <createRxState>
 800d762:	60f8      	str	r0, [r7, #12]
        
        if(states == NULL)
 800d764:	68fb      	ldr	r3, [r7, #12]
 800d766:	2b00      	cmp	r3, #0
 800d768:	d101      	bne.n	800d76e <traverseRxStates+0x2e>
        {
            return NULL;
 800d76a:	2300      	movs	r3, #0
 800d76c:	e013      	b.n	800d796 <traverseRxStates+0x56>
        }

        ins->rx_states = states;
 800d76e:	687b      	ldr	r3, [r7, #4]
 800d770:	68fa      	ldr	r2, [r7, #12]
 800d772:	619a      	str	r2, [r3, #24]
        return states;
 800d774:	68fb      	ldr	r3, [r7, #12]
 800d776:	e00e      	b.n	800d796 <traverseRxStates+0x56>
    }

    states = findRxState(states, transfer_descriptor);
 800d778:	68f8      	ldr	r0, [r7, #12]
 800d77a:	6839      	ldr	r1, [r7, #0]
 800d77c:	f000 f810 	bl	800d7a0 <findRxState>
 800d780:	60f8      	str	r0, [r7, #12]
    if (states != NULL)
 800d782:	68fb      	ldr	r3, [r7, #12]
 800d784:	2b00      	cmp	r3, #0
 800d786:	d001      	beq.n	800d78c <traverseRxStates+0x4c>
    {
        return states;
 800d788:	68fb      	ldr	r3, [r7, #12]
 800d78a:	e004      	b.n	800d796 <traverseRxStates+0x56>
    }
    else
    {
        return prependRxState(ins, transfer_descriptor);
 800d78c:	6878      	ldr	r0, [r7, #4]
 800d78e:	6839      	ldr	r1, [r7, #0]
 800d790:	f000 f820 	bl	800d7d4 <prependRxState>
 800d794:	4603      	mov	r3, r0
    }
}
 800d796:	4618      	mov	r0, r3
 800d798:	3710      	adds	r7, #16
 800d79a:	46bd      	mov	sp, r7
 800d79c:	bd80      	pop	{r7, pc}
 800d79e:	bf00      	nop

0800d7a0 <findRxState>:

/**
 * returns pointer to the rx state of transfer descriptor or null if not found
 */
CANARD_INTERNAL CanardRxState* findRxState(CanardRxState* state, uint32_t transfer_descriptor)
{
 800d7a0:	b480      	push	{r7}
 800d7a2:	b083      	sub	sp, #12
 800d7a4:	af00      	add	r7, sp, #0
 800d7a6:	6078      	str	r0, [r7, #4]
 800d7a8:	6039      	str	r1, [r7, #0]
 800d7aa:	e009      	b.n	800d7c0 <findRxState+0x20>
    while (state != NULL)
    {
        if (state->dtid_tt_snid_dnid == transfer_descriptor)
 800d7ac:	687b      	ldr	r3, [r7, #4]
 800d7ae:	691a      	ldr	r2, [r3, #16]
 800d7b0:	683b      	ldr	r3, [r7, #0]
 800d7b2:	429a      	cmp	r2, r3
 800d7b4:	d101      	bne.n	800d7ba <findRxState+0x1a>
        {
            return state;
 800d7b6:	687b      	ldr	r3, [r7, #4]
 800d7b8:	e006      	b.n	800d7c8 <findRxState+0x28>
        }
        state = state->next;
 800d7ba:	687b      	ldr	r3, [r7, #4]
 800d7bc:	681b      	ldr	r3, [r3, #0]
 800d7be:	607b      	str	r3, [r7, #4]
/**
 * returns pointer to the rx state of transfer descriptor or null if not found
 */
CANARD_INTERNAL CanardRxState* findRxState(CanardRxState* state, uint32_t transfer_descriptor)
{
    while (state != NULL)
 800d7c0:	687b      	ldr	r3, [r7, #4]
 800d7c2:	2b00      	cmp	r3, #0
 800d7c4:	d1f2      	bne.n	800d7ac <findRxState+0xc>
        {
            return state;
        }
        state = state->next;
    }
    return NULL;
 800d7c6:	2300      	movs	r3, #0
}
 800d7c8:	4618      	mov	r0, r3
 800d7ca:	370c      	adds	r7, #12
 800d7cc:	46bd      	mov	sp, r7
 800d7ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d7d2:	4770      	bx	lr

0800d7d4 <prependRxState>:

/**
 * prepends rx state to the canard instance rx_states
 */
CANARD_INTERNAL CanardRxState* prependRxState(CanardInstance* ins, uint32_t transfer_descriptor)
{
 800d7d4:	b580      	push	{r7, lr}
 800d7d6:	b084      	sub	sp, #16
 800d7d8:	af00      	add	r7, sp, #0
 800d7da:	6078      	str	r0, [r7, #4]
 800d7dc:	6039      	str	r1, [r7, #0]
    CanardRxState* state = createRxState(&ins->allocator, transfer_descriptor);
 800d7de:	687b      	ldr	r3, [r7, #4]
 800d7e0:	330c      	adds	r3, #12
 800d7e2:	4618      	mov	r0, r3
 800d7e4:	6839      	ldr	r1, [r7, #0]
 800d7e6:	f000 f813 	bl	800d810 <createRxState>
 800d7ea:	60f8      	str	r0, [r7, #12]

    if(state == NULL)
 800d7ec:	68fb      	ldr	r3, [r7, #12]
 800d7ee:	2b00      	cmp	r3, #0
 800d7f0:	d101      	bne.n	800d7f6 <prependRxState+0x22>
    {
        return NULL;
 800d7f2:	2300      	movs	r3, #0
 800d7f4:	e007      	b.n	800d806 <prependRxState+0x32>
    }

    state->next = ins->rx_states;
 800d7f6:	687b      	ldr	r3, [r7, #4]
 800d7f8:	699a      	ldr	r2, [r3, #24]
 800d7fa:	68fb      	ldr	r3, [r7, #12]
 800d7fc:	601a      	str	r2, [r3, #0]
    ins->rx_states = state;
 800d7fe:	687b      	ldr	r3, [r7, #4]
 800d800:	68fa      	ldr	r2, [r7, #12]
 800d802:	619a      	str	r2, [r3, #24]
    return state;
 800d804:	68fb      	ldr	r3, [r7, #12]
}
 800d806:	4618      	mov	r0, r3
 800d808:	3710      	adds	r7, #16
 800d80a:	46bd      	mov	sp, r7
 800d80c:	bd80      	pop	{r7, pc}
 800d80e:	bf00      	nop

0800d810 <createRxState>:

CANARD_INTERNAL CanardRxState* createRxState(CanardPoolAllocator* allocator, uint32_t transfer_descriptor)
{
 800d810:	b580      	push	{r7, lr}
 800d812:	b08c      	sub	sp, #48	; 0x30
 800d814:	af00      	add	r7, sp, #0
 800d816:	6078      	str	r0, [r7, #4]
 800d818:	6039      	str	r1, [r7, #0]
    CanardRxState init = {
 800d81a:	f107 0308 	add.w	r3, r7, #8
 800d81e:	2200      	movs	r2, #0
 800d820:	601a      	str	r2, [r3, #0]
 800d822:	3304      	adds	r3, #4
 800d824:	2200      	movs	r2, #0
 800d826:	601a      	str	r2, [r3, #0]
 800d828:	3304      	adds	r3, #4
 800d82a:	2200      	movs	r2, #0
 800d82c:	601a      	str	r2, [r3, #0]
 800d82e:	3304      	adds	r3, #4
 800d830:	2200      	movs	r2, #0
 800d832:	601a      	str	r2, [r3, #0]
 800d834:	3304      	adds	r3, #4
 800d836:	2200      	movs	r2, #0
 800d838:	601a      	str	r2, [r3, #0]
 800d83a:	3304      	adds	r3, #4
 800d83c:	2200      	movs	r2, #0
 800d83e:	601a      	str	r2, [r3, #0]
 800d840:	3304      	adds	r3, #4
 800d842:	2200      	movs	r2, #0
 800d844:	601a      	str	r2, [r3, #0]
 800d846:	3304      	adds	r3, #4
 800d848:	2200      	movs	r2, #0
 800d84a:	601a      	str	r2, [r3, #0]
 800d84c:	3304      	adds	r3, #4
 800d84e:	683b      	ldr	r3, [r7, #0]
 800d850:	61bb      	str	r3, [r7, #24]
        .next = NULL,
        .buffer_blocks = NULL,
        .dtid_tt_snid_dnid = transfer_descriptor
    };

    CanardRxState* state = (CanardRxState*) allocateBlock(allocator);
 800d852:	6878      	ldr	r0, [r7, #4]
 800d854:	f000 fba4 	bl	800dfa0 <allocateBlock>
 800d858:	62f8      	str	r0, [r7, #44]	; 0x2c
    if (state == NULL)
 800d85a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d85c:	2b00      	cmp	r3, #0
 800d85e:	d101      	bne.n	800d864 <createRxState+0x54>
    {
        return NULL;
 800d860:	2300      	movs	r3, #0
 800d862:	e007      	b.n	800d874 <createRxState+0x64>
    }
    memcpy(state, &init, sizeof(*state));
 800d864:	f107 0308 	add.w	r3, r7, #8
 800d868:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800d86a:	4619      	mov	r1, r3
 800d86c:	2220      	movs	r2, #32
 800d86e:	f000 fe87 	bl	800e580 <memcpy>

    return state;
 800d872:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 800d874:	4618      	mov	r0, r3
 800d876:	3730      	adds	r7, #48	; 0x30
 800d878:	46bd      	mov	sp, r7
 800d87a:	bd80      	pop	{r7, pc}

0800d87c <releaseStatePayload>:

CANARD_INTERNAL uint64_t releaseStatePayload(CanardInstance* ins, CanardRxState* rxstate)
{
 800d87c:	b580      	push	{r7, lr}
 800d87e:	b084      	sub	sp, #16
 800d880:	af00      	add	r7, sp, #0
 800d882:	6078      	str	r0, [r7, #4]
 800d884:	6039      	str	r1, [r7, #0]
 800d886:	e00f      	b.n	800d8a8 <releaseStatePayload+0x2c>
    while (rxstate->buffer_blocks != NULL)
    {
        CanardBufferBlock* const temp = rxstate->buffer_blocks->next;
 800d888:	683b      	ldr	r3, [r7, #0]
 800d88a:	685b      	ldr	r3, [r3, #4]
 800d88c:	681b      	ldr	r3, [r3, #0]
 800d88e:	60fb      	str	r3, [r7, #12]
        freeBlock(&ins->allocator, rxstate->buffer_blocks);
 800d890:	687b      	ldr	r3, [r7, #4]
 800d892:	f103 020c 	add.w	r2, r3, #12
 800d896:	683b      	ldr	r3, [r7, #0]
 800d898:	685b      	ldr	r3, [r3, #4]
 800d89a:	4610      	mov	r0, r2
 800d89c:	4619      	mov	r1, r3
 800d89e:	f000 fba9 	bl	800dff4 <freeBlock>
        rxstate->buffer_blocks = temp;
 800d8a2:	683b      	ldr	r3, [r7, #0]
 800d8a4:	68fa      	ldr	r2, [r7, #12]
 800d8a6:	605a      	str	r2, [r3, #4]
    return state;
}

CANARD_INTERNAL uint64_t releaseStatePayload(CanardInstance* ins, CanardRxState* rxstate)
{
    while (rxstate->buffer_blocks != NULL)
 800d8a8:	683b      	ldr	r3, [r7, #0]
 800d8aa:	685b      	ldr	r3, [r3, #4]
 800d8ac:	2b00      	cmp	r3, #0
 800d8ae:	d1eb      	bne.n	800d888 <releaseStatePayload+0xc>
    {
        CanardBufferBlock* const temp = rxstate->buffer_blocks->next;
        freeBlock(&ins->allocator, rxstate->buffer_blocks);
        rxstate->buffer_blocks = temp;
    }
    rxstate->payload_len = 0;
 800d8b0:	683a      	ldr	r2, [r7, #0]
 800d8b2:	8b13      	ldrh	r3, [r2, #24]
 800d8b4:	f36f 0309 	bfc	r3, #0, #10
 800d8b8:	8313      	strh	r3, [r2, #24]
    return CANARD_OK;
 800d8ba:	f04f 0200 	mov.w	r2, #0
 800d8be:	f04f 0300 	mov.w	r3, #0
}
 800d8c2:	4610      	mov	r0, r2
 800d8c4:	4619      	mov	r1, r3
 800d8c6:	3710      	adds	r7, #16
 800d8c8:	46bd      	mov	sp, r7
 800d8ca:	bd80      	pop	{r7, pc}

0800d8cc <bufferBlockPushBytes>:
 */
CANARD_INTERNAL int bufferBlockPushBytes(CanardPoolAllocator* allocator,
                                         CanardRxState* state,
                                         const uint8_t* data,
                                         uint8_t data_len)
{
 800d8cc:	b580      	push	{r7, lr}
 800d8ce:	b08a      	sub	sp, #40	; 0x28
 800d8d0:	af00      	add	r7, sp, #0
 800d8d2:	60f8      	str	r0, [r7, #12]
 800d8d4:	60b9      	str	r1, [r7, #8]
 800d8d6:	607a      	str	r2, [r7, #4]
 800d8d8:	70fb      	strb	r3, [r7, #3]
    uint16_t data_index = 0;
 800d8da:	2300      	movs	r3, #0
 800d8dc:	84fb      	strh	r3, [r7, #38]	; 0x26

    // if head is not full, add data to head
    if ((int) CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE - (int) state->payload_len > 0)
 800d8de:	68bb      	ldr	r3, [r7, #8]
 800d8e0:	8b1b      	ldrh	r3, [r3, #24]
 800d8e2:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d8e6:	b29b      	uxth	r3, r3
 800d8e8:	f1c3 0306 	rsb	r3, r3, #6
 800d8ec:	2b00      	cmp	r3, #0
 800d8ee:	dd36      	ble.n	800d95e <bufferBlockPushBytes+0x92>
    {
        for (uint16_t i = (uint16_t)state->payload_len;
 800d8f0:	68bb      	ldr	r3, [r7, #8]
 800d8f2:	8b1b      	ldrh	r3, [r3, #24]
 800d8f4:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d8f8:	b29b      	uxth	r3, r3
 800d8fa:	84bb      	strh	r3, [r7, #36]	; 0x24
 800d8fc:	e00e      	b.n	800d91c <bufferBlockPushBytes+0x50>
             i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE && data_index < data_len;
             i++, data_index++)
        {
            state->buffer_head[i] = data[data_index];
 800d8fe:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800d900:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800d902:	6879      	ldr	r1, [r7, #4]
 800d904:	440a      	add	r2, r1
 800d906:	7811      	ldrb	r1, [r2, #0]
 800d908:	68ba      	ldr	r2, [r7, #8]
 800d90a:	4413      	add	r3, r2
 800d90c:	460a      	mov	r2, r1
 800d90e:	769a      	strb	r2, [r3, #26]
    // if head is not full, add data to head
    if ((int) CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE - (int) state->payload_len > 0)
    {
        for (uint16_t i = (uint16_t)state->payload_len;
             i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE && data_index < data_len;
             i++, data_index++)
 800d910:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800d912:	3301      	adds	r3, #1
 800d914:	84bb      	strh	r3, [r7, #36]	; 0x24
 800d916:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800d918:	3301      	adds	r3, #1
 800d91a:	84fb      	strh	r3, [r7, #38]	; 0x26
    uint16_t data_index = 0;

    // if head is not full, add data to head
    if ((int) CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE - (int) state->payload_len > 0)
    {
        for (uint16_t i = (uint16_t)state->payload_len;
 800d91c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800d91e:	2b05      	cmp	r3, #5
 800d920:	d804      	bhi.n	800d92c <bufferBlockPushBytes+0x60>
             i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE && data_index < data_len;
 800d922:	78fb      	ldrb	r3, [r7, #3]
 800d924:	b29b      	uxth	r3, r3
 800d926:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800d928:	429a      	cmp	r2, r3
 800d92a:	d3e8      	bcc.n	800d8fe <bufferBlockPushBytes+0x32>
             i++, data_index++)
        {
            state->buffer_head[i] = data[data_index];
        }
        if (data_index >= data_len)
 800d92c:	78fb      	ldrb	r3, [r7, #3]
 800d92e:	b29b      	uxth	r3, r3
 800d930:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800d932:	429a      	cmp	r2, r3
 800d934:	d313      	bcc.n	800d95e <bufferBlockPushBytes+0x92>
        {
            state->payload_len += data_len;
 800d936:	68bb      	ldr	r3, [r7, #8]
 800d938:	8b1b      	ldrh	r3, [r3, #24]
 800d93a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d93e:	b29b      	uxth	r3, r3
 800d940:	461a      	mov	r2, r3
 800d942:	78fb      	ldrb	r3, [r7, #3]
 800d944:	b29b      	uxth	r3, r3
 800d946:	4413      	add	r3, r2
 800d948:	b29b      	uxth	r3, r3
 800d94a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d94e:	b299      	uxth	r1, r3
 800d950:	68ba      	ldr	r2, [r7, #8]
 800d952:	8b13      	ldrh	r3, [r2, #24]
 800d954:	f361 0309 	bfi	r3, r1, #0, #10
 800d958:	8313      	strh	r3, [r2, #24]
            return 1;
 800d95a:	2301      	movs	r3, #1
 800d95c:	e0ae      	b.n	800dabc <bufferBlockPushBytes+0x1f0>
        }
    } // head is full.

    uint8_t index_at_nth_block =
        (((state->payload_len) - CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) % CANARD_BUFFER_BLOCK_DATA_SIZE);
 800d95e:	68bb      	ldr	r3, [r7, #8]
 800d960:	8b1b      	ldrh	r3, [r3, #24]
 800d962:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d966:	b29b      	uxth	r3, r3
 800d968:	1f9a      	subs	r2, r3, #6
 800d96a:	0893      	lsrs	r3, r2, #2
 800d96c:	4955      	ldr	r1, [pc, #340]	; (800dac4 <bufferBlockPushBytes+0x1f8>)
 800d96e:	fba1 3103 	umull	r3, r1, r1, r3
 800d972:	460b      	mov	r3, r1
 800d974:	00db      	lsls	r3, r3, #3
 800d976:	1a5b      	subs	r3, r3, r1
 800d978:	009b      	lsls	r3, r3, #2
 800d97a:	1ad3      	subs	r3, r2, r3
            state->payload_len += data_len;
            return 1;
        }
    } // head is full.

    uint8_t index_at_nth_block =
 800d97c:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        (((state->payload_len) - CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) % CANARD_BUFFER_BLOCK_DATA_SIZE);

    // get to current block
    CanardBufferBlock* block = NULL;
 800d980:	2300      	movs	r3, #0
 800d982:	61fb      	str	r3, [r7, #28]

    // buffer blocks uninitialized
    if (state->buffer_blocks == NULL)
 800d984:	68bb      	ldr	r3, [r7, #8]
 800d986:	685b      	ldr	r3, [r3, #4]
 800d988:	2b00      	cmp	r3, #0
 800d98a:	d113      	bne.n	800d9b4 <bufferBlockPushBytes+0xe8>
    {
        state->buffer_blocks = createBufferBlock(allocator);
 800d98c:	68f8      	ldr	r0, [r7, #12]
 800d98e:	f000 f89b 	bl	800dac8 <createBufferBlock>
 800d992:	4602      	mov	r2, r0
 800d994:	68bb      	ldr	r3, [r7, #8]
 800d996:	605a      	str	r2, [r3, #4]

        if (state->buffer_blocks == NULL)
 800d998:	68bb      	ldr	r3, [r7, #8]
 800d99a:	685b      	ldr	r3, [r3, #4]
 800d99c:	2b00      	cmp	r3, #0
 800d99e:	d102      	bne.n	800d9a6 <bufferBlockPushBytes+0xda>
        {
            return -CANARD_ERROR_OUT_OF_MEMORY;
 800d9a0:	f06f 0302 	mvn.w	r3, #2
 800d9a4:	e08a      	b.n	800dabc <bufferBlockPushBytes+0x1f0>
        }

        block = state->buffer_blocks;
 800d9a6:	68bb      	ldr	r3, [r7, #8]
 800d9a8:	685b      	ldr	r3, [r3, #4]
 800d9aa:	61fb      	str	r3, [r7, #28]
        index_at_nth_block = 0;
 800d9ac:	2300      	movs	r3, #0
 800d9ae:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800d9b2:	e06b      	b.n	800da8c <bufferBlockPushBytes+0x1c0>
    }
    else
    {
        uint8_t nth_block = 1;
 800d9b4:	2301      	movs	r3, #1
 800d9b6:	76fb      	strb	r3, [r7, #27]

        // get to block
        block = state->buffer_blocks;
 800d9b8:	68bb      	ldr	r3, [r7, #8]
 800d9ba:	685b      	ldr	r3, [r3, #4]
 800d9bc:	61fb      	str	r3, [r7, #28]
 800d9be:	e005      	b.n	800d9cc <bufferBlockPushBytes+0x100>
        while (block->next != NULL)
        {
            nth_block++;
 800d9c0:	7efb      	ldrb	r3, [r7, #27]
 800d9c2:	3301      	adds	r3, #1
 800d9c4:	76fb      	strb	r3, [r7, #27]
            block = block->next;
 800d9c6:	69fb      	ldr	r3, [r7, #28]
 800d9c8:	681b      	ldr	r3, [r3, #0]
 800d9ca:	61fb      	str	r3, [r7, #28]
    {
        uint8_t nth_block = 1;

        // get to block
        block = state->buffer_blocks;
        while (block->next != NULL)
 800d9cc:	69fb      	ldr	r3, [r7, #28]
 800d9ce:	681b      	ldr	r3, [r3, #0]
 800d9d0:	2b00      	cmp	r3, #0
 800d9d2:	d1f5      	bne.n	800d9c0 <bufferBlockPushBytes+0xf4>
        {
            nth_block++;
            block = block->next;
        }

        const uint8_t num_buffer_blocks = (((state->payload_len + data_len) - CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) /
 800d9d4:	68bb      	ldr	r3, [r7, #8]
 800d9d6:	8b1b      	ldrh	r3, [r3, #24]
 800d9d8:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d9dc:	b29b      	uxth	r3, r3
 800d9de:	461a      	mov	r2, r3
 800d9e0:	78fb      	ldrb	r3, [r7, #3]
 800d9e2:	4413      	add	r3, r2
 800d9e4:	3b06      	subs	r3, #6
 800d9e6:	089b      	lsrs	r3, r3, #2
 800d9e8:	4a36      	ldr	r2, [pc, #216]	; (800dac4 <bufferBlockPushBytes+0x1f8>)
 800d9ea:	fba2 2303 	umull	r2, r3, r2, r3
 800d9ee:	b2db      	uxtb	r3, r3
 800d9f0:	3301      	adds	r3, #1
 800d9f2:	75fb      	strb	r3, [r7, #23]
                                           CANARD_BUFFER_BLOCK_DATA_SIZE) + 1;

        if (num_buffer_blocks > nth_block && index_at_nth_block == 0)
 800d9f4:	7dfa      	ldrb	r2, [r7, #23]
 800d9f6:	7efb      	ldrb	r3, [r7, #27]
 800d9f8:	429a      	cmp	r2, r3
 800d9fa:	d947      	bls.n	800da8c <bufferBlockPushBytes+0x1c0>
 800d9fc:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800da00:	2b00      	cmp	r3, #0
 800da02:	d143      	bne.n	800da8c <bufferBlockPushBytes+0x1c0>
        {
            block->next = createBufferBlock(allocator);
 800da04:	68f8      	ldr	r0, [r7, #12]
 800da06:	f000 f85f 	bl	800dac8 <createBufferBlock>
 800da0a:	4602      	mov	r2, r0
 800da0c:	69fb      	ldr	r3, [r7, #28]
 800da0e:	601a      	str	r2, [r3, #0]
            if (block->next == NULL)
 800da10:	69fb      	ldr	r3, [r7, #28]
 800da12:	681b      	ldr	r3, [r3, #0]
 800da14:	2b00      	cmp	r3, #0
 800da16:	d102      	bne.n	800da1e <bufferBlockPushBytes+0x152>
            {
                return -CANARD_ERROR_OUT_OF_MEMORY;
 800da18:	f06f 0302 	mvn.w	r3, #2
 800da1c:	e04e      	b.n	800dabc <bufferBlockPushBytes+0x1f0>
            }
            block = block->next;
 800da1e:	69fb      	ldr	r3, [r7, #28]
 800da20:	681b      	ldr	r3, [r3, #0]
 800da22:	61fb      	str	r3, [r7, #28]
 800da24:	e032      	b.n	800da8c <bufferBlockPushBytes+0x1c0>
    }

    // add data to current block until it becomes full, add new block if necessary
    while (data_index < data_len)
    {
        for (uint16_t i = index_at_nth_block;
 800da26:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800da2a:	833b      	strh	r3, [r7, #24]
 800da2c:	e00e      	b.n	800da4c <bufferBlockPushBytes+0x180>
             i < CANARD_BUFFER_BLOCK_DATA_SIZE && data_index < data_len;
             i++, data_index++)
        {
            block->data[i] = data[data_index];
 800da2e:	8b3b      	ldrh	r3, [r7, #24]
 800da30:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800da32:	6879      	ldr	r1, [r7, #4]
 800da34:	440a      	add	r2, r1
 800da36:	7811      	ldrb	r1, [r2, #0]
 800da38:	69fa      	ldr	r2, [r7, #28]
 800da3a:	4413      	add	r3, r2
 800da3c:	460a      	mov	r2, r1
 800da3e:	711a      	strb	r2, [r3, #4]
    // add data to current block until it becomes full, add new block if necessary
    while (data_index < data_len)
    {
        for (uint16_t i = index_at_nth_block;
             i < CANARD_BUFFER_BLOCK_DATA_SIZE && data_index < data_len;
             i++, data_index++)
 800da40:	8b3b      	ldrh	r3, [r7, #24]
 800da42:	3301      	adds	r3, #1
 800da44:	833b      	strh	r3, [r7, #24]
 800da46:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800da48:	3301      	adds	r3, #1
 800da4a:	84fb      	strh	r3, [r7, #38]	; 0x26
    }

    // add data to current block until it becomes full, add new block if necessary
    while (data_index < data_len)
    {
        for (uint16_t i = index_at_nth_block;
 800da4c:	8b3b      	ldrh	r3, [r7, #24]
 800da4e:	2b1b      	cmp	r3, #27
 800da50:	d804      	bhi.n	800da5c <bufferBlockPushBytes+0x190>
             i < CANARD_BUFFER_BLOCK_DATA_SIZE && data_index < data_len;
 800da52:	78fb      	ldrb	r3, [r7, #3]
 800da54:	b29b      	uxth	r3, r3
 800da56:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800da58:	429a      	cmp	r2, r3
 800da5a:	d3e8      	bcc.n	800da2e <bufferBlockPushBytes+0x162>
             i++, data_index++)
        {
            block->data[i] = data[data_index];
        }

        if (data_index < data_len)
 800da5c:	78fb      	ldrb	r3, [r7, #3]
 800da5e:	b29b      	uxth	r3, r3
 800da60:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800da62:	429a      	cmp	r2, r3
 800da64:	d212      	bcs.n	800da8c <bufferBlockPushBytes+0x1c0>
        {
            block->next = createBufferBlock(allocator);
 800da66:	68f8      	ldr	r0, [r7, #12]
 800da68:	f000 f82e 	bl	800dac8 <createBufferBlock>
 800da6c:	4602      	mov	r2, r0
 800da6e:	69fb      	ldr	r3, [r7, #28]
 800da70:	601a      	str	r2, [r3, #0]
            if (block->next == NULL)
 800da72:	69fb      	ldr	r3, [r7, #28]
 800da74:	681b      	ldr	r3, [r3, #0]
 800da76:	2b00      	cmp	r3, #0
 800da78:	d102      	bne.n	800da80 <bufferBlockPushBytes+0x1b4>
            {
                return -CANARD_ERROR_OUT_OF_MEMORY;
 800da7a:	f06f 0302 	mvn.w	r3, #2
 800da7e:	e01d      	b.n	800dabc <bufferBlockPushBytes+0x1f0>
            }
            block = block->next;
 800da80:	69fb      	ldr	r3, [r7, #28]
 800da82:	681b      	ldr	r3, [r3, #0]
 800da84:	61fb      	str	r3, [r7, #28]
            index_at_nth_block = 0;
 800da86:	2300      	movs	r3, #0
 800da88:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
            block = block->next;
        }
    }

    // add data to current block until it becomes full, add new block if necessary
    while (data_index < data_len)
 800da8c:	78fb      	ldrb	r3, [r7, #3]
 800da8e:	b29b      	uxth	r3, r3
 800da90:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800da92:	429a      	cmp	r2, r3
 800da94:	d3c7      	bcc.n	800da26 <bufferBlockPushBytes+0x15a>
            block = block->next;
            index_at_nth_block = 0;
        }
    }

    state->payload_len += data_len;
 800da96:	68bb      	ldr	r3, [r7, #8]
 800da98:	8b1b      	ldrh	r3, [r3, #24]
 800da9a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800da9e:	b29b      	uxth	r3, r3
 800daa0:	461a      	mov	r2, r3
 800daa2:	78fb      	ldrb	r3, [r7, #3]
 800daa4:	b29b      	uxth	r3, r3
 800daa6:	4413      	add	r3, r2
 800daa8:	b29b      	uxth	r3, r3
 800daaa:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800daae:	b299      	uxth	r1, r3
 800dab0:	68ba      	ldr	r2, [r7, #8]
 800dab2:	8b13      	ldrh	r3, [r2, #24]
 800dab4:	f361 0309 	bfi	r3, r1, #0, #10
 800dab8:	8313      	strh	r3, [r2, #24]

    return 1;
 800daba:	2301      	movs	r3, #1
}
 800dabc:	4618      	mov	r0, r3
 800dabe:	3728      	adds	r7, #40	; 0x28
 800dac0:	46bd      	mov	sp, r7
 800dac2:	bd80      	pop	{r7, pc}
 800dac4:	24924925 	.word	0x24924925

0800dac8 <createBufferBlock>:

CANARD_INTERNAL CanardBufferBlock* createBufferBlock(CanardPoolAllocator* allocator)
{
 800dac8:	b580      	push	{r7, lr}
 800daca:	b084      	sub	sp, #16
 800dacc:	af00      	add	r7, sp, #0
 800dace:	6078      	str	r0, [r7, #4]
    CanardBufferBlock* block = (CanardBufferBlock*) allocateBlock(allocator);
 800dad0:	6878      	ldr	r0, [r7, #4]
 800dad2:	f000 fa65 	bl	800dfa0 <allocateBlock>
 800dad6:	60f8      	str	r0, [r7, #12]
    if (block == NULL)
 800dad8:	68fb      	ldr	r3, [r7, #12]
 800dada:	2b00      	cmp	r3, #0
 800dadc:	d101      	bne.n	800dae2 <createBufferBlock+0x1a>
    {
        return NULL;
 800dade:	2300      	movs	r3, #0
 800dae0:	e003      	b.n	800daea <createBufferBlock+0x22>
    }
    block->next = NULL;
 800dae2:	68fb      	ldr	r3, [r7, #12]
 800dae4:	2200      	movs	r2, #0
 800dae6:	601a      	str	r2, [r3, #0]
    return block;
 800dae8:	68fb      	ldr	r3, [r7, #12]
}
 800daea:	4618      	mov	r0, r3
 800daec:	3710      	adds	r7, #16
 800daee:	46bd      	mov	sp, r7
 800daf0:	bd80      	pop	{r7, pc}
 800daf2:	bf00      	nop

0800daf4 <copyBitArray>:
/**
 * Bit array copy routine, originally developed by Ben Dyer for Libuavcan. Thanks Ben.
 */
void copyBitArray(const uint8_t* src, uint32_t src_offset, uint32_t src_len,
                        uint8_t* dst, uint32_t dst_offset)
{
 800daf4:	b480      	push	{r7}
 800daf6:	b089      	sub	sp, #36	; 0x24
 800daf8:	af00      	add	r7, sp, #0
 800dafa:	60f8      	str	r0, [r7, #12]
 800dafc:	60b9      	str	r1, [r7, #8]
 800dafe:	607a      	str	r2, [r7, #4]
 800db00:	603b      	str	r3, [r7, #0]
    CANARD_ASSERT(src_len > 0U);

    // Normalizing inputs
    src += src_offset / 8;
 800db02:	68bb      	ldr	r3, [r7, #8]
 800db04:	08db      	lsrs	r3, r3, #3
 800db06:	68fa      	ldr	r2, [r7, #12]
 800db08:	4413      	add	r3, r2
 800db0a:	60fb      	str	r3, [r7, #12]
    dst += dst_offset / 8;
 800db0c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800db0e:	08db      	lsrs	r3, r3, #3
 800db10:	683a      	ldr	r2, [r7, #0]
 800db12:	4413      	add	r3, r2
 800db14:	603b      	str	r3, [r7, #0]

    src_offset %= 8;
 800db16:	68bb      	ldr	r3, [r7, #8]
 800db18:	f003 0307 	and.w	r3, r3, #7
 800db1c:	60bb      	str	r3, [r7, #8]
    dst_offset %= 8;
 800db1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800db20:	f003 0307 	and.w	r3, r3, #7
 800db24:	62bb      	str	r3, [r7, #40]	; 0x28

    const size_t last_bit = src_offset + src_len;
 800db26:	68ba      	ldr	r2, [r7, #8]
 800db28:	687b      	ldr	r3, [r7, #4]
 800db2a:	4413      	add	r3, r2
 800db2c:	61fb      	str	r3, [r7, #28]
 800db2e:	e051      	b.n	800dbd4 <copyBitArray+0xe0>
    while (last_bit - src_offset)
    {
        const uint8_t src_bit_offset = (uint8_t)(src_offset % 8U);
 800db30:	68bb      	ldr	r3, [r7, #8]
 800db32:	b2db      	uxtb	r3, r3
 800db34:	f003 0307 	and.w	r3, r3, #7
 800db38:	76fb      	strb	r3, [r7, #27]
        const uint8_t dst_bit_offset = (uint8_t)(dst_offset % 8U);
 800db3a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800db3c:	b2db      	uxtb	r3, r3
 800db3e:	f003 0307 	and.w	r3, r3, #7
 800db42:	76bb      	strb	r3, [r7, #26]

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
 800db44:	7eba      	ldrb	r2, [r7, #26]
 800db46:	7efb      	ldrb	r3, [r7, #27]
 800db48:	4293      	cmp	r3, r2
 800db4a:	bf38      	it	cc
 800db4c:	4613      	movcc	r3, r2
 800db4e:	767b      	strb	r3, [r7, #25]
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);
 800db50:	7e7b      	ldrb	r3, [r7, #25]
 800db52:	f1c3 0208 	rsb	r2, r3, #8
 800db56:	69f9      	ldr	r1, [r7, #28]
 800db58:	68bb      	ldr	r3, [r7, #8]
 800db5a:	1acb      	subs	r3, r1, r3
 800db5c:	4293      	cmp	r3, r2
 800db5e:	bf28      	it	cs
 800db60:	4613      	movcs	r3, r2
 800db62:	617b      	str	r3, [r7, #20]

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
 800db64:	697b      	ldr	r3, [r7, #20]
 800db66:	f44f 427f 	mov.w	r2, #65280	; 0xff00
 800db6a:	fa22 f303 	lsr.w	r3, r2, r3
 800db6e:	b2db      	uxtb	r3, r3
 800db70:	461a      	mov	r2, r3
 800db72:	7ebb      	ldrb	r3, [r7, #26]
 800db74:	fa42 f303 	asr.w	r3, r2, r3
 800db78:	74fb      	strb	r3, [r7, #19]
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);
 800db7a:	68bb      	ldr	r3, [r7, #8]
 800db7c:	08db      	lsrs	r3, r3, #3
 800db7e:	68fa      	ldr	r2, [r7, #12]
 800db80:	4413      	add	r3, r2
 800db82:	781b      	ldrb	r3, [r3, #0]
 800db84:	461a      	mov	r2, r3
 800db86:	7efb      	ldrb	r3, [r7, #27]
 800db88:	409a      	lsls	r2, r3
 800db8a:	7ebb      	ldrb	r3, [r7, #26]
 800db8c:	fa42 f303 	asr.w	r3, r2, r3
 800db90:	74bb      	strb	r3, [r7, #18]

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));
 800db92:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800db94:	08db      	lsrs	r3, r3, #3
 800db96:	683a      	ldr	r2, [r7, #0]
 800db98:	4413      	add	r3, r2
 800db9a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800db9c:	08d2      	lsrs	r2, r2, #3
 800db9e:	6839      	ldr	r1, [r7, #0]
 800dba0:	440a      	add	r2, r1
 800dba2:	7812      	ldrb	r2, [r2, #0]
 800dba4:	b2d1      	uxtb	r1, r2
 800dba6:	7cfa      	ldrb	r2, [r7, #19]
 800dba8:	43d2      	mvns	r2, r2
 800dbaa:	b2d2      	uxtb	r2, r2
 800dbac:	400a      	ands	r2, r1
 800dbae:	b2d0      	uxtb	r0, r2
 800dbb0:	7cb9      	ldrb	r1, [r7, #18]
 800dbb2:	7cfa      	ldrb	r2, [r7, #19]
 800dbb4:	400a      	ands	r2, r1
 800dbb6:	b2d2      	uxtb	r2, r2
 800dbb8:	b2d2      	uxtb	r2, r2
 800dbba:	4601      	mov	r1, r0
 800dbbc:	430a      	orrs	r2, r1
 800dbbe:	b2d2      	uxtb	r2, r2
 800dbc0:	b2d2      	uxtb	r2, r2
 800dbc2:	701a      	strb	r2, [r3, #0]

        src_offset += copy_bits;
 800dbc4:	68ba      	ldr	r2, [r7, #8]
 800dbc6:	697b      	ldr	r3, [r7, #20]
 800dbc8:	4413      	add	r3, r2
 800dbca:	60bb      	str	r3, [r7, #8]
        dst_offset += copy_bits;
 800dbcc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800dbce:	697b      	ldr	r3, [r7, #20]
 800dbd0:	4413      	add	r3, r2
 800dbd2:	62bb      	str	r3, [r7, #40]	; 0x28

    src_offset %= 8;
    dst_offset %= 8;

    const size_t last_bit = src_offset + src_len;
    while (last_bit - src_offset)
 800dbd4:	69fa      	ldr	r2, [r7, #28]
 800dbd6:	68bb      	ldr	r3, [r7, #8]
 800dbd8:	429a      	cmp	r2, r3
 800dbda:	d1a9      	bne.n	800db30 <copyBitArray+0x3c>
        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));

        src_offset += copy_bits;
        dst_offset += copy_bits;
    }
}
 800dbdc:	3724      	adds	r7, #36	; 0x24
 800dbde:	46bd      	mov	sp, r7
 800dbe0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dbe4:	4770      	bx	lr
 800dbe6:	bf00      	nop

0800dbe8 <descatterTransferPayload>:

CANARD_INTERNAL int descatterTransferPayload(const CanardRxTransfer* transfer,
                                             uint32_t bit_offset,
                                             uint8_t bit_length,
                                             void* output)
{
 800dbe8:	b580      	push	{r7, lr}
 800dbea:	b090      	sub	sp, #64	; 0x40
 800dbec:	af02      	add	r7, sp, #8
 800dbee:	60f8      	str	r0, [r7, #12]
 800dbf0:	60b9      	str	r1, [r7, #8]
 800dbf2:	603b      	str	r3, [r7, #0]
 800dbf4:	4613      	mov	r3, r2
 800dbf6:	71fb      	strb	r3, [r7, #7]
    CANARD_ASSERT(transfer != 0);

    if (bit_offset >= transfer->payload_len * 8)
 800dbf8:	68fb      	ldr	r3, [r7, #12]
 800dbfa:	8a9b      	ldrh	r3, [r3, #20]
 800dbfc:	00db      	lsls	r3, r3, #3
 800dbfe:	461a      	mov	r2, r3
 800dc00:	68bb      	ldr	r3, [r7, #8]
 800dc02:	429a      	cmp	r2, r3
 800dc04:	d801      	bhi.n	800dc0a <descatterTransferPayload+0x22>
    {
        return 0;       // Out of range, reading zero bits
 800dc06:	2300      	movs	r3, #0
 800dc08:	e0da      	b.n	800ddc0 <descatterTransferPayload+0x1d8>
    }

    if (bit_offset + bit_length > transfer->payload_len * 8)
 800dc0a:	79fa      	ldrb	r2, [r7, #7]
 800dc0c:	68bb      	ldr	r3, [r7, #8]
 800dc0e:	4413      	add	r3, r2
 800dc10:	68fa      	ldr	r2, [r7, #12]
 800dc12:	8a92      	ldrh	r2, [r2, #20]
 800dc14:	00d2      	lsls	r2, r2, #3
 800dc16:	4293      	cmp	r3, r2
 800dc18:	d908      	bls.n	800dc2c <descatterTransferPayload+0x44>
    {
        bit_length = (uint8_t)(transfer->payload_len * 8 - bit_offset);
 800dc1a:	68fb      	ldr	r3, [r7, #12]
 800dc1c:	8a9b      	ldrh	r3, [r3, #20]
 800dc1e:	b2db      	uxtb	r3, r3
 800dc20:	00db      	lsls	r3, r3, #3
 800dc22:	b2da      	uxtb	r2, r3
 800dc24:	68bb      	ldr	r3, [r7, #8]
 800dc26:	b2db      	uxtb	r3, r3
 800dc28:	1ad3      	subs	r3, r2, r3
 800dc2a:	71fb      	strb	r3, [r7, #7]
    }

    CANARD_ASSERT(bit_length > 0);

    if ((transfer->payload_middle != NULL) || (transfer->payload_tail != NULL)) // Multi frame
 800dc2c:	68fb      	ldr	r3, [r7, #12]
 800dc2e:	68db      	ldr	r3, [r3, #12]
 800dc30:	2b00      	cmp	r3, #0
 800dc32:	d104      	bne.n	800dc3e <descatterTransferPayload+0x56>
 800dc34:	68fb      	ldr	r3, [r7, #12]
 800dc36:	691b      	ldr	r3, [r3, #16]
 800dc38:	2b00      	cmp	r3, #0
 800dc3a:	f000 80b6 	beq.w	800ddaa <descatterTransferPayload+0x1c2>
        /*
         * This part is hideously complicated and probably should be redesigned.
         * The objective here is to copy the requested number of bits from scattered storage into the temporary
         * local storage. We go through great pains to ensure that all corner cases are handled correctly.
         */
        uint32_t input_bit_offset = bit_offset;
 800dc3e:	68bb      	ldr	r3, [r7, #8]
 800dc40:	637b      	str	r3, [r7, #52]	; 0x34
        uint8_t output_bit_offset = 0;
 800dc42:	2300      	movs	r3, #0
 800dc44:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
        uint8_t remaining_bit_length = bit_length;
 800dc48:	79fb      	ldrb	r3, [r7, #7]
 800dc4a:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32

        // Reading head
        if (input_bit_offset < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8)
 800dc4e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dc50:	2b2f      	cmp	r3, #47	; 0x2f
 800dc52:	d827      	bhi.n	800dca4 <descatterTransferPayload+0xbc>
        {
            const uint8_t amount = MIN(remaining_bit_length,
 800dc54:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dc56:	f1c3 0230 	rsb	r2, r3, #48	; 0x30
 800dc5a:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800dc5e:	4293      	cmp	r3, r2
 800dc60:	bf28      	it	cs
 800dc62:	4613      	movcs	r3, r2
 800dc64:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
                                       CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8U - input_bit_offset);

            copyBitArray(&transfer->payload_head[0], input_bit_offset, amount, (uint8_t*) output, 0);
 800dc68:	68fb      	ldr	r3, [r7, #12]
 800dc6a:	6899      	ldr	r1, [r3, #8]
 800dc6c:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 800dc70:	2300      	movs	r3, #0
 800dc72:	9300      	str	r3, [sp, #0]
 800dc74:	4608      	mov	r0, r1
 800dc76:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800dc78:	683b      	ldr	r3, [r7, #0]
 800dc7a:	f7ff ff3b 	bl	800daf4 <copyBitArray>

            input_bit_offset += amount;
 800dc7e:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800dc82:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800dc84:	4413      	add	r3, r2
 800dc86:	637b      	str	r3, [r7, #52]	; 0x34
            output_bit_offset += amount;
 800dc88:	f897 2033 	ldrb.w	r2, [r7, #51]	; 0x33
 800dc8c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800dc90:	4413      	add	r3, r2
 800dc92:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
            remaining_bit_length -= amount;
 800dc96:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 800dc9a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800dc9e:	1ad3      	subs	r3, r2, r3
 800dca0:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
        }

        // Reading middle
        uint32_t remaining_bits = transfer->payload_len * 8U - CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8U;
 800dca4:	68fb      	ldr	r3, [r7, #12]
 800dca6:	8a9b      	ldrh	r3, [r3, #20]
 800dca8:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800dcac:	3b06      	subs	r3, #6
 800dcae:	00db      	lsls	r3, r3, #3
 800dcb0:	62fb      	str	r3, [r7, #44]	; 0x2c
        uint32_t block_bit_offset = CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8U;
 800dcb2:	2330      	movs	r3, #48	; 0x30
 800dcb4:	62bb      	str	r3, [r7, #40]	; 0x28
        const CanardBufferBlock* block = transfer->payload_middle;
 800dcb6:	68fb      	ldr	r3, [r7, #12]
 800dcb8:	68db      	ldr	r3, [r3, #12]
 800dcba:	627b      	str	r3, [r7, #36]	; 0x24
 800dcbc:	e046      	b.n	800dd4c <descatterTransferPayload+0x164>

        while ((block != NULL) && (remaining_bit_length > 0))
        {
            CANARD_ASSERT(remaining_bits > 0);
            const uint32_t block_end_bit_offset = block_bit_offset + MIN(CANARD_BUFFER_BLOCK_DATA_SIZE * 8,
 800dcbe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800dcc0:	2be0      	cmp	r3, #224	; 0xe0
 800dcc2:	bf28      	it	cs
 800dcc4:	23e0      	movcs	r3, #224	; 0xe0
 800dcc6:	461a      	mov	r2, r3
 800dcc8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800dcca:	4413      	add	r3, r2
 800dccc:	61fb      	str	r3, [r7, #28]
                                                                         remaining_bits);

            // Perform copy if we've reached the requested offset, otherwise jump over this block and try next
            if (block_end_bit_offset > input_bit_offset)
 800dcce:	69fa      	ldr	r2, [r7, #28]
 800dcd0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dcd2:	429a      	cmp	r2, r3
 800dcd4:	d92f      	bls.n	800dd36 <descatterTransferPayload+0x14e>
            {
                const uint8_t amount = (uint8_t) MIN(remaining_bit_length, block_end_bit_offset - input_bit_offset);
 800dcd6:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 800dcda:	69f9      	ldr	r1, [r7, #28]
 800dcdc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dcde:	1acb      	subs	r3, r1, r3
 800dce0:	429a      	cmp	r2, r3
 800dce2:	d306      	bcc.n	800dcf2 <descatterTransferPayload+0x10a>
 800dce4:	69fb      	ldr	r3, [r7, #28]
 800dce6:	b2da      	uxtb	r2, r3
 800dce8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dcea:	b2db      	uxtb	r3, r3
 800dcec:	1ad3      	subs	r3, r2, r3
 800dcee:	b2db      	uxtb	r3, r3
 800dcf0:	e001      	b.n	800dcf6 <descatterTransferPayload+0x10e>
 800dcf2:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800dcf6:	76fb      	strb	r3, [r7, #27]

                CANARD_ASSERT(input_bit_offset >= block_bit_offset);
                const uint32_t bit_offset_within_block = input_bit_offset - block_bit_offset;
 800dcf8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800dcfa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800dcfc:	1ad3      	subs	r3, r2, r3
 800dcfe:	617b      	str	r3, [r7, #20]

                copyBitArray(&block->data[0], bit_offset_within_block, amount, (uint8_t*) output, output_bit_offset);
 800dd00:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dd02:	1d19      	adds	r1, r3, #4
 800dd04:	7efa      	ldrb	r2, [r7, #27]
 800dd06:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800dd0a:	9300      	str	r3, [sp, #0]
 800dd0c:	4608      	mov	r0, r1
 800dd0e:	6979      	ldr	r1, [r7, #20]
 800dd10:	683b      	ldr	r3, [r7, #0]
 800dd12:	f7ff feef 	bl	800daf4 <copyBitArray>

                input_bit_offset += amount;
 800dd16:	7efb      	ldrb	r3, [r7, #27]
 800dd18:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800dd1a:	4413      	add	r3, r2
 800dd1c:	637b      	str	r3, [r7, #52]	; 0x34
                output_bit_offset += amount;
 800dd1e:	f897 2033 	ldrb.w	r2, [r7, #51]	; 0x33
 800dd22:	7efb      	ldrb	r3, [r7, #27]
 800dd24:	4413      	add	r3, r2
 800dd26:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
                remaining_bit_length -= amount;
 800dd2a:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 800dd2e:	7efb      	ldrb	r3, [r7, #27]
 800dd30:	1ad3      	subs	r3, r2, r3
 800dd32:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
            }

            CANARD_ASSERT(block_end_bit_offset > block_bit_offset);
            remaining_bits -= block_end_bit_offset - block_bit_offset;
 800dd36:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800dd38:	69fb      	ldr	r3, [r7, #28]
 800dd3a:	1ad3      	subs	r3, r2, r3
 800dd3c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800dd3e:	4413      	add	r3, r2
 800dd40:	62fb      	str	r3, [r7, #44]	; 0x2c
            block_bit_offset = block_end_bit_offset;
 800dd42:	69fb      	ldr	r3, [r7, #28]
 800dd44:	62bb      	str	r3, [r7, #40]	; 0x28
            block = block->next;
 800dd46:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dd48:	681b      	ldr	r3, [r3, #0]
 800dd4a:	627b      	str	r3, [r7, #36]	; 0x24
        // Reading middle
        uint32_t remaining_bits = transfer->payload_len * 8U - CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8U;
        uint32_t block_bit_offset = CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8U;
        const CanardBufferBlock* block = transfer->payload_middle;

        while ((block != NULL) && (remaining_bit_length > 0))
 800dd4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dd4e:	2b00      	cmp	r3, #0
 800dd50:	d003      	beq.n	800dd5a <descatterTransferPayload+0x172>
 800dd52:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800dd56:	2b00      	cmp	r3, #0
 800dd58:	d1b1      	bne.n	800dcbe <descatterTransferPayload+0xd6>
        }

        CANARD_ASSERT(remaining_bit_length <= remaining_bits);

        // Reading tail
        if ((transfer->payload_tail != NULL) && (remaining_bit_length > 0))
 800dd5a:	68fb      	ldr	r3, [r7, #12]
 800dd5c:	691b      	ldr	r3, [r3, #16]
 800dd5e:	2b00      	cmp	r3, #0
 800dd60:	d02d      	beq.n	800ddbe <descatterTransferPayload+0x1d6>
 800dd62:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800dd66:	2b00      	cmp	r3, #0
 800dd68:	d029      	beq.n	800ddbe <descatterTransferPayload+0x1d6>
        {
            CANARD_ASSERT(input_bit_offset >= block_bit_offset);
            const uint32_t offset = input_bit_offset - block_bit_offset;
 800dd6a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800dd6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800dd6e:	1ad3      	subs	r3, r2, r3
 800dd70:	613b      	str	r3, [r7, #16]

            copyBitArray(&transfer->payload_tail[0], offset, remaining_bit_length, (uint8_t*) output,
 800dd72:	68fb      	ldr	r3, [r7, #12]
 800dd74:	6919      	ldr	r1, [r3, #16]
 800dd76:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 800dd7a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800dd7e:	9300      	str	r3, [sp, #0]
 800dd80:	4608      	mov	r0, r1
 800dd82:	6939      	ldr	r1, [r7, #16]
 800dd84:	683b      	ldr	r3, [r7, #0]
 800dd86:	f7ff feb5 	bl	800daf4 <copyBitArray>
                         output_bit_offset);

            input_bit_offset += remaining_bit_length;
 800dd8a:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800dd8e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800dd90:	4413      	add	r3, r2
 800dd92:	637b      	str	r3, [r7, #52]	; 0x34
            output_bit_offset += remaining_bit_length;
 800dd94:	f897 2033 	ldrb.w	r2, [r7, #51]	; 0x33
 800dd98:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800dd9c:	4413      	add	r3, r2
 800dd9e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
            remaining_bit_length = 0;
 800dda2:	2300      	movs	r3, #0
 800dda4:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
 800dda8:	e009      	b.n	800ddbe <descatterTransferPayload+0x1d6>
        CANARD_ASSERT(output_bit_offset <= 64);
        CANARD_ASSERT(remaining_bit_length == 0);
    }
    else                                                                    // Single frame
    {
        copyBitArray(&transfer->payload_head[0], bit_offset, bit_length, (uint8_t*) output, 0);
 800ddaa:	68fb      	ldr	r3, [r7, #12]
 800ddac:	6899      	ldr	r1, [r3, #8]
 800ddae:	79fa      	ldrb	r2, [r7, #7]
 800ddb0:	2300      	movs	r3, #0
 800ddb2:	9300      	str	r3, [sp, #0]
 800ddb4:	4608      	mov	r0, r1
 800ddb6:	68b9      	ldr	r1, [r7, #8]
 800ddb8:	683b      	ldr	r3, [r7, #0]
 800ddba:	f7ff fe9b 	bl	800daf4 <copyBitArray>
    }

    return bit_length;
 800ddbe:	79fb      	ldrb	r3, [r7, #7]
}
 800ddc0:	4618      	mov	r0, r3
 800ddc2:	3738      	adds	r7, #56	; 0x38
 800ddc4:	46bd      	mov	sp, r7
 800ddc6:	bd80      	pop	{r7, pc}

0800ddc8 <isBigEndian>:

CANARD_INTERNAL bool isBigEndian(void)
{
 800ddc8:	b480      	push	{r7}
 800ddca:	b083      	sub	sp, #12
 800ddcc:	af00      	add	r7, sp, #0
    union
    {
        uint16_t a;
        uint8_t b[2];
    } u;
    u.a = 1;
 800ddce:	2301      	movs	r3, #1
 800ddd0:	80bb      	strh	r3, [r7, #4]
    return u.b[1] == 1;                             // Some don't...
 800ddd2:	797b      	ldrb	r3, [r7, #5]
 800ddd4:	2b01      	cmp	r3, #1
 800ddd6:	bf0c      	ite	eq
 800ddd8:	2301      	moveq	r3, #1
 800ddda:	2300      	movne	r3, #0
 800dddc:	b2db      	uxtb	r3, r3
#endif
}
 800ddde:	4618      	mov	r0, r3
 800dde0:	370c      	adds	r7, #12
 800dde2:	46bd      	mov	sp, r7
 800dde4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dde8:	4770      	bx	lr
 800ddea:	bf00      	nop

0800ddec <swapByteOrder>:

CANARD_INTERNAL void swapByteOrder(void* data, unsigned size)
{
 800ddec:	b480      	push	{r7}
 800ddee:	b087      	sub	sp, #28
 800ddf0:	af00      	add	r7, sp, #0
 800ddf2:	6078      	str	r0, [r7, #4]
 800ddf4:	6039      	str	r1, [r7, #0]
    CANARD_ASSERT(data != NULL);

    uint8_t* const bytes = (uint8_t*) data;
 800ddf6:	687b      	ldr	r3, [r7, #4]
 800ddf8:	60fb      	str	r3, [r7, #12]

    unsigned fwd = 0;
 800ddfa:	2300      	movs	r3, #0
 800ddfc:	617b      	str	r3, [r7, #20]
    unsigned rev = size - 1;
 800ddfe:	683b      	ldr	r3, [r7, #0]
 800de00:	3b01      	subs	r3, #1
 800de02:	613b      	str	r3, [r7, #16]
 800de04:	e017      	b.n	800de36 <swapByteOrder+0x4a>

    while (fwd < rev)
    {
        const uint8_t x = bytes[fwd];
 800de06:	68fa      	ldr	r2, [r7, #12]
 800de08:	697b      	ldr	r3, [r7, #20]
 800de0a:	4413      	add	r3, r2
 800de0c:	781b      	ldrb	r3, [r3, #0]
 800de0e:	72fb      	strb	r3, [r7, #11]
        bytes[fwd] = bytes[rev];
 800de10:	68fa      	ldr	r2, [r7, #12]
 800de12:	697b      	ldr	r3, [r7, #20]
 800de14:	4413      	add	r3, r2
 800de16:	68f9      	ldr	r1, [r7, #12]
 800de18:	693a      	ldr	r2, [r7, #16]
 800de1a:	440a      	add	r2, r1
 800de1c:	7812      	ldrb	r2, [r2, #0]
 800de1e:	701a      	strb	r2, [r3, #0]
        bytes[rev] = x;
 800de20:	68fa      	ldr	r2, [r7, #12]
 800de22:	693b      	ldr	r3, [r7, #16]
 800de24:	4413      	add	r3, r2
 800de26:	7afa      	ldrb	r2, [r7, #11]
 800de28:	701a      	strb	r2, [r3, #0]
        fwd++;
 800de2a:	697b      	ldr	r3, [r7, #20]
 800de2c:	3301      	adds	r3, #1
 800de2e:	617b      	str	r3, [r7, #20]
        rev--;
 800de30:	693b      	ldr	r3, [r7, #16]
 800de32:	3b01      	subs	r3, #1
 800de34:	613b      	str	r3, [r7, #16]
    uint8_t* const bytes = (uint8_t*) data;

    unsigned fwd = 0;
    unsigned rev = size - 1;

    while (fwd < rev)
 800de36:	697a      	ldr	r2, [r7, #20]
 800de38:	693b      	ldr	r3, [r7, #16]
 800de3a:	429a      	cmp	r2, r3
 800de3c:	d3e3      	bcc.n	800de06 <swapByteOrder+0x1a>
        bytes[fwd] = bytes[rev];
        bytes[rev] = x;
        fwd++;
        rev--;
    }
}
 800de3e:	371c      	adds	r7, #28
 800de40:	46bd      	mov	sp, r7
 800de42:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de46:	4770      	bx	lr

0800de48 <crcAddByte>:

/*
 * CRC functions
 */
CANARD_INTERNAL uint16_t crcAddByte(uint16_t crc_val, uint8_t byte)
{
 800de48:	b480      	push	{r7}
 800de4a:	b085      	sub	sp, #20
 800de4c:	af00      	add	r7, sp, #0
 800de4e:	4603      	mov	r3, r0
 800de50:	460a      	mov	r2, r1
 800de52:	80fb      	strh	r3, [r7, #6]
 800de54:	4613      	mov	r3, r2
 800de56:	717b      	strb	r3, [r7, #5]
    crc_val ^= (uint16_t) ((uint16_t) (byte) << 8);
 800de58:	797b      	ldrb	r3, [r7, #5]
 800de5a:	b29b      	uxth	r3, r3
 800de5c:	021b      	lsls	r3, r3, #8
 800de5e:	b29a      	uxth	r2, r3
 800de60:	88fb      	ldrh	r3, [r7, #6]
 800de62:	4053      	eors	r3, r2
 800de64:	80fb      	strh	r3, [r7, #6]
    for (int j = 0; j < 8; j++)
 800de66:	2300      	movs	r3, #0
 800de68:	60fb      	str	r3, [r7, #12]
 800de6a:	e012      	b.n	800de92 <crcAddByte+0x4a>
    {
        if (crc_val & 0x8000U)
 800de6c:	88fb      	ldrh	r3, [r7, #6]
 800de6e:	b21b      	sxth	r3, r3
 800de70:	2b00      	cmp	r3, #0
 800de72:	da08      	bge.n	800de86 <crcAddByte+0x3e>
        {
            crc_val = (uint16_t) ((uint16_t) (crc_val << 1) ^ 0x1021U);
 800de74:	88fb      	ldrh	r3, [r7, #6]
 800de76:	005b      	lsls	r3, r3, #1
 800de78:	b29b      	uxth	r3, r3
 800de7a:	f483 5381 	eor.w	r3, r3, #4128	; 0x1020
 800de7e:	f083 0301 	eor.w	r3, r3, #1
 800de82:	80fb      	strh	r3, [r7, #6]
 800de84:	e002      	b.n	800de8c <crcAddByte+0x44>
        }
        else
        {
            crc_val = (uint16_t) (crc_val << 1);
 800de86:	88fb      	ldrh	r3, [r7, #6]
 800de88:	005b      	lsls	r3, r3, #1
 800de8a:	80fb      	strh	r3, [r7, #6]
 * CRC functions
 */
CANARD_INTERNAL uint16_t crcAddByte(uint16_t crc_val, uint8_t byte)
{
    crc_val ^= (uint16_t) ((uint16_t) (byte) << 8);
    for (int j = 0; j < 8; j++)
 800de8c:	68fb      	ldr	r3, [r7, #12]
 800de8e:	3301      	adds	r3, #1
 800de90:	60fb      	str	r3, [r7, #12]
 800de92:	68fb      	ldr	r3, [r7, #12]
 800de94:	2b07      	cmp	r3, #7
 800de96:	dde9      	ble.n	800de6c <crcAddByte+0x24>
        else
        {
            crc_val = (uint16_t) (crc_val << 1);
        }
    }
    return crc_val;
 800de98:	88fb      	ldrh	r3, [r7, #6]
}
 800de9a:	4618      	mov	r0, r3
 800de9c:	3714      	adds	r7, #20
 800de9e:	46bd      	mov	sp, r7
 800dea0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dea4:	4770      	bx	lr
 800dea6:	bf00      	nop

0800dea8 <crcAddSignature>:

CANARD_INTERNAL uint16_t crcAddSignature(uint16_t crc_val, uint64_t data_type_signature)
{
 800dea8:	b5f0      	push	{r4, r5, r6, r7, lr}
 800deaa:	b087      	sub	sp, #28
 800deac:	af00      	add	r7, sp, #0
 800deae:	4601      	mov	r1, r0
 800deb0:	e9c7 2300 	strd	r2, r3, [r7]
 800deb4:	460b      	mov	r3, r1
 800deb6:	81fb      	strh	r3, [r7, #14]
    for (int shift_val = 0; shift_val < 64; shift_val += 8)
 800deb8:	2300      	movs	r3, #0
 800deba:	617b      	str	r3, [r7, #20]
 800debc:	e01b      	b.n	800def6 <crcAddSignature+0x4e>
    {
        crc_val = crcAddByte(crc_val, (uint8_t) (data_type_signature >> shift_val));
 800debe:	e9d7 2300 	ldrd	r2, r3, [r7]
 800dec2:	6979      	ldr	r1, [r7, #20]
 800dec4:	f1c1 0620 	rsb	r6, r1, #32
 800dec8:	f1a1 0020 	sub.w	r0, r1, #32
 800decc:	fa22 f401 	lsr.w	r4, r2, r1
 800ded0:	fa03 f606 	lsl.w	r6, r3, r6
 800ded4:	4334      	orrs	r4, r6
 800ded6:	fa23 f000 	lsr.w	r0, r3, r0
 800deda:	4304      	orrs	r4, r0
 800dedc:	fa23 f501 	lsr.w	r5, r3, r1
 800dee0:	b2e3      	uxtb	r3, r4
 800dee2:	89fa      	ldrh	r2, [r7, #14]
 800dee4:	4610      	mov	r0, r2
 800dee6:	4619      	mov	r1, r3
 800dee8:	f7ff ffae 	bl	800de48 <crcAddByte>
 800deec:	4603      	mov	r3, r0
 800deee:	81fb      	strh	r3, [r7, #14]
    return crc_val;
}

CANARD_INTERNAL uint16_t crcAddSignature(uint16_t crc_val, uint64_t data_type_signature)
{
    for (int shift_val = 0; shift_val < 64; shift_val += 8)
 800def0:	697b      	ldr	r3, [r7, #20]
 800def2:	3308      	adds	r3, #8
 800def4:	617b      	str	r3, [r7, #20]
 800def6:	697b      	ldr	r3, [r7, #20]
 800def8:	2b3f      	cmp	r3, #63	; 0x3f
 800defa:	dde0      	ble.n	800debe <crcAddSignature+0x16>
    {
        crc_val = crcAddByte(crc_val, (uint8_t) (data_type_signature >> shift_val));
    }
    return crc_val;
 800defc:	89fb      	ldrh	r3, [r7, #14]
}
 800defe:	4618      	mov	r0, r3
 800df00:	371c      	adds	r7, #28
 800df02:	46bd      	mov	sp, r7
 800df04:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800df06:	bf00      	nop

0800df08 <crcAdd>:

CANARD_INTERNAL uint16_t crcAdd(uint16_t crc_val, const uint8_t* bytes, size_t len)
{
 800df08:	b580      	push	{r7, lr}
 800df0a:	b084      	sub	sp, #16
 800df0c:	af00      	add	r7, sp, #0
 800df0e:	4603      	mov	r3, r0
 800df10:	60b9      	str	r1, [r7, #8]
 800df12:	607a      	str	r2, [r7, #4]
 800df14:	81fb      	strh	r3, [r7, #14]
 800df16:	e00a      	b.n	800df2e <crcAdd+0x26>
    while (len--)
    {
        crc_val = crcAddByte(crc_val, *bytes++);
 800df18:	68bb      	ldr	r3, [r7, #8]
 800df1a:	1c5a      	adds	r2, r3, #1
 800df1c:	60ba      	str	r2, [r7, #8]
 800df1e:	781b      	ldrb	r3, [r3, #0]
 800df20:	89fa      	ldrh	r2, [r7, #14]
 800df22:	4610      	mov	r0, r2
 800df24:	4619      	mov	r1, r3
 800df26:	f7ff ff8f 	bl	800de48 <crcAddByte>
 800df2a:	4603      	mov	r3, r0
 800df2c:	81fb      	strh	r3, [r7, #14]
    return crc_val;
}

CANARD_INTERNAL uint16_t crcAdd(uint16_t crc_val, const uint8_t* bytes, size_t len)
{
    while (len--)
 800df2e:	687b      	ldr	r3, [r7, #4]
 800df30:	1e5a      	subs	r2, r3, #1
 800df32:	607a      	str	r2, [r7, #4]
 800df34:	2b00      	cmp	r3, #0
 800df36:	d1ef      	bne.n	800df18 <crcAdd+0x10>
    {
        crc_val = crcAddByte(crc_val, *bytes++);
    }
    return crc_val;
 800df38:	89fb      	ldrh	r3, [r7, #14]
}
 800df3a:	4618      	mov	r0, r3
 800df3c:	3710      	adds	r7, #16
 800df3e:	46bd      	mov	sp, r7
 800df40:	bd80      	pop	{r7, pc}
 800df42:	bf00      	nop

0800df44 <initPoolAllocator>:
 *  Pool Allocator functions
 */
CANARD_INTERNAL void initPoolAllocator(CanardPoolAllocator* allocator,
                                       CanardPoolAllocatorBlock* buf,
                                       uint16_t buf_len)
{
 800df44:	b480      	push	{r7}
 800df46:	b087      	sub	sp, #28
 800df48:	af00      	add	r7, sp, #0
 800df4a:	60f8      	str	r0, [r7, #12]
 800df4c:	60b9      	str	r1, [r7, #8]
 800df4e:	4613      	mov	r3, r2
 800df50:	80fb      	strh	r3, [r7, #6]
    size_t current_index = 0;
 800df52:	2300      	movs	r3, #0
 800df54:	617b      	str	r3, [r7, #20]
    CanardPoolAllocatorBlock** current_block = &(allocator->free_list);
 800df56:	68fb      	ldr	r3, [r7, #12]
 800df58:	613b      	str	r3, [r7, #16]
 800df5a:	e00b      	b.n	800df74 <initPoolAllocator+0x30>
    while (current_index < buf_len)
    {
        *current_block = &buf[current_index];
 800df5c:	697b      	ldr	r3, [r7, #20]
 800df5e:	015b      	lsls	r3, r3, #5
 800df60:	68ba      	ldr	r2, [r7, #8]
 800df62:	441a      	add	r2, r3
 800df64:	693b      	ldr	r3, [r7, #16]
 800df66:	601a      	str	r2, [r3, #0]
        current_block = &((*current_block)->next);
 800df68:	693b      	ldr	r3, [r7, #16]
 800df6a:	681b      	ldr	r3, [r3, #0]
 800df6c:	613b      	str	r3, [r7, #16]
        current_index++;
 800df6e:	697b      	ldr	r3, [r7, #20]
 800df70:	3301      	adds	r3, #1
 800df72:	617b      	str	r3, [r7, #20]
                                       CanardPoolAllocatorBlock* buf,
                                       uint16_t buf_len)
{
    size_t current_index = 0;
    CanardPoolAllocatorBlock** current_block = &(allocator->free_list);
    while (current_index < buf_len)
 800df74:	88fa      	ldrh	r2, [r7, #6]
 800df76:	697b      	ldr	r3, [r7, #20]
 800df78:	429a      	cmp	r2, r3
 800df7a:	d8ef      	bhi.n	800df5c <initPoolAllocator+0x18>
    {
        *current_block = &buf[current_index];
        current_block = &((*current_block)->next);
        current_index++;
    }
    *current_block = NULL;
 800df7c:	693b      	ldr	r3, [r7, #16]
 800df7e:	2200      	movs	r2, #0
 800df80:	601a      	str	r2, [r3, #0]

    allocator->statistics.capacity_blocks = buf_len;
 800df82:	68fb      	ldr	r3, [r7, #12]
 800df84:	88fa      	ldrh	r2, [r7, #6]
 800df86:	809a      	strh	r2, [r3, #4]
    allocator->statistics.current_usage_blocks = 0;
 800df88:	68fb      	ldr	r3, [r7, #12]
 800df8a:	2200      	movs	r2, #0
 800df8c:	80da      	strh	r2, [r3, #6]
    allocator->statistics.peak_usage_blocks = 0;
 800df8e:	68fb      	ldr	r3, [r7, #12]
 800df90:	2200      	movs	r2, #0
 800df92:	811a      	strh	r2, [r3, #8]
}
 800df94:	371c      	adds	r7, #28
 800df96:	46bd      	mov	sp, r7
 800df98:	f85d 7b04 	ldr.w	r7, [sp], #4
 800df9c:	4770      	bx	lr
 800df9e:	bf00      	nop

0800dfa0 <allocateBlock>:

CANARD_INTERNAL void* allocateBlock(CanardPoolAllocator* allocator)
{
 800dfa0:	b480      	push	{r7}
 800dfa2:	b085      	sub	sp, #20
 800dfa4:	af00      	add	r7, sp, #0
 800dfa6:	6078      	str	r0, [r7, #4]
    // Check if there are any blocks available in the free list.
    if (allocator->free_list == NULL)
 800dfa8:	687b      	ldr	r3, [r7, #4]
 800dfaa:	681b      	ldr	r3, [r3, #0]
 800dfac:	2b00      	cmp	r3, #0
 800dfae:	d101      	bne.n	800dfb4 <allocateBlock+0x14>
    {
        return NULL;
 800dfb0:	2300      	movs	r3, #0
 800dfb2:	e018      	b.n	800dfe6 <allocateBlock+0x46>
    }

    // Take first available block and prepares next block for use.
    void* result = allocator->free_list;
 800dfb4:	687b      	ldr	r3, [r7, #4]
 800dfb6:	681b      	ldr	r3, [r3, #0]
 800dfb8:	60fb      	str	r3, [r7, #12]
    allocator->free_list = allocator->free_list->next;
 800dfba:	687b      	ldr	r3, [r7, #4]
 800dfbc:	681b      	ldr	r3, [r3, #0]
 800dfbe:	681a      	ldr	r2, [r3, #0]
 800dfc0:	687b      	ldr	r3, [r7, #4]
 800dfc2:	601a      	str	r2, [r3, #0]

    // Update statistics
    allocator->statistics.current_usage_blocks++;
 800dfc4:	687b      	ldr	r3, [r7, #4]
 800dfc6:	88db      	ldrh	r3, [r3, #6]
 800dfc8:	3301      	adds	r3, #1
 800dfca:	b29a      	uxth	r2, r3
 800dfcc:	687b      	ldr	r3, [r7, #4]
 800dfce:	80da      	strh	r2, [r3, #6]
    if (allocator->statistics.peak_usage_blocks < allocator->statistics.current_usage_blocks)
 800dfd0:	687b      	ldr	r3, [r7, #4]
 800dfd2:	891a      	ldrh	r2, [r3, #8]
 800dfd4:	687b      	ldr	r3, [r7, #4]
 800dfd6:	88db      	ldrh	r3, [r3, #6]
 800dfd8:	429a      	cmp	r2, r3
 800dfda:	d203      	bcs.n	800dfe4 <allocateBlock+0x44>
    {
        allocator->statistics.peak_usage_blocks = allocator->statistics.current_usage_blocks;
 800dfdc:	687b      	ldr	r3, [r7, #4]
 800dfde:	88da      	ldrh	r2, [r3, #6]
 800dfe0:	687b      	ldr	r3, [r7, #4]
 800dfe2:	811a      	strh	r2, [r3, #8]
    }

    return result;
 800dfe4:	68fb      	ldr	r3, [r7, #12]
}
 800dfe6:	4618      	mov	r0, r3
 800dfe8:	3714      	adds	r7, #20
 800dfea:	46bd      	mov	sp, r7
 800dfec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dff0:	4770      	bx	lr
 800dff2:	bf00      	nop

0800dff4 <freeBlock>:

CANARD_INTERNAL void freeBlock(CanardPoolAllocator* allocator, void* p)
{
 800dff4:	b480      	push	{r7}
 800dff6:	b085      	sub	sp, #20
 800dff8:	af00      	add	r7, sp, #0
 800dffa:	6078      	str	r0, [r7, #4]
 800dffc:	6039      	str	r1, [r7, #0]
    CanardPoolAllocatorBlock* block = (CanardPoolAllocatorBlock*) p;
 800dffe:	683b      	ldr	r3, [r7, #0]
 800e000:	60fb      	str	r3, [r7, #12]

    block->next = allocator->free_list;
 800e002:	687b      	ldr	r3, [r7, #4]
 800e004:	681a      	ldr	r2, [r3, #0]
 800e006:	68fb      	ldr	r3, [r7, #12]
 800e008:	601a      	str	r2, [r3, #0]
    allocator->free_list = block;
 800e00a:	687b      	ldr	r3, [r7, #4]
 800e00c:	68fa      	ldr	r2, [r7, #12]
 800e00e:	601a      	str	r2, [r3, #0]

    CANARD_ASSERT(allocator->statistics.current_usage_blocks > 0);
    allocator->statistics.current_usage_blocks--;
 800e010:	687b      	ldr	r3, [r7, #4]
 800e012:	88db      	ldrh	r3, [r3, #6]
 800e014:	3b01      	subs	r3, #1
 800e016:	b29a      	uxth	r2, r3
 800e018:	687b      	ldr	r3, [r7, #4]
 800e01a:	80da      	strh	r2, [r3, #6]
}
 800e01c:	3714      	adds	r7, #20
 800e01e:	46bd      	mov	sp, r7
 800e020:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e024:	4770      	bx	lr
 800e026:	bf00      	nop

0800e028 <encode_func.lto_priv.48>:
#include <uavcan.protocol.NodeStatus.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800e028:	b580      	push	{r7, lr}
 800e02a:	b084      	sub	sp, #16
 800e02c:	af00      	add	r7, sp, #0
 800e02e:	60f8      	str	r0, [r7, #12]
 800e030:	60b9      	str	r1, [r7, #8]
 800e032:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_NodeStatus(msg, chunk_cb, ctx);
 800e034:	68f8      	ldr	r0, [r7, #12]
 800e036:	68b9      	ldr	r1, [r7, #8]
 800e038:	687a      	ldr	r2, [r7, #4]
 800e03a:	f000 f811 	bl	800e060 <encode_uavcan_protocol_NodeStatus>
}
 800e03e:	3710      	adds	r7, #16
 800e040:	46bd      	mov	sp, r7
 800e042:	bd80      	pop	{r7, pc}

0800e044 <decode_func.lto_priv.56>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800e044:	b580      	push	{r7, lr}
 800e046:	b082      	sub	sp, #8
 800e048:	af00      	add	r7, sp, #0
 800e04a:	6078      	str	r0, [r7, #4]
 800e04c:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_NodeStatus(transfer, msg);
 800e04e:	6878      	ldr	r0, [r7, #4]
 800e050:	6839      	ldr	r1, [r7, #0]
 800e052:	f000 f819 	bl	800e088 <decode_uavcan_protocol_NodeStatus>
 800e056:	4603      	mov	r3, r0
}
 800e058:	4618      	mov	r0, r3
 800e05a:	3708      	adds	r7, #8
 800e05c:	46bd      	mov	sp, r7
 800e05e:	bd80      	pop	{r7, pc}

0800e060 <encode_uavcan_protocol_NodeStatus>:
    encode_func,
    decode_func,
    NULL
};

void encode_uavcan_protocol_NodeStatus(struct uavcan_protocol_NodeStatus_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800e060:	b580      	push	{r7, lr}
 800e062:	b088      	sub	sp, #32
 800e064:	af02      	add	r7, sp, #8
 800e066:	60f8      	str	r0, [r7, #12]
 800e068:	60b9      	str	r1, [r7, #8]
 800e06a:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_NodeStatus(buffer, msg, chunk_cb, ctx, true);
 800e06c:	f107 0210 	add.w	r2, r7, #16
 800e070:	2301      	movs	r3, #1
 800e072:	9300      	str	r3, [sp, #0]
 800e074:	4610      	mov	r0, r2
 800e076:	68f9      	ldr	r1, [r7, #12]
 800e078:	68ba      	ldr	r2, [r7, #8]
 800e07a:	687b      	ldr	r3, [r7, #4]
 800e07c:	f000 f81a 	bl	800e0b4 <_encode_uavcan_protocol_NodeStatus>
}
 800e080:	3718      	adds	r7, #24
 800e082:	46bd      	mov	sp, r7
 800e084:	bd80      	pop	{r7, pc}
 800e086:	bf00      	nop

0800e088 <decode_uavcan_protocol_NodeStatus>:

uint32_t decode_uavcan_protocol_NodeStatus(const CanardRxTransfer* transfer, struct uavcan_protocol_NodeStatus_s* msg) {
 800e088:	b580      	push	{r7, lr}
 800e08a:	b084      	sub	sp, #16
 800e08c:	af00      	add	r7, sp, #0
 800e08e:	6078      	str	r0, [r7, #4]
 800e090:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800e092:	2300      	movs	r3, #0
 800e094:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_NodeStatus(transfer, &bit_ofs, msg, true);
 800e096:	f107 030c 	add.w	r3, r7, #12
 800e09a:	6878      	ldr	r0, [r7, #4]
 800e09c:	4619      	mov	r1, r3
 800e09e:	683a      	ldr	r2, [r7, #0]
 800e0a0:	2301      	movs	r3, #1
 800e0a2:	f000 f865 	bl	800e170 <_decode_uavcan_protocol_NodeStatus>
    return (bit_ofs+7)/8;
 800e0a6:	68fb      	ldr	r3, [r7, #12]
 800e0a8:	3307      	adds	r3, #7
 800e0aa:	08db      	lsrs	r3, r3, #3
}
 800e0ac:	4618      	mov	r0, r3
 800e0ae:	3710      	adds	r7, #16
 800e0b0:	46bd      	mov	sp, r7
 800e0b2:	bd80      	pop	{r7, pc}

0800e0b4 <_encode_uavcan_protocol_NodeStatus>:

void _encode_uavcan_protocol_NodeStatus(uint8_t* buffer, struct uavcan_protocol_NodeStatus_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800e0b4:	b580      	push	{r7, lr}
 800e0b6:	b084      	sub	sp, #16
 800e0b8:	af00      	add	r7, sp, #0
 800e0ba:	60f8      	str	r0, [r7, #12]
 800e0bc:	60b9      	str	r1, [r7, #8]
 800e0be:	607a      	str	r2, [r7, #4]
 800e0c0:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
 800e0c2:	68f8      	ldr	r0, [r7, #12]
 800e0c4:	2100      	movs	r1, #0
 800e0c6:	2208      	movs	r2, #8
 800e0c8:	f000 fa80 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 32, &msg->uptime_sec);
 800e0cc:	68bb      	ldr	r3, [r7, #8]
 800e0ce:	68f8      	ldr	r0, [r7, #12]
 800e0d0:	2100      	movs	r1, #0
 800e0d2:	2220      	movs	r2, #32
 800e0d4:	f7ff fa02 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 32, ctx);
 800e0d8:	687b      	ldr	r3, [r7, #4]
 800e0da:	68f8      	ldr	r0, [r7, #12]
 800e0dc:	2120      	movs	r1, #32
 800e0de:	683a      	ldr	r2, [r7, #0]
 800e0e0:	4798      	blx	r3
    memset(buffer,0,8);
 800e0e2:	68f8      	ldr	r0, [r7, #12]
 800e0e4:	2100      	movs	r1, #0
 800e0e6:	2208      	movs	r2, #8
 800e0e8:	f000 fa70 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 2, &msg->health);
 800e0ec:	68bb      	ldr	r3, [r7, #8]
 800e0ee:	3304      	adds	r3, #4
 800e0f0:	68f8      	ldr	r0, [r7, #12]
 800e0f2:	2100      	movs	r1, #0
 800e0f4:	2202      	movs	r2, #2
 800e0f6:	f7ff f9f1 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 2, ctx);
 800e0fa:	687b      	ldr	r3, [r7, #4]
 800e0fc:	68f8      	ldr	r0, [r7, #12]
 800e0fe:	2102      	movs	r1, #2
 800e100:	683a      	ldr	r2, [r7, #0]
 800e102:	4798      	blx	r3
    memset(buffer,0,8);
 800e104:	68f8      	ldr	r0, [r7, #12]
 800e106:	2100      	movs	r1, #0
 800e108:	2208      	movs	r2, #8
 800e10a:	f000 fa5f 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 3, &msg->mode);
 800e10e:	68bb      	ldr	r3, [r7, #8]
 800e110:	3305      	adds	r3, #5
 800e112:	68f8      	ldr	r0, [r7, #12]
 800e114:	2100      	movs	r1, #0
 800e116:	2203      	movs	r2, #3
 800e118:	f7ff f9e0 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 3, ctx);
 800e11c:	687b      	ldr	r3, [r7, #4]
 800e11e:	68f8      	ldr	r0, [r7, #12]
 800e120:	2103      	movs	r1, #3
 800e122:	683a      	ldr	r2, [r7, #0]
 800e124:	4798      	blx	r3
    memset(buffer,0,8);
 800e126:	68f8      	ldr	r0, [r7, #12]
 800e128:	2100      	movs	r1, #0
 800e12a:	2208      	movs	r2, #8
 800e12c:	f000 fa4e 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 3, &msg->sub_mode);
 800e130:	68bb      	ldr	r3, [r7, #8]
 800e132:	3306      	adds	r3, #6
 800e134:	68f8      	ldr	r0, [r7, #12]
 800e136:	2100      	movs	r1, #0
 800e138:	2203      	movs	r2, #3
 800e13a:	f7ff f9cf 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 3, ctx);
 800e13e:	687b      	ldr	r3, [r7, #4]
 800e140:	68f8      	ldr	r0, [r7, #12]
 800e142:	2103      	movs	r1, #3
 800e144:	683a      	ldr	r2, [r7, #0]
 800e146:	4798      	blx	r3
    memset(buffer,0,8);
 800e148:	68f8      	ldr	r0, [r7, #12]
 800e14a:	2100      	movs	r1, #0
 800e14c:	2208      	movs	r2, #8
 800e14e:	f000 fa3d 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 16, &msg->vendor_specific_status_code);
 800e152:	68bb      	ldr	r3, [r7, #8]
 800e154:	3308      	adds	r3, #8
 800e156:	68f8      	ldr	r0, [r7, #12]
 800e158:	2100      	movs	r1, #0
 800e15a:	2210      	movs	r2, #16
 800e15c:	f7ff f9be 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 16, ctx);
 800e160:	687b      	ldr	r3, [r7, #4]
 800e162:	68f8      	ldr	r0, [r7, #12]
 800e164:	2110      	movs	r1, #16
 800e166:	683a      	ldr	r2, [r7, #0]
 800e168:	4798      	blx	r3
}
 800e16a:	3710      	adds	r7, #16
 800e16c:	46bd      	mov	sp, r7
 800e16e:	bd80      	pop	{r7, pc}

0800e170 <_decode_uavcan_protocol_NodeStatus>:

void _decode_uavcan_protocol_NodeStatus(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_NodeStatus_s* msg, bool tao) {
 800e170:	b580      	push	{r7, lr}
 800e172:	b086      	sub	sp, #24
 800e174:	af02      	add	r7, sp, #8
 800e176:	60f8      	str	r0, [r7, #12]
 800e178:	60b9      	str	r1, [r7, #8]
 800e17a:	607a      	str	r2, [r7, #4]
 800e17c:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 32, false, &msg->uptime_sec);
 800e17e:	68bb      	ldr	r3, [r7, #8]
 800e180:	681a      	ldr	r2, [r3, #0]
 800e182:	687b      	ldr	r3, [r7, #4]
 800e184:	9300      	str	r3, [sp, #0]
 800e186:	68f8      	ldr	r0, [r7, #12]
 800e188:	4611      	mov	r1, r2
 800e18a:	2220      	movs	r2, #32
 800e18c:	2300      	movs	r3, #0
 800e18e:	f7ff f82d 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 32;
 800e192:	68bb      	ldr	r3, [r7, #8]
 800e194:	681b      	ldr	r3, [r3, #0]
 800e196:	f103 0220 	add.w	r2, r3, #32
 800e19a:	68bb      	ldr	r3, [r7, #8]
 800e19c:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 2, false, &msg->health);
 800e19e:	68bb      	ldr	r3, [r7, #8]
 800e1a0:	681a      	ldr	r2, [r3, #0]
 800e1a2:	687b      	ldr	r3, [r7, #4]
 800e1a4:	3304      	adds	r3, #4
 800e1a6:	9300      	str	r3, [sp, #0]
 800e1a8:	68f8      	ldr	r0, [r7, #12]
 800e1aa:	4611      	mov	r1, r2
 800e1ac:	2202      	movs	r2, #2
 800e1ae:	2300      	movs	r3, #0
 800e1b0:	f7ff f81c 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 2;
 800e1b4:	68bb      	ldr	r3, [r7, #8]
 800e1b6:	681b      	ldr	r3, [r3, #0]
 800e1b8:	1c9a      	adds	r2, r3, #2
 800e1ba:	68bb      	ldr	r3, [r7, #8]
 800e1bc:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 3, false, &msg->mode);
 800e1be:	68bb      	ldr	r3, [r7, #8]
 800e1c0:	681a      	ldr	r2, [r3, #0]
 800e1c2:	687b      	ldr	r3, [r7, #4]
 800e1c4:	3305      	adds	r3, #5
 800e1c6:	9300      	str	r3, [sp, #0]
 800e1c8:	68f8      	ldr	r0, [r7, #12]
 800e1ca:	4611      	mov	r1, r2
 800e1cc:	2203      	movs	r2, #3
 800e1ce:	2300      	movs	r3, #0
 800e1d0:	f7ff f80c 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 3;
 800e1d4:	68bb      	ldr	r3, [r7, #8]
 800e1d6:	681b      	ldr	r3, [r3, #0]
 800e1d8:	1cda      	adds	r2, r3, #3
 800e1da:	68bb      	ldr	r3, [r7, #8]
 800e1dc:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 3, false, &msg->sub_mode);
 800e1de:	68bb      	ldr	r3, [r7, #8]
 800e1e0:	681a      	ldr	r2, [r3, #0]
 800e1e2:	687b      	ldr	r3, [r7, #4]
 800e1e4:	3306      	adds	r3, #6
 800e1e6:	9300      	str	r3, [sp, #0]
 800e1e8:	68f8      	ldr	r0, [r7, #12]
 800e1ea:	4611      	mov	r1, r2
 800e1ec:	2203      	movs	r2, #3
 800e1ee:	2300      	movs	r3, #0
 800e1f0:	f7fe fffc 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 3;
 800e1f4:	68bb      	ldr	r3, [r7, #8]
 800e1f6:	681b      	ldr	r3, [r3, #0]
 800e1f8:	1cda      	adds	r2, r3, #3
 800e1fa:	68bb      	ldr	r3, [r7, #8]
 800e1fc:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 16, false, &msg->vendor_specific_status_code);
 800e1fe:	68bb      	ldr	r3, [r7, #8]
 800e200:	681a      	ldr	r2, [r3, #0]
 800e202:	687b      	ldr	r3, [r7, #4]
 800e204:	3308      	adds	r3, #8
 800e206:	9300      	str	r3, [sp, #0]
 800e208:	68f8      	ldr	r0, [r7, #12]
 800e20a:	4611      	mov	r1, r2
 800e20c:	2210      	movs	r2, #16
 800e20e:	2300      	movs	r3, #0
 800e210:	f7fe ffec 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 16;
 800e214:	68bb      	ldr	r3, [r7, #8]
 800e216:	681b      	ldr	r3, [r3, #0]
 800e218:	f103 0210 	add.w	r2, r3, #16
 800e21c:	68bb      	ldr	r3, [r7, #8]
 800e21e:	601a      	str	r2, [r3, #0]

}
 800e220:	3710      	adds	r7, #16
 800e222:	46bd      	mov	sp, r7
 800e224:	bd80      	pop	{r7, pc}
 800e226:	bf00      	nop

0800e228 <encode_func.lto_priv.49>:
#include <uavcan.protocol.RestartNode_res.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800e228:	b580      	push	{r7, lr}
 800e22a:	b084      	sub	sp, #16
 800e22c:	af00      	add	r7, sp, #0
 800e22e:	60f8      	str	r0, [r7, #12]
 800e230:	60b9      	str	r1, [r7, #8]
 800e232:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_RestartNode_res(msg, chunk_cb, ctx);
 800e234:	68f8      	ldr	r0, [r7, #12]
 800e236:	68b9      	ldr	r1, [r7, #8]
 800e238:	687a      	ldr	r2, [r7, #4]
 800e23a:	f000 f811 	bl	800e260 <encode_uavcan_protocol_RestartNode_res>
}
 800e23e:	3710      	adds	r7, #16
 800e240:	46bd      	mov	sp, r7
 800e242:	bd80      	pop	{r7, pc}

0800e244 <decode_func.lto_priv.57>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800e244:	b580      	push	{r7, lr}
 800e246:	b082      	sub	sp, #8
 800e248:	af00      	add	r7, sp, #0
 800e24a:	6078      	str	r0, [r7, #4]
 800e24c:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_RestartNode_res(transfer, msg);
 800e24e:	6878      	ldr	r0, [r7, #4]
 800e250:	6839      	ldr	r1, [r7, #0]
 800e252:	f000 f819 	bl	800e288 <decode_uavcan_protocol_RestartNode_res>
 800e256:	4603      	mov	r3, r0
}
 800e258:	4618      	mov	r0, r3
 800e25a:	3708      	adds	r7, #8
 800e25c:	46bd      	mov	sp, r7
 800e25e:	bd80      	pop	{r7, pc}

0800e260 <encode_uavcan_protocol_RestartNode_res>:
    encode_func,
    decode_func,
    NULL
};

void encode_uavcan_protocol_RestartNode_res(struct uavcan_protocol_RestartNode_res_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800e260:	b580      	push	{r7, lr}
 800e262:	b088      	sub	sp, #32
 800e264:	af02      	add	r7, sp, #8
 800e266:	60f8      	str	r0, [r7, #12]
 800e268:	60b9      	str	r1, [r7, #8]
 800e26a:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_RestartNode_res(buffer, msg, chunk_cb, ctx, true);
 800e26c:	f107 0210 	add.w	r2, r7, #16
 800e270:	2301      	movs	r3, #1
 800e272:	9300      	str	r3, [sp, #0]
 800e274:	4610      	mov	r0, r2
 800e276:	68f9      	ldr	r1, [r7, #12]
 800e278:	68ba      	ldr	r2, [r7, #8]
 800e27a:	687b      	ldr	r3, [r7, #4]
 800e27c:	f000 f81a 	bl	800e2b4 <_encode_uavcan_protocol_RestartNode_res>
}
 800e280:	3718      	adds	r7, #24
 800e282:	46bd      	mov	sp, r7
 800e284:	bd80      	pop	{r7, pc}
 800e286:	bf00      	nop

0800e288 <decode_uavcan_protocol_RestartNode_res>:

uint32_t decode_uavcan_protocol_RestartNode_res(const CanardRxTransfer* transfer, struct uavcan_protocol_RestartNode_res_s* msg) {
 800e288:	b580      	push	{r7, lr}
 800e28a:	b084      	sub	sp, #16
 800e28c:	af00      	add	r7, sp, #0
 800e28e:	6078      	str	r0, [r7, #4]
 800e290:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800e292:	2300      	movs	r3, #0
 800e294:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_RestartNode_res(transfer, &bit_ofs, msg, true);
 800e296:	f107 030c 	add.w	r3, r7, #12
 800e29a:	6878      	ldr	r0, [r7, #4]
 800e29c:	4619      	mov	r1, r3
 800e29e:	683a      	ldr	r2, [r7, #0]
 800e2a0:	2301      	movs	r3, #1
 800e2a2:	f000 f821 	bl	800e2e8 <_decode_uavcan_protocol_RestartNode_res>
    return (bit_ofs+7)/8;
 800e2a6:	68fb      	ldr	r3, [r7, #12]
 800e2a8:	3307      	adds	r3, #7
 800e2aa:	08db      	lsrs	r3, r3, #3
}
 800e2ac:	4618      	mov	r0, r3
 800e2ae:	3710      	adds	r7, #16
 800e2b0:	46bd      	mov	sp, r7
 800e2b2:	bd80      	pop	{r7, pc}

0800e2b4 <_encode_uavcan_protocol_RestartNode_res>:

void _encode_uavcan_protocol_RestartNode_res(uint8_t* buffer, struct uavcan_protocol_RestartNode_res_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800e2b4:	b580      	push	{r7, lr}
 800e2b6:	b084      	sub	sp, #16
 800e2b8:	af00      	add	r7, sp, #0
 800e2ba:	60f8      	str	r0, [r7, #12]
 800e2bc:	60b9      	str	r1, [r7, #8]
 800e2be:	607a      	str	r2, [r7, #4]
 800e2c0:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
 800e2c2:	68f8      	ldr	r0, [r7, #12]
 800e2c4:	2100      	movs	r1, #0
 800e2c6:	2208      	movs	r2, #8
 800e2c8:	f000 f980 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 1, &msg->ok);
 800e2cc:	68bb      	ldr	r3, [r7, #8]
 800e2ce:	68f8      	ldr	r0, [r7, #12]
 800e2d0:	2100      	movs	r1, #0
 800e2d2:	2201      	movs	r2, #1
 800e2d4:	f7ff f902 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 1, ctx);
 800e2d8:	687b      	ldr	r3, [r7, #4]
 800e2da:	68f8      	ldr	r0, [r7, #12]
 800e2dc:	2101      	movs	r1, #1
 800e2de:	683a      	ldr	r2, [r7, #0]
 800e2e0:	4798      	blx	r3
}
 800e2e2:	3710      	adds	r7, #16
 800e2e4:	46bd      	mov	sp, r7
 800e2e6:	bd80      	pop	{r7, pc}

0800e2e8 <_decode_uavcan_protocol_RestartNode_res>:

void _decode_uavcan_protocol_RestartNode_res(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_RestartNode_res_s* msg, bool tao) {
 800e2e8:	b580      	push	{r7, lr}
 800e2ea:	b086      	sub	sp, #24
 800e2ec:	af02      	add	r7, sp, #8
 800e2ee:	60f8      	str	r0, [r7, #12]
 800e2f0:	60b9      	str	r1, [r7, #8]
 800e2f2:	607a      	str	r2, [r7, #4]
 800e2f4:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 1, false, &msg->ok);
 800e2f6:	68bb      	ldr	r3, [r7, #8]
 800e2f8:	681a      	ldr	r2, [r3, #0]
 800e2fa:	687b      	ldr	r3, [r7, #4]
 800e2fc:	9300      	str	r3, [sp, #0]
 800e2fe:	68f8      	ldr	r0, [r7, #12]
 800e300:	4611      	mov	r1, r2
 800e302:	2201      	movs	r2, #1
 800e304:	2300      	movs	r3, #0
 800e306:	f7fe ff71 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 1;
 800e30a:	68bb      	ldr	r3, [r7, #8]
 800e30c:	681b      	ldr	r3, [r3, #0]
 800e30e:	1c5a      	adds	r2, r3, #1
 800e310:	68bb      	ldr	r3, [r7, #8]
 800e312:	601a      	str	r2, [r3, #0]

}
 800e314:	3710      	adds	r7, #16
 800e316:	46bd      	mov	sp, r7
 800e318:	bd80      	pop	{r7, pc}
 800e31a:	bf00      	nop

0800e31c <encode_func.lto_priv.50>:
#include <uavcan.protocol.RestartNode_req.h>
#include <uavcan.protocol.RestartNode_res.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800e31c:	b580      	push	{r7, lr}
 800e31e:	b084      	sub	sp, #16
 800e320:	af00      	add	r7, sp, #0
 800e322:	60f8      	str	r0, [r7, #12]
 800e324:	60b9      	str	r1, [r7, #8]
 800e326:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_RestartNode_req(msg, chunk_cb, ctx);
 800e328:	68f8      	ldr	r0, [r7, #12]
 800e32a:	68b9      	ldr	r1, [r7, #8]
 800e32c:	687a      	ldr	r2, [r7, #4]
 800e32e:	f000 f811 	bl	800e354 <encode_uavcan_protocol_RestartNode_req>
}
 800e332:	3710      	adds	r7, #16
 800e334:	46bd      	mov	sp, r7
 800e336:	bd80      	pop	{r7, pc}

0800e338 <decode_func.lto_priv.58>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800e338:	b580      	push	{r7, lr}
 800e33a:	b082      	sub	sp, #8
 800e33c:	af00      	add	r7, sp, #0
 800e33e:	6078      	str	r0, [r7, #4]
 800e340:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_RestartNode_req(transfer, msg);
 800e342:	6878      	ldr	r0, [r7, #4]
 800e344:	6839      	ldr	r1, [r7, #0]
 800e346:	f000 f819 	bl	800e37c <decode_uavcan_protocol_RestartNode_req>
 800e34a:	4603      	mov	r3, r0
}
 800e34c:	4618      	mov	r0, r3
 800e34e:	3708      	adds	r7, #8
 800e350:	46bd      	mov	sp, r7
 800e352:	bd80      	pop	{r7, pc}

0800e354 <encode_uavcan_protocol_RestartNode_req>:
    encode_func,
    decode_func,
    &uavcan_protocol_RestartNode_res_descriptor
};

void encode_uavcan_protocol_RestartNode_req(struct uavcan_protocol_RestartNode_req_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800e354:	b580      	push	{r7, lr}
 800e356:	b088      	sub	sp, #32
 800e358:	af02      	add	r7, sp, #8
 800e35a:	60f8      	str	r0, [r7, #12]
 800e35c:	60b9      	str	r1, [r7, #8]
 800e35e:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_RestartNode_req(buffer, msg, chunk_cb, ctx, true);
 800e360:	f107 0210 	add.w	r2, r7, #16
 800e364:	2301      	movs	r3, #1
 800e366:	9300      	str	r3, [sp, #0]
 800e368:	4610      	mov	r0, r2
 800e36a:	68f9      	ldr	r1, [r7, #12]
 800e36c:	68ba      	ldr	r2, [r7, #8]
 800e36e:	687b      	ldr	r3, [r7, #4]
 800e370:	f000 f81a 	bl	800e3a8 <_encode_uavcan_protocol_RestartNode_req>
}
 800e374:	3718      	adds	r7, #24
 800e376:	46bd      	mov	sp, r7
 800e378:	bd80      	pop	{r7, pc}
 800e37a:	bf00      	nop

0800e37c <decode_uavcan_protocol_RestartNode_req>:

uint32_t decode_uavcan_protocol_RestartNode_req(const CanardRxTransfer* transfer, struct uavcan_protocol_RestartNode_req_s* msg) {
 800e37c:	b580      	push	{r7, lr}
 800e37e:	b084      	sub	sp, #16
 800e380:	af00      	add	r7, sp, #0
 800e382:	6078      	str	r0, [r7, #4]
 800e384:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800e386:	2300      	movs	r3, #0
 800e388:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_RestartNode_req(transfer, &bit_ofs, msg, true);
 800e38a:	f107 030c 	add.w	r3, r7, #12
 800e38e:	6878      	ldr	r0, [r7, #4]
 800e390:	4619      	mov	r1, r3
 800e392:	683a      	ldr	r2, [r7, #0]
 800e394:	2301      	movs	r3, #1
 800e396:	f000 f821 	bl	800e3dc <_decode_uavcan_protocol_RestartNode_req>
    return (bit_ofs+7)/8;
 800e39a:	68fb      	ldr	r3, [r7, #12]
 800e39c:	3307      	adds	r3, #7
 800e39e:	08db      	lsrs	r3, r3, #3
}
 800e3a0:	4618      	mov	r0, r3
 800e3a2:	3710      	adds	r7, #16
 800e3a4:	46bd      	mov	sp, r7
 800e3a6:	bd80      	pop	{r7, pc}

0800e3a8 <_encode_uavcan_protocol_RestartNode_req>:

void _encode_uavcan_protocol_RestartNode_req(uint8_t* buffer, struct uavcan_protocol_RestartNode_req_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800e3a8:	b580      	push	{r7, lr}
 800e3aa:	b084      	sub	sp, #16
 800e3ac:	af00      	add	r7, sp, #0
 800e3ae:	60f8      	str	r0, [r7, #12]
 800e3b0:	60b9      	str	r1, [r7, #8]
 800e3b2:	607a      	str	r2, [r7, #4]
 800e3b4:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
 800e3b6:	68f8      	ldr	r0, [r7, #12]
 800e3b8:	2100      	movs	r1, #0
 800e3ba:	2208      	movs	r2, #8
 800e3bc:	f000 f906 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 40, &msg->magic_number);
 800e3c0:	68bb      	ldr	r3, [r7, #8]
 800e3c2:	68f8      	ldr	r0, [r7, #12]
 800e3c4:	2100      	movs	r1, #0
 800e3c6:	2228      	movs	r2, #40	; 0x28
 800e3c8:	f7ff f888 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 40, ctx);
 800e3cc:	687b      	ldr	r3, [r7, #4]
 800e3ce:	68f8      	ldr	r0, [r7, #12]
 800e3d0:	2128      	movs	r1, #40	; 0x28
 800e3d2:	683a      	ldr	r2, [r7, #0]
 800e3d4:	4798      	blx	r3
}
 800e3d6:	3710      	adds	r7, #16
 800e3d8:	46bd      	mov	sp, r7
 800e3da:	bd80      	pop	{r7, pc}

0800e3dc <_decode_uavcan_protocol_RestartNode_req>:

void _decode_uavcan_protocol_RestartNode_req(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_RestartNode_req_s* msg, bool tao) {
 800e3dc:	b580      	push	{r7, lr}
 800e3de:	b086      	sub	sp, #24
 800e3e0:	af02      	add	r7, sp, #8
 800e3e2:	60f8      	str	r0, [r7, #12]
 800e3e4:	60b9      	str	r1, [r7, #8]
 800e3e6:	607a      	str	r2, [r7, #4]
 800e3e8:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 40, false, &msg->magic_number);
 800e3ea:	68bb      	ldr	r3, [r7, #8]
 800e3ec:	681a      	ldr	r2, [r3, #0]
 800e3ee:	687b      	ldr	r3, [r7, #4]
 800e3f0:	9300      	str	r3, [sp, #0]
 800e3f2:	68f8      	ldr	r0, [r7, #12]
 800e3f4:	4611      	mov	r1, r2
 800e3f6:	2228      	movs	r2, #40	; 0x28
 800e3f8:	2300      	movs	r3, #0
 800e3fa:	f7fe fef7 	bl	800d1ec <canardDecodeScalar>
    *bit_ofs += 40;
 800e3fe:	68bb      	ldr	r3, [r7, #8]
 800e400:	681b      	ldr	r3, [r3, #0]
 800e402:	f103 0228 	add.w	r2, r3, #40	; 0x28
 800e406:	68bb      	ldr	r3, [r7, #8]
 800e408:	601a      	str	r2, [r3, #0]

}
 800e40a:	3710      	adds	r7, #16
 800e40c:	46bd      	mov	sp, r7
 800e40e:	bd80      	pop	{r7, pc}

0800e410 <encode_func.lto_priv.51>:
#include <uavcan.protocol.dynamic_node_id.Allocation.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800e410:	b580      	push	{r7, lr}
 800e412:	b084      	sub	sp, #16
 800e414:	af00      	add	r7, sp, #0
 800e416:	60f8      	str	r0, [r7, #12]
 800e418:	60b9      	str	r1, [r7, #8]
 800e41a:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_dynamic_node_id_Allocation(msg, chunk_cb, ctx);
 800e41c:	68f8      	ldr	r0, [r7, #12]
 800e41e:	68b9      	ldr	r1, [r7, #8]
 800e420:	687a      	ldr	r2, [r7, #4]
 800e422:	f000 f811 	bl	800e448 <encode_uavcan_protocol_dynamic_node_id_Allocation>
}
 800e426:	3710      	adds	r7, #16
 800e428:	46bd      	mov	sp, r7
 800e42a:	bd80      	pop	{r7, pc}

0800e42c <decode_func.lto_priv.59>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800e42c:	b580      	push	{r7, lr}
 800e42e:	b082      	sub	sp, #8
 800e430:	af00      	add	r7, sp, #0
 800e432:	6078      	str	r0, [r7, #4]
 800e434:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_dynamic_node_id_Allocation(transfer, msg);
 800e436:	6878      	ldr	r0, [r7, #4]
 800e438:	6839      	ldr	r1, [r7, #0]
 800e43a:	f000 f819 	bl	800e470 <decode_uavcan_protocol_dynamic_node_id_Allocation>
 800e43e:	4603      	mov	r3, r0
}
 800e440:	4618      	mov	r0, r3
 800e442:	3708      	adds	r7, #8
 800e444:	46bd      	mov	sp, r7
 800e446:	bd80      	pop	{r7, pc}

0800e448 <encode_uavcan_protocol_dynamic_node_id_Allocation>:
    encode_func,
    decode_func,
    NULL
};

void encode_uavcan_protocol_dynamic_node_id_Allocation(struct uavcan_protocol_dynamic_node_id_Allocation_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800e448:	b580      	push	{r7, lr}
 800e44a:	b088      	sub	sp, #32
 800e44c:	af02      	add	r7, sp, #8
 800e44e:	60f8      	str	r0, [r7, #12]
 800e450:	60b9      	str	r1, [r7, #8]
 800e452:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_dynamic_node_id_Allocation(buffer, msg, chunk_cb, ctx, true);
 800e454:	f107 0210 	add.w	r2, r7, #16
 800e458:	2301      	movs	r3, #1
 800e45a:	9300      	str	r3, [sp, #0]
 800e45c:	4610      	mov	r0, r2
 800e45e:	68f9      	ldr	r1, [r7, #12]
 800e460:	68ba      	ldr	r2, [r7, #8]
 800e462:	687b      	ldr	r3, [r7, #4]
 800e464:	f000 f81a 	bl	800e49c <_encode_uavcan_protocol_dynamic_node_id_Allocation>
}
 800e468:	3718      	adds	r7, #24
 800e46a:	46bd      	mov	sp, r7
 800e46c:	bd80      	pop	{r7, pc}
 800e46e:	bf00      	nop

0800e470 <decode_uavcan_protocol_dynamic_node_id_Allocation>:

uint32_t decode_uavcan_protocol_dynamic_node_id_Allocation(const CanardRxTransfer* transfer, struct uavcan_protocol_dynamic_node_id_Allocation_s* msg) {
 800e470:	b580      	push	{r7, lr}
 800e472:	b084      	sub	sp, #16
 800e474:	af00      	add	r7, sp, #0
 800e476:	6078      	str	r0, [r7, #4]
 800e478:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800e47a:	2300      	movs	r3, #0
 800e47c:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_dynamic_node_id_Allocation(transfer, &bit_ofs, msg, true);
 800e47e:	f107 030c 	add.w	r3, r7, #12
 800e482:	6878      	ldr	r0, [r7, #4]
 800e484:	4619      	mov	r1, r3
 800e486:	683a      	ldr	r2, [r7, #0]
 800e488:	2301      	movs	r3, #1
 800e48a:	f7fd fb83 	bl	800bb94 <_decode_uavcan_protocol_dynamic_node_id_Allocation>
    return (bit_ofs+7)/8;
 800e48e:	68fb      	ldr	r3, [r7, #12]
 800e490:	3307      	adds	r3, #7
 800e492:	08db      	lsrs	r3, r3, #3
}
 800e494:	4618      	mov	r0, r3
 800e496:	3710      	adds	r7, #16
 800e498:	46bd      	mov	sp, r7
 800e49a:	bd80      	pop	{r7, pc}

0800e49c <_encode_uavcan_protocol_dynamic_node_id_Allocation>:

void _encode_uavcan_protocol_dynamic_node_id_Allocation(uint8_t* buffer, struct uavcan_protocol_dynamic_node_id_Allocation_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800e49c:	b580      	push	{r7, lr}
 800e49e:	b086      	sub	sp, #24
 800e4a0:	af00      	add	r7, sp, #0
 800e4a2:	60f8      	str	r0, [r7, #12]
 800e4a4:	60b9      	str	r1, [r7, #8]
 800e4a6:	607a      	str	r2, [r7, #4]
 800e4a8:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
 800e4aa:	68f8      	ldr	r0, [r7, #12]
 800e4ac:	2100      	movs	r1, #0
 800e4ae:	2208      	movs	r2, #8
 800e4b0:	f000 f88c 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 7, &msg->node_id);
 800e4b4:	68bb      	ldr	r3, [r7, #8]
 800e4b6:	68f8      	ldr	r0, [r7, #12]
 800e4b8:	2100      	movs	r1, #0
 800e4ba:	2207      	movs	r2, #7
 800e4bc:	f7ff f80e 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 7, ctx);
 800e4c0:	687b      	ldr	r3, [r7, #4]
 800e4c2:	68f8      	ldr	r0, [r7, #12]
 800e4c4:	2107      	movs	r1, #7
 800e4c6:	683a      	ldr	r2, [r7, #0]
 800e4c8:	4798      	blx	r3
    memset(buffer,0,8);
 800e4ca:	68f8      	ldr	r0, [r7, #12]
 800e4cc:	2100      	movs	r1, #0
 800e4ce:	2208      	movs	r2, #8
 800e4d0:	f000 f87c 	bl	800e5cc <memset>
    canardEncodeScalar(buffer, 0, 1, &msg->first_part_of_unique_id);
 800e4d4:	68bb      	ldr	r3, [r7, #8]
 800e4d6:	3301      	adds	r3, #1
 800e4d8:	68f8      	ldr	r0, [r7, #12]
 800e4da:	2100      	movs	r1, #0
 800e4dc:	2201      	movs	r2, #1
 800e4de:	f7fe fffd 	bl	800d4dc <canardEncodeScalar>
    chunk_cb(buffer, 1, ctx);
 800e4e2:	687b      	ldr	r3, [r7, #4]
 800e4e4:	68f8      	ldr	r0, [r7, #12]
 800e4e6:	2101      	movs	r1, #1
 800e4e8:	683a      	ldr	r2, [r7, #0]
 800e4ea:	4798      	blx	r3
    if (!tao) {
 800e4ec:	f897 3020 	ldrb.w	r3, [r7, #32]
 800e4f0:	f083 0301 	eor.w	r3, r3, #1
 800e4f4:	b2db      	uxtb	r3, r3
 800e4f6:	2b00      	cmp	r3, #0
 800e4f8:	d010      	beq.n	800e51c <_encode_uavcan_protocol_dynamic_node_id_Allocation+0x80>
        memset(buffer,0,8);
 800e4fa:	68f8      	ldr	r0, [r7, #12]
 800e4fc:	2100      	movs	r1, #0
 800e4fe:	2208      	movs	r2, #8
 800e500:	f000 f864 	bl	800e5cc <memset>
        canardEncodeScalar(buffer, 0, 5, &msg->unique_id_len);
 800e504:	68bb      	ldr	r3, [r7, #8]
 800e506:	3302      	adds	r3, #2
 800e508:	68f8      	ldr	r0, [r7, #12]
 800e50a:	2100      	movs	r1, #0
 800e50c:	2205      	movs	r2, #5
 800e50e:	f7fe ffe5 	bl	800d4dc <canardEncodeScalar>
        chunk_cb(buffer, 5, ctx);
 800e512:	687b      	ldr	r3, [r7, #4]
 800e514:	68f8      	ldr	r0, [r7, #12]
 800e516:	2105      	movs	r1, #5
 800e518:	683a      	ldr	r2, [r7, #0]
 800e51a:	4798      	blx	r3
    }
    for (size_t i=0; i < msg->unique_id_len; i++) {
 800e51c:	2300      	movs	r3, #0
 800e51e:	617b      	str	r3, [r7, #20]
 800e520:	e015      	b.n	800e54e <_encode_uavcan_protocol_dynamic_node_id_Allocation+0xb2>
            memset(buffer,0,8);
 800e522:	68f8      	ldr	r0, [r7, #12]
 800e524:	2100      	movs	r1, #0
 800e526:	2208      	movs	r2, #8
 800e528:	f000 f850 	bl	800e5cc <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->unique_id[i]);
 800e52c:	68ba      	ldr	r2, [r7, #8]
 800e52e:	697b      	ldr	r3, [r7, #20]
 800e530:	4413      	add	r3, r2
 800e532:	3303      	adds	r3, #3
 800e534:	68f8      	ldr	r0, [r7, #12]
 800e536:	2100      	movs	r1, #0
 800e538:	2208      	movs	r2, #8
 800e53a:	f7fe ffcf 	bl	800d4dc <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800e53e:	687b      	ldr	r3, [r7, #4]
 800e540:	68f8      	ldr	r0, [r7, #12]
 800e542:	2108      	movs	r1, #8
 800e544:	683a      	ldr	r2, [r7, #0]
 800e546:	4798      	blx	r3
    if (!tao) {
        memset(buffer,0,8);
        canardEncodeScalar(buffer, 0, 5, &msg->unique_id_len);
        chunk_cb(buffer, 5, ctx);
    }
    for (size_t i=0; i < msg->unique_id_len; i++) {
 800e548:	697b      	ldr	r3, [r7, #20]
 800e54a:	3301      	adds	r3, #1
 800e54c:	617b      	str	r3, [r7, #20]
 800e54e:	68bb      	ldr	r3, [r7, #8]
 800e550:	789b      	ldrb	r3, [r3, #2]
 800e552:	461a      	mov	r2, r3
 800e554:	697b      	ldr	r3, [r7, #20]
 800e556:	429a      	cmp	r2, r3
 800e558:	d8e3      	bhi.n	800e522 <_encode_uavcan_protocol_dynamic_node_id_Allocation+0x86>
            memset(buffer,0,8);
            canardEncodeScalar(buffer, 0, 8, &msg->unique_id[i]);
            chunk_cb(buffer, 8, ctx);
    }
}
 800e55a:	3718      	adds	r7, #24
 800e55c:	46bd      	mov	sp, r7
 800e55e:	bd80      	pop	{r7, pc}

0800e560 <memcmp>:
 800e560:	b510      	push	{r4, lr}
 800e562:	440a      	add	r2, r1
 800e564:	1e44      	subs	r4, r0, #1
 800e566:	4291      	cmp	r1, r2
 800e568:	d008      	beq.n	800e57c <memcmp+0x1c>
 800e56a:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 800e56e:	7808      	ldrb	r0, [r1, #0]
 800e570:	4283      	cmp	r3, r0
 800e572:	d001      	beq.n	800e578 <memcmp+0x18>
 800e574:	1a18      	subs	r0, r3, r0
 800e576:	bd10      	pop	{r4, pc}
 800e578:	3101      	adds	r1, #1
 800e57a:	e7f4      	b.n	800e566 <memcmp+0x6>
 800e57c:	2000      	movs	r0, #0
 800e57e:	bd10      	pop	{r4, pc}

0800e580 <memcpy>:
 800e580:	b510      	push	{r4, lr}
 800e582:	1e43      	subs	r3, r0, #1
 800e584:	440a      	add	r2, r1
 800e586:	4291      	cmp	r1, r2
 800e588:	d004      	beq.n	800e594 <memcpy+0x14>
 800e58a:	f811 4b01 	ldrb.w	r4, [r1], #1
 800e58e:	f803 4f01 	strb.w	r4, [r3, #1]!
 800e592:	e7f8      	b.n	800e586 <memcpy+0x6>
 800e594:	bd10      	pop	{r4, pc}

0800e596 <memmove>:
 800e596:	4281      	cmp	r1, r0
 800e598:	b510      	push	{r4, lr}
 800e59a:	eb01 0302 	add.w	r3, r1, r2
 800e59e:	d301      	bcc.n	800e5a4 <memmove+0xe>
 800e5a0:	1e42      	subs	r2, r0, #1
 800e5a2:	e00b      	b.n	800e5bc <memmove+0x26>
 800e5a4:	4298      	cmp	r0, r3
 800e5a6:	d2fb      	bcs.n	800e5a0 <memmove+0xa>
 800e5a8:	1881      	adds	r1, r0, r2
 800e5aa:	1ad2      	subs	r2, r2, r3
 800e5ac:	42d3      	cmn	r3, r2
 800e5ae:	d004      	beq.n	800e5ba <memmove+0x24>
 800e5b0:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800e5b4:	f801 4d01 	strb.w	r4, [r1, #-1]!
 800e5b8:	e7f8      	b.n	800e5ac <memmove+0x16>
 800e5ba:	bd10      	pop	{r4, pc}
 800e5bc:	4299      	cmp	r1, r3
 800e5be:	d004      	beq.n	800e5ca <memmove+0x34>
 800e5c0:	f811 4b01 	ldrb.w	r4, [r1], #1
 800e5c4:	f802 4f01 	strb.w	r4, [r2, #1]!
 800e5c8:	e7f8      	b.n	800e5bc <memmove+0x26>
 800e5ca:	bd10      	pop	{r4, pc}

0800e5cc <memset>:
 800e5cc:	4603      	mov	r3, r0
 800e5ce:	4402      	add	r2, r0
 800e5d0:	4293      	cmp	r3, r2
 800e5d2:	d002      	beq.n	800e5da <memset+0xe>
 800e5d4:	f803 1b01 	strb.w	r1, [r3], #1
 800e5d8:	e7fa      	b.n	800e5d0 <memset+0x4>
 800e5da:	4770      	bx	lr

0800e5dc <strnlen>:
 800e5dc:	4602      	mov	r2, r0
 800e5de:	b510      	push	{r4, lr}
 800e5e0:	4401      	add	r1, r0
 800e5e2:	428a      	cmp	r2, r1
 800e5e4:	4613      	mov	r3, r2
 800e5e6:	d003      	beq.n	800e5f0 <strnlen+0x14>
 800e5e8:	781c      	ldrb	r4, [r3, #0]
 800e5ea:	3201      	adds	r2, #1
 800e5ec:	2c00      	cmp	r4, #0
 800e5ee:	d1f8      	bne.n	800e5e2 <strnlen+0x6>
 800e5f0:	1a18      	subs	r0, r3, r0
 800e5f2:	bd10      	pop	{r4, pc}
