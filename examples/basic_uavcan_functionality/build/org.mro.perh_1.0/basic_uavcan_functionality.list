
build/org.mro.perh_1.0/basic_uavcan_functionality.elf:     file format elf32-littlearm


Disassembly of section .text:

080031c0 <Reset_Handler>:
                .align  2
                .thumb_func
                .global Reset_Handler
Reset_Handler:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80031c0:	b672      	cpsid	i
                ldr     r0, =__main_stack_end__
                msr     MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80031c2:	4825      	ldr	r0, [pc, #148]	; (8003258 <endfiniloop+0x4>)
                msr     PSP, r0
 80031c4:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80031c8:	4824      	ldr	r0, [pc, #144]	; (800325c <endfiniloop+0x8>)
                movw    r1, #SCB_VTOR & 0xFFFF
 80031ca:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 80031ce:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80031d2:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80031d4:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80031d6:	f380 8814 	msr	CONTROL, r0
                isb
 80031da:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 80031de:	f007 feb5 	bl	800af4c <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 80031e2:	f001 fbdd 	bl	80049a0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80031e6:	481e      	ldr	r0, [pc, #120]	; (8003260 <endfiniloop+0xc>)
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80031e8:	491e      	ldr	r1, [pc, #120]	; (8003264 <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
 80031ea:	4a1f      	ldr	r2, [pc, #124]	; (8003268 <endfiniloop+0x14>)

080031ec <msloop>:
msloop:
                cmp     r1, r2
 80031ec:	4291      	cmp	r1, r2
                itt     lo
 80031ee:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80031f0:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 80031f4:	e7fa      	bcc.n	80031ec <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80031f6:	491d      	ldr	r1, [pc, #116]	; (800326c <endfiniloop+0x18>)
                ldr     r2, =__process_stack_end__
 80031f8:	4a17      	ldr	r2, [pc, #92]	; (8003258 <endfiniloop+0x4>)

080031fa <psloop>:
psloop:
                cmp     r1, r2
 80031fa:	4291      	cmp	r1, r2
                itt     lo
 80031fc:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80031fe:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8003202:	e7fa      	bcc.n	80031fa <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 8003204:	491a      	ldr	r1, [pc, #104]	; (8003270 <endfiniloop+0x1c>)
                ldr     r2, =_data_start
 8003206:	4a1b      	ldr	r2, [pc, #108]	; (8003274 <endfiniloop+0x20>)
                ldr     r3, =_data_end
 8003208:	4b1b      	ldr	r3, [pc, #108]	; (8003278 <endfiniloop+0x24>)

0800320a <dloop>:
dloop:
                cmp     r2, r3
 800320a:	429a      	cmp	r2, r3
                ittt    lo
 800320c:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 800320e:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8003212:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8003216:	e7f8      	bcc.n	800320a <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8003218:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 800321a:	4918      	ldr	r1, [pc, #96]	; (800327c <endfiniloop+0x28>)
                ldr     r2, =_bss_end
 800321c:	4a18      	ldr	r2, [pc, #96]	; (8003280 <endfiniloop+0x2c>)

0800321e <bloop>:
bloop:
                cmp     r1, r2
 800321e:	4291      	cmp	r1, r2
                itt     lo
 8003220:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8003222:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8003226:	e7fa      	bcc.n	800321e <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8003228:	f007 fea0 	bl	800af6c <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800322c:	f007 fe94 	bl	800af58 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 8003230:	4c14      	ldr	r4, [pc, #80]	; (8003284 <endfiniloop+0x30>)
                ldr     r5, =__init_array_end
 8003232:	4d15      	ldr	r5, [pc, #84]	; (8003288 <endfiniloop+0x34>)

08003234 <initloop>:
initloop:
                cmp     r4, r5
 8003234:	42ac      	cmp	r4, r5
                bge     endinitloop
 8003236:	da03      	bge.n	8003240 <endinitloop>
                ldr     r1, [r4], #4
 8003238:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800323c:	4788      	blx	r1
                b       initloop
 800323e:	e7f9      	b.n	8003234 <initloop>

08003240 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8003240:	f008 f84c 	bl	800b2dc <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 8003244:	4c11      	ldr	r4, [pc, #68]	; (800328c <endfiniloop+0x38>)
                ldr     r5, =__fini_array_end
 8003246:	4d12      	ldr	r5, [pc, #72]	; (8003290 <endfiniloop+0x3c>)

08003248 <finiloop>:
finiloop:
                cmp     r4, r5
 8003248:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800324a:	da03      	bge.n	8003254 <endfiniloop>
                ldr     r1, [r4], #4
 800324c:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8003250:	4788      	blx	r1
                b       finiloop
 8003252:	e7f9      	b.n	8003248 <finiloop>

08003254 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8003254:	f007 be86 	b.w	800af64 <__default_exit>
                ldr     r0, =__main_stack_end__
                msr     MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8003258:	20000a00 	.word	0x20000a00
                msr     PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 800325c:	08003000 	.word	0x08003000

                /* Early initialization.*/
                bl      __early_init

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8003260:	55555555 	.word	0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8003264:	20000000 	.word	0x20000000
                ldr     r2, =__main_stack_end__
 8003268:	20000500 	.word	0x20000500
                blo     msloop

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800326c:	20000500 	.word	0x20000500
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 8003270:	0800d22c 	.word	0x0800d22c
                ldr     r2, =_data_start
 8003274:	20000a00 	.word	0x20000a00
                ldr     r3, =_data_end
 8003278:	20000a1c 	.word	0x20000a1c

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
                ldr     r1, =_bss_start
 800327c:	20000a20 	.word	0x20000a20
                ldr     r2, =_bss_end
 8003280:	200014b8 	.word	0x200014b8
                /* Late initialization..*/
                bl      __late_init

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 8003284:	08003188 	.word	0x08003188
                ldr     r5, =__init_array_end
 8003288:	080031c0 	.word	0x080031c0
                /* Main program invocation, r0 contains the returned value.*/
                bl      main

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 800328c:	080031c0 	.word	0x080031c0
                ldr     r5, =__fini_array_end
 8003290:	080031c0 	.word	0x080031c0

08003294 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8003294:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 8003298:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 800329c:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 800329e:	469d      	mov	sp, r3
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80032a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080032a4 <_port_thread_start>:
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_thread_start
_port_thread_start:
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80032a4:	f006 fc0e 	bl	8009ac4 <_dbg_check_unlock>
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80032a8:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80032aa:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80032ae:	4628      	mov	r0, r5
                blx     r4
 80032b0:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 80032b2:	2000      	movs	r0, #0
                bl      chThdExit
 80032b4:	f005 fe9a 	bl	8008fec <chThdExit>

080032b8 <_port_switch_from_isr>:
_port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
 80032b8:	f006 fbee 	bl	8009a98 <_dbg_check_lock>
#endif
                bl      chSchDoReschedule
 80032bc:	f007 f8c4 	bl	800a448 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80032c0:	f006 fc00 	bl	8009ac4 <_dbg_check_unlock>

080032c4 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80032c4:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80032c6:	e7fe      	b.n	80032c6 <_port_exit_from_isr+0x2>

080032c8 <__aeabi_f2uiz>:
 80032c8:	0042      	lsls	r2, r0, #1
 80032ca:	d20e      	bcs.n	80032ea <__aeabi_f2uiz+0x22>
 80032cc:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80032d0:	d30b      	bcc.n	80032ea <__aeabi_f2uiz+0x22>
 80032d2:	f04f 039e 	mov.w	r3, #158	; 0x9e
 80032d6:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 80032da:	d409      	bmi.n	80032f0 <__aeabi_f2uiz+0x28>
 80032dc:	ea4f 2300 	mov.w	r3, r0, lsl #8
 80032e0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80032e4:	fa23 f002 	lsr.w	r0, r3, r2
 80032e8:	4770      	bx	lr
 80032ea:	f04f 0000 	mov.w	r0, #0
 80032ee:	4770      	bx	lr
 80032f0:	f112 0f61 	cmn.w	r2, #97	; 0x61
 80032f4:	d101      	bne.n	80032fa <__aeabi_f2uiz+0x32>
 80032f6:	0242      	lsls	r2, r0, #9
 80032f8:	d102      	bne.n	8003300 <__aeabi_f2uiz+0x38>
 80032fa:	f04f 30ff 	mov.w	r0, #4294967295
 80032fe:	4770      	bx	lr
 8003300:	f04f 0000 	mov.w	r0, #0
 8003304:	4770      	bx	lr
 8003306:	bf00      	nop

08003308 <__aeabi_uldivmod>:
 8003308:	b953      	cbnz	r3, 8003320 <__aeabi_uldivmod+0x18>
 800330a:	b94a      	cbnz	r2, 8003320 <__aeabi_uldivmod+0x18>
 800330c:	2900      	cmp	r1, #0
 800330e:	bf08      	it	eq
 8003310:	2800      	cmpeq	r0, #0
 8003312:	bf1c      	itt	ne
 8003314:	f04f 31ff 	movne.w	r1, #4294967295
 8003318:	f04f 30ff 	movne.w	r0, #4294967295
 800331c:	f000 b83c 	b.w	8003398 <__aeabi_idiv0>
 8003320:	b082      	sub	sp, #8
 8003322:	46ec      	mov	ip, sp
 8003324:	e92d 5000 	stmdb	sp!, {ip, lr}
 8003328:	f000 f81e 	bl	8003368 <__gnu_uldivmod_helper>
 800332c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8003330:	b002      	add	sp, #8
 8003332:	bc0c      	pop	{r2, r3}
 8003334:	4770      	bx	lr
 8003336:	bf00      	nop

08003338 <__gnu_ldivmod_helper>:
 8003338:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800333c:	9c06      	ldr	r4, [sp, #24]
 800333e:	4690      	mov	r8, r2
 8003340:	4606      	mov	r6, r0
 8003342:	460f      	mov	r7, r1
 8003344:	461d      	mov	r5, r3
 8003346:	f000 f829 	bl	800339c <__divdi3>
 800334a:	fb08 fc01 	mul.w	ip, r8, r1
 800334e:	fba8 2300 	umull	r2, r3, r8, r0
 8003352:	fb00 c505 	mla	r5, r0, r5, ip
 8003356:	1ab2      	subs	r2, r6, r2
 8003358:	442b      	add	r3, r5
 800335a:	eb67 0303 	sbc.w	r3, r7, r3
 800335e:	4686      	mov	lr, r0
 8003360:	e9c4 2300 	strd	r2, r3, [r4]
 8003364:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08003368 <__gnu_uldivmod_helper>:
 8003368:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800336c:	9e08      	ldr	r6, [sp, #32]
 800336e:	4617      	mov	r7, r2
 8003370:	4680      	mov	r8, r0
 8003372:	4689      	mov	r9, r1
 8003374:	461d      	mov	r5, r3
 8003376:	f000 f967 	bl	8003648 <__udivdi3>
 800337a:	fb00 f305 	mul.w	r3, r0, r5
 800337e:	fba0 4507 	umull	r4, r5, r0, r7
 8003382:	fb07 3701 	mla	r7, r7, r1, r3
 8003386:	ebb8 0404 	subs.w	r4, r8, r4
 800338a:	443d      	add	r5, r7
 800338c:	eb69 0505 	sbc.w	r5, r9, r5
 8003390:	e9c6 4500 	strd	r4, r5, [r6]
 8003394:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08003398 <__aeabi_idiv0>:
 8003398:	4770      	bx	lr
 800339a:	bf00      	nop

0800339c <__divdi3>:
 800339c:	2900      	cmp	r1, #0
 800339e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80033a2:	f2c0 80a8 	blt.w	80034f6 <__divdi3+0x15a>
 80033a6:	2600      	movs	r6, #0
 80033a8:	2b00      	cmp	r3, #0
 80033aa:	f2c0 809e 	blt.w	80034ea <__divdi3+0x14e>
 80033ae:	4681      	mov	r9, r0
 80033b0:	468e      	mov	lr, r1
 80033b2:	4690      	mov	r8, r2
 80033b4:	469c      	mov	ip, r3
 80033b6:	4617      	mov	r7, r2
 80033b8:	4604      	mov	r4, r0
 80033ba:	460d      	mov	r5, r1
 80033bc:	2b00      	cmp	r3, #0
 80033be:	d13d      	bne.n	800343c <__divdi3+0xa0>
 80033c0:	428a      	cmp	r2, r1
 80033c2:	d959      	bls.n	8003478 <__divdi3+0xdc>
 80033c4:	fab2 f382 	clz	r3, r2
 80033c8:	b13b      	cbz	r3, 80033da <__divdi3+0x3e>
 80033ca:	f1c3 0220 	rsb	r2, r3, #32
 80033ce:	409d      	lsls	r5, r3
 80033d0:	fa20 f202 	lsr.w	r2, r0, r2
 80033d4:	409f      	lsls	r7, r3
 80033d6:	4315      	orrs	r5, r2
 80033d8:	409c      	lsls	r4, r3
 80033da:	0c39      	lsrs	r1, r7, #16
 80033dc:	fbb5 f0f1 	udiv	r0, r5, r1
 80033e0:	fa1f fe87 	uxth.w	lr, r7
 80033e4:	fb01 5510 	mls	r5, r1, r0, r5
 80033e8:	fb0e f300 	mul.w	r3, lr, r0
 80033ec:	0c22      	lsrs	r2, r4, #16
 80033ee:	ea42 4505 	orr.w	r5, r2, r5, lsl #16
 80033f2:	42ab      	cmp	r3, r5
 80033f4:	d909      	bls.n	800340a <__divdi3+0x6e>
 80033f6:	19ed      	adds	r5, r5, r7
 80033f8:	f100 32ff 	add.w	r2, r0, #4294967295
 80033fc:	f080 810b 	bcs.w	8003616 <__divdi3+0x27a>
 8003400:	42ab      	cmp	r3, r5
 8003402:	f240 8108 	bls.w	8003616 <__divdi3+0x27a>
 8003406:	3802      	subs	r0, #2
 8003408:	443d      	add	r5, r7
 800340a:	1aed      	subs	r5, r5, r3
 800340c:	fbb5 f3f1 	udiv	r3, r5, r1
 8003410:	fb01 5513 	mls	r5, r1, r3, r5
 8003414:	fb0e fe03 	mul.w	lr, lr, r3
 8003418:	b2a4      	uxth	r4, r4
 800341a:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 800341e:	45ae      	cmp	lr, r5
 8003420:	d908      	bls.n	8003434 <__divdi3+0x98>
 8003422:	19ed      	adds	r5, r5, r7
 8003424:	f103 32ff 	add.w	r2, r3, #4294967295
 8003428:	f080 80f7 	bcs.w	800361a <__divdi3+0x27e>
 800342c:	45ae      	cmp	lr, r5
 800342e:	f240 80f4 	bls.w	800361a <__divdi3+0x27e>
 8003432:	3b02      	subs	r3, #2
 8003434:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 8003438:	2200      	movs	r2, #0
 800343a:	e003      	b.n	8003444 <__divdi3+0xa8>
 800343c:	428b      	cmp	r3, r1
 800343e:	d90f      	bls.n	8003460 <__divdi3+0xc4>
 8003440:	2200      	movs	r2, #0
 8003442:	4613      	mov	r3, r2
 8003444:	1c34      	adds	r4, r6, #0
 8003446:	bf18      	it	ne
 8003448:	2401      	movne	r4, #1
 800344a:	4260      	negs	r0, r4
 800344c:	f04f 0500 	mov.w	r5, #0
 8003450:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
 8003454:	4058      	eors	r0, r3
 8003456:	4051      	eors	r1, r2
 8003458:	1900      	adds	r0, r0, r4
 800345a:	4169      	adcs	r1, r5
 800345c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8003460:	fab3 f283 	clz	r2, r3
 8003464:	2a00      	cmp	r2, #0
 8003466:	f040 8089 	bne.w	800357c <__divdi3+0x1e0>
 800346a:	428b      	cmp	r3, r1
 800346c:	d302      	bcc.n	8003474 <__divdi3+0xd8>
 800346e:	4580      	cmp	r8, r0
 8003470:	f200 80e2 	bhi.w	8003638 <__divdi3+0x29c>
 8003474:	2301      	movs	r3, #1
 8003476:	e7e5      	b.n	8003444 <__divdi3+0xa8>
 8003478:	b912      	cbnz	r2, 8003480 <__divdi3+0xe4>
 800347a:	2301      	movs	r3, #1
 800347c:	fbb3 f7f2 	udiv	r7, r3, r2
 8003480:	fab7 f887 	clz	r8, r7
 8003484:	f1b8 0f00 	cmp.w	r8, #0
 8003488:	d13b      	bne.n	8003502 <__divdi3+0x166>
 800348a:	1bed      	subs	r5, r5, r7
 800348c:	ea4f 4c17 	mov.w	ip, r7, lsr #16
 8003490:	fa1f fe87 	uxth.w	lr, r7
 8003494:	2201      	movs	r2, #1
 8003496:	fbb5 f0fc 	udiv	r0, r5, ip
 800349a:	fb0c 5510 	mls	r5, ip, r0, r5
 800349e:	fb0e f300 	mul.w	r3, lr, r0
 80034a2:	0c21      	lsrs	r1, r4, #16
 80034a4:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
 80034a8:	42ab      	cmp	r3, r5
 80034aa:	d907      	bls.n	80034bc <__divdi3+0x120>
 80034ac:	19ed      	adds	r5, r5, r7
 80034ae:	f100 31ff 	add.w	r1, r0, #4294967295
 80034b2:	d202      	bcs.n	80034ba <__divdi3+0x11e>
 80034b4:	42ab      	cmp	r3, r5
 80034b6:	f200 80c3 	bhi.w	8003640 <__divdi3+0x2a4>
 80034ba:	4608      	mov	r0, r1
 80034bc:	1aed      	subs	r5, r5, r3
 80034be:	fbb5 f3fc 	udiv	r3, r5, ip
 80034c2:	fb0c 5513 	mls	r5, ip, r3, r5
 80034c6:	fb0e fe03 	mul.w	lr, lr, r3
 80034ca:	b2a4      	uxth	r4, r4
 80034cc:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 80034d0:	45ae      	cmp	lr, r5
 80034d2:	d907      	bls.n	80034e4 <__divdi3+0x148>
 80034d4:	19ed      	adds	r5, r5, r7
 80034d6:	f103 31ff 	add.w	r1, r3, #4294967295
 80034da:	d202      	bcs.n	80034e2 <__divdi3+0x146>
 80034dc:	45ae      	cmp	lr, r5
 80034de:	f200 80ad 	bhi.w	800363c <__divdi3+0x2a0>
 80034e2:	460b      	mov	r3, r1
 80034e4:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 80034e8:	e7ac      	b.n	8003444 <__divdi3+0xa8>
 80034ea:	4252      	negs	r2, r2
 80034ec:	ea6f 0606 	mvn.w	r6, r6
 80034f0:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80034f4:	e75b      	b.n	80033ae <__divdi3+0x12>
 80034f6:	4240      	negs	r0, r0
 80034f8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80034fc:	f04f 36ff 	mov.w	r6, #4294967295
 8003500:	e752      	b.n	80033a8 <__divdi3+0xc>
 8003502:	fa07 f708 	lsl.w	r7, r7, r8
 8003506:	f1c8 0220 	rsb	r2, r8, #32
 800350a:	fa25 f302 	lsr.w	r3, r5, r2
 800350e:	ea4f 4c17 	mov.w	ip, r7, lsr #16
 8003512:	fbb3 f1fc 	udiv	r1, r3, ip
 8003516:	fa1f fe87 	uxth.w	lr, r7
 800351a:	fb0c 3311 	mls	r3, ip, r1, r3
 800351e:	fa24 f202 	lsr.w	r2, r4, r2
 8003522:	fa05 f508 	lsl.w	r5, r5, r8
 8003526:	fb0e f901 	mul.w	r9, lr, r1
 800352a:	432a      	orrs	r2, r5
 800352c:	0c10      	lsrs	r0, r2, #16
 800352e:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 8003532:	4599      	cmp	r9, r3
 8003534:	fa04 f408 	lsl.w	r4, r4, r8
 8003538:	d907      	bls.n	800354a <__divdi3+0x1ae>
 800353a:	19db      	adds	r3, r3, r7
 800353c:	f101 30ff 	add.w	r0, r1, #4294967295
 8003540:	d278      	bcs.n	8003634 <__divdi3+0x298>
 8003542:	4599      	cmp	r9, r3
 8003544:	d976      	bls.n	8003634 <__divdi3+0x298>
 8003546:	3902      	subs	r1, #2
 8003548:	443b      	add	r3, r7
 800354a:	ebc9 0303 	rsb	r3, r9, r3
 800354e:	fbb3 f0fc 	udiv	r0, r3, ip
 8003552:	fb0c 3310 	mls	r3, ip, r0, r3
 8003556:	fb0e f500 	mul.w	r5, lr, r0
 800355a:	b292      	uxth	r2, r2
 800355c:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 8003560:	429d      	cmp	r5, r3
 8003562:	d907      	bls.n	8003574 <__divdi3+0x1d8>
 8003564:	19db      	adds	r3, r3, r7
 8003566:	f100 32ff 	add.w	r2, r0, #4294967295
 800356a:	d25f      	bcs.n	800362c <__divdi3+0x290>
 800356c:	429d      	cmp	r5, r3
 800356e:	d95d      	bls.n	800362c <__divdi3+0x290>
 8003570:	3802      	subs	r0, #2
 8003572:	443b      	add	r3, r7
 8003574:	1b5d      	subs	r5, r3, r5
 8003576:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
 800357a:	e78c      	b.n	8003496 <__divdi3+0xfa>
 800357c:	f1c2 0320 	rsb	r3, r2, #32
 8003580:	fa28 f103 	lsr.w	r1, r8, r3
 8003584:	fa0c fc02 	lsl.w	ip, ip, r2
 8003588:	ea41 0c0c 	orr.w	ip, r1, ip
 800358c:	ea4f 401c 	mov.w	r0, ip, lsr #16
 8003590:	fa2e f103 	lsr.w	r1, lr, r3
 8003594:	fbb1 f5f0 	udiv	r5, r1, r0
 8003598:	fa1f f78c 	uxth.w	r7, ip
 800359c:	fb00 1115 	mls	r1, r0, r5, r1
 80035a0:	fa29 f303 	lsr.w	r3, r9, r3
 80035a4:	fa0e fe02 	lsl.w	lr, lr, r2
 80035a8:	fb07 f905 	mul.w	r9, r7, r5
 80035ac:	ea43 0e0e 	orr.w	lr, r3, lr
 80035b0:	ea4f 431e 	mov.w	r3, lr, lsr #16
 80035b4:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 80035b8:	4589      	cmp	r9, r1
 80035ba:	fa08 f802 	lsl.w	r8, r8, r2
 80035be:	d908      	bls.n	80035d2 <__divdi3+0x236>
 80035c0:	eb11 010c 	adds.w	r1, r1, ip
 80035c4:	f105 33ff 	add.w	r3, r5, #4294967295
 80035c8:	d232      	bcs.n	8003630 <__divdi3+0x294>
 80035ca:	4589      	cmp	r9, r1
 80035cc:	d930      	bls.n	8003630 <__divdi3+0x294>
 80035ce:	3d02      	subs	r5, #2
 80035d0:	4461      	add	r1, ip
 80035d2:	ebc9 0101 	rsb	r1, r9, r1
 80035d6:	fbb1 f3f0 	udiv	r3, r1, r0
 80035da:	fb00 1113 	mls	r1, r0, r3, r1
 80035de:	fb07 f703 	mul.w	r7, r7, r3
 80035e2:	fa1f fe8e 	uxth.w	lr, lr
 80035e6:	ea4e 4e01 	orr.w	lr, lr, r1, lsl #16
 80035ea:	4577      	cmp	r7, lr
 80035ec:	d908      	bls.n	8003600 <__divdi3+0x264>
 80035ee:	eb1e 0e0c 	adds.w	lr, lr, ip
 80035f2:	f103 31ff 	add.w	r1, r3, #4294967295
 80035f6:	d217      	bcs.n	8003628 <__divdi3+0x28c>
 80035f8:	4577      	cmp	r7, lr
 80035fa:	d915      	bls.n	8003628 <__divdi3+0x28c>
 80035fc:	3b02      	subs	r3, #2
 80035fe:	44e6      	add	lr, ip
 8003600:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
 8003604:	fba3 8908 	umull	r8, r9, r3, r8
 8003608:	ebc7 0e0e 	rsb	lr, r7, lr
 800360c:	45ce      	cmp	lr, r9
 800360e:	d309      	bcc.n	8003624 <__divdi3+0x288>
 8003610:	d005      	beq.n	800361e <__divdi3+0x282>
 8003612:	2200      	movs	r2, #0
 8003614:	e716      	b.n	8003444 <__divdi3+0xa8>
 8003616:	4610      	mov	r0, r2
 8003618:	e6f7      	b.n	800340a <__divdi3+0x6e>
 800361a:	4613      	mov	r3, r2
 800361c:	e70a      	b.n	8003434 <__divdi3+0x98>
 800361e:	4094      	lsls	r4, r2
 8003620:	4544      	cmp	r4, r8
 8003622:	d2f6      	bcs.n	8003612 <__divdi3+0x276>
 8003624:	3b01      	subs	r3, #1
 8003626:	e7f4      	b.n	8003612 <__divdi3+0x276>
 8003628:	460b      	mov	r3, r1
 800362a:	e7e9      	b.n	8003600 <__divdi3+0x264>
 800362c:	4610      	mov	r0, r2
 800362e:	e7a1      	b.n	8003574 <__divdi3+0x1d8>
 8003630:	461d      	mov	r5, r3
 8003632:	e7ce      	b.n	80035d2 <__divdi3+0x236>
 8003634:	4601      	mov	r1, r0
 8003636:	e788      	b.n	800354a <__divdi3+0x1ae>
 8003638:	4613      	mov	r3, r2
 800363a:	e703      	b.n	8003444 <__divdi3+0xa8>
 800363c:	3b02      	subs	r3, #2
 800363e:	e751      	b.n	80034e4 <__divdi3+0x148>
 8003640:	3802      	subs	r0, #2
 8003642:	443d      	add	r5, r7
 8003644:	e73a      	b.n	80034bc <__divdi3+0x120>
 8003646:	bf00      	nop

08003648 <__udivdi3>:
 8003648:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800364c:	2b00      	cmp	r3, #0
 800364e:	d144      	bne.n	80036da <__udivdi3+0x92>
 8003650:	428a      	cmp	r2, r1
 8003652:	4615      	mov	r5, r2
 8003654:	4604      	mov	r4, r0
 8003656:	d94f      	bls.n	80036f8 <__udivdi3+0xb0>
 8003658:	fab2 f782 	clz	r7, r2
 800365c:	460e      	mov	r6, r1
 800365e:	b14f      	cbz	r7, 8003674 <__udivdi3+0x2c>
 8003660:	f1c7 0320 	rsb	r3, r7, #32
 8003664:	40b9      	lsls	r1, r7
 8003666:	fa20 f603 	lsr.w	r6, r0, r3
 800366a:	fa02 f507 	lsl.w	r5, r2, r7
 800366e:	430e      	orrs	r6, r1
 8003670:	fa00 f407 	lsl.w	r4, r0, r7
 8003674:	0c2f      	lsrs	r7, r5, #16
 8003676:	fbb6 f0f7 	udiv	r0, r6, r7
 800367a:	fa1f fe85 	uxth.w	lr, r5
 800367e:	fb07 6210 	mls	r2, r7, r0, r6
 8003682:	fb0e f100 	mul.w	r1, lr, r0
 8003686:	0c26      	lsrs	r6, r4, #16
 8003688:	ea46 4302 	orr.w	r3, r6, r2, lsl #16
 800368c:	4299      	cmp	r1, r3
 800368e:	d909      	bls.n	80036a4 <__udivdi3+0x5c>
 8003690:	195b      	adds	r3, r3, r5
 8003692:	f100 32ff 	add.w	r2, r0, #4294967295
 8003696:	f080 80ee 	bcs.w	8003876 <__udivdi3+0x22e>
 800369a:	4299      	cmp	r1, r3
 800369c:	f240 80eb 	bls.w	8003876 <__udivdi3+0x22e>
 80036a0:	3802      	subs	r0, #2
 80036a2:	442b      	add	r3, r5
 80036a4:	1a59      	subs	r1, r3, r1
 80036a6:	fbb1 f3f7 	udiv	r3, r1, r7
 80036aa:	fb07 1113 	mls	r1, r7, r3, r1
 80036ae:	fb0e fe03 	mul.w	lr, lr, r3
 80036b2:	b2a4      	uxth	r4, r4
 80036b4:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
 80036b8:	458e      	cmp	lr, r1
 80036ba:	d908      	bls.n	80036ce <__udivdi3+0x86>
 80036bc:	1949      	adds	r1, r1, r5
 80036be:	f103 32ff 	add.w	r2, r3, #4294967295
 80036c2:	f080 80da 	bcs.w	800387a <__udivdi3+0x232>
 80036c6:	458e      	cmp	lr, r1
 80036c8:	f240 80d7 	bls.w	800387a <__udivdi3+0x232>
 80036cc:	3b02      	subs	r3, #2
 80036ce:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80036d2:	2600      	movs	r6, #0
 80036d4:	4631      	mov	r1, r6
 80036d6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80036da:	428b      	cmp	r3, r1
 80036dc:	d847      	bhi.n	800376e <__udivdi3+0x126>
 80036de:	fab3 f683 	clz	r6, r3
 80036e2:	2e00      	cmp	r6, #0
 80036e4:	d148      	bne.n	8003778 <__udivdi3+0x130>
 80036e6:	428b      	cmp	r3, r1
 80036e8:	d302      	bcc.n	80036f0 <__udivdi3+0xa8>
 80036ea:	4282      	cmp	r2, r0
 80036ec:	f200 80cf 	bhi.w	800388e <__udivdi3+0x246>
 80036f0:	2001      	movs	r0, #1
 80036f2:	4631      	mov	r1, r6
 80036f4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80036f8:	b912      	cbnz	r2, 8003700 <__udivdi3+0xb8>
 80036fa:	2501      	movs	r5, #1
 80036fc:	fbb5 f5f2 	udiv	r5, r5, r2
 8003700:	fab5 fc85 	clz	ip, r5
 8003704:	f1bc 0f00 	cmp.w	ip, #0
 8003708:	d178      	bne.n	80037fc <__udivdi3+0x1b4>
 800370a:	1b49      	subs	r1, r1, r5
 800370c:	0c2f      	lsrs	r7, r5, #16
 800370e:	fa1f fe85 	uxth.w	lr, r5
 8003712:	2601      	movs	r6, #1
 8003714:	fbb1 f0f7 	udiv	r0, r1, r7
 8003718:	fb07 1110 	mls	r1, r7, r0, r1
 800371c:	fb0e f200 	mul.w	r2, lr, r0
 8003720:	0c23      	lsrs	r3, r4, #16
 8003722:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8003726:	428a      	cmp	r2, r1
 8003728:	d907      	bls.n	800373a <__udivdi3+0xf2>
 800372a:	1949      	adds	r1, r1, r5
 800372c:	f100 33ff 	add.w	r3, r0, #4294967295
 8003730:	d202      	bcs.n	8003738 <__udivdi3+0xf0>
 8003732:	428a      	cmp	r2, r1
 8003734:	f200 80bc 	bhi.w	80038b0 <__udivdi3+0x268>
 8003738:	4618      	mov	r0, r3
 800373a:	1a89      	subs	r1, r1, r2
 800373c:	fbb1 f3f7 	udiv	r3, r1, r7
 8003740:	fb07 1113 	mls	r1, r7, r3, r1
 8003744:	fb0e fe03 	mul.w	lr, lr, r3
 8003748:	b2a4      	uxth	r4, r4
 800374a:	ea44 4201 	orr.w	r2, r4, r1, lsl #16
 800374e:	4596      	cmp	lr, r2
 8003750:	d908      	bls.n	8003764 <__udivdi3+0x11c>
 8003752:	1952      	adds	r2, r2, r5
 8003754:	f103 31ff 	add.w	r1, r3, #4294967295
 8003758:	f080 8091 	bcs.w	800387e <__udivdi3+0x236>
 800375c:	4596      	cmp	lr, r2
 800375e:	f240 808e 	bls.w	800387e <__udivdi3+0x236>
 8003762:	3b02      	subs	r3, #2
 8003764:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8003768:	4631      	mov	r1, r6
 800376a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800376e:	2600      	movs	r6, #0
 8003770:	4630      	mov	r0, r6
 8003772:	4631      	mov	r1, r6
 8003774:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8003778:	f1c6 0420 	rsb	r4, r6, #32
 800377c:	fa22 f504 	lsr.w	r5, r2, r4
 8003780:	40b3      	lsls	r3, r6
 8003782:	432b      	orrs	r3, r5
 8003784:	fa21 f704 	lsr.w	r7, r1, r4
 8003788:	ea4f 4813 	mov.w	r8, r3, lsr #16
 800378c:	fbb7 fcf8 	udiv	ip, r7, r8
 8003790:	fa1f f983 	uxth.w	r9, r3
 8003794:	fb08 771c 	mls	r7, r8, ip, r7
 8003798:	fa20 fe04 	lsr.w	lr, r0, r4
 800379c:	fa01 f506 	lsl.w	r5, r1, r6
 80037a0:	fb09 f40c 	mul.w	r4, r9, ip
 80037a4:	ea4e 0505 	orr.w	r5, lr, r5
 80037a8:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80037ac:	ea4e 4707 	orr.w	r7, lr, r7, lsl #16
 80037b0:	42bc      	cmp	r4, r7
 80037b2:	fa02 f206 	lsl.w	r2, r2, r6
 80037b6:	d904      	bls.n	80037c2 <__udivdi3+0x17a>
 80037b8:	18ff      	adds	r7, r7, r3
 80037ba:	f10c 31ff 	add.w	r1, ip, #4294967295
 80037be:	d368      	bcc.n	8003892 <__udivdi3+0x24a>
 80037c0:	468c      	mov	ip, r1
 80037c2:	1b3f      	subs	r7, r7, r4
 80037c4:	fbb7 f4f8 	udiv	r4, r7, r8
 80037c8:	fb08 7714 	mls	r7, r8, r4, r7
 80037cc:	fb09 f904 	mul.w	r9, r9, r4
 80037d0:	b2ad      	uxth	r5, r5
 80037d2:	ea45 4107 	orr.w	r1, r5, r7, lsl #16
 80037d6:	4589      	cmp	r9, r1
 80037d8:	d904      	bls.n	80037e4 <__udivdi3+0x19c>
 80037da:	18c9      	adds	r1, r1, r3
 80037dc:	f104 35ff 	add.w	r5, r4, #4294967295
 80037e0:	d35d      	bcc.n	800389e <__udivdi3+0x256>
 80037e2:	462c      	mov	r4, r5
 80037e4:	ea44 440c 	orr.w	r4, r4, ip, lsl #16
 80037e8:	fba4 2302 	umull	r2, r3, r4, r2
 80037ec:	ebc9 0101 	rsb	r1, r9, r1
 80037f0:	4299      	cmp	r1, r3
 80037f2:	d349      	bcc.n	8003888 <__udivdi3+0x240>
 80037f4:	d045      	beq.n	8003882 <__udivdi3+0x23a>
 80037f6:	4620      	mov	r0, r4
 80037f8:	2600      	movs	r6, #0
 80037fa:	e76b      	b.n	80036d4 <__udivdi3+0x8c>
 80037fc:	f1cc 0420 	rsb	r4, ip, #32
 8003800:	fa05 f50c 	lsl.w	r5, r5, ip
 8003804:	fa21 f304 	lsr.w	r3, r1, r4
 8003808:	0c2a      	lsrs	r2, r5, #16
 800380a:	fbb3 f6f2 	udiv	r6, r3, r2
 800380e:	fa1f fe85 	uxth.w	lr, r5
 8003812:	fb02 3816 	mls	r8, r2, r6, r3
 8003816:	fa20 f704 	lsr.w	r7, r0, r4
 800381a:	fa01 f10c 	lsl.w	r1, r1, ip
 800381e:	fb0e f906 	mul.w	r9, lr, r6
 8003822:	430f      	orrs	r7, r1
 8003824:	0c3c      	lsrs	r4, r7, #16
 8003826:	ea44 4308 	orr.w	r3, r4, r8, lsl #16
 800382a:	4599      	cmp	r9, r3
 800382c:	fa00 f40c 	lsl.w	r4, r0, ip
 8003830:	d907      	bls.n	8003842 <__udivdi3+0x1fa>
 8003832:	195b      	adds	r3, r3, r5
 8003834:	f106 31ff 	add.w	r1, r6, #4294967295
 8003838:	d238      	bcs.n	80038ac <__udivdi3+0x264>
 800383a:	4599      	cmp	r9, r3
 800383c:	d936      	bls.n	80038ac <__udivdi3+0x264>
 800383e:	3e02      	subs	r6, #2
 8003840:	442b      	add	r3, r5
 8003842:	ebc9 0303 	rsb	r3, r9, r3
 8003846:	fbb3 f0f2 	udiv	r0, r3, r2
 800384a:	fb02 3310 	mls	r3, r2, r0, r3
 800384e:	fb0e f100 	mul.w	r1, lr, r0
 8003852:	b2bf      	uxth	r7, r7
 8003854:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
 8003858:	4299      	cmp	r1, r3
 800385a:	d907      	bls.n	800386c <__udivdi3+0x224>
 800385c:	195b      	adds	r3, r3, r5
 800385e:	f100 37ff 	add.w	r7, r0, #4294967295
 8003862:	d221      	bcs.n	80038a8 <__udivdi3+0x260>
 8003864:	4299      	cmp	r1, r3
 8003866:	d91f      	bls.n	80038a8 <__udivdi3+0x260>
 8003868:	3802      	subs	r0, #2
 800386a:	442b      	add	r3, r5
 800386c:	4617      	mov	r7, r2
 800386e:	1a59      	subs	r1, r3, r1
 8003870:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 8003874:	e74e      	b.n	8003714 <__udivdi3+0xcc>
 8003876:	4610      	mov	r0, r2
 8003878:	e714      	b.n	80036a4 <__udivdi3+0x5c>
 800387a:	4613      	mov	r3, r2
 800387c:	e727      	b.n	80036ce <__udivdi3+0x86>
 800387e:	460b      	mov	r3, r1
 8003880:	e770      	b.n	8003764 <__udivdi3+0x11c>
 8003882:	40b0      	lsls	r0, r6
 8003884:	4290      	cmp	r0, r2
 8003886:	d2b6      	bcs.n	80037f6 <__udivdi3+0x1ae>
 8003888:	1e60      	subs	r0, r4, #1
 800388a:	2600      	movs	r6, #0
 800388c:	e722      	b.n	80036d4 <__udivdi3+0x8c>
 800388e:	4630      	mov	r0, r6
 8003890:	e720      	b.n	80036d4 <__udivdi3+0x8c>
 8003892:	42bc      	cmp	r4, r7
 8003894:	d994      	bls.n	80037c0 <__udivdi3+0x178>
 8003896:	f1ac 0c02 	sub.w	ip, ip, #2
 800389a:	441f      	add	r7, r3
 800389c:	e791      	b.n	80037c2 <__udivdi3+0x17a>
 800389e:	4589      	cmp	r9, r1
 80038a0:	d99f      	bls.n	80037e2 <__udivdi3+0x19a>
 80038a2:	3c02      	subs	r4, #2
 80038a4:	4419      	add	r1, r3
 80038a6:	e79d      	b.n	80037e4 <__udivdi3+0x19c>
 80038a8:	4638      	mov	r0, r7
 80038aa:	e7df      	b.n	800386c <__udivdi3+0x224>
 80038ac:	460e      	mov	r6, r1
 80038ae:	e7c8      	b.n	8003842 <__udivdi3+0x1fa>
 80038b0:	3802      	subs	r0, #2
 80038b2:	4429      	add	r1, r5
 80038b4:	e741      	b.n	800373a <__udivdi3+0xf2>
 80038b6:	bf00      	nop

080038b8 <__aeabi_frsub>:
 80038b8:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 80038bc:	e002      	b.n	80038c4 <__addsf3>
 80038be:	bf00      	nop

080038c0 <__aeabi_fsub>:
 80038c0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

080038c4 <__addsf3>:
 80038c4:	0042      	lsls	r2, r0, #1
 80038c6:	bf1f      	itttt	ne
 80038c8:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 80038cc:	ea92 0f03 	teqne	r2, r3
 80038d0:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 80038d4:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80038d8:	d06a      	beq.n	80039b0 <__addsf3+0xec>
 80038da:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80038de:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 80038e2:	bfc1      	itttt	gt
 80038e4:	18d2      	addgt	r2, r2, r3
 80038e6:	4041      	eorgt	r1, r0
 80038e8:	4048      	eorgt	r0, r1
 80038ea:	4041      	eorgt	r1, r0
 80038ec:	bfb8      	it	lt
 80038ee:	425b      	neglt	r3, r3
 80038f0:	2b19      	cmp	r3, #25
 80038f2:	bf88      	it	hi
 80038f4:	4770      	bxhi	lr
 80038f6:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80038fa:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80038fe:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8003902:	bf18      	it	ne
 8003904:	4240      	negne	r0, r0
 8003906:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800390a:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 800390e:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8003912:	bf18      	it	ne
 8003914:	4249      	negne	r1, r1
 8003916:	ea92 0f03 	teq	r2, r3
 800391a:	d03f      	beq.n	800399c <__addsf3+0xd8>
 800391c:	f1a2 0201 	sub.w	r2, r2, #1
 8003920:	fa41 fc03 	asr.w	ip, r1, r3
 8003924:	eb10 000c 	adds.w	r0, r0, ip
 8003928:	f1c3 0320 	rsb	r3, r3, #32
 800392c:	fa01 f103 	lsl.w	r1, r1, r3
 8003930:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8003934:	d502      	bpl.n	800393c <__addsf3+0x78>
 8003936:	4249      	negs	r1, r1
 8003938:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 800393c:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8003940:	d313      	bcc.n	800396a <__addsf3+0xa6>
 8003942:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8003946:	d306      	bcc.n	8003956 <__addsf3+0x92>
 8003948:	0840      	lsrs	r0, r0, #1
 800394a:	ea4f 0131 	mov.w	r1, r1, rrx
 800394e:	f102 0201 	add.w	r2, r2, #1
 8003952:	2afe      	cmp	r2, #254	; 0xfe
 8003954:	d251      	bcs.n	80039fa <__addsf3+0x136>
 8003956:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 800395a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 800395e:	bf08      	it	eq
 8003960:	f020 0001 	biceq.w	r0, r0, #1
 8003964:	ea40 0003 	orr.w	r0, r0, r3
 8003968:	4770      	bx	lr
 800396a:	0049      	lsls	r1, r1, #1
 800396c:	eb40 0000 	adc.w	r0, r0, r0
 8003970:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 8003974:	f1a2 0201 	sub.w	r2, r2, #1
 8003978:	d1ed      	bne.n	8003956 <__addsf3+0x92>
 800397a:	fab0 fc80 	clz	ip, r0
 800397e:	f1ac 0c08 	sub.w	ip, ip, #8
 8003982:	ebb2 020c 	subs.w	r2, r2, ip
 8003986:	fa00 f00c 	lsl.w	r0, r0, ip
 800398a:	bfaa      	itet	ge
 800398c:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8003990:	4252      	neglt	r2, r2
 8003992:	4318      	orrge	r0, r3
 8003994:	bfbc      	itt	lt
 8003996:	40d0      	lsrlt	r0, r2
 8003998:	4318      	orrlt	r0, r3
 800399a:	4770      	bx	lr
 800399c:	f092 0f00 	teq	r2, #0
 80039a0:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 80039a4:	bf06      	itte	eq
 80039a6:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 80039aa:	3201      	addeq	r2, #1
 80039ac:	3b01      	subne	r3, #1
 80039ae:	e7b5      	b.n	800391c <__addsf3+0x58>
 80039b0:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80039b4:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80039b8:	bf18      	it	ne
 80039ba:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80039be:	d021      	beq.n	8003a04 <__addsf3+0x140>
 80039c0:	ea92 0f03 	teq	r2, r3
 80039c4:	d004      	beq.n	80039d0 <__addsf3+0x10c>
 80039c6:	f092 0f00 	teq	r2, #0
 80039ca:	bf08      	it	eq
 80039cc:	4608      	moveq	r0, r1
 80039ce:	4770      	bx	lr
 80039d0:	ea90 0f01 	teq	r0, r1
 80039d4:	bf1c      	itt	ne
 80039d6:	2000      	movne	r0, #0
 80039d8:	4770      	bxne	lr
 80039da:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 80039de:	d104      	bne.n	80039ea <__addsf3+0x126>
 80039e0:	0040      	lsls	r0, r0, #1
 80039e2:	bf28      	it	cs
 80039e4:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 80039e8:	4770      	bx	lr
 80039ea:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 80039ee:	bf3c      	itt	cc
 80039f0:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 80039f4:	4770      	bxcc	lr
 80039f6:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80039fa:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 80039fe:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8003a02:	4770      	bx	lr
 8003a04:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8003a08:	bf16      	itet	ne
 8003a0a:	4608      	movne	r0, r1
 8003a0c:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8003a10:	4601      	movne	r1, r0
 8003a12:	0242      	lsls	r2, r0, #9
 8003a14:	bf06      	itte	eq
 8003a16:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8003a1a:	ea90 0f01 	teqeq	r0, r1
 8003a1e:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 8003a22:	4770      	bx	lr

08003a24 <__aeabi_ui2f>:
 8003a24:	f04f 0300 	mov.w	r3, #0
 8003a28:	e004      	b.n	8003a34 <__aeabi_i2f+0x8>
 8003a2a:	bf00      	nop

08003a2c <__aeabi_i2f>:
 8003a2c:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8003a30:	bf48      	it	mi
 8003a32:	4240      	negmi	r0, r0
 8003a34:	ea5f 0c00 	movs.w	ip, r0
 8003a38:	bf08      	it	eq
 8003a3a:	4770      	bxeq	lr
 8003a3c:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8003a40:	4601      	mov	r1, r0
 8003a42:	f04f 0000 	mov.w	r0, #0
 8003a46:	e01c      	b.n	8003a82 <__aeabi_l2f+0x2a>

08003a48 <__aeabi_ul2f>:
 8003a48:	ea50 0201 	orrs.w	r2, r0, r1
 8003a4c:	bf08      	it	eq
 8003a4e:	4770      	bxeq	lr
 8003a50:	f04f 0300 	mov.w	r3, #0
 8003a54:	e00a      	b.n	8003a6c <__aeabi_l2f+0x14>
 8003a56:	bf00      	nop

08003a58 <__aeabi_l2f>:
 8003a58:	ea50 0201 	orrs.w	r2, r0, r1
 8003a5c:	bf08      	it	eq
 8003a5e:	4770      	bxeq	lr
 8003a60:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8003a64:	d502      	bpl.n	8003a6c <__aeabi_l2f+0x14>
 8003a66:	4240      	negs	r0, r0
 8003a68:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8003a6c:	ea5f 0c01 	movs.w	ip, r1
 8003a70:	bf02      	ittt	eq
 8003a72:	4684      	moveq	ip, r0
 8003a74:	4601      	moveq	r1, r0
 8003a76:	2000      	moveq	r0, #0
 8003a78:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 8003a7c:	bf08      	it	eq
 8003a7e:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8003a82:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8003a86:	fabc f28c 	clz	r2, ip
 8003a8a:	3a08      	subs	r2, #8
 8003a8c:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8003a90:	db10      	blt.n	8003ab4 <__aeabi_l2f+0x5c>
 8003a92:	fa01 fc02 	lsl.w	ip, r1, r2
 8003a96:	4463      	add	r3, ip
 8003a98:	fa00 fc02 	lsl.w	ip, r0, r2
 8003a9c:	f1c2 0220 	rsb	r2, r2, #32
 8003aa0:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8003aa4:	fa20 f202 	lsr.w	r2, r0, r2
 8003aa8:	eb43 0002 	adc.w	r0, r3, r2
 8003aac:	bf08      	it	eq
 8003aae:	f020 0001 	biceq.w	r0, r0, #1
 8003ab2:	4770      	bx	lr
 8003ab4:	f102 0220 	add.w	r2, r2, #32
 8003ab8:	fa01 fc02 	lsl.w	ip, r1, r2
 8003abc:	f1c2 0220 	rsb	r2, r2, #32
 8003ac0:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8003ac4:	fa21 f202 	lsr.w	r2, r1, r2
 8003ac8:	eb43 0002 	adc.w	r0, r3, r2
 8003acc:	bf08      	it	eq
 8003ace:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8003ad2:	4770      	bx	lr

08003ad4 <__aeabi_fmul>:
 8003ad4:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8003ad8:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8003adc:	bf1e      	ittt	ne
 8003ade:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8003ae2:	ea92 0f0c 	teqne	r2, ip
 8003ae6:	ea93 0f0c 	teqne	r3, ip
 8003aea:	d06f      	beq.n	8003bcc <__aeabi_fmul+0xf8>
 8003aec:	441a      	add	r2, r3
 8003aee:	ea80 0c01 	eor.w	ip, r0, r1
 8003af2:	0240      	lsls	r0, r0, #9
 8003af4:	bf18      	it	ne
 8003af6:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 8003afa:	d01e      	beq.n	8003b3a <__aeabi_fmul+0x66>
 8003afc:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8003b00:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 8003b04:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 8003b08:	fba0 3101 	umull	r3, r1, r0, r1
 8003b0c:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8003b10:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8003b14:	bf3e      	ittt	cc
 8003b16:	0049      	lslcc	r1, r1, #1
 8003b18:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 8003b1c:	005b      	lslcc	r3, r3, #1
 8003b1e:	ea40 0001 	orr.w	r0, r0, r1
 8003b22:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 8003b26:	2afd      	cmp	r2, #253	; 0xfd
 8003b28:	d81d      	bhi.n	8003b66 <__aeabi_fmul+0x92>
 8003b2a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8003b2e:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8003b32:	bf08      	it	eq
 8003b34:	f020 0001 	biceq.w	r0, r0, #1
 8003b38:	4770      	bx	lr
 8003b3a:	f090 0f00 	teq	r0, #0
 8003b3e:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8003b42:	bf08      	it	eq
 8003b44:	0249      	lsleq	r1, r1, #9
 8003b46:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8003b4a:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 8003b4e:	3a7f      	subs	r2, #127	; 0x7f
 8003b50:	bfc2      	ittt	gt
 8003b52:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8003b56:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8003b5a:	4770      	bxgt	lr
 8003b5c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8003b60:	f04f 0300 	mov.w	r3, #0
 8003b64:	3a01      	subs	r2, #1
 8003b66:	dc5d      	bgt.n	8003c24 <__aeabi_fmul+0x150>
 8003b68:	f112 0f19 	cmn.w	r2, #25
 8003b6c:	bfdc      	itt	le
 8003b6e:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 8003b72:	4770      	bxle	lr
 8003b74:	f1c2 0200 	rsb	r2, r2, #0
 8003b78:	0041      	lsls	r1, r0, #1
 8003b7a:	fa21 f102 	lsr.w	r1, r1, r2
 8003b7e:	f1c2 0220 	rsb	r2, r2, #32
 8003b82:	fa00 fc02 	lsl.w	ip, r0, r2
 8003b86:	ea5f 0031 	movs.w	r0, r1, rrx
 8003b8a:	f140 0000 	adc.w	r0, r0, #0
 8003b8e:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 8003b92:	bf08      	it	eq
 8003b94:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8003b98:	4770      	bx	lr
 8003b9a:	f092 0f00 	teq	r2, #0
 8003b9e:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8003ba2:	bf02      	ittt	eq
 8003ba4:	0040      	lsleq	r0, r0, #1
 8003ba6:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8003baa:	3a01      	subeq	r2, #1
 8003bac:	d0f9      	beq.n	8003ba2 <__aeabi_fmul+0xce>
 8003bae:	ea40 000c 	orr.w	r0, r0, ip
 8003bb2:	f093 0f00 	teq	r3, #0
 8003bb6:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8003bba:	bf02      	ittt	eq
 8003bbc:	0049      	lsleq	r1, r1, #1
 8003bbe:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8003bc2:	3b01      	subeq	r3, #1
 8003bc4:	d0f9      	beq.n	8003bba <__aeabi_fmul+0xe6>
 8003bc6:	ea41 010c 	orr.w	r1, r1, ip
 8003bca:	e78f      	b.n	8003aec <__aeabi_fmul+0x18>
 8003bcc:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8003bd0:	ea92 0f0c 	teq	r2, ip
 8003bd4:	bf18      	it	ne
 8003bd6:	ea93 0f0c 	teqne	r3, ip
 8003bda:	d00a      	beq.n	8003bf2 <__aeabi_fmul+0x11e>
 8003bdc:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8003be0:	bf18      	it	ne
 8003be2:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8003be6:	d1d8      	bne.n	8003b9a <__aeabi_fmul+0xc6>
 8003be8:	ea80 0001 	eor.w	r0, r0, r1
 8003bec:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8003bf0:	4770      	bx	lr
 8003bf2:	f090 0f00 	teq	r0, #0
 8003bf6:	bf17      	itett	ne
 8003bf8:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 8003bfc:	4608      	moveq	r0, r1
 8003bfe:	f091 0f00 	teqne	r1, #0
 8003c02:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 8003c06:	d014      	beq.n	8003c32 <__aeabi_fmul+0x15e>
 8003c08:	ea92 0f0c 	teq	r2, ip
 8003c0c:	d101      	bne.n	8003c12 <__aeabi_fmul+0x13e>
 8003c0e:	0242      	lsls	r2, r0, #9
 8003c10:	d10f      	bne.n	8003c32 <__aeabi_fmul+0x15e>
 8003c12:	ea93 0f0c 	teq	r3, ip
 8003c16:	d103      	bne.n	8003c20 <__aeabi_fmul+0x14c>
 8003c18:	024b      	lsls	r3, r1, #9
 8003c1a:	bf18      	it	ne
 8003c1c:	4608      	movne	r0, r1
 8003c1e:	d108      	bne.n	8003c32 <__aeabi_fmul+0x15e>
 8003c20:	ea80 0001 	eor.w	r0, r0, r1
 8003c24:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8003c28:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8003c2c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8003c30:	4770      	bx	lr
 8003c32:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8003c36:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 8003c3a:	4770      	bx	lr

08003c3c <__aeabi_fdiv>:
 8003c3c:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8003c40:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8003c44:	bf1e      	ittt	ne
 8003c46:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8003c4a:	ea92 0f0c 	teqne	r2, ip
 8003c4e:	ea93 0f0c 	teqne	r3, ip
 8003c52:	d069      	beq.n	8003d28 <__aeabi_fdiv+0xec>
 8003c54:	eba2 0203 	sub.w	r2, r2, r3
 8003c58:	ea80 0c01 	eor.w	ip, r0, r1
 8003c5c:	0249      	lsls	r1, r1, #9
 8003c5e:	ea4f 2040 	mov.w	r0, r0, lsl #9
 8003c62:	d037      	beq.n	8003cd4 <__aeabi_fdiv+0x98>
 8003c64:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8003c68:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 8003c6c:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8003c70:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8003c74:	428b      	cmp	r3, r1
 8003c76:	bf38      	it	cc
 8003c78:	005b      	lslcc	r3, r3, #1
 8003c7a:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 8003c7e:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 8003c82:	428b      	cmp	r3, r1
 8003c84:	bf24      	itt	cs
 8003c86:	1a5b      	subcs	r3, r3, r1
 8003c88:	ea40 000c 	orrcs.w	r0, r0, ip
 8003c8c:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 8003c90:	bf24      	itt	cs
 8003c92:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 8003c96:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8003c9a:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 8003c9e:	bf24      	itt	cs
 8003ca0:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 8003ca4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8003ca8:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 8003cac:	bf24      	itt	cs
 8003cae:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 8003cb2:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8003cb6:	011b      	lsls	r3, r3, #4
 8003cb8:	bf18      	it	ne
 8003cba:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 8003cbe:	d1e0      	bne.n	8003c82 <__aeabi_fdiv+0x46>
 8003cc0:	2afd      	cmp	r2, #253	; 0xfd
 8003cc2:	f63f af50 	bhi.w	8003b66 <__aeabi_fmul+0x92>
 8003cc6:	428b      	cmp	r3, r1
 8003cc8:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8003ccc:	bf08      	it	eq
 8003cce:	f020 0001 	biceq.w	r0, r0, #1
 8003cd2:	4770      	bx	lr
 8003cd4:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8003cd8:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8003cdc:	327f      	adds	r2, #127	; 0x7f
 8003cde:	bfc2      	ittt	gt
 8003ce0:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8003ce4:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8003ce8:	4770      	bxgt	lr
 8003cea:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8003cee:	f04f 0300 	mov.w	r3, #0
 8003cf2:	3a01      	subs	r2, #1
 8003cf4:	e737      	b.n	8003b66 <__aeabi_fmul+0x92>
 8003cf6:	f092 0f00 	teq	r2, #0
 8003cfa:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8003cfe:	bf02      	ittt	eq
 8003d00:	0040      	lsleq	r0, r0, #1
 8003d02:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8003d06:	3a01      	subeq	r2, #1
 8003d08:	d0f9      	beq.n	8003cfe <__aeabi_fdiv+0xc2>
 8003d0a:	ea40 000c 	orr.w	r0, r0, ip
 8003d0e:	f093 0f00 	teq	r3, #0
 8003d12:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8003d16:	bf02      	ittt	eq
 8003d18:	0049      	lsleq	r1, r1, #1
 8003d1a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8003d1e:	3b01      	subeq	r3, #1
 8003d20:	d0f9      	beq.n	8003d16 <__aeabi_fdiv+0xda>
 8003d22:	ea41 010c 	orr.w	r1, r1, ip
 8003d26:	e795      	b.n	8003c54 <__aeabi_fdiv+0x18>
 8003d28:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8003d2c:	ea92 0f0c 	teq	r2, ip
 8003d30:	d108      	bne.n	8003d44 <__aeabi_fdiv+0x108>
 8003d32:	0242      	lsls	r2, r0, #9
 8003d34:	f47f af7d 	bne.w	8003c32 <__aeabi_fmul+0x15e>
 8003d38:	ea93 0f0c 	teq	r3, ip
 8003d3c:	f47f af70 	bne.w	8003c20 <__aeabi_fmul+0x14c>
 8003d40:	4608      	mov	r0, r1
 8003d42:	e776      	b.n	8003c32 <__aeabi_fmul+0x15e>
 8003d44:	ea93 0f0c 	teq	r3, ip
 8003d48:	d104      	bne.n	8003d54 <__aeabi_fdiv+0x118>
 8003d4a:	024b      	lsls	r3, r1, #9
 8003d4c:	f43f af4c 	beq.w	8003be8 <__aeabi_fmul+0x114>
 8003d50:	4608      	mov	r0, r1
 8003d52:	e76e      	b.n	8003c32 <__aeabi_fmul+0x15e>
 8003d54:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8003d58:	bf18      	it	ne
 8003d5a:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8003d5e:	d1ca      	bne.n	8003cf6 <__aeabi_fdiv+0xba>
 8003d60:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8003d64:	f47f af5c 	bne.w	8003c20 <__aeabi_fmul+0x14c>
 8003d68:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 8003d6c:	f47f af3c 	bne.w	8003be8 <__aeabi_fmul+0x114>
 8003d70:	e75f      	b.n	8003c32 <__aeabi_fmul+0x15e>
 8003d72:	bf00      	nop

08003d74 <stale_transfer_cleanup_task_func.lto_priv.52>:
    uint64_t timestamp = micros64();
    canardHandleRxFrame(&instance->canard, &canard_frame, timestamp);
    palClearPad(GPIOB, 3);
}

static void stale_transfer_cleanup_task_func(struct worker_thread_timer_task_s* task) {
 8003d74:	b590      	push	{r4, r7, lr}
 8003d76:	b085      	sub	sp, #20
 8003d78:	af00      	add	r7, sp, #0
 8003d7a:	6078      	str	r0, [r7, #4]
    (void)task;
    struct uavcan_instance_s* instance = NULL;
 8003d7c:	2300      	movs	r3, #0
 8003d7e:	60fb      	str	r3, [r7, #12]
 8003d80:	e009      	b.n	8003d96 <stale_transfer_cleanup_task_func.lto_priv.52+0x22>

    while (uavcan_iterate_instances(&instance)) {
        canardCleanupStaleTransfers(&instance->canard, micros64());
 8003d82:	68fb      	ldr	r3, [r7, #12]
 8003d84:	f103 0408 	add.w	r4, r3, #8
 8003d88:	f003 faba 	bl	8007300 <micros64>
 8003d8c:	4602      	mov	r2, r0
 8003d8e:	460b      	mov	r3, r1
 8003d90:	4620      	mov	r0, r4
 8003d92:	f007 fe63 	bl	800ba5c <canardCleanupStaleTransfers>

static void stale_transfer_cleanup_task_func(struct worker_thread_timer_task_s* task) {
    (void)task;
    struct uavcan_instance_s* instance = NULL;

    while (uavcan_iterate_instances(&instance)) {
 8003d96:	f107 030c 	add.w	r3, r7, #12
 8003d9a:	4618      	mov	r0, r3
 8003d9c:	f001 fc22 	bl	80055e4 <uavcan_iterate_instances.lto_priv.47>
 8003da0:	4603      	mov	r3, r0
 8003da2:	2b00      	cmp	r3, #0
 8003da4:	d1ed      	bne.n	8003d82 <stale_transfer_cleanup_task_func.lto_priv.52+0xe>
        canardCleanupStaleTransfers(&instance->canard, micros64());
    }
}
 8003da6:	3714      	adds	r7, #20
 8003da8:	46bd      	mov	sp, r7
 8003daa:	bd90      	pop	{r4, r7, pc}

08003dac <uavcan_get_instance.lto_priv.71>:

static struct uavcan_instance_s* uavcan_get_instance(uint8_t idx) {
 8003dac:	b480      	push	{r7}
 8003dae:	b085      	sub	sp, #20
 8003db0:	af00      	add	r7, sp, #0
 8003db2:	4603      	mov	r3, r0
 8003db4:	71fb      	strb	r3, [r7, #7]
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
 8003db6:	4b0e      	ldr	r3, [pc, #56]	; (8003df0 <uavcan_get_instance.lto_priv.71+0x44>)
 8003db8:	681b      	ldr	r3, [r3, #0]
 8003dba:	60fb      	str	r3, [r7, #12]
 8003dbc:	e005      	b.n	8003dca <uavcan_get_instance.lto_priv.71+0x1e>
    while (instance && idx != 0) {
        idx--;
 8003dbe:	79fb      	ldrb	r3, [r7, #7]
 8003dc0:	3b01      	subs	r3, #1
 8003dc2:	71fb      	strb	r3, [r7, #7]
        instance = instance->next;
 8003dc4:	68fb      	ldr	r3, [r7, #12]
 8003dc6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003dc8:	60fb      	str	r3, [r7, #12]
    }
}

static struct uavcan_instance_s* uavcan_get_instance(uint8_t idx) {
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
    while (instance && idx != 0) {
 8003dca:	68fb      	ldr	r3, [r7, #12]
 8003dcc:	2b00      	cmp	r3, #0
 8003dce:	d002      	beq.n	8003dd6 <uavcan_get_instance.lto_priv.71+0x2a>
 8003dd0:	79fb      	ldrb	r3, [r7, #7]
 8003dd2:	2b00      	cmp	r3, #0
 8003dd4:	d1f3      	bne.n	8003dbe <uavcan_get_instance.lto_priv.71+0x12>
        idx--;
        instance = instance->next;
    }

    if (idx != 0) {
 8003dd6:	79fb      	ldrb	r3, [r7, #7]
 8003dd8:	2b00      	cmp	r3, #0
 8003dda:	d001      	beq.n	8003de0 <uavcan_get_instance.lto_priv.71+0x34>
        return NULL;
 8003ddc:	2300      	movs	r3, #0
 8003dde:	e000      	b.n	8003de2 <uavcan_get_instance.lto_priv.71+0x36>
    } else {
        return instance;
 8003de0:	68fb      	ldr	r3, [r7, #12]
    }
}
 8003de2:	4618      	mov	r0, r3
 8003de4:	3714      	adds	r7, #20
 8003de6:	46bd      	mov	sp, r7
 8003de8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003dec:	4770      	bx	lr
 8003dee:	bf00      	nop
 8003df0:	20001414 	.word	0x20001414

08003df4 <uavcan_get_num_instances>:

uint8_t uavcan_get_num_instances(void) {
 8003df4:	b480      	push	{r7}
 8003df6:	b083      	sub	sp, #12
 8003df8:	af00      	add	r7, sp, #0
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
 8003dfa:	4b0b      	ldr	r3, [pc, #44]	; (8003e28 <uavcan_get_num_instances+0x34>)
 8003dfc:	681b      	ldr	r3, [r3, #0]
 8003dfe:	607b      	str	r3, [r7, #4]
    uint8_t count = 0;
 8003e00:	2300      	movs	r3, #0
 8003e02:	70fb      	strb	r3, [r7, #3]
 8003e04:	e005      	b.n	8003e12 <uavcan_get_num_instances+0x1e>
    while (instance) {
        count++;
 8003e06:	78fb      	ldrb	r3, [r7, #3]
 8003e08:	3301      	adds	r3, #1
 8003e0a:	70fb      	strb	r3, [r7, #3]
        instance = instance->next;
 8003e0c:	687b      	ldr	r3, [r7, #4]
 8003e0e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003e10:	607b      	str	r3, [r7, #4]
}

uint8_t uavcan_get_num_instances(void) {
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
    uint8_t count = 0;
    while (instance) {
 8003e12:	687b      	ldr	r3, [r7, #4]
 8003e14:	2b00      	cmp	r3, #0
 8003e16:	d1f6      	bne.n	8003e06 <uavcan_get_num_instances+0x12>
        count++;
        instance = instance->next;
    }
    return count;
 8003e18:	78fb      	ldrb	r3, [r7, #3]
}
 8003e1a:	4618      	mov	r0, r3
 8003e1c:	370c      	adds	r7, #12
 8003e1e:	46bd      	mov	sp, r7
 8003e20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003e24:	4770      	bx	lr
 8003e26:	bf00      	nop
 8003e28:	20001414 	.word	0x20001414

08003e2c <uavcan_get_idx.lto_priv.73>:

static uint8_t uavcan_get_idx(struct uavcan_instance_s* instance_arg) {
 8003e2c:	b480      	push	{r7}
 8003e2e:	b085      	sub	sp, #20
 8003e30:	af00      	add	r7, sp, #0
 8003e32:	6078      	str	r0, [r7, #4]
    uint8_t idx = 0;
 8003e34:	2300      	movs	r3, #0
 8003e36:	73fb      	strb	r3, [r7, #15]
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
 8003e38:	4b0b      	ldr	r3, [pc, #44]	; (8003e68 <uavcan_get_idx.lto_priv.73+0x3c>)
 8003e3a:	681b      	ldr	r3, [r3, #0]
 8003e3c:	60bb      	str	r3, [r7, #8]
 8003e3e:	e005      	b.n	8003e4c <uavcan_get_idx.lto_priv.73+0x20>
    while (instance && instance != instance_arg) {
        idx++;
 8003e40:	7bfb      	ldrb	r3, [r7, #15]
 8003e42:	3301      	adds	r3, #1
 8003e44:	73fb      	strb	r3, [r7, #15]
        instance = instance->next;
 8003e46:	68bb      	ldr	r3, [r7, #8]
 8003e48:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003e4a:	60bb      	str	r3, [r7, #8]
}

static uint8_t uavcan_get_idx(struct uavcan_instance_s* instance_arg) {
    uint8_t idx = 0;
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
    while (instance && instance != instance_arg) {
 8003e4c:	68bb      	ldr	r3, [r7, #8]
 8003e4e:	2b00      	cmp	r3, #0
 8003e50:	d003      	beq.n	8003e5a <uavcan_get_idx.lto_priv.73+0x2e>
 8003e52:	68ba      	ldr	r2, [r7, #8]
 8003e54:	687b      	ldr	r3, [r7, #4]
 8003e56:	429a      	cmp	r2, r3
 8003e58:	d1f2      	bne.n	8003e40 <uavcan_get_idx.lto_priv.73+0x14>
        idx++;
        instance = instance->next;
    }
    return idx;
 8003e5a:	7bfb      	ldrb	r3, [r7, #15]
}
 8003e5c:	4618      	mov	r0, r3
 8003e5e:	3714      	adds	r7, #20
 8003e60:	46bd      	mov	sp, r7
 8003e62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003e66:	4770      	bx	lr
 8003e68:	20001414 	.word	0x20001414

08003e6c <convert_can_frame_to_CanardCANFrame.lto_priv.70>:

static CanardCANFrame convert_can_frame_to_CanardCANFrame(const struct can_frame_s* frame) {
 8003e6c:	b590      	push	{r4, r7, lr}
 8003e6e:	b087      	sub	sp, #28
 8003e70:	af00      	add	r7, sp, #0
 8003e72:	6078      	str	r0, [r7, #4]
 8003e74:	6039      	str	r1, [r7, #0]
    CanardCANFrame ret;
    if (frame->IDE) {
 8003e76:	683b      	ldr	r3, [r7, #0]
 8003e78:	781b      	ldrb	r3, [r3, #0]
 8003e7a:	f003 0302 	and.w	r3, r3, #2
 8003e7e:	b2db      	uxtb	r3, r3
 8003e80:	2b00      	cmp	r3, #0
 8003e82:	d007      	beq.n	8003e94 <convert_can_frame_to_CanardCANFrame.lto_priv.70+0x28>
        ret.id = frame->EID | CANARD_CAN_FRAME_EFF;
 8003e84:	683b      	ldr	r3, [r7, #0]
 8003e86:	685b      	ldr	r3, [r3, #4]
 8003e88:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8003e8c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8003e90:	60bb      	str	r3, [r7, #8]
 8003e92:	e005      	b.n	8003ea0 <convert_can_frame_to_CanardCANFrame.lto_priv.70+0x34>
    } else {
        ret.id = frame->SID;
 8003e94:	683b      	ldr	r3, [r7, #0]
 8003e96:	889b      	ldrh	r3, [r3, #4]
 8003e98:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8003e9c:	b29b      	uxth	r3, r3
 8003e9e:	60bb      	str	r3, [r7, #8]
    }

    if (frame->RTR) {
 8003ea0:	683b      	ldr	r3, [r7, #0]
 8003ea2:	781b      	ldrb	r3, [r3, #0]
 8003ea4:	f003 0301 	and.w	r3, r3, #1
 8003ea8:	b2db      	uxtb	r3, r3
 8003eaa:	2b00      	cmp	r3, #0
 8003eac:	d003      	beq.n	8003eb6 <convert_can_frame_to_CanardCANFrame.lto_priv.70+0x4a>
        ret.id |= CANARD_CAN_FRAME_RTR;
 8003eae:	68bb      	ldr	r3, [r7, #8]
 8003eb0:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8003eb4:	60bb      	str	r3, [r7, #8]
    }

    ret.data_len = frame->DLC;
 8003eb6:	683b      	ldr	r3, [r7, #0]
 8003eb8:	781b      	ldrb	r3, [r3, #0]
 8003eba:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8003ebe:	b2db      	uxtb	r3, r3
 8003ec0:	753b      	strb	r3, [r7, #20]
    memcpy(ret.data, frame->data, ret.data_len);
 8003ec2:	683b      	ldr	r3, [r7, #0]
 8003ec4:	f103 0208 	add.w	r2, r3, #8
 8003ec8:	7d3b      	ldrb	r3, [r7, #20]
 8003eca:	461c      	mov	r4, r3
 8003ecc:	f107 0308 	add.w	r3, r7, #8
 8003ed0:	3304      	adds	r3, #4
 8003ed2:	4618      	mov	r0, r3
 8003ed4:	4611      	mov	r1, r2
 8003ed6:	4622      	mov	r2, r4
 8003ed8:	f008 fe8a 	bl	800cbf0 <memcpy>
    return ret;
 8003edc:	687b      	ldr	r3, [r7, #4]
 8003ede:	461c      	mov	r4, r3
 8003ee0:	f107 0308 	add.w	r3, r7, #8
 8003ee4:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8003ee6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 8003eea:	6878      	ldr	r0, [r7, #4]
 8003eec:	371c      	adds	r7, #28
 8003eee:	46bd      	mov	sp, r7
 8003ef0:	bd90      	pop	{r4, r7, pc}
 8003ef2:	bf00      	nop

08003ef4 <uavcan_message_writer_func>:
    uint8_t uavcan_idx;
    CanardRxTransfer* transfer;
    const struct uavcan_message_descriptor_s* const descriptor;
};

static void uavcan_message_writer_func(size_t msg_size, void* write_buf, void* ctx) {
 8003ef4:	b580      	push	{r7, lr}
 8003ef6:	b086      	sub	sp, #24
 8003ef8:	af00      	add	r7, sp, #0
 8003efa:	60f8      	str	r0, [r7, #12]
 8003efc:	60b9      	str	r1, [r7, #8]
 8003efe:	607a      	str	r2, [r7, #4]
    (void)msg_size;
    struct uavcan_message_writer_func_args* args = ctx;
 8003f00:	687b      	ldr	r3, [r7, #4]
 8003f02:	617b      	str	r3, [r7, #20]
    struct uavcan_deserialized_message_s* deserialized_message = write_buf;
 8003f04:	68bb      	ldr	r3, [r7, #8]
 8003f06:	613b      	str	r3, [r7, #16]
    deserialized_message->uavcan_idx = args->uavcan_idx;
 8003f08:	697b      	ldr	r3, [r7, #20]
 8003f0a:	781a      	ldrb	r2, [r3, #0]
 8003f0c:	693b      	ldr	r3, [r7, #16]
 8003f0e:	701a      	strb	r2, [r3, #0]
    deserialized_message->descriptor = args->descriptor;
 8003f10:	697b      	ldr	r3, [r7, #20]
 8003f12:	689a      	ldr	r2, [r3, #8]
 8003f14:	693b      	ldr	r3, [r7, #16]
 8003f16:	605a      	str	r2, [r3, #4]
    deserialized_message->data_type_id = args->transfer->data_type_id;
 8003f18:	697b      	ldr	r3, [r7, #20]
 8003f1a:	685b      	ldr	r3, [r3, #4]
 8003f1c:	8ada      	ldrh	r2, [r3, #22]
 8003f1e:	693b      	ldr	r3, [r7, #16]
 8003f20:	811a      	strh	r2, [r3, #8]
    deserialized_message->transfer_id = args->transfer->transfer_id;
 8003f22:	697b      	ldr	r3, [r7, #20]
 8003f24:	685b      	ldr	r3, [r3, #4]
 8003f26:	7e5a      	ldrb	r2, [r3, #25]
 8003f28:	693b      	ldr	r3, [r7, #16]
 8003f2a:	729a      	strb	r2, [r3, #10]
    deserialized_message->priority = args->transfer->priority;
 8003f2c:	697b      	ldr	r3, [r7, #20]
 8003f2e:	685b      	ldr	r3, [r3, #4]
 8003f30:	7e9a      	ldrb	r2, [r3, #26]
 8003f32:	693b      	ldr	r3, [r7, #16]
 8003f34:	72da      	strb	r2, [r3, #11]
    deserialized_message->source_node_id = args->transfer->source_node_id;
 8003f36:	697b      	ldr	r3, [r7, #20]
 8003f38:	685b      	ldr	r3, [r3, #4]
 8003f3a:	7eda      	ldrb	r2, [r3, #27]
 8003f3c:	693b      	ldr	r3, [r7, #16]
 8003f3e:	731a      	strb	r2, [r3, #12]
    args->descriptor->deserializer_func(args->transfer, deserialized_message->msg);
 8003f40:	697b      	ldr	r3, [r7, #20]
 8003f42:	689b      	ldr	r3, [r3, #8]
 8003f44:	699b      	ldr	r3, [r3, #24]
 8003f46:	697a      	ldr	r2, [r7, #20]
 8003f48:	6851      	ldr	r1, [r2, #4]
 8003f4a:	693a      	ldr	r2, [r7, #16]
 8003f4c:	3210      	adds	r2, #16
 8003f4e:	4608      	mov	r0, r1
 8003f50:	4611      	mov	r1, r2
 8003f52:	4798      	blx	r3
}
 8003f54:	3718      	adds	r7, #24
 8003f56:	46bd      	mov	sp, r7
 8003f58:	bd80      	pop	{r7, pc}
 8003f5a:	bf00      	nop

08003f5c <uavcan_on_transfer_rx.lto_priv.49>:

static void uavcan_on_transfer_rx(CanardInstance* canard, CanardRxTransfer* transfer) {
 8003f5c:	b580      	push	{r7, lr}
 8003f5e:	b088      	sub	sp, #32
 8003f60:	af00      	add	r7, sp, #0
 8003f62:	6078      	str	r0, [r7, #4]
 8003f64:	6039      	str	r1, [r7, #0]
    if (!canard || !transfer) {
 8003f66:	687b      	ldr	r3, [r7, #4]
 8003f68:	2b00      	cmp	r3, #0
 8003f6a:	d03c      	beq.n	8003fe6 <uavcan_on_transfer_rx.lto_priv.49+0x8a>
 8003f6c:	683b      	ldr	r3, [r7, #0]
 8003f6e:	2b00      	cmp	r3, #0
 8003f70:	d039      	beq.n	8003fe6 <uavcan_on_transfer_rx.lto_priv.49+0x8a>
        return;
    }

    struct uavcan_instance_s* instance = canardGetUserReference(canard);
 8003f72:	6878      	ldr	r0, [r7, #4]
 8003f74:	f007 fa12 	bl	800b39c <canardGetUserReference>
 8003f78:	61b8      	str	r0, [r7, #24]
    if (!instance) {
 8003f7a:	69bb      	ldr	r3, [r7, #24]
 8003f7c:	2b00      	cmp	r3, #0
 8003f7e:	d032      	beq.n	8003fe6 <uavcan_on_transfer_rx.lto_priv.49+0x8a>
        return;
    }

    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
 8003f80:	69bb      	ldr	r3, [r7, #24]
 8003f82:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8003f84:	61fb      	str	r3, [r7, #28]
 8003f86:	e02b      	b.n	8003fe0 <uavcan_on_transfer_rx.lto_priv.49+0x84>
    while (rx_list_item) {
        if (rx_list_item->msg_descriptor->transfer_type == transfer->transfer_type && _uavcan_get_message_data_type_id(instance, rx_list_item->msg_descriptor) == transfer->data_type_id) {
 8003f88:	69fb      	ldr	r3, [r7, #28]
 8003f8a:	681b      	ldr	r3, [r3, #0]
 8003f8c:	7a9a      	ldrb	r2, [r3, #10]
 8003f8e:	683b      	ldr	r3, [r7, #0]
 8003f90:	7e1b      	ldrb	r3, [r3, #24]
 8003f92:	429a      	cmp	r2, r3
 8003f94:	d121      	bne.n	8003fda <uavcan_on_transfer_rx.lto_priv.49+0x7e>
 8003f96:	69fb      	ldr	r3, [r7, #28]
 8003f98:	681b      	ldr	r3, [r3, #0]
 8003f9a:	69b8      	ldr	r0, [r7, #24]
 8003f9c:	4619      	mov	r1, r3
 8003f9e:	f001 fbaf 	bl	8005700 <_uavcan_get_message_data_type_id.lto_priv.46>
 8003fa2:	4603      	mov	r3, r0
 8003fa4:	461a      	mov	r2, r3
 8003fa6:	683b      	ldr	r3, [r7, #0]
 8003fa8:	8adb      	ldrh	r3, [r3, #22]
 8003faa:	429a      	cmp	r2, r3
 8003fac:	d115      	bne.n	8003fda <uavcan_on_transfer_rx.lto_priv.49+0x7e>
            struct uavcan_message_writer_func_args writer_args = { instance->idx, transfer, rx_list_item->msg_descriptor };
 8003fae:	69bb      	ldr	r3, [r7, #24]
 8003fb0:	781b      	ldrb	r3, [r3, #0]
 8003fb2:	733b      	strb	r3, [r7, #12]
 8003fb4:	683b      	ldr	r3, [r7, #0]
 8003fb6:	613b      	str	r3, [r7, #16]
 8003fb8:	69fb      	ldr	r3, [r7, #28]
 8003fba:	681b      	ldr	r3, [r3, #0]
 8003fbc:	617b      	str	r3, [r7, #20]
            pubsub_publish_message(&rx_list_item->topic, rx_list_item->msg_descriptor->deserialized_size+sizeof(struct uavcan_deserialized_message_s), uavcan_message_writer_func, &writer_args);
 8003fbe:	69fb      	ldr	r3, [r7, #28]
 8003fc0:	1d19      	adds	r1, r3, #4
 8003fc2:	69fb      	ldr	r3, [r7, #28]
 8003fc4:	681b      	ldr	r3, [r3, #0]
 8003fc6:	68db      	ldr	r3, [r3, #12]
 8003fc8:	f103 0210 	add.w	r2, r3, #16
 8003fcc:	f107 030c 	add.w	r3, r7, #12
 8003fd0:	4608      	mov	r0, r1
 8003fd2:	4611      	mov	r1, r2
 8003fd4:	4a05      	ldr	r2, [pc, #20]	; (8003fec <uavcan_on_transfer_rx.lto_priv.49+0x90>)
 8003fd6:	f003 fcaf 	bl	8007938 <pubsub_publish_message>
        }

        rx_list_item = rx_list_item->next;
 8003fda:	69fb      	ldr	r3, [r7, #28]
 8003fdc:	691b      	ldr	r3, [r3, #16]
 8003fde:	61fb      	str	r3, [r7, #28]
    if (!instance) {
        return;
    }

    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
    while (rx_list_item) {
 8003fe0:	69fb      	ldr	r3, [r7, #28]
 8003fe2:	2b00      	cmp	r3, #0
 8003fe4:	d1d0      	bne.n	8003f88 <uavcan_on_transfer_rx.lto_priv.49+0x2c>
            pubsub_publish_message(&rx_list_item->topic, rx_list_item->msg_descriptor->deserialized_size+sizeof(struct uavcan_deserialized_message_s), uavcan_message_writer_func, &writer_args);
        }

        rx_list_item = rx_list_item->next;
    }
}
 8003fe6:	3720      	adds	r7, #32
 8003fe8:	46bd      	mov	sp, r7
 8003fea:	bd80      	pop	{r7, pc}
 8003fec:	08003ef5 	.word	0x08003ef5

08003ff0 <uavcan_should_accept_transfer.lto_priv.50>:

static bool uavcan_should_accept_transfer(const CanardInstance* canard, uint64_t* out_data_type_signature, uint16_t data_type_id, CanardTransferType transfer_type, uint8_t source_node_id) {
 8003ff0:	b580      	push	{r7, lr}
 8003ff2:	b086      	sub	sp, #24
 8003ff4:	af00      	add	r7, sp, #0
 8003ff6:	60f8      	str	r0, [r7, #12]
 8003ff8:	60b9      	str	r1, [r7, #8]
 8003ffa:	4611      	mov	r1, r2
 8003ffc:	461a      	mov	r2, r3
 8003ffe:	460b      	mov	r3, r1
 8004000:	80fb      	strh	r3, [r7, #6]
 8004002:	4613      	mov	r3, r2
 8004004:	717b      	strb	r3, [r7, #5]
    (void)source_node_id;
    if (!canard || !out_data_type_signature) {
 8004006:	68fb      	ldr	r3, [r7, #12]
 8004008:	2b00      	cmp	r3, #0
 800400a:	d002      	beq.n	8004012 <uavcan_should_accept_transfer.lto_priv.50+0x22>
 800400c:	68bb      	ldr	r3, [r7, #8]
 800400e:	2b00      	cmp	r3, #0
 8004010:	d101      	bne.n	8004016 <uavcan_should_accept_transfer.lto_priv.50+0x26>
        return false;
 8004012:	2300      	movs	r3, #0
 8004014:	e02d      	b.n	8004072 <uavcan_should_accept_transfer.lto_priv.50+0x82>
    }

    struct uavcan_instance_s* instance = canardGetUserReference((CanardInstance*)canard);
 8004016:	68f8      	ldr	r0, [r7, #12]
 8004018:	f007 f9c0 	bl	800b39c <canardGetUserReference>
 800401c:	6138      	str	r0, [r7, #16]
    if (!instance) {
 800401e:	693b      	ldr	r3, [r7, #16]
 8004020:	2b00      	cmp	r3, #0
 8004022:	d101      	bne.n	8004028 <uavcan_should_accept_transfer.lto_priv.50+0x38>
        return false;
 8004024:	2300      	movs	r3, #0
 8004026:	e024      	b.n	8004072 <uavcan_should_accept_transfer.lto_priv.50+0x82>
    }

    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
 8004028:	693b      	ldr	r3, [r7, #16]
 800402a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800402c:	617b      	str	r3, [r7, #20]
 800402e:	e01c      	b.n	800406a <uavcan_should_accept_transfer.lto_priv.50+0x7a>
    while (rx_list_item) {
        if (transfer_type == rx_list_item->msg_descriptor->transfer_type && data_type_id == _uavcan_get_message_data_type_id(instance, rx_list_item->msg_descriptor)) {
 8004030:	697b      	ldr	r3, [r7, #20]
 8004032:	681b      	ldr	r3, [r3, #0]
 8004034:	7a9b      	ldrb	r3, [r3, #10]
 8004036:	797a      	ldrb	r2, [r7, #5]
 8004038:	429a      	cmp	r2, r3
 800403a:	d113      	bne.n	8004064 <uavcan_should_accept_transfer.lto_priv.50+0x74>
 800403c:	697b      	ldr	r3, [r7, #20]
 800403e:	681b      	ldr	r3, [r3, #0]
 8004040:	6938      	ldr	r0, [r7, #16]
 8004042:	4619      	mov	r1, r3
 8004044:	f001 fb5c 	bl	8005700 <_uavcan_get_message_data_type_id.lto_priv.46>
 8004048:	4603      	mov	r3, r0
 800404a:	461a      	mov	r2, r3
 800404c:	88fb      	ldrh	r3, [r7, #6]
 800404e:	4293      	cmp	r3, r2
 8004050:	d108      	bne.n	8004064 <uavcan_should_accept_transfer.lto_priv.50+0x74>
            *out_data_type_signature = rx_list_item->msg_descriptor->data_type_signature;
 8004052:	697b      	ldr	r3, [r7, #20]
 8004054:	681b      	ldr	r3, [r3, #0]
 8004056:	e9d3 2300 	ldrd	r2, r3, [r3]
 800405a:	68b9      	ldr	r1, [r7, #8]
 800405c:	e9c1 2300 	strd	r2, r3, [r1]
            return true;
 8004060:	2301      	movs	r3, #1
 8004062:	e006      	b.n	8004072 <uavcan_should_accept_transfer.lto_priv.50+0x82>
        }

        rx_list_item = rx_list_item->next;
 8004064:	697b      	ldr	r3, [r7, #20]
 8004066:	691b      	ldr	r3, [r3, #16]
 8004068:	617b      	str	r3, [r7, #20]
    if (!instance) {
        return false;
    }

    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
    while (rx_list_item) {
 800406a:	697b      	ldr	r3, [r7, #20]
 800406c:	2b00      	cmp	r3, #0
 800406e:	d1df      	bne.n	8004030 <uavcan_should_accept_transfer.lto_priv.50+0x40>
        }

        rx_list_item = rx_list_item->next;
    }

    return false;
 8004070:	2300      	movs	r3, #0
}
 8004072:	4618      	mov	r0, r3
 8004074:	3718      	adds	r7, #24
 8004076:	46bd      	mov	sp, r7
 8004078:	bd80      	pop	{r7, pc}
 800407a:	bf00      	nop

0800407c <uavcan_transfer_id_map_init.lto_priv.74>:

#define UAVCAN_TRANSFER_ID_MAP_MAX_LEN ((1<<7)-1)

static void uavcan_transfer_id_map_init(struct transfer_id_map_s* map, size_t map_mem_size, void* map_mem) {
 800407c:	b480      	push	{r7}
 800407e:	b085      	sub	sp, #20
 8004080:	af00      	add	r7, sp, #0
 8004082:	60f8      	str	r0, [r7, #12]
 8004084:	60b9      	str	r1, [r7, #8]
 8004086:	607a      	str	r2, [r7, #4]
    if (!map) {
 8004088:	68fb      	ldr	r3, [r7, #12]
 800408a:	2b00      	cmp	r3, #0
 800408c:	d011      	beq.n	80040b2 <uavcan_transfer_id_map_init.lto_priv.74+0x36>
        return;
    }
    map->entries = map_mem;
 800408e:	68fb      	ldr	r3, [r7, #12]
 8004090:	687a      	ldr	r2, [r7, #4]
 8004092:	601a      	str	r2, [r3, #0]
    map->size = map_mem_size/sizeof(struct map_entry_s);
 8004094:	68bb      	ldr	r3, [r7, #8]
 8004096:	089b      	lsrs	r3, r3, #2
 8004098:	b29a      	uxth	r2, r3
 800409a:	68fb      	ldr	r3, [r7, #12]
 800409c:	809a      	strh	r2, [r3, #4]
    if (map->size > UAVCAN_TRANSFER_ID_MAP_MAX_LEN) {
 800409e:	68fb      	ldr	r3, [r7, #12]
 80040a0:	889b      	ldrh	r3, [r3, #4]
 80040a2:	2b7f      	cmp	r3, #127	; 0x7f
 80040a4:	d902      	bls.n	80040ac <uavcan_transfer_id_map_init.lto_priv.74+0x30>
        map->size = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
 80040a6:	68fb      	ldr	r3, [r7, #12]
 80040a8:	227f      	movs	r2, #127	; 0x7f
 80040aa:	809a      	strh	r2, [r3, #4]
    }
    map->head = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
 80040ac:	68fb      	ldr	r3, [r7, #12]
 80040ae:	227f      	movs	r2, #127	; 0x7f
 80040b0:	80da      	strh	r2, [r3, #6]
}
 80040b2:	3714      	adds	r7, #20
 80040b4:	46bd      	mov	sp, r7
 80040b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80040ba:	4770      	bx	lr

080040bc <uavcan_transfer_id_map_retrieve.lto_priv.72>:

static uint8_t* uavcan_transfer_id_map_retrieve(struct transfer_id_map_s* map, bool service_not_message, uint16_t data_type_id, uint8_t dest_node_id) {
 80040bc:	b480      	push	{r7}
 80040be:	b087      	sub	sp, #28
 80040c0:	af00      	add	r7, sp, #0
 80040c2:	6078      	str	r0, [r7, #4]
 80040c4:	4608      	mov	r0, r1
 80040c6:	4611      	mov	r1, r2
 80040c8:	461a      	mov	r2, r3
 80040ca:	4603      	mov	r3, r0
 80040cc:	70fb      	strb	r3, [r7, #3]
 80040ce:	460b      	mov	r3, r1
 80040d0:	803b      	strh	r3, [r7, #0]
 80040d2:	4613      	mov	r3, r2
 80040d4:	70bb      	strb	r3, [r7, #2]
    if (!map || !map->entries) {
 80040d6:	687b      	ldr	r3, [r7, #4]
 80040d8:	2b00      	cmp	r3, #0
 80040da:	d003      	beq.n	80040e4 <uavcan_transfer_id_map_retrieve.lto_priv.72+0x28>
 80040dc:	687b      	ldr	r3, [r7, #4]
 80040de:	681b      	ldr	r3, [r3, #0]
 80040e0:	2b00      	cmp	r3, #0
 80040e2:	d101      	bne.n	80040e8 <uavcan_transfer_id_map_retrieve.lto_priv.72+0x2c>
        return 0;
 80040e4:	2300      	movs	r3, #0
 80040e6:	e0a6      	b.n	8004236 <uavcan_transfer_id_map_retrieve.lto_priv.72+0x17a>
    }

    uint32_t key;
    if (service_not_message) {
 80040e8:	78fb      	ldrb	r3, [r7, #3]
 80040ea:	2b00      	cmp	r3, #0
 80040ec:	d008      	beq.n	8004100 <uavcan_transfer_id_map_retrieve.lto_priv.72+0x44>
        key = (1<<16) | ((data_type_id << 8) & 0xFF00) | ((dest_node_id << 0) & 0x00FF);
 80040ee:	883b      	ldrh	r3, [r7, #0]
 80040f0:	021b      	lsls	r3, r3, #8
 80040f2:	b29b      	uxth	r3, r3
 80040f4:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 80040f8:	78bb      	ldrb	r3, [r7, #2]
 80040fa:	4313      	orrs	r3, r2
 80040fc:	617b      	str	r3, [r7, #20]
 80040fe:	e001      	b.n	8004104 <uavcan_transfer_id_map_retrieve.lto_priv.72+0x48>
    } else {
        key = data_type_id;
 8004100:	883b      	ldrh	r3, [r7, #0]
 8004102:	617b      	str	r3, [r7, #20]
    }

    uint16_t count = 0;
 8004104:	2300      	movs	r3, #0
 8004106:	827b      	strh	r3, [r7, #18]
    uint16_t entry = map->head;
 8004108:	687b      	ldr	r3, [r7, #4]
 800410a:	88db      	ldrh	r3, [r3, #6]
 800410c:	823b      	strh	r3, [r7, #16]
    uint16_t entry_prev = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
 800410e:	237f      	movs	r3, #127	; 0x7f
 8004110:	81fb      	strh	r3, [r7, #14]
    uint16_t entry_prev_prev = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
 8004112:	237f      	movs	r3, #127	; 0x7f
 8004114:	81bb      	strh	r3, [r7, #12]
 8004116:	e010      	b.n	800413a <uavcan_transfer_id_map_retrieve.lto_priv.72+0x7e>

    while (entry != UAVCAN_TRANSFER_ID_MAP_MAX_LEN && map->entries[entry].key != key) {
        count++;
 8004118:	8a7b      	ldrh	r3, [r7, #18]
 800411a:	3301      	adds	r3, #1
 800411c:	827b      	strh	r3, [r7, #18]
        entry_prev_prev = entry_prev;
 800411e:	89fb      	ldrh	r3, [r7, #14]
 8004120:	81bb      	strh	r3, [r7, #12]
        entry_prev = entry;
 8004122:	8a3b      	ldrh	r3, [r7, #16]
 8004124:	81fb      	strh	r3, [r7, #14]
        entry = map->entries[entry].next;
 8004126:	687b      	ldr	r3, [r7, #4]
 8004128:	681a      	ldr	r2, [r3, #0]
 800412a:	8a3b      	ldrh	r3, [r7, #16]
 800412c:	009b      	lsls	r3, r3, #2
 800412e:	4413      	add	r3, r2
 8004130:	789b      	ldrb	r3, [r3, #2]
 8004132:	f3c3 0346 	ubfx	r3, r3, #1, #7
 8004136:	b2db      	uxtb	r3, r3
 8004138:	823b      	strh	r3, [r7, #16]
    uint16_t count = 0;
    uint16_t entry = map->head;
    uint16_t entry_prev = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
    uint16_t entry_prev_prev = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;

    while (entry != UAVCAN_TRANSFER_ID_MAP_MAX_LEN && map->entries[entry].key != key) {
 800413a:	8a3b      	ldrh	r3, [r7, #16]
 800413c:	2b7f      	cmp	r3, #127	; 0x7f
 800413e:	d011      	beq.n	8004164 <uavcan_transfer_id_map_retrieve.lto_priv.72+0xa8>
 8004140:	687b      	ldr	r3, [r7, #4]
 8004142:	681a      	ldr	r2, [r3, #0]
 8004144:	8a3b      	ldrh	r3, [r7, #16]
 8004146:	009b      	lsls	r3, r3, #2
 8004148:	4413      	add	r3, r2
 800414a:	781a      	ldrb	r2, [r3, #0]
 800414c:	7859      	ldrb	r1, [r3, #1]
 800414e:	0209      	lsls	r1, r1, #8
 8004150:	430a      	orrs	r2, r1
 8004152:	789b      	ldrb	r3, [r3, #2]
 8004154:	f003 0301 	and.w	r3, r3, #1
 8004158:	041b      	lsls	r3, r3, #16
 800415a:	4313      	orrs	r3, r2
 800415c:	461a      	mov	r2, r3
 800415e:	697b      	ldr	r3, [r7, #20]
 8004160:	429a      	cmp	r2, r3
 8004162:	d1d9      	bne.n	8004118 <uavcan_transfer_id_map_retrieve.lto_priv.72+0x5c>
        entry_prev_prev = entry_prev;
        entry_prev = entry;
        entry = map->entries[entry].next;
    }

    if (entry == UAVCAN_TRANSFER_ID_MAP_MAX_LEN) {
 8004164:	8a3b      	ldrh	r3, [r7, #16]
 8004166:	2b7f      	cmp	r3, #127	; 0x7f
 8004168:	d138      	bne.n	80041dc <uavcan_transfer_id_map_retrieve.lto_priv.72+0x120>
        // Not found. Allocate an entry.
        if (count >= map->size) {
 800416a:	687b      	ldr	r3, [r7, #4]
 800416c:	889b      	ldrh	r3, [r3, #4]
 800416e:	8a7a      	ldrh	r2, [r7, #18]
 8004170:	429a      	cmp	r2, r3
 8004172:	d304      	bcc.n	800417e <uavcan_transfer_id_map_retrieve.lto_priv.72+0xc2>
            // list is full - entry_prev is the LRU entry
            entry = entry_prev;
 8004174:	89fb      	ldrh	r3, [r7, #14]
 8004176:	823b      	strh	r3, [r7, #16]
            entry_prev = entry_prev_prev;
 8004178:	89bb      	ldrh	r3, [r7, #12]
 800417a:	81fb      	strh	r3, [r7, #14]
 800417c:	e001      	b.n	8004182 <uavcan_transfer_id_map_retrieve.lto_priv.72+0xc6>
        } else {
            // list is not full - allocate next available element
            entry = count;
 800417e:	8a7b      	ldrh	r3, [r7, #18]
 8004180:	823b      	strh	r3, [r7, #16]
        }

        // Populate the allocated entry
        map->entries[entry].key = key;
 8004182:	687b      	ldr	r3, [r7, #4]
 8004184:	681a      	ldr	r2, [r3, #0]
 8004186:	8a3b      	ldrh	r3, [r7, #16]
 8004188:	009b      	lsls	r3, r3, #2
 800418a:	4413      	add	r3, r2
 800418c:	697a      	ldr	r2, [r7, #20]
 800418e:	f3c2 0210 	ubfx	r2, r2, #0, #17
 8004192:	b2d1      	uxtb	r1, r2
 8004194:	2000      	movs	r0, #0
 8004196:	4301      	orrs	r1, r0
 8004198:	7019      	strb	r1, [r3, #0]
 800419a:	0a11      	lsrs	r1, r2, #8
 800419c:	b2c9      	uxtb	r1, r1
 800419e:	2000      	movs	r0, #0
 80041a0:	4301      	orrs	r1, r0
 80041a2:	7059      	strb	r1, [r3, #1]
 80041a4:	0c12      	lsrs	r2, r2, #16
 80041a6:	f002 0201 	and.w	r2, r2, #1
 80041aa:	f002 0001 	and.w	r0, r2, #1
 80041ae:	789a      	ldrb	r2, [r3, #2]
 80041b0:	f022 0201 	bic.w	r2, r2, #1
 80041b4:	4611      	mov	r1, r2
 80041b6:	4602      	mov	r2, r0
 80041b8:	430a      	orrs	r2, r1
 80041ba:	709a      	strb	r2, [r3, #2]
        map->entries[entry].transfer_id = 0;
 80041bc:	687b      	ldr	r3, [r7, #4]
 80041be:	681a      	ldr	r2, [r3, #0]
 80041c0:	8a3b      	ldrh	r3, [r7, #16]
 80041c2:	009b      	lsls	r3, r3, #2
 80041c4:	4413      	add	r3, r2
 80041c6:	2200      	movs	r2, #0
 80041c8:	70da      	strb	r2, [r3, #3]
        map->entries[entry].next = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
 80041ca:	687b      	ldr	r3, [r7, #4]
 80041cc:	681a      	ldr	r2, [r3, #0]
 80041ce:	8a3b      	ldrh	r3, [r7, #16]
 80041d0:	009b      	lsls	r3, r3, #2
 80041d2:	441a      	add	r2, r3
 80041d4:	7893      	ldrb	r3, [r2, #2]
 80041d6:	f043 03fe 	orr.w	r3, r3, #254	; 0xfe
 80041da:	7093      	strb	r3, [r2, #2]
    }

    // Move to front
    if (entry_prev != UAVCAN_TRANSFER_ID_MAP_MAX_LEN) {
 80041dc:	89fb      	ldrh	r3, [r7, #14]
 80041de:	2b7f      	cmp	r3, #127	; 0x7f
 80041e0:	d020      	beq.n	8004224 <uavcan_transfer_id_map_retrieve.lto_priv.72+0x168>
        map->entries[entry_prev].next = map->entries[entry].next;
 80041e2:	687b      	ldr	r3, [r7, #4]
 80041e4:	681a      	ldr	r2, [r3, #0]
 80041e6:	89fb      	ldrh	r3, [r7, #14]
 80041e8:	009b      	lsls	r3, r3, #2
 80041ea:	441a      	add	r2, r3
 80041ec:	687b      	ldr	r3, [r7, #4]
 80041ee:	6819      	ldr	r1, [r3, #0]
 80041f0:	8a3b      	ldrh	r3, [r7, #16]
 80041f2:	009b      	lsls	r3, r3, #2
 80041f4:	440b      	add	r3, r1
 80041f6:	789b      	ldrb	r3, [r3, #2]
 80041f8:	f3c3 0346 	ubfx	r3, r3, #1, #7
 80041fc:	b2d9      	uxtb	r1, r3
 80041fe:	7893      	ldrb	r3, [r2, #2]
 8004200:	f361 0347 	bfi	r3, r1, #1, #7
 8004204:	7093      	strb	r3, [r2, #2]
        map->entries[entry].next = map->head;
 8004206:	687b      	ldr	r3, [r7, #4]
 8004208:	681a      	ldr	r2, [r3, #0]
 800420a:	8a3b      	ldrh	r3, [r7, #16]
 800420c:	009b      	lsls	r3, r3, #2
 800420e:	441a      	add	r2, r3
 8004210:	687b      	ldr	r3, [r7, #4]
 8004212:	88db      	ldrh	r3, [r3, #6]
 8004214:	b2db      	uxtb	r3, r3
 8004216:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800421a:	b2d9      	uxtb	r1, r3
 800421c:	7893      	ldrb	r3, [r2, #2]
 800421e:	f361 0347 	bfi	r3, r1, #1, #7
 8004222:	7093      	strb	r3, [r2, #2]
    }
    map->head = entry;
 8004224:	687b      	ldr	r3, [r7, #4]
 8004226:	8a3a      	ldrh	r2, [r7, #16]
 8004228:	80da      	strh	r2, [r3, #6]

    return &map->entries[entry].transfer_id;
 800422a:	687b      	ldr	r3, [r7, #4]
 800422c:	681a      	ldr	r2, [r3, #0]
 800422e:	8a3b      	ldrh	r3, [r7, #16]
 8004230:	009b      	lsls	r3, r3, #2
 8004232:	4413      	add	r3, r2
 8004234:	3303      	adds	r3, #3
}
 8004236:	4618      	mov	r0, r3
 8004238:	371c      	adds	r7, #28
 800423a:	46bd      	mov	sp, r7
 800423c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004240:	4770      	bx	lr
 8004242:	bf00      	nop

08004244 <uavcan_nodestatus_publisher_get_nodestatus_message>:

static void node_status_publisher_task_func(struct worker_thread_timer_task_s* task);

// TODO mechanism to change node status

const struct uavcan_protocol_NodeStatus_s* uavcan_nodestatus_publisher_get_nodestatus_message(void) {
 8004244:	b480      	push	{r7}
 8004246:	af00      	add	r7, sp, #0
    return &node_status;
 8004248:	4b02      	ldr	r3, [pc, #8]	; (8004254 <uavcan_nodestatus_publisher_get_nodestatus_message+0x10>)
}
 800424a:	4618      	mov	r0, r3
 800424c:	46bd      	mov	sp, r7
 800424e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004252:	4770      	bx	lr
 8004254:	20001418 	.word	0x20001418

08004258 <_local_ctor_24>:

RUN_AFTER(UAVCAN_INIT) {
 8004258:	b580      	push	{r7, lr}
 800425a:	b082      	sub	sp, #8
 800425c:	af02      	add	r7, sp, #8
    node_status.uptime_sec = 0;
 800425e:	4b0e      	ldr	r3, [pc, #56]	; (8004298 <_local_ctor_24+0x40>)
 8004260:	2200      	movs	r2, #0
 8004262:	601a      	str	r2, [r3, #0]
    node_status.health = UAVCAN_PROTOCOL_NODESTATUS_HEALTH_OK;
 8004264:	4b0c      	ldr	r3, [pc, #48]	; (8004298 <_local_ctor_24+0x40>)
 8004266:	2200      	movs	r2, #0
 8004268:	711a      	strb	r2, [r3, #4]
    node_status.mode = UAVCAN_PROTOCOL_NODESTATUS_MODE_OPERATIONAL;
 800426a:	4b0b      	ldr	r3, [pc, #44]	; (8004298 <_local_ctor_24+0x40>)
 800426c:	2200      	movs	r2, #0
 800426e:	715a      	strb	r2, [r3, #5]
    node_status.sub_mode = 0;
 8004270:	4b09      	ldr	r3, [pc, #36]	; (8004298 <_local_ctor_24+0x40>)
 8004272:	2200      	movs	r2, #0
 8004274:	719a      	strb	r2, [r3, #6]
    node_status.vendor_specific_status_code = 0;
 8004276:	4b08      	ldr	r3, [pc, #32]	; (8004298 <_local_ctor_24+0x40>)
 8004278:	2200      	movs	r2, #0
 800427a:	811a      	strh	r2, [r3, #8]

    worker_thread_add_timer_task(&WT, &node_status_publisher_task, node_status_publisher_task_func, NULL, S2ST(1), true);
 800427c:	f242 7310 	movw	r3, #10000	; 0x2710
 8004280:	9300      	str	r3, [sp, #0]
 8004282:	2301      	movs	r3, #1
 8004284:	9301      	str	r3, [sp, #4]
 8004286:	4805      	ldr	r0, [pc, #20]	; (800429c <_local_ctor_24+0x44>)
 8004288:	4905      	ldr	r1, [pc, #20]	; (80042a0 <_local_ctor_24+0x48>)
 800428a:	4a06      	ldr	r2, [pc, #24]	; (80042a4 <_local_ctor_24+0x4c>)
 800428c:	2300      	movs	r3, #0
 800428e:	f003 fe0f 	bl	8007eb0 <worker_thread_add_timer_task>
}
 8004292:	46bd      	mov	sp, r7
 8004294:	bd80      	pop	{r7, pc}
 8004296:	bf00      	nop
 8004298:	20001418 	.word	0x20001418
 800429c:	20000a20 	.word	0x20000a20
 80042a0:	20001424 	.word	0x20001424
 80042a4:	080042a9 	.word	0x080042a9

080042a8 <node_status_publisher_task_func>:
void set_node_mode(uint8_t mode) {
    node_status.mode = mode;
}


static void node_status_publisher_task_func(struct worker_thread_timer_task_s* task) {
 80042a8:	b580      	push	{r7, lr}
 80042aa:	b082      	sub	sp, #8
 80042ac:	af00      	add	r7, sp, #0
 80042ae:	6078      	str	r0, [r7, #4]
    (void)task;

    node_status.uptime_sec++;
 80042b0:	4b06      	ldr	r3, [pc, #24]	; (80042cc <node_status_publisher_task_func+0x24>)
 80042b2:	681b      	ldr	r3, [r3, #0]
 80042b4:	3301      	adds	r3, #1
 80042b6:	4a05      	ldr	r2, [pc, #20]	; (80042cc <node_status_publisher_task_func+0x24>)
 80042b8:	6013      	str	r3, [r2, #0]
    uavcan_broadcast(0, &uavcan_protocol_NodeStatus_descriptor, CANARD_TRANSFER_PRIORITY_LOW, &node_status);
 80042ba:	2000      	movs	r0, #0
 80042bc:	4904      	ldr	r1, [pc, #16]	; (80042d0 <node_status_publisher_task_func+0x28>)
 80042be:	2218      	movs	r2, #24
 80042c0:	4b02      	ldr	r3, [pc, #8]	; (80042cc <node_status_publisher_task_func+0x24>)
 80042c2:	f001 fce7 	bl	8005c94 <uavcan_broadcast>
}
 80042c6:	3708      	adds	r7, #8
 80042c8:	46bd      	mov	sp, r7
 80042ca:	bd80      	pop	{r7, pc}
 80042cc:	20001418 	.word	0x20001418
 80042d0:	0800cce8 	.word	0x0800cce8

080042d4 <_local_ctor_26>:
#include <uavcan.protocol.GetNodeInfo.h>

static struct worker_thread_listener_task_s getnodeinfo_req_listener_task;
static void getnodeinfo_req_handler(size_t msg_size, const void* buf, void* ctx);

RUN_AFTER(UAVCAN_INIT) {
 80042d4:	b580      	push	{r7, lr}
 80042d6:	b084      	sub	sp, #16
 80042d8:	af02      	add	r7, sp, #8
    struct pubsub_topic_s* getnodeinfo_req_topic = uavcan_get_message_topic(0, &uavcan_protocol_GetNodeInfo_req_descriptor);
 80042da:	2000      	movs	r0, #0
 80042dc:	4907      	ldr	r1, [pc, #28]	; (80042fc <_local_ctor_26+0x28>)
 80042de:	f001 f9fb 	bl	80056d8 <uavcan_get_message_topic>
 80042e2:	6078      	str	r0, [r7, #4]
    worker_thread_add_listener_task(&WT, &getnodeinfo_req_listener_task, getnodeinfo_req_topic, getnodeinfo_req_handler, NULL);
 80042e4:	2300      	movs	r3, #0
 80042e6:	9300      	str	r3, [sp, #0]
 80042e8:	4805      	ldr	r0, [pc, #20]	; (8004300 <_local_ctor_26+0x2c>)
 80042ea:	4906      	ldr	r1, [pc, #24]	; (8004304 <_local_ctor_26+0x30>)
 80042ec:	687a      	ldr	r2, [r7, #4]
 80042ee:	4b06      	ldr	r3, [pc, #24]	; (8004308 <_local_ctor_26+0x34>)
 80042f0:	f003 fe8c 	bl	800800c <worker_thread_add_listener_task>
}
 80042f4:	3708      	adds	r7, #8
 80042f6:	46bd      	mov	sp, r7
 80042f8:	bd80      	pop	{r7, pc}
 80042fa:	bf00      	nop
 80042fc:	0800cd88 	.word	0x0800cd88
 8004300:	20000a20 	.word	0x20000a20
 8004304:	20001438 	.word	0x20001438
 8004308:	0800430d 	.word	0x0800430d

0800430c <getnodeinfo_req_handler>:

static void getnodeinfo_req_handler(size_t msg_size, const void* buf, void* ctx) {
 800430c:	b580      	push	{r7, lr}
 800430e:	b0e8      	sub	sp, #416	; 0x1a0
 8004310:	af00      	add	r7, sp, #0
 8004312:	f107 030c 	add.w	r3, r7, #12
 8004316:	6018      	str	r0, [r3, #0]
 8004318:	f107 0308 	add.w	r3, r7, #8
 800431c:	6019      	str	r1, [r3, #0]
 800431e:	1d3b      	adds	r3, r7, #4
 8004320:	601a      	str	r2, [r3, #0]
    (void)msg_size;
    (void)ctx;

    const struct uavcan_deserialized_message_s* msg_wrapper = buf;
 8004322:	f107 0308 	add.w	r3, r7, #8
 8004326:	681b      	ldr	r3, [r3, #0]
 8004328:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c

    struct uavcan_protocol_GetNodeInfo_res_s res;
    memset(&res, 0, sizeof(struct uavcan_protocol_GetNodeInfo_res_s));
 800432c:	f107 0310 	add.w	r3, r7, #16
 8004330:	4618      	mov	r0, r3
 8004332:	2100      	movs	r1, #0
 8004334:	f44f 72c4 	mov.w	r2, #392	; 0x188
 8004338:	f008 fc80 	bl	800cc3c <memset>

    res.status = *uavcan_nodestatus_publisher_get_nodestatus_message();
 800433c:	f7ff ff82 	bl	8004244 <uavcan_nodestatus_publisher_get_nodestatus_message>
 8004340:	4602      	mov	r2, r0
 8004342:	f107 0310 	add.w	r3, r7, #16
 8004346:	ca07      	ldmia	r2, {r0, r1, r2}
 8004348:	e883 0007 	stmia.w	r3, {r0, r1, r2}

    board_get_unique_id(res.hardware_version.unique_id, sizeof(res.hardware_version.unique_id));
 800434c:	f107 0310 	add.w	r3, r7, #16
 8004350:	3322      	adds	r3, #34	; 0x22
 8004352:	4618      	mov	r0, r3
 8004354:	2110      	movs	r1, #16
 8004356:	f000 fb29 	bl	80049ac <board_get_unique_id>
        res.hardware_version.minor = boot_msg.boot_info_msg.hw_info->hw_minor_version;
    }
#endif

#ifdef MODULE_APP_DESCRIPTOR_ENABLED
    res.software_version.major = shared_app_descriptor.major_version;
 800435a:	4b14      	ldr	r3, [pc, #80]	; (80043ac <getnodeinfo_req_handler+0xa0>)
 800435c:	7e1a      	ldrb	r2, [r3, #24]
 800435e:	f107 0310 	add.w	r3, r7, #16
 8004362:	741a      	strb	r2, [r3, #16]
    res.software_version.minor = shared_app_descriptor.minor_version;
 8004364:	4b11      	ldr	r3, [pc, #68]	; (80043ac <getnodeinfo_req_handler+0xa0>)
 8004366:	7e5a      	ldrb	r2, [r3, #25]
 8004368:	f107 0310 	add.w	r3, r7, #16
 800436c:	745a      	strb	r2, [r3, #17]
    res.software_version.optional_field_flags = UAVCAN_PROTOCOL_SOFTWAREVERSION_OPTIONAL_FIELD_FLAG_VCS_COMMIT |
 800436e:	f107 0310 	add.w	r3, r7, #16
 8004372:	2203      	movs	r2, #3
 8004374:	749a      	strb	r2, [r3, #18]
                                                UAVCAN_PROTOCOL_SOFTWAREVERSION_OPTIONAL_FIELD_FLAG_IMAGE_CRC;
    res.software_version.vcs_commit = shared_app_descriptor.vcs_commit;
 8004376:	4b0d      	ldr	r3, [pc, #52]	; (80043ac <getnodeinfo_req_handler+0xa0>)
 8004378:	695a      	ldr	r2, [r3, #20]
 800437a:	f107 0310 	add.w	r3, r7, #16
 800437e:	615a      	str	r2, [r3, #20]
    res.software_version.image_crc = *(volatile uint64_t*)&shared_app_descriptor.image_crc;
 8004380:	4b0a      	ldr	r3, [pc, #40]	; (80043ac <getnodeinfo_req_handler+0xa0>)
 8004382:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8004386:	f107 0110 	add.w	r1, r7, #16
 800438a:	e9c1 2306 	strd	r2, r3, [r1, #24]
#endif

    uavcan_respond(msg_wrapper->uavcan_idx, msg_wrapper, &res);
 800438e:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 8004392:	781a      	ldrb	r2, [r3, #0]
 8004394:	f107 0310 	add.w	r3, r7, #16
 8004398:	4610      	mov	r0, r2
 800439a:	f8d7 119c 	ldr.w	r1, [r7, #412]	; 0x19c
 800439e:	461a      	mov	r2, r3
 80043a0:	f001 fcbc 	bl	8005d1c <uavcan_respond>
}
 80043a4:	f507 77d0 	add.w	r7, r7, #416	; 0x1a0
 80043a8:	46bd      	mov	sp, r7
 80043aa:	bd80      	pop	{r7, pc}
 80043ac:	08003160 	.word	0x08003160

080043b0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
static inline void *chCoreAlloc(size_t size) {
 80043b0:	b580      	push	{r7, lr}
 80043b2:	b082      	sub	sp, #8
 80043b4:	af00      	add	r7, sp, #0
 80043b6:	6078      	str	r0, [r7, #4]

  return chCoreAllocAlignedWithOffset(size, PORT_NATURAL_ALIGN, 0U);
 80043b8:	6878      	ldr	r0, [r7, #4]
 80043ba:	2104      	movs	r1, #4
 80043bc:	2200      	movs	r2, #0
 80043be:	f004 fb8d 	bl	8008adc <chCoreAllocAlignedWithOffset>
 80043c2:	4603      	mov	r3, r0
}
 80043c4:	4618      	mov	r0, r3
 80043c6:	3708      	adds	r7, #8
 80043c8:	46bd      	mov	sp, r7
 80043ca:	bd80      	pop	{r7, pc}

080043cc <_local_ctor_34>:
    struct worker_thread_timer_task_s request_transmit_task;
    struct worker_thread_listener_task_s allocation_listener_task;
};


RUN_AFTER(UAVCAN_INIT) {
 80043cc:	b580      	push	{r7, lr}
 80043ce:	b086      	sub	sp, #24
 80043d0:	af02      	add	r7, sp, #8
     for (uint8_t i=0; i<uavcan_get_num_instances(); i++) {
 80043d2:	2300      	movs	r3, #0
 80043d4:	73fb      	strb	r3, [r7, #15]
 80043d6:	e034      	b.n	8004442 <_local_ctor_34+0x76>
        if (uavcan_get_node_id(i) != 0) {
 80043d8:	7bfb      	ldrb	r3, [r7, #15]
 80043da:	4618      	mov	r0, r3
 80043dc:	f001 f9bc 	bl	8005758 <uavcan_get_node_id>
 80043e0:	4603      	mov	r3, r0
 80043e2:	2b00      	cmp	r3, #0
 80043e4:	d127      	bne.n	8004436 <_local_ctor_34+0x6a>
            continue;
        }

        struct allocatee_instance_s* instance = chCoreAlloc(sizeof(struct allocatee_instance_s));
 80043e6:	2050      	movs	r0, #80	; 0x50
 80043e8:	f7ff ffe2 	bl	80043b0 <chCoreAlloc>
 80043ec:	60b8      	str	r0, [r7, #8]

        chDbgCheck(instance != NULL);
 80043ee:	68bb      	ldr	r3, [r7, #8]
 80043f0:	2b00      	cmp	r3, #0
 80043f2:	d102      	bne.n	80043fa <_local_ctor_34+0x2e>
 80043f4:	4818      	ldr	r0, [pc, #96]	; (8004458 <_local_ctor_34+0x8c>)
 80043f6:	f005 fb01 	bl	80099fc <chSysHalt>
        if (!instance) {
 80043fa:	68bb      	ldr	r3, [r7, #8]
 80043fc:	2b00      	cmp	r3, #0
 80043fe:	d01c      	beq.n	800443a <_local_ctor_34+0x6e>
            continue;
        }

        struct pubsub_topic_s* allocation_topic = uavcan_get_message_topic(i, &uavcan_protocol_dynamic_node_id_Allocation_descriptor);
 8004400:	7bfb      	ldrb	r3, [r7, #15]
 8004402:	4618      	mov	r0, r3
 8004404:	4915      	ldr	r1, [pc, #84]	; (800445c <_local_ctor_34+0x90>)
 8004406:	f001 f967 	bl	80056d8 <uavcan_get_message_topic>
 800440a:	6078      	str	r0, [r7, #4]

        instance->uavcan_idx = i;
 800440c:	68bb      	ldr	r3, [r7, #8]
 800440e:	7bfa      	ldrb	r2, [r7, #15]
 8004410:	701a      	strb	r2, [r3, #0]
        instance->unique_id_offset = 0;
 8004412:	68bb      	ldr	r3, [r7, #8]
 8004414:	2200      	movs	r2, #0
 8004416:	605a      	str	r2, [r3, #4]
        worker_thread_add_listener_task(&WT, &instance->allocation_listener_task, allocation_topic, allocation_message_handler, instance);
 8004418:	68bb      	ldr	r3, [r7, #8]
 800441a:	f103 021c 	add.w	r2, r3, #28
 800441e:	68bb      	ldr	r3, [r7, #8]
 8004420:	9300      	str	r3, [sp, #0]
 8004422:	480f      	ldr	r0, [pc, #60]	; (8004460 <_local_ctor_34+0x94>)
 8004424:	4611      	mov	r1, r2
 8004426:	687a      	ldr	r2, [r7, #4]
 8004428:	4b0e      	ldr	r3, [pc, #56]	; (8004464 <_local_ctor_34+0x98>)
 800442a:	f003 fdef 	bl	800800c <worker_thread_add_listener_task>
        allocation_start_request_timer(instance);
 800442e:	68b8      	ldr	r0, [r7, #8]
 8004430:	f000 f8d6 	bl	80045e0 <allocation_start_request_timer>
 8004434:	e002      	b.n	800443c <_local_ctor_34+0x70>


RUN_AFTER(UAVCAN_INIT) {
     for (uint8_t i=0; i<uavcan_get_num_instances(); i++) {
        if (uavcan_get_node_id(i) != 0) {
            continue;
 8004436:	bf00      	nop
 8004438:	e000      	b.n	800443c <_local_ctor_34+0x70>

        struct allocatee_instance_s* instance = chCoreAlloc(sizeof(struct allocatee_instance_s));

        chDbgCheck(instance != NULL);
        if (!instance) {
            continue;
 800443a:	bf00      	nop
    struct worker_thread_listener_task_s allocation_listener_task;
};


RUN_AFTER(UAVCAN_INIT) {
     for (uint8_t i=0; i<uavcan_get_num_instances(); i++) {
 800443c:	7bfb      	ldrb	r3, [r7, #15]
 800443e:	3301      	adds	r3, #1
 8004440:	73fb      	strb	r3, [r7, #15]
 8004442:	f7ff fcd7 	bl	8003df4 <uavcan_get_num_instances>
 8004446:	4603      	mov	r3, r0
 8004448:	461a      	mov	r2, r3
 800444a:	7bfb      	ldrb	r3, [r7, #15]
 800444c:	4293      	cmp	r3, r2
 800444e:	d3c3      	bcc.n	80043d8 <_local_ctor_34+0xc>
        instance->uavcan_idx = i;
        instance->unique_id_offset = 0;
        worker_thread_add_listener_task(&WT, &instance->allocation_listener_task, allocation_topic, allocation_message_handler, instance);
        allocation_start_request_timer(instance);
    }
}
 8004450:	3710      	adds	r7, #16
 8004452:	46bd      	mov	sp, r7
 8004454:	bd80      	pop	{r7, pc}
 8004456:	bf00      	nop
 8004458:	0800d208 	.word	0x0800d208
 800445c:	0800cd48 	.word	0x0800cd48
 8004460:	20000a20 	.word	0x20000a20
 8004464:	08004539 	.word	0x08004539

08004468 <allocation_stop_and_cleanup>:

static void allocation_stop_and_cleanup(struct allocatee_instance_s* instance) {
 8004468:	b580      	push	{r7, lr}
 800446a:	b082      	sub	sp, #8
 800446c:	af00      	add	r7, sp, #0
 800446e:	6078      	str	r0, [r7, #4]
    worker_thread_remove_timer_task(&WT, &instance->request_transmit_task);
 8004470:	687b      	ldr	r3, [r7, #4]
 8004472:	3308      	adds	r3, #8
 8004474:	4806      	ldr	r0, [pc, #24]	; (8004490 <allocation_stop_and_cleanup+0x28>)
 8004476:	4619      	mov	r1, r3
 8004478:	f003 fda6 	bl	8007fc8 <worker_thread_remove_timer_task>
    worker_thread_remove_listener_task(&WT, &instance->allocation_listener_task);
 800447c:	687b      	ldr	r3, [r7, #4]
 800447e:	331c      	adds	r3, #28
 8004480:	4803      	ldr	r0, [pc, #12]	; (8004490 <allocation_stop_and_cleanup+0x28>)
 8004482:	4619      	mov	r1, r3
 8004484:	f003 fe00 	bl	8008088 <worker_thread_remove_listener_task>
}
 8004488:	3708      	adds	r7, #8
 800448a:	46bd      	mov	sp, r7
 800448c:	bd80      	pop	{r7, pc}
 800448e:	bf00      	nop
 8004490:	20000a20 	.word	0x20000a20

08004494 <allocation_timer_expired>:

static void allocation_timer_expired(struct worker_thread_timer_task_s* task) {
 8004494:	b590      	push	{r4, r7, lr}
 8004496:	b08d      	sub	sp, #52	; 0x34
 8004498:	af00      	add	r7, sp, #0
 800449a:	6078      	str	r0, [r7, #4]
    struct allocatee_instance_s* instance = worker_thread_task_get_user_context(task);
 800449c:	6878      	ldr	r0, [r7, #4]
 800449e:	f003 fda3 	bl	8007fe8 <worker_thread_task_get_user_context>
 80044a2:	62f8      	str	r0, [r7, #44]	; 0x2c

    if (!allocation_running(instance)) {
 80044a4:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80044a6:	f000 f92f 	bl	8004708 <allocation_running>
 80044aa:	4603      	mov	r3, r0
 80044ac:	f083 0301 	eor.w	r3, r3, #1
 80044b0:	b2db      	uxtb	r3, r3
 80044b2:	2b00      	cmp	r3, #0
 80044b4:	d003      	beq.n	80044be <allocation_timer_expired+0x2a>
        allocation_stop_and_cleanup(instance);
 80044b6:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80044b8:	f7ff ffd6 	bl	8004468 <allocation_stop_and_cleanup>
 80044bc:	e036      	b.n	800452c <allocation_timer_expired+0x98>
        return;
    }

    // Start allocation request timer
    allocation_start_request_timer(instance);
 80044be:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80044c0:	f000 f88e 	bl	80045e0 <allocation_start_request_timer>

    // Send allocation message
    struct uavcan_protocol_dynamic_node_id_Allocation_s msg;

    uint8_t my_unique_id[16];
    board_get_unique_id(my_unique_id, sizeof(my_unique_id));
 80044c4:	f107 0308 	add.w	r3, r7, #8
 80044c8:	4618      	mov	r0, r3
 80044ca:	2110      	movs	r1, #16
 80044cc:	f000 fa6e 	bl	80049ac <board_get_unique_id>

    msg.node_id = 0;
 80044d0:	2300      	movs	r3, #0
 80044d2:	763b      	strb	r3, [r7, #24]
    msg.first_part_of_unique_id = (instance->unique_id_offset == 0);
 80044d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80044d6:	685b      	ldr	r3, [r3, #4]
 80044d8:	2b00      	cmp	r3, #0
 80044da:	bf0c      	ite	eq
 80044dc:	2301      	moveq	r3, #1
 80044de:	2300      	movne	r3, #0
 80044e0:	b2db      	uxtb	r3, r3
 80044e2:	767b      	strb	r3, [r7, #25]
    msg.unique_id_len = MIN(16-instance->unique_id_offset, UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MAX_LENGTH_OF_UNIQUE_ID_IN_REQUEST);
 80044e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80044e6:	685b      	ldr	r3, [r3, #4]
 80044e8:	f1c3 0310 	rsb	r3, r3, #16
 80044ec:	2b06      	cmp	r3, #6
 80044ee:	bf28      	it	cs
 80044f0:	2306      	movcs	r3, #6
 80044f2:	b2db      	uxtb	r3, r3
 80044f4:	76bb      	strb	r3, [r7, #26]
    memcpy(&msg.unique_id, &my_unique_id[instance->unique_id_offset], msg.unique_id_len);
 80044f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80044f8:	685b      	ldr	r3, [r3, #4]
 80044fa:	f107 0208 	add.w	r2, r7, #8
 80044fe:	441a      	add	r2, r3
 8004500:	7ebb      	ldrb	r3, [r7, #26]
 8004502:	461c      	mov	r4, r3
 8004504:	f107 0318 	add.w	r3, r7, #24
 8004508:	3303      	adds	r3, #3
 800450a:	4618      	mov	r0, r3
 800450c:	4611      	mov	r1, r2
 800450e:	4622      	mov	r2, r4
 8004510:	f008 fb6e 	bl	800cbf0 <memcpy>
    uavcan_broadcast(instance->uavcan_idx, &uavcan_protocol_dynamic_node_id_Allocation_descriptor, CANARD_TRANSFER_PRIORITY_LOW, &msg);
 8004514:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004516:	781a      	ldrb	r2, [r3, #0]
 8004518:	f107 0318 	add.w	r3, r7, #24
 800451c:	4610      	mov	r0, r2
 800451e:	4905      	ldr	r1, [pc, #20]	; (8004534 <allocation_timer_expired+0xa0>)
 8004520:	2218      	movs	r2, #24
 8004522:	f001 fbb7 	bl	8005c94 <uavcan_broadcast>
    instance->unique_id_offset = 0;
 8004526:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004528:	2200      	movs	r2, #0
 800452a:	605a      	str	r2, [r3, #4]
}
 800452c:	3734      	adds	r7, #52	; 0x34
 800452e:	46bd      	mov	sp, r7
 8004530:	bd90      	pop	{r4, r7, pc}
 8004532:	bf00      	nop
 8004534:	0800cd48 	.word	0x0800cd48

08004538 <allocation_message_handler>:

static void allocation_message_handler(size_t msg_size, const void* buf, void* ctx) {
 8004538:	b590      	push	{r4, r7, lr}
 800453a:	b08d      	sub	sp, #52	; 0x34
 800453c:	af00      	add	r7, sp, #0
 800453e:	60f8      	str	r0, [r7, #12]
 8004540:	60b9      	str	r1, [r7, #8]
 8004542:	607a      	str	r2, [r7, #4]
    (void)msg_size;

    const struct uavcan_deserialized_message_s* wrapper = buf;
 8004544:	68bb      	ldr	r3, [r7, #8]
 8004546:	62fb      	str	r3, [r7, #44]	; 0x2c
    const struct uavcan_protocol_dynamic_node_id_Allocation_s* msg = (const struct uavcan_protocol_dynamic_node_id_Allocation_s*)wrapper->msg;
 8004548:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800454a:	3310      	adds	r3, #16
 800454c:	62bb      	str	r3, [r7, #40]	; 0x28

    struct allocatee_instance_s* instance = ctx;
 800454e:	687b      	ldr	r3, [r7, #4]
 8004550:	627b      	str	r3, [r7, #36]	; 0x24

    if (!allocation_running(instance)) {
 8004552:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8004554:	f000 f8d8 	bl	8004708 <allocation_running>
 8004558:	4603      	mov	r3, r0
 800455a:	f083 0301 	eor.w	r3, r3, #1
 800455e:	b2db      	uxtb	r3, r3
 8004560:	2b00      	cmp	r3, #0
 8004562:	d003      	beq.n	800456c <allocation_message_handler+0x34>
        allocation_stop_and_cleanup(instance);
 8004564:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8004566:	f7ff ff7f 	bl	8004468 <allocation_stop_and_cleanup>
 800456a:	e036      	b.n	80045da <allocation_message_handler+0xa2>
        return;
    }

    allocation_start_request_timer(instance);
 800456c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800456e:	f000 f837 	bl	80045e0 <allocation_start_request_timer>
    instance->unique_id_offset = 0;
 8004572:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004574:	2200      	movs	r2, #0
 8004576:	605a      	str	r2, [r3, #4]

    if (wrapper->source_node_id == 0) {
 8004578:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800457a:	7b1b      	ldrb	r3, [r3, #12]
 800457c:	2b00      	cmp	r3, #0
 800457e:	d02c      	beq.n	80045da <allocation_message_handler+0xa2>
        return;
    }

    uint8_t my_unique_id[16];
    board_get_unique_id(my_unique_id, sizeof(my_unique_id));
 8004580:	f107 0314 	add.w	r3, r7, #20
 8004584:	4618      	mov	r0, r3
 8004586:	2110      	movs	r1, #16
 8004588:	f000 fa10 	bl	80049ac <board_get_unique_id>

    if (memcmp(my_unique_id, msg->unique_id, msg->unique_id_len) != 0) {
 800458c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800458e:	1cda      	adds	r2, r3, #3
 8004590:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004592:	789b      	ldrb	r3, [r3, #2]
 8004594:	461c      	mov	r4, r3
 8004596:	f107 0314 	add.w	r3, r7, #20
 800459a:	4618      	mov	r0, r3
 800459c:	4611      	mov	r1, r2
 800459e:	4622      	mov	r2, r4
 80045a0:	f008 fb16 	bl	800cbd0 <memcmp>
 80045a4:	4603      	mov	r3, r0
 80045a6:	2b00      	cmp	r3, #0
 80045a8:	d117      	bne.n	80045da <allocation_message_handler+0xa2>
        // If unique ID does not match, return
        return;
    }

    if (msg->unique_id_len < 16) {
 80045aa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80045ac:	789b      	ldrb	r3, [r3, #2]
 80045ae:	2b0f      	cmp	r3, #15
 80045b0:	d808      	bhi.n	80045c4 <allocation_message_handler+0x8c>
        // Unique ID partially matches - set the UID offset and start the followup timer
        instance->unique_id_offset = msg->unique_id_len;
 80045b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80045b4:	789b      	ldrb	r3, [r3, #2]
 80045b6:	461a      	mov	r2, r3
 80045b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80045ba:	605a      	str	r2, [r3, #4]
        allocation_start_followup_timer(instance);
 80045bc:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80045be:	f000 f85d 	bl	800467c <allocation_start_followup_timer>
 80045c2:	e00a      	b.n	80045da <allocation_message_handler+0xa2>
    } else {
        // Complete match received
        uavcan_set_node_id(instance->uavcan_idx, msg->node_id);
 80045c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80045c6:	781a      	ldrb	r2, [r3, #0]
 80045c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80045ca:	781b      	ldrb	r3, [r3, #0]
 80045cc:	4610      	mov	r0, r2
 80045ce:	4619      	mov	r1, r3
 80045d0:	f001 f8f8 	bl	80057c4 <uavcan_set_node_id>
        allocation_stop_and_cleanup(instance);
 80045d4:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80045d6:	f7ff ff47 	bl	8004468 <allocation_stop_and_cleanup>
    }
}
 80045da:	3734      	adds	r7, #52	; 0x34
 80045dc:	46bd      	mov	sp, r7
 80045de:	bd90      	pop	{r4, r7, pc}

080045e0 <allocation_start_request_timer>:

static void allocation_start_request_timer(struct allocatee_instance_s* instance) {
 80045e0:	b590      	push	{r4, r7, lr}
 80045e2:	b087      	sub	sp, #28
 80045e4:	af02      	add	r7, sp, #8
 80045e6:	6078      	str	r0, [r7, #4]
    if (!allocation_running(instance)) {
 80045e8:	6878      	ldr	r0, [r7, #4]
 80045ea:	f000 f88d 	bl	8004708 <allocation_running>
 80045ee:	4603      	mov	r3, r0
 80045f0:	f083 0301 	eor.w	r3, r3, #1
 80045f4:	b2db      	uxtb	r3, r3
 80045f6:	2b00      	cmp	r3, #0
 80045f8:	d003      	beq.n	8004602 <allocation_start_request_timer+0x22>
        allocation_stop_and_cleanup(instance);
 80045fa:	6878      	ldr	r0, [r7, #4]
 80045fc:	f7ff ff34 	bl	8004468 <allocation_stop_and_cleanup>
 8004600:	e02e      	b.n	8004660 <allocation_start_request_timer+0x80>
        return;
    }

    float request_delay_ms = UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MIN_REQUEST_PERIOD_MS + (getRandomFloat() * (UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MAX_REQUEST_PERIOD_MS-UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MIN_REQUEST_PERIOD_MS));
 8004602:	f000 f895 	bl	8004730 <getRandomFloat>
 8004606:	4603      	mov	r3, r0
 8004608:	4618      	mov	r0, r3
 800460a:	4917      	ldr	r1, [pc, #92]	; (8004668 <allocation_start_request_timer+0x88>)
 800460c:	f7ff fa62 	bl	8003ad4 <__aeabi_fmul>
 8004610:	4603      	mov	r3, r0
 8004612:	4618      	mov	r0, r3
 8004614:	4915      	ldr	r1, [pc, #84]	; (800466c <allocation_start_request_timer+0x8c>)
 8004616:	f7ff f955 	bl	80038c4 <__addsf3>
 800461a:	4603      	mov	r3, r0
 800461c:	60fb      	str	r3, [r7, #12]

    worker_thread_remove_timer_task(&WT, &instance->request_transmit_task);
 800461e:	687b      	ldr	r3, [r7, #4]
 8004620:	3308      	adds	r3, #8
 8004622:	4813      	ldr	r0, [pc, #76]	; (8004670 <allocation_start_request_timer+0x90>)
 8004624:	4619      	mov	r1, r3
 8004626:	f003 fccf 	bl	8007fc8 <worker_thread_remove_timer_task>
    worker_thread_add_timer_task(&WT, &instance->request_transmit_task, allocation_timer_expired, instance, MS2ST(request_delay_ms), false);
 800462a:	687b      	ldr	r3, [r7, #4]
 800462c:	f103 0408 	add.w	r4, r3, #8
 8004630:	68f8      	ldr	r0, [r7, #12]
 8004632:	f7fe fe49 	bl	80032c8 <__aeabi_f2uiz>
 8004636:	4602      	mov	r2, r0
 8004638:	f242 7310 	movw	r3, #10000	; 0x2710
 800463c:	fb03 f302 	mul.w	r3, r3, r2
 8004640:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
 8004644:	4a0b      	ldr	r2, [pc, #44]	; (8004674 <allocation_start_request_timer+0x94>)
 8004646:	fba2 2303 	umull	r2, r3, r2, r3
 800464a:	099b      	lsrs	r3, r3, #6
 800464c:	b29b      	uxth	r3, r3
 800464e:	9300      	str	r3, [sp, #0]
 8004650:	2300      	movs	r3, #0
 8004652:	9301      	str	r3, [sp, #4]
 8004654:	4806      	ldr	r0, [pc, #24]	; (8004670 <allocation_start_request_timer+0x90>)
 8004656:	4621      	mov	r1, r4
 8004658:	4a07      	ldr	r2, [pc, #28]	; (8004678 <allocation_start_request_timer+0x98>)
 800465a:	687b      	ldr	r3, [r7, #4]
 800465c:	f003 fc28 	bl	8007eb0 <worker_thread_add_timer_task>
}
 8004660:	3714      	adds	r7, #20
 8004662:	46bd      	mov	sp, r7
 8004664:	bd90      	pop	{r4, r7, pc}
 8004666:	bf00      	nop
 8004668:	43c80000 	.word	0x43c80000
 800466c:	44160000 	.word	0x44160000
 8004670:	20000a20 	.word	0x20000a20
 8004674:	10624dd3 	.word	0x10624dd3
 8004678:	08004495 	.word	0x08004495

0800467c <allocation_start_followup_timer>:

static void allocation_start_followup_timer(struct allocatee_instance_s* instance) {
 800467c:	b590      	push	{r4, r7, lr}
 800467e:	b087      	sub	sp, #28
 8004680:	af02      	add	r7, sp, #8
 8004682:	6078      	str	r0, [r7, #4]
    if (!allocation_running(instance)) {
 8004684:	6878      	ldr	r0, [r7, #4]
 8004686:	f000 f83f 	bl	8004708 <allocation_running>
 800468a:	4603      	mov	r3, r0
 800468c:	f083 0301 	eor.w	r3, r3, #1
 8004690:	b2db      	uxtb	r3, r3
 8004692:	2b00      	cmp	r3, #0
 8004694:	d003      	beq.n	800469e <allocation_start_followup_timer+0x22>
        allocation_stop_and_cleanup(instance);
 8004696:	6878      	ldr	r0, [r7, #4]
 8004698:	f7ff fee6 	bl	8004468 <allocation_stop_and_cleanup>
 800469c:	e029      	b.n	80046f2 <allocation_start_followup_timer+0x76>
        return;
    }

    float request_delay_ms = UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MIN_FOLLOWUP_DELAY_MS + (getRandomFloat() * (UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MAX_FOLLOWUP_DELAY_MS-UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MIN_FOLLOWUP_DELAY_MS));
 800469e:	f000 f847 	bl	8004730 <getRandomFloat>
 80046a2:	4603      	mov	r3, r0
 80046a4:	4618      	mov	r0, r3
 80046a6:	4914      	ldr	r1, [pc, #80]	; (80046f8 <allocation_start_followup_timer+0x7c>)
 80046a8:	f7ff fa14 	bl	8003ad4 <__aeabi_fmul>
 80046ac:	4603      	mov	r3, r0
 80046ae:	60fb      	str	r3, [r7, #12]

    worker_thread_remove_timer_task(&WT, &instance->request_transmit_task);
 80046b0:	687b      	ldr	r3, [r7, #4]
 80046b2:	3308      	adds	r3, #8
 80046b4:	4811      	ldr	r0, [pc, #68]	; (80046fc <allocation_start_followup_timer+0x80>)
 80046b6:	4619      	mov	r1, r3
 80046b8:	f003 fc86 	bl	8007fc8 <worker_thread_remove_timer_task>
    worker_thread_add_timer_task(&WT, &instance->request_transmit_task, allocation_timer_expired, instance, MS2ST(request_delay_ms), false);
 80046bc:	687b      	ldr	r3, [r7, #4]
 80046be:	f103 0408 	add.w	r4, r3, #8
 80046c2:	68f8      	ldr	r0, [r7, #12]
 80046c4:	f7fe fe00 	bl	80032c8 <__aeabi_f2uiz>
 80046c8:	4602      	mov	r2, r0
 80046ca:	f242 7310 	movw	r3, #10000	; 0x2710
 80046ce:	fb03 f302 	mul.w	r3, r3, r2
 80046d2:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
 80046d6:	4a0a      	ldr	r2, [pc, #40]	; (8004700 <allocation_start_followup_timer+0x84>)
 80046d8:	fba2 2303 	umull	r2, r3, r2, r3
 80046dc:	099b      	lsrs	r3, r3, #6
 80046de:	b29b      	uxth	r3, r3
 80046e0:	9300      	str	r3, [sp, #0]
 80046e2:	2300      	movs	r3, #0
 80046e4:	9301      	str	r3, [sp, #4]
 80046e6:	4805      	ldr	r0, [pc, #20]	; (80046fc <allocation_start_followup_timer+0x80>)
 80046e8:	4621      	mov	r1, r4
 80046ea:	4a06      	ldr	r2, [pc, #24]	; (8004704 <allocation_start_followup_timer+0x88>)
 80046ec:	687b      	ldr	r3, [r7, #4]
 80046ee:	f003 fbdf 	bl	8007eb0 <worker_thread_add_timer_task>
}
 80046f2:	3714      	adds	r7, #20
 80046f4:	46bd      	mov	sp, r7
 80046f6:	bd90      	pop	{r4, r7, pc}
 80046f8:	43c80000 	.word	0x43c80000
 80046fc:	20000a20 	.word	0x20000a20
 8004700:	10624dd3 	.word	0x10624dd3
 8004704:	08004495 	.word	0x08004495

08004708 <allocation_running>:

static bool allocation_running(struct allocatee_instance_s* instance) {
 8004708:	b580      	push	{r7, lr}
 800470a:	b082      	sub	sp, #8
 800470c:	af00      	add	r7, sp, #0
 800470e:	6078      	str	r0, [r7, #4]
    return uavcan_get_node_id(instance->uavcan_idx) == 0;
 8004710:	687b      	ldr	r3, [r7, #4]
 8004712:	781b      	ldrb	r3, [r3, #0]
 8004714:	4618      	mov	r0, r3
 8004716:	f001 f81f 	bl	8005758 <uavcan_get_node_id>
 800471a:	4603      	mov	r3, r0
 800471c:	2b00      	cmp	r3, #0
 800471e:	bf0c      	ite	eq
 8004720:	2301      	moveq	r3, #1
 8004722:	2300      	movne	r3, #0
 8004724:	b2db      	uxtb	r3, r3
}
 8004726:	4618      	mov	r0, r3
 8004728:	3708      	adds	r7, #8
 800472a:	46bd      	mov	sp, r7
 800472c:	bd80      	pop	{r7, pc}
 800472e:	bf00      	nop

08004730 <getRandomFloat>:

static float getRandomFloat(void) {
 8004730:	b580      	push	{r7, lr}
 8004732:	b086      	sub	sp, #24
 8004734:	af00      	add	r7, sp, #0
    static uint32_t state;
    if (state == 0) {
 8004736:	4b1f      	ldr	r3, [pc, #124]	; (80047b4 <getRandomFloat+0x84>)
 8004738:	681b      	ldr	r3, [r3, #0]
 800473a:	2b00      	cmp	r3, #0
 800473c:	d11a      	bne.n	8004774 <getRandomFloat+0x44>
        uint8_t unique_id[16];
        board_get_unique_id(unique_id, sizeof(unique_id));
 800473e:	1d3b      	adds	r3, r7, #4
 8004740:	4618      	mov	r0, r3
 8004742:	2110      	movs	r1, #16
 8004744:	f000 f932 	bl	80049ac <board_get_unique_id>

        const uint32_t* unique_32 = (uint32_t*)&unique_id[0];
 8004748:	1d3b      	adds	r3, r7, #4
 800474a:	617b      	str	r3, [r7, #20]

        state = micros() ^ unique_32[0] ^ unique_32[1] ^ unique_32[2] ^ unique_32[3];
 800474c:	f002 fda0 	bl	8007290 <micros>
 8004750:	4602      	mov	r2, r0
 8004752:	697b      	ldr	r3, [r7, #20]
 8004754:	681b      	ldr	r3, [r3, #0]
 8004756:	405a      	eors	r2, r3
 8004758:	697b      	ldr	r3, [r7, #20]
 800475a:	3304      	adds	r3, #4
 800475c:	681b      	ldr	r3, [r3, #0]
 800475e:	405a      	eors	r2, r3
 8004760:	697b      	ldr	r3, [r7, #20]
 8004762:	3308      	adds	r3, #8
 8004764:	681b      	ldr	r3, [r3, #0]
 8004766:	405a      	eors	r2, r3
 8004768:	697b      	ldr	r3, [r7, #20]
 800476a:	330c      	adds	r3, #12
 800476c:	681b      	ldr	r3, [r3, #0]
 800476e:	4053      	eors	r3, r2
 8004770:	4a10      	ldr	r2, [pc, #64]	; (80047b4 <getRandomFloat+0x84>)
 8004772:	6013      	str	r3, [r2, #0]
    }

    state = state * 747796405U;
 8004774:	4b0f      	ldr	r3, [pc, #60]	; (80047b4 <getRandomFloat+0x84>)
 8004776:	681b      	ldr	r3, [r3, #0]
 8004778:	4a0f      	ldr	r2, [pc, #60]	; (80047b8 <getRandomFloat+0x88>)
 800477a:	fb02 f303 	mul.w	r3, r2, r3
 800477e:	4a0d      	ldr	r2, [pc, #52]	; (80047b4 <getRandomFloat+0x84>)
 8004780:	6013      	str	r3, [r2, #0]
    return (float)(uint16_t)(((state >> 11u) ^ state) >> ((state >> 30u) + 11u)) / UINT16_MAX;
 8004782:	4b0c      	ldr	r3, [pc, #48]	; (80047b4 <getRandomFloat+0x84>)
 8004784:	681b      	ldr	r3, [r3, #0]
 8004786:	0ada      	lsrs	r2, r3, #11
 8004788:	4b0a      	ldr	r3, [pc, #40]	; (80047b4 <getRandomFloat+0x84>)
 800478a:	681b      	ldr	r3, [r3, #0]
 800478c:	4053      	eors	r3, r2
 800478e:	4a09      	ldr	r2, [pc, #36]	; (80047b4 <getRandomFloat+0x84>)
 8004790:	6812      	ldr	r2, [r2, #0]
 8004792:	0f92      	lsrs	r2, r2, #30
 8004794:	320b      	adds	r2, #11
 8004796:	40d3      	lsrs	r3, r2
 8004798:	b29b      	uxth	r3, r3
 800479a:	4618      	mov	r0, r3
 800479c:	f7ff f942 	bl	8003a24 <__aeabi_ui2f>
 80047a0:	4603      	mov	r3, r0
 80047a2:	4618      	mov	r0, r3
 80047a4:	4905      	ldr	r1, [pc, #20]	; (80047bc <getRandomFloat+0x8c>)
 80047a6:	f7ff fa49 	bl	8003c3c <__aeabi_fdiv>
 80047aa:	4603      	mov	r3, r0
}
 80047ac:	4618      	mov	r0, r3
 80047ae:	3718      	adds	r7, #24
 80047b0:	46bd      	mov	sp, r7
 80047b2:	bd80      	pop	{r7, pc}
 80047b4:	2000146c 	.word	0x2000146c
 80047b8:	2c9277b5 	.word	0x2c9277b5
 80047bc:	477fff00 	.word	0x477fff00

080047c0 <NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
 80047c0:	b480      	push	{r7}
 80047c2:	af00      	add	r7, sp, #0
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80047c4:	f3bf 8f4f 	dsb	sy
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80047c8:	4905      	ldr	r1, [pc, #20]	; (80047e0 <NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80047ca:	4b05      	ldr	r3, [pc, #20]	; (80047e0 <NVIC_SystemReset+0x20>)
 80047cc:	68db      	ldr	r3, [r3, #12]
 80047ce:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80047d2:	4b04      	ldr	r3, [pc, #16]	; (80047e4 <NVIC_SystemReset+0x24>)
 80047d4:	4313      	orrs	r3, r2
 80047d6:	60cb      	str	r3, [r1, #12]
 80047d8:	f3bf 8f4f 	dsb	sy
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 80047dc:	bf00      	nop
 80047de:	e7fd      	b.n	80047dc <NVIC_SystemReset+0x1c>
 80047e0:	e000ed00 	.word	0xe000ed00
 80047e4:	05fa0004 	.word	0x05fa0004

080047e8 <LL_MS2ST>:
 * @param[in] msec      number of milliseconds
 * @return              The number of ticks.
 *
 * @api
 */
static inline systime_t LL_MS2ST(unsigned int msec) {
 80047e8:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80047ec:	b086      	sub	sp, #24
 80047ee:	af00      	add	r7, sp, #0
 80047f0:	60f8      	str	r0, [r7, #12]
  uint64_t ticks = (((uint64_t)msec * (uint64_t)CH_CFG_ST_FREQUENCY) + 999ULL)
 80047f2:	68f9      	ldr	r1, [r7, #12]
 80047f4:	460c      	mov	r4, r1
 80047f6:	f04f 0500 	mov.w	r5, #0
 80047fa:	4620      	mov	r0, r4
 80047fc:	4629      	mov	r1, r5
 80047fe:	ea4f 0b81 	mov.w	fp, r1, lsl #2
 8004802:	ea4b 7b90 	orr.w	fp, fp, r0, lsr #30
 8004806:	ea4f 0a80 	mov.w	sl, r0, lsl #2
 800480a:	4650      	mov	r0, sl
 800480c:	4659      	mov	r1, fp
 800480e:	014b      	lsls	r3, r1, #5
 8004810:	ea43 63d0 	orr.w	r3, r3, r0, lsr #27
 8004814:	0142      	lsls	r2, r0, #5
 8004816:	1a12      	subs	r2, r2, r0
 8004818:	eb63 0301 	sbc.w	r3, r3, r1
 800481c:	18a4      	adds	r4, r4, r2
 800481e:	eb45 0503 	adc.w	r5, r5, r3
 8004822:	4622      	mov	r2, r4
 8004824:	462b      	mov	r3, r5
 8004826:	0099      	lsls	r1, r3, #2
 8004828:	6079      	str	r1, [r7, #4]
 800482a:	6879      	ldr	r1, [r7, #4]
 800482c:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
 8004830:	6079      	str	r1, [r7, #4]
 8004832:	0091      	lsls	r1, r2, #2
 8004834:	6039      	str	r1, [r7, #0]
 8004836:	e9d7 0100 	ldrd	r0, r1, [r7]
 800483a:	1880      	adds	r0, r0, r2
 800483c:	eb41 0103 	adc.w	r1, r1, r3
 8004840:	4602      	mov	r2, r0
 8004842:	460b      	mov	r3, r1
 8004844:	ea4f 1903 	mov.w	r9, r3, lsl #4
 8004848:	ea49 7912 	orr.w	r9, r9, r2, lsr #28
 800484c:	ea4f 1802 	mov.w	r8, r2, lsl #4
 8004850:	4642      	mov	r2, r8
 8004852:	464b      	mov	r3, r9
 8004854:	4610      	mov	r0, r2
 8004856:	4619      	mov	r1, r3
 8004858:	f240 32e7 	movw	r2, #999	; 0x3e7
 800485c:	f04f 0300 	mov.w	r3, #0
 8004860:	1812      	adds	r2, r2, r0
 8004862:	eb43 0301 	adc.w	r3, r3, r1
 8004866:	4610      	mov	r0, r2
 8004868:	4619      	mov	r1, r3
 800486a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800486e:	f04f 0300 	mov.w	r3, #0
 8004872:	f7fe fd49 	bl	8003308 <__aeabi_uldivmod>
 8004876:	4602      	mov	r2, r0
 8004878:	460b      	mov	r3, r1
 800487a:	e9c7 2304 	strd	r2, r3, [r7, #16]
                   / 1000ULL;

  chDbgAssert(ticks <= (uint64_t)TIME_MAXIMUM, "conversion overflow");
 800487e:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8004882:	f64f 70fe 	movw	r0, #65534	; 0xfffe
 8004886:	f04f 0100 	mov.w	r1, #0
 800488a:	4299      	cmp	r1, r3
 800488c:	bf08      	it	eq
 800488e:	4290      	cmpeq	r0, r2
 8004890:	d202      	bcs.n	8004898 <LL_MS2ST+0xb0>
 8004892:	4804      	ldr	r0, [pc, #16]	; (80048a4 <LL_MS2ST+0xbc>)
 8004894:	f005 f8b2 	bl	80099fc <chSysHalt>

  return (systime_t)ticks;
 8004898:	8a3b      	ldrh	r3, [r7, #16]
}
 800489a:	4618      	mov	r0, r3
 800489c:	3718      	adds	r7, #24
 800489e:	46bd      	mov	sp, r7
 80048a0:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 80048a4:	0800d218 	.word	0x0800d218

080048a8 <_local_ctor_25>:

static struct worker_thread_timer_task_s delayed_restart_task;
static struct worker_thread_listener_task_s restart_req_listener_task;
static void restart_req_handler(size_t msg_size, const void* buf, void* ctx);

RUN_AFTER(UAVCAN_INIT) {
 80048a8:	b580      	push	{r7, lr}
 80048aa:	b084      	sub	sp, #16
 80048ac:	af02      	add	r7, sp, #8
    struct pubsub_topic_s* restart_topic = uavcan_get_message_topic(0, &uavcan_protocol_RestartNode_req_descriptor);
 80048ae:	2000      	movs	r0, #0
 80048b0:	4907      	ldr	r1, [pc, #28]	; (80048d0 <_local_ctor_25+0x28>)
 80048b2:	f000 ff11 	bl	80056d8 <uavcan_get_message_topic>
 80048b6:	6078      	str	r0, [r7, #4]
    worker_thread_add_listener_task(&WT, &restart_req_listener_task, restart_topic, restart_req_handler, NULL);
 80048b8:	2300      	movs	r3, #0
 80048ba:	9300      	str	r3, [sp, #0]
 80048bc:	4805      	ldr	r0, [pc, #20]	; (80048d4 <_local_ctor_25+0x2c>)
 80048be:	4906      	ldr	r1, [pc, #24]	; (80048d8 <_local_ctor_25+0x30>)
 80048c0:	687a      	ldr	r2, [r7, #4]
 80048c2:	4b06      	ldr	r3, [pc, #24]	; (80048dc <_local_ctor_25+0x34>)
 80048c4:	f003 fba2 	bl	800800c <worker_thread_add_listener_task>
}
 80048c8:	3708      	adds	r7, #8
 80048ca:	46bd      	mov	sp, r7
 80048cc:	bd80      	pop	{r7, pc}
 80048ce:	bf00      	nop
 80048d0:	0800cd28 	.word	0x0800cd28
 80048d4:	20000a20 	.word	0x20000a20
 80048d8:	20001484 	.word	0x20001484
 80048dc:	080048f9 	.word	0x080048f9

080048e0 <delayed_restart_func>:

static void delayed_restart_func(struct worker_thread_timer_task_s* task) {
 80048e0:	b580      	push	{r7, lr}
 80048e2:	b082      	sub	sp, #8
 80048e4:	af00      	add	r7, sp, #0
 80048e6:	6078      	str	r0, [r7, #4]
    union shared_msg_payload_u msg;
    boot_msg_fill_shared_canbus_info(&msg.canbus_info);
    shared_msg_finalize_and_write(SHARED_MSG_CANBUS_INFO, &msg);
#endif

    NVIC_SystemReset();
 80048e8:	f7ff ff6a 	bl	80047c0 <NVIC_SystemReset>
}
 80048ec:	3708      	adds	r7, #8
 80048ee:	46bd      	mov	sp, r7
 80048f0:	bd80      	pop	{r7, pc}
 80048f2:	bf00      	nop
 80048f4:	0000      	movs	r0, r0
	...

080048f8 <restart_req_handler>:

static void restart_req_handler(size_t msg_size, const void* buf, void* ctx) {
 80048f8:	b580      	push	{r7, lr}
 80048fa:	b08a      	sub	sp, #40	; 0x28
 80048fc:	af02      	add	r7, sp, #8
 80048fe:	60f8      	str	r0, [r7, #12]
 8004900:	60b9      	str	r1, [r7, #8]
 8004902:	607a      	str	r2, [r7, #4]
    (void)msg_size;
    (void)ctx;

    const struct uavcan_deserialized_message_s* msg_wrapper = buf;
 8004904:	68bb      	ldr	r3, [r7, #8]
 8004906:	61fb      	str	r3, [r7, #28]
    const struct uavcan_protocol_RestartNode_req_s* msg = (const struct uavcan_protocol_RestartNode_req_s*)msg_wrapper->msg;
 8004908:	69fb      	ldr	r3, [r7, #28]
 800490a:	3310      	adds	r3, #16
 800490c:	61bb      	str	r3, [r7, #24]

    struct uavcan_protocol_RestartNode_res_s res;

    res.ok = false;
 800490e:	2300      	movs	r3, #0
 8004910:	753b      	strb	r3, [r7, #20]

    if (msg->magic_number == UAVCAN_PROTOCOL_RESTARTNODE_REQ_MAGIC_NUMBER && system_get_restart_allowed()) {
 8004912:	69bb      	ldr	r3, [r7, #24]
 8004914:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004918:	a116      	add	r1, pc, #88	; (adr r1, 8004974 <restart_req_handler+0x7c>)
 800491a:	e9d1 0100 	ldrd	r0, r1, [r1]
 800491e:	428b      	cmp	r3, r1
 8004920:	bf08      	it	eq
 8004922:	4282      	cmpeq	r2, r0
 8004924:	d113      	bne.n	800494e <restart_req_handler+0x56>
 8004926:	f002 fda5 	bl	8007474 <system_get_restart_allowed>
 800492a:	4603      	mov	r3, r0
 800492c:	2b00      	cmp	r3, #0
 800492e:	d00e      	beq.n	800494e <restart_req_handler+0x56>
        res.ok = true;
 8004930:	2301      	movs	r3, #1
 8004932:	753b      	strb	r3, [r7, #20]
        worker_thread_add_timer_task(&WT, &delayed_restart_task, delayed_restart_func, NULL, LL_MS2ST(UAVCAN_RESTART_DELAY_MS), false);
 8004934:	200a      	movs	r0, #10
 8004936:	f7ff ff57 	bl	80047e8 <LL_MS2ST>
 800493a:	4603      	mov	r3, r0
 800493c:	9300      	str	r3, [sp, #0]
 800493e:	2300      	movs	r3, #0
 8004940:	9301      	str	r3, [sp, #4]
 8004942:	4809      	ldr	r0, [pc, #36]	; (8004968 <restart_req_handler+0x70>)
 8004944:	4909      	ldr	r1, [pc, #36]	; (800496c <restart_req_handler+0x74>)
 8004946:	4a0a      	ldr	r2, [pc, #40]	; (8004970 <restart_req_handler+0x78>)
 8004948:	2300      	movs	r3, #0
 800494a:	f003 fab1 	bl	8007eb0 <worker_thread_add_timer_task>
    }

    uavcan_respond(msg_wrapper->uavcan_idx, msg_wrapper, &res);
 800494e:	69fb      	ldr	r3, [r7, #28]
 8004950:	781a      	ldrb	r2, [r3, #0]
 8004952:	f107 0314 	add.w	r3, r7, #20
 8004956:	4610      	mov	r0, r2
 8004958:	69f9      	ldr	r1, [r7, #28]
 800495a:	461a      	mov	r2, r3
 800495c:	f001 f9de 	bl	8005d1c <uavcan_respond>
}
 8004960:	3720      	adds	r7, #32
 8004962:	46bd      	mov	sp, r7
 8004964:	bd80      	pop	{r7, pc}
 8004966:	bf00      	nop
 8004968:	20000a20 	.word	0x20000a20
 800496c:	20001470 	.word	0x20001470
 8004970:	080048e1 	.word	0x080048e1
 8004974:	ce551b1e 	.word	0xce551b1e
 8004978:	000000ac 	.word	0x000000ac

0800497c <_local_ctor_14>:
#error Please define REQUIRED_RAM_MARGIN_AFTER_INIT (bytes) in framework_conf.h.
#endif

uint8_t _module_freemem_init_phase = 1;

RUN_AFTER(INIT_END) {
 800497c:	b580      	push	{r7, lr}
 800497e:	af00      	add	r7, sp, #0
#if REQUIRED_RAM_MARGIN_AFTER_INIT != 0
    if (chCoreGetStatusX() < REQUIRED_RAM_MARGIN_AFTER_INIT) {
 8004980:	f004 f8c2 	bl	8008b08 <chCoreGetStatusX>
 8004984:	4603      	mov	r3, r0
 8004986:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800498a:	d202      	bcs.n	8004992 <_local_ctor_14+0x16>
        chSysHalt(NULL);
 800498c:	2000      	movs	r0, #0
 800498e:	f005 f835 	bl	80099fc <chSysHalt>

#ifdef MODULE_UAVCAN_DEBUG_ENABLED
    uavcan_send_debug_msg(UAVCAN_PROTOCOL_DEBUG_LOGLEVEL_INFO, "", "freemem %u", chCoreGetStatusX());
#endif

    _module_freemem_init_phase = 0;
 8004992:	4b02      	ldr	r3, [pc, #8]	; (800499c <_local_ctor_14+0x20>)
 8004994:	2200      	movs	r2, #0
 8004996:	701a      	strb	r2, [r3, #0]
}
 8004998:	bd80      	pop	{r7, pc}
 800499a:	bf00      	nop
 800499c:	20000a18 	.word	0x20000a18

080049a0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 80049a0:	b580      	push	{r7, lr}
 80049a2:	af00      	add	r7, sp, #0
    stm32_clock_init();
 80049a4:	f003 fd08 	bl	80083b8 <stm32_clock_init>
}
 80049a8:	bd80      	pop	{r7, pc}
 80049aa:	bf00      	nop

080049ac <board_get_unique_id>:

void board_get_unique_id(uint8_t* buf, uint8_t len) {
 80049ac:	b580      	push	{r7, lr}
 80049ae:	b086      	sub	sp, #24
 80049b0:	af00      	add	r7, sp, #0
 80049b2:	6078      	str	r0, [r7, #4]
 80049b4:	460b      	mov	r3, r1
 80049b6:	70fb      	strb	r3, [r7, #3]
    uint32_t unique_id_uint32[3];
    unique_id_uint32[0] = ((uint32_t*)0x1ffff7e8)[2];
 80049b8:	4b12      	ldr	r3, [pc, #72]	; (8004a04 <board_get_unique_id+0x58>)
 80049ba:	681b      	ldr	r3, [r3, #0]
 80049bc:	60fb      	str	r3, [r7, #12]
    unique_id_uint32[1] = ((uint32_t*)0x1ffff7e8)[1];
 80049be:	4b12      	ldr	r3, [pc, #72]	; (8004a08 <board_get_unique_id+0x5c>)
 80049c0:	681b      	ldr	r3, [r3, #0]
 80049c2:	613b      	str	r3, [r7, #16]
    unique_id_uint32[2] = ((uint32_t*)0x1ffff7e8)[0];
 80049c4:	4b11      	ldr	r3, [pc, #68]	; (8004a0c <board_get_unique_id+0x60>)
 80049c6:	681b      	ldr	r3, [r3, #0]
 80049c8:	617b      	str	r3, [r7, #20]

    if (len>12) {
 80049ca:	78fb      	ldrb	r3, [r7, #3]
 80049cc:	2b0c      	cmp	r3, #12
 80049ce:	d90d      	bls.n	80049ec <board_get_unique_id+0x40>
        memset(buf, 0, len);
 80049d0:	78fb      	ldrb	r3, [r7, #3]
 80049d2:	6878      	ldr	r0, [r7, #4]
 80049d4:	2100      	movs	r1, #0
 80049d6:	461a      	mov	r2, r3
 80049d8:	f008 f930 	bl	800cc3c <memset>
        memcpy(buf, unique_id_uint32, 12);
 80049dc:	f107 030c 	add.w	r3, r7, #12
 80049e0:	6878      	ldr	r0, [r7, #4]
 80049e2:	4619      	mov	r1, r3
 80049e4:	220c      	movs	r2, #12
 80049e6:	f008 f903 	bl	800cbf0 <memcpy>
 80049ea:	e007      	b.n	80049fc <board_get_unique_id+0x50>
    } else {
        memcpy(buf, unique_id_uint32, len);
 80049ec:	78fb      	ldrb	r3, [r7, #3]
 80049ee:	f107 020c 	add.w	r2, r7, #12
 80049f2:	6878      	ldr	r0, [r7, #4]
 80049f4:	4611      	mov	r1, r2
 80049f6:	461a      	mov	r2, r3
 80049f8:	f008 f8fa 	bl	800cbf0 <memcpy>
    }
}
 80049fc:	3718      	adds	r7, #24
 80049fe:	46bd      	mov	sp, r7
 8004a00:	bd80      	pop	{r7, pc}
 8004a02:	bf00      	nop
 8004a04:	1ffff7f0 	.word	0x1ffff7f0
 8004a08:	1ffff7ec 	.word	0x1ffff7ec
 8004a0c:	1ffff7e8 	.word	0x1ffff7e8

08004a10 <can_free_tx_frames>:

    can_try_enqueue_waiting_frame(instance);
    can_reschedule_expire_timer(instance);
}

void can_free_tx_frames(struct can_instance_s* instance, struct can_tx_frame_s** frame_list) {
 8004a10:	b580      	push	{r7, lr}
 8004a12:	b084      	sub	sp, #16
 8004a14:	af00      	add	r7, sp, #0
 8004a16:	6078      	str	r0, [r7, #4]
 8004a18:	6039      	str	r1, [r7, #0]
    if (!instance) {
 8004a1a:	687b      	ldr	r3, [r7, #4]
 8004a1c:	2b00      	cmp	r3, #0
 8004a1e:	d012      	beq.n	8004a46 <can_free_tx_frames+0x36>
        return;
    }
    
    for (struct can_tx_frame_s* frame = *frame_list; frame != NULL; frame = frame->next) {
 8004a20:	683b      	ldr	r3, [r7, #0]
 8004a22:	681b      	ldr	r3, [r3, #0]
 8004a24:	60fb      	str	r3, [r7, #12]
 8004a26:	e008      	b.n	8004a3a <can_free_tx_frames+0x2a>
        chPoolFree(&instance->frame_pool, frame);
 8004a28:	687b      	ldr	r3, [r7, #4]
 8004a2a:	3330      	adds	r3, #48	; 0x30
 8004a2c:	4618      	mov	r0, r3
 8004a2e:	68f9      	ldr	r1, [r7, #12]
 8004a30:	f004 f964 	bl	8008cfc <chPoolFree>
void can_free_tx_frames(struct can_instance_s* instance, struct can_tx_frame_s** frame_list) {
    if (!instance) {
        return;
    }
    
    for (struct can_tx_frame_s* frame = *frame_list; frame != NULL; frame = frame->next) {
 8004a34:	68fb      	ldr	r3, [r7, #12]
 8004a36:	699b      	ldr	r3, [r3, #24]
 8004a38:	60fb      	str	r3, [r7, #12]
 8004a3a:	68fb      	ldr	r3, [r7, #12]
 8004a3c:	2b00      	cmp	r3, #0
 8004a3e:	d1f3      	bne.n	8004a28 <can_free_tx_frames+0x18>
        chPoolFree(&instance->frame_pool, frame);
    }
    
    *frame_list = NULL;
 8004a40:	683b      	ldr	r3, [r7, #0]
 8004a42:	2200      	movs	r2, #0
 8004a44:	601a      	str	r2, [r3, #0]
}
 8004a46:	3710      	adds	r7, #16
 8004a48:	46bd      	mov	sp, r7
 8004a4a:	bd80      	pop	{r7, pc}

08004a4c <can_driver_register>:

struct can_instance_s* can_driver_register(uint8_t can_idx, void* driver_ctx, const struct can_driver_iface_s* driver_iface, uint8_t num_tx_mailboxes, uint8_t num_rx_mailboxes, uint8_t rx_fifo_depth) {
 8004a4c:	b580      	push	{r7, lr}
 8004a4e:	b08a      	sub	sp, #40	; 0x28
 8004a50:	af02      	add	r7, sp, #8
 8004a52:	60b9      	str	r1, [r7, #8]
 8004a54:	607a      	str	r2, [r7, #4]
 8004a56:	461a      	mov	r2, r3
 8004a58:	4603      	mov	r3, r0
 8004a5a:	73fb      	strb	r3, [r7, #15]
 8004a5c:	4613      	mov	r3, r2
 8004a5e:	73bb      	strb	r3, [r7, #14]
    if (can_get_instance(can_idx) != NULL) {
 8004a60:	7bfb      	ldrb	r3, [r7, #15]
 8004a62:	4618      	mov	r0, r3
 8004a64:	f002 fa00 	bl	8006e68 <can_get_instance>
 8004a68:	4603      	mov	r3, r0
 8004a6a:	2b00      	cmp	r3, #0
 8004a6c:	d001      	beq.n	8004a72 <can_driver_register+0x26>
        return NULL;
 8004a6e:	2300      	movs	r3, #0
 8004a70:	e093      	b.n	8004b9a <can_driver_register+0x14e>
    }

    struct can_instance_s* instance = chPoolAlloc(&can_instance_pool);
 8004a72:	484c      	ldr	r0, [pc, #304]	; (8004ba4 <can_driver_register+0x158>)
 8004a74:	f004 f912 	bl	8008c9c <chPoolAlloc>
 8004a78:	6178      	str	r0, [r7, #20]

    if (!instance) {
 8004a7a:	697b      	ldr	r3, [r7, #20]
 8004a7c:	2b00      	cmp	r3, #0
 8004a7e:	d101      	bne.n	8004a84 <can_driver_register+0x38>
        return NULL;
 8004a80:	2300      	movs	r3, #0
 8004a82:	e08a      	b.n	8004b9a <can_driver_register+0x14e>
    }
    
    void* tx_queue_mem = chCoreAlloc(CAN_TX_QUEUE_LEN*sizeof(struct can_tx_frame_s));
 8004a84:	f44f 60e0 	mov.w	r0, #1792	; 0x700
 8004a88:	f002 f9b8 	bl	8006dfc <chCoreAlloc.lto_priv.53>
 8004a8c:	6138      	str	r0, [r7, #16]
    
    if (!tx_queue_mem) {
 8004a8e:	693b      	ldr	r3, [r7, #16]
 8004a90:	2b00      	cmp	r3, #0
 8004a92:	d101      	bne.n	8004a98 <can_driver_register+0x4c>
        return NULL;
 8004a94:	2300      	movs	r3, #0
 8004a96:	e080      	b.n	8004b9a <can_driver_register+0x14e>
    }

    if (num_tx_mailboxes > MAX_NUM_TX_MAILBOXES) {
 8004a98:	7bbb      	ldrb	r3, [r7, #14]
 8004a9a:	2b03      	cmp	r3, #3
 8004a9c:	d901      	bls.n	8004aa2 <can_driver_register+0x56>
        num_tx_mailboxes = MAX_NUM_TX_MAILBOXES;
 8004a9e:	2303      	movs	r3, #3
 8004aa0:	73bb      	strb	r3, [r7, #14]
    }

    instance->idx = can_idx;
 8004aa2:	697b      	ldr	r3, [r7, #20]
 8004aa4:	7bfa      	ldrb	r2, [r7, #15]
 8004aa6:	701a      	strb	r2, [r3, #0]

    instance->started = false;
 8004aa8:	697b      	ldr	r3, [r7, #20]
 8004aaa:	2200      	movs	r2, #0
 8004aac:	705a      	strb	r2, [r3, #1]
    instance->silent = false;
 8004aae:	697b      	ldr	r3, [r7, #20]
 8004ab0:	2200      	movs	r2, #0
 8004ab2:	709a      	strb	r2, [r3, #2]
    instance->auto_retransmit = false;
 8004ab4:	697b      	ldr	r3, [r7, #20]
 8004ab6:	2200      	movs	r2, #0
 8004ab8:	70da      	strb	r2, [r3, #3]
    instance->baudrate = 0;
 8004aba:	697b      	ldr	r3, [r7, #20]
 8004abc:	2200      	movs	r2, #0
 8004abe:	605a      	str	r2, [r3, #4]
    instance->baudrate_confirmed = false;
 8004ac0:	697b      	ldr	r3, [r7, #20]
 8004ac2:	2200      	movs	r2, #0
 8004ac4:	721a      	strb	r2, [r3, #8]

    instance->driver_ctx = driver_ctx;
 8004ac6:	697b      	ldr	r3, [r7, #20]
 8004ac8:	68ba      	ldr	r2, [r7, #8]
 8004aca:	60da      	str	r2, [r3, #12]
    instance->driver_iface = driver_iface;
 8004acc:	697b      	ldr	r3, [r7, #20]
 8004ace:	687a      	ldr	r2, [r7, #4]
 8004ad0:	611a      	str	r2, [r3, #16]

    for (uint8_t i=0; i<MAX_NUM_TX_MAILBOXES; i++) {
 8004ad2:	2300      	movs	r3, #0
 8004ad4:	77fb      	strb	r3, [r7, #31]
 8004ad6:	e009      	b.n	8004aec <can_driver_register+0xa0>
        instance->tx_mailbox[i].state = CAN_TX_MAILBOX_EMPTY;
 8004ad8:	7ffb      	ldrb	r3, [r7, #31]
 8004ada:	697a      	ldr	r2, [r7, #20]
 8004adc:	3302      	adds	r3, #2
 8004ade:	00db      	lsls	r3, r3, #3
 8004ae0:	4413      	add	r3, r2
 8004ae2:	2200      	movs	r2, #0
 8004ae4:	721a      	strb	r2, [r3, #8]
    instance->baudrate_confirmed = false;

    instance->driver_ctx = driver_ctx;
    instance->driver_iface = driver_iface;

    for (uint8_t i=0; i<MAX_NUM_TX_MAILBOXES; i++) {
 8004ae6:	7ffb      	ldrb	r3, [r7, #31]
 8004ae8:	3301      	adds	r3, #1
 8004aea:	77fb      	strb	r3, [r7, #31]
 8004aec:	7ffb      	ldrb	r3, [r7, #31]
 8004aee:	2b02      	cmp	r3, #2
 8004af0:	d9f2      	bls.n	8004ad8 <can_driver_register+0x8c>
        instance->tx_mailbox[i].state = CAN_TX_MAILBOX_EMPTY;
    }
    instance->num_tx_mailboxes = num_tx_mailboxes;
 8004af2:	697b      	ldr	r3, [r7, #20]
 8004af4:	7bba      	ldrb	r2, [r7, #14]
 8004af6:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    
    chPoolObjectInit(&instance->frame_pool, sizeof(struct can_tx_frame_s), NULL);
 8004afa:	697b      	ldr	r3, [r7, #20]
 8004afc:	3330      	adds	r3, #48	; 0x30
 8004afe:	4618      	mov	r0, r3
 8004b00:	211c      	movs	r1, #28
 8004b02:	2200      	movs	r2, #0
 8004b04:	f004 f85c 	bl	8008bc0 <chPoolObjectInit>
    chPoolLoadArray(&instance->frame_pool, tx_queue_mem, CAN_TX_QUEUE_LEN);
 8004b08:	697b      	ldr	r3, [r7, #20]
 8004b0a:	3330      	adds	r3, #48	; 0x30
 8004b0c:	4618      	mov	r0, r3
 8004b0e:	6939      	ldr	r1, [r7, #16]
 8004b10:	2240      	movs	r2, #64	; 0x40
 8004b12:	f004 f873 	bl	8008bfc <chPoolLoadArray>

    can_tx_queue_init(&instance->tx_queue);
 8004b16:	697b      	ldr	r3, [r7, #20]
 8004b18:	333c      	adds	r3, #60	; 0x3c
 8004b1a:	4618      	mov	r0, r3
 8004b1c:	f001 ff4e 	bl	80069bc <can_tx_queue_init>

    pubsub_init_topic(&instance->rx_topic, NULL); // TODO specific/configurable topic group
 8004b20:	697b      	ldr	r3, [r7, #20]
 8004b22:	3340      	adds	r3, #64	; 0x40
 8004b24:	4618      	mov	r0, r3
 8004b26:	2100      	movs	r1, #0
 8004b28:	f002 fe20 	bl	800776c <pubsub_init_topic>
    worker_thread_add_publisher_task(&WT_TRX, &instance->rx_publisher_task, sizeof(struct can_rx_frame_s), num_rx_mailboxes*rx_fifo_depth);
 8004b2c:	697b      	ldr	r3, [r7, #20]
 8004b2e:	f103 014c 	add.w	r1, r3, #76	; 0x4c
 8004b32:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8004b36:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
 8004b3a:	fb02 f303 	mul.w	r3, r2, r3
 8004b3e:	481a      	ldr	r0, [pc, #104]	; (8004ba8 <can_driver_register+0x15c>)
 8004b40:	2214      	movs	r2, #20
 8004b42:	f003 fb29 	bl	8008198 <worker_thread_add_publisher_task>

    worker_thread_add_publisher_task(&WT_TRX, &instance->tx_publisher_task, sizeof(struct can_transmit_completion_msg_s), num_tx_mailboxes);
 8004b46:	697b      	ldr	r3, [r7, #20]
 8004b48:	f103 028c 	add.w	r2, r3, #140	; 0x8c
 8004b4c:	7bbb      	ldrb	r3, [r7, #14]
 8004b4e:	4816      	ldr	r0, [pc, #88]	; (8004ba8 <can_driver_register+0x15c>)
 8004b50:	4611      	mov	r1, r2
 8004b52:	2204      	movs	r2, #4
 8004b54:	f003 fb20 	bl	8008198 <worker_thread_add_publisher_task>

    worker_thread_add_timer_task(&WT_EXPIRE, &instance->expire_timer_task, can_expire_handler, instance, TIME_INFINITE, false);
 8004b58:	697b      	ldr	r3, [r7, #20]
 8004b5a:	f103 02cc 	add.w	r2, r3, #204	; 0xcc
 8004b5e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004b62:	9300      	str	r3, [sp, #0]
 8004b64:	2300      	movs	r3, #0
 8004b66:	9301      	str	r3, [sp, #4]
 8004b68:	480f      	ldr	r0, [pc, #60]	; (8004ba8 <can_driver_register+0x15c>)
 8004b6a:	4611      	mov	r1, r2
 8004b6c:	4a0f      	ldr	r2, [pc, #60]	; (8004bac <can_driver_register+0x160>)
 8004b6e:	697b      	ldr	r3, [r7, #20]
 8004b70:	f003 f99e 	bl	8007eb0 <worker_thread_add_timer_task>

    LINKED_LIST_APPEND(struct can_instance_s, can_instance_list_head, instance);
 8004b74:	697b      	ldr	r3, [r7, #20]
 8004b76:	2200      	movs	r2, #0
 8004b78:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 8004b7c:	4b0c      	ldr	r3, [pc, #48]	; (8004bb0 <can_driver_register+0x164>)
 8004b7e:	61bb      	str	r3, [r7, #24]
 8004b80:	e003      	b.n	8004b8a <can_driver_register+0x13e>
 8004b82:	69bb      	ldr	r3, [r7, #24]
 8004b84:	681b      	ldr	r3, [r3, #0]
 8004b86:	33e0      	adds	r3, #224	; 0xe0
 8004b88:	61bb      	str	r3, [r7, #24]
 8004b8a:	69bb      	ldr	r3, [r7, #24]
 8004b8c:	681b      	ldr	r3, [r3, #0]
 8004b8e:	2b00      	cmp	r3, #0
 8004b90:	d1f7      	bne.n	8004b82 <can_driver_register+0x136>
 8004b92:	69bb      	ldr	r3, [r7, #24]
 8004b94:	697a      	ldr	r2, [r7, #20]
 8004b96:	601a      	str	r2, [r3, #0]

    return instance;
 8004b98:	697b      	ldr	r3, [r7, #20]
}
 8004b9a:	4618      	mov	r0, r3
 8004b9c:	3720      	adds	r7, #32
 8004b9e:	46bd      	mov	sp, r7
 8004ba0:	bd80      	pop	{r7, pc}
 8004ba2:	bf00      	nop
 8004ba4:	20000a00 	.word	0x20000a00
 8004ba8:	20000a3c 	.word	0x20000a3c
 8004bac:	08004e85 	.word	0x08004e85
 8004bb0:	200013e4 	.word	0x200013e4

08004bb4 <can_try_enqueue_waiting_frame_I>:

static void can_try_enqueue_waiting_frame_I(struct can_instance_s* instance) {
 8004bb4:	b580      	push	{r7, lr}
 8004bb6:	b088      	sub	sp, #32
 8004bb8:	af00      	add	r7, sp, #0
 8004bba:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
 8004bbc:	f004 fffc 	bl	8009bb8 <chDbgCheckClassI>
    
    // Enqueue the next frame if it will be the highest priority
    bool have_empty_mailbox = false;
 8004bc0:	2300      	movs	r3, #0
 8004bc2:	77fb      	strb	r3, [r7, #31]
    uint8_t empty_mailbox_idx;
    bool have_pending_mailbox = false;
 8004bc4:	2300      	movs	r3, #0
 8004bc6:	777b      	strb	r3, [r7, #29]
    can_frame_priority_t highest_prio_pending = 0;
 8004bc8:	2300      	movs	r3, #0
 8004bca:	61bb      	str	r3, [r7, #24]
    
    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8004bcc:	2300      	movs	r3, #0
 8004bce:	75fb      	strb	r3, [r7, #23]
 8004bd0:	e037      	b.n	8004c42 <can_try_enqueue_waiting_frame_I+0x8e>
        if (instance->tx_mailbox[i].state == CAN_TX_MAILBOX_EMPTY) {
 8004bd2:	7dfb      	ldrb	r3, [r7, #23]
 8004bd4:	687a      	ldr	r2, [r7, #4]
 8004bd6:	3302      	adds	r3, #2
 8004bd8:	00db      	lsls	r3, r3, #3
 8004bda:	4413      	add	r3, r2
 8004bdc:	7a1b      	ldrb	r3, [r3, #8]
 8004bde:	2b00      	cmp	r3, #0
 8004be0:	d104      	bne.n	8004bec <can_try_enqueue_waiting_frame_I+0x38>
            have_empty_mailbox = true;
 8004be2:	2301      	movs	r3, #1
 8004be4:	77fb      	strb	r3, [r7, #31]
            empty_mailbox_idx = i;
 8004be6:	7dfb      	ldrb	r3, [r7, #23]
 8004be8:	77bb      	strb	r3, [r7, #30]
 8004bea:	e027      	b.n	8004c3c <can_try_enqueue_waiting_frame_I+0x88>
        } else if (instance->tx_mailbox[i].state == CAN_TX_MAILBOX_PENDING || instance->tx_mailbox[i].state == CAN_TX_MAILBOX_ABORTING) {
 8004bec:	7dfb      	ldrb	r3, [r7, #23]
 8004bee:	687a      	ldr	r2, [r7, #4]
 8004bf0:	3302      	adds	r3, #2
 8004bf2:	00db      	lsls	r3, r3, #3
 8004bf4:	4413      	add	r3, r2
 8004bf6:	7a1b      	ldrb	r3, [r3, #8]
 8004bf8:	2b01      	cmp	r3, #1
 8004bfa:	d007      	beq.n	8004c0c <can_try_enqueue_waiting_frame_I+0x58>
 8004bfc:	7dfb      	ldrb	r3, [r7, #23]
 8004bfe:	687a      	ldr	r2, [r7, #4]
 8004c00:	3302      	adds	r3, #2
 8004c02:	00db      	lsls	r3, r3, #3
 8004c04:	4413      	add	r3, r2
 8004c06:	7a1b      	ldrb	r3, [r3, #8]
 8004c08:	2b02      	cmp	r3, #2
 8004c0a:	d117      	bne.n	8004c3c <can_try_enqueue_waiting_frame_I+0x88>
            can_frame_priority_t prio = can_get_tx_frame_priority_X(instance->tx_mailbox[i].frame);
 8004c0c:	7dfb      	ldrb	r3, [r7, #23]
 8004c0e:	687a      	ldr	r2, [r7, #4]
 8004c10:	3302      	adds	r3, #2
 8004c12:	00db      	lsls	r3, r3, #3
 8004c14:	4413      	add	r3, r2
 8004c16:	685b      	ldr	r3, [r3, #4]
 8004c18:	4618      	mov	r0, r3
 8004c1a:	f002 f875 	bl	8006d08 <can_get_tx_frame_priority_X>
 8004c1e:	6138      	str	r0, [r7, #16]
            if (!have_pending_mailbox || prio > highest_prio_pending) {
 8004c20:	7f7b      	ldrb	r3, [r7, #29]
 8004c22:	f083 0301 	eor.w	r3, r3, #1
 8004c26:	b2db      	uxtb	r3, r3
 8004c28:	2b00      	cmp	r3, #0
 8004c2a:	d103      	bne.n	8004c34 <can_try_enqueue_waiting_frame_I+0x80>
 8004c2c:	693a      	ldr	r2, [r7, #16]
 8004c2e:	69bb      	ldr	r3, [r7, #24]
 8004c30:	429a      	cmp	r2, r3
 8004c32:	d901      	bls.n	8004c38 <can_try_enqueue_waiting_frame_I+0x84>
                highest_prio_pending = prio;
 8004c34:	693b      	ldr	r3, [r7, #16]
 8004c36:	61bb      	str	r3, [r7, #24]
            }
            have_pending_mailbox = true;
 8004c38:	2301      	movs	r3, #1
 8004c3a:	777b      	strb	r3, [r7, #29]
    bool have_empty_mailbox = false;
    uint8_t empty_mailbox_idx;
    bool have_pending_mailbox = false;
    can_frame_priority_t highest_prio_pending = 0;
    
    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8004c3c:	7dfb      	ldrb	r3, [r7, #23]
 8004c3e:	3301      	adds	r3, #1
 8004c40:	75fb      	strb	r3, [r7, #23]
 8004c42:	687b      	ldr	r3, [r7, #4]
 8004c44:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8004c48:	7dfa      	ldrb	r2, [r7, #23]
 8004c4a:	429a      	cmp	r2, r3
 8004c4c:	d3c1      	bcc.n	8004bd2 <can_try_enqueue_waiting_frame_I+0x1e>
            }
            have_pending_mailbox = true;
        }
    }
    
    if (!have_empty_mailbox) {
 8004c4e:	7ffb      	ldrb	r3, [r7, #31]
 8004c50:	f083 0301 	eor.w	r3, r3, #1
 8004c54:	b2db      	uxtb	r3, r3
 8004c56:	2b00      	cmp	r3, #0
 8004c58:	d130      	bne.n	8004cbc <can_try_enqueue_waiting_frame_I+0x108>
        return;
    }
    
    struct can_tx_frame_s* frame = can_tx_queue_peek_I(&instance->tx_queue);
 8004c5a:	687b      	ldr	r3, [r7, #4]
 8004c5c:	333c      	adds	r3, #60	; 0x3c
 8004c5e:	4618      	mov	r0, r3
 8004c60:	f001 ff2e 	bl	8006ac0 <can_tx_queue_peek_I>
 8004c64:	60f8      	str	r0, [r7, #12]
    if (frame && (!have_pending_mailbox || can_get_tx_frame_priority_X(frame) > highest_prio_pending)) {
 8004c66:	68fb      	ldr	r3, [r7, #12]
 8004c68:	2b00      	cmp	r3, #0
 8004c6a:	d027      	beq.n	8004cbc <can_try_enqueue_waiting_frame_I+0x108>
 8004c6c:	7f7b      	ldrb	r3, [r7, #29]
 8004c6e:	f083 0301 	eor.w	r3, r3, #1
 8004c72:	b2db      	uxtb	r3, r3
 8004c74:	2b00      	cmp	r3, #0
 8004c76:	d106      	bne.n	8004c86 <can_try_enqueue_waiting_frame_I+0xd2>
 8004c78:	68f8      	ldr	r0, [r7, #12]
 8004c7a:	f002 f845 	bl	8006d08 <can_get_tx_frame_priority_X>
 8004c7e:	4602      	mov	r2, r0
 8004c80:	69bb      	ldr	r3, [r7, #24]
 8004c82:	429a      	cmp	r2, r3
 8004c84:	d91a      	bls.n	8004cbc <can_try_enqueue_waiting_frame_I+0x108>
        can_tx_queue_pop_I(&instance->tx_queue);
 8004c86:	687b      	ldr	r3, [r7, #4]
 8004c88:	333c      	adds	r3, #60	; 0x3c
 8004c8a:	4618      	mov	r0, r3
 8004c8c:	f001 ff24 	bl	8006ad8 <can_tx_queue_pop_I>
        instance->tx_mailbox[empty_mailbox_idx].frame = frame;
 8004c90:	7fbb      	ldrb	r3, [r7, #30]
 8004c92:	687a      	ldr	r2, [r7, #4]
 8004c94:	3302      	adds	r3, #2
 8004c96:	00db      	lsls	r3, r3, #3
 8004c98:	4413      	add	r3, r2
 8004c9a:	68fa      	ldr	r2, [r7, #12]
 8004c9c:	605a      	str	r2, [r3, #4]
        instance->tx_mailbox[empty_mailbox_idx].state = CAN_TX_MAILBOX_PENDING;
 8004c9e:	7fbb      	ldrb	r3, [r7, #30]
 8004ca0:	687a      	ldr	r2, [r7, #4]
 8004ca2:	3302      	adds	r3, #2
 8004ca4:	00db      	lsls	r3, r3, #3
 8004ca6:	4413      	add	r3, r2
 8004ca8:	2201      	movs	r2, #1
 8004caa:	721a      	strb	r2, [r3, #8]
        instance->driver_iface->load_tx_mailbox_I(instance->driver_ctx, empty_mailbox_idx, &frame->content);
 8004cac:	687b      	ldr	r3, [r7, #4]
 8004cae:	691b      	ldr	r3, [r3, #16]
 8004cb0:	68db      	ldr	r3, [r3, #12]
 8004cb2:	687a      	ldr	r2, [r7, #4]
 8004cb4:	68d0      	ldr	r0, [r2, #12]
 8004cb6:	68fa      	ldr	r2, [r7, #12]
 8004cb8:	7fb9      	ldrb	r1, [r7, #30]
 8004cba:	4798      	blx	r3
    }
}
 8004cbc:	3720      	adds	r7, #32
 8004cbe:	46bd      	mov	sp, r7
 8004cc0:	bd80      	pop	{r7, pc}
 8004cc2:	bf00      	nop

08004cc4 <can_try_enqueue_waiting_frame.lto_priv.104>:

static void can_try_enqueue_waiting_frame(struct can_instance_s* instance) {
 8004cc4:	b580      	push	{r7, lr}
 8004cc6:	b082      	sub	sp, #8
 8004cc8:	af00      	add	r7, sp, #0
 8004cca:	6078      	str	r0, [r7, #4]
    chSysLock();
 8004ccc:	f002 f85a 	bl	8006d84 <chSysLock.lto_priv.61>
    can_try_enqueue_waiting_frame_I(instance);
 8004cd0:	6878      	ldr	r0, [r7, #4]
 8004cd2:	f7ff ff6f 	bl	8004bb4 <can_try_enqueue_waiting_frame_I>
    chSysUnlock();
 8004cd6:	f002 f85d 	bl	8006d94 <chSysUnlock.lto_priv.58>
}
 8004cda:	3708      	adds	r7, #8
 8004cdc:	46bd      	mov	sp, r7
 8004cde:	bd80      	pop	{r7, pc}

08004ce0 <can_reschedule_expire_timer_I>:

static void can_reschedule_expire_timer_I(struct can_instance_s* instance) {
 8004ce0:	b580      	push	{r7, lr}
 8004ce2:	b086      	sub	sp, #24
 8004ce4:	af00      	add	r7, sp, #0
 8004ce6:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
 8004ce8:	f004 ff66 	bl	8009bb8 <chDbgCheckClassI>

    // Find frame that expires soonest in mailboxes and queue, schedule expire handler for that time
    systime_t t_now = chVTGetSystemTimeX();
 8004cec:	f002 f86e 	bl	8006dcc <chVTGetSystemTimeX.lto_priv.75>
 8004cf0:	4603      	mov	r3, r0
 8004cf2:	827b      	strh	r3, [r7, #18]
    systime_t min_ticks_to_expire = TIME_INFINITE;
 8004cf4:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004cf8:	82fb      	strh	r3, [r7, #22]

    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8004cfa:	2300      	movs	r3, #0
 8004cfc:	757b      	strb	r3, [r7, #21]
 8004cfe:	e01d      	b.n	8004d3c <can_reschedule_expire_timer_I+0x5c>
        if (instance->tx_mailbox[i].state == CAN_TX_MAILBOX_PENDING) {
 8004d00:	7d7b      	ldrb	r3, [r7, #21]
 8004d02:	687a      	ldr	r2, [r7, #4]
 8004d04:	3302      	adds	r3, #2
 8004d06:	00db      	lsls	r3, r3, #3
 8004d08:	4413      	add	r3, r2
 8004d0a:	7a1b      	ldrb	r3, [r3, #8]
 8004d0c:	2b01      	cmp	r3, #1
 8004d0e:	d112      	bne.n	8004d36 <can_reschedule_expire_timer_I+0x56>
            systime_t ticks_to_expire = can_tx_frame_time_until_expire_X(instance->tx_mailbox[i].frame, t_now);
 8004d10:	7d7b      	ldrb	r3, [r7, #21]
 8004d12:	687a      	ldr	r2, [r7, #4]
 8004d14:	3302      	adds	r3, #2
 8004d16:	00db      	lsls	r3, r3, #3
 8004d18:	4413      	add	r3, r2
 8004d1a:	685a      	ldr	r2, [r3, #4]
 8004d1c:	8a7b      	ldrh	r3, [r7, #18]
 8004d1e:	4610      	mov	r0, r2
 8004d20:	4619      	mov	r1, r3
 8004d22:	f001 ff7b 	bl	8006c1c <can_tx_frame_time_until_expire_X>
 8004d26:	4603      	mov	r3, r0
 8004d28:	823b      	strh	r3, [r7, #16]
            if (ticks_to_expire < min_ticks_to_expire) {
 8004d2a:	8a3a      	ldrh	r2, [r7, #16]
 8004d2c:	8afb      	ldrh	r3, [r7, #22]
 8004d2e:	429a      	cmp	r2, r3
 8004d30:	d201      	bcs.n	8004d36 <can_reschedule_expire_timer_I+0x56>
                min_ticks_to_expire = ticks_to_expire;
 8004d32:	8a3b      	ldrh	r3, [r7, #16]
 8004d34:	82fb      	strh	r3, [r7, #22]

    // Find frame that expires soonest in mailboxes and queue, schedule expire handler for that time
    systime_t t_now = chVTGetSystemTimeX();
    systime_t min_ticks_to_expire = TIME_INFINITE;

    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8004d36:	7d7b      	ldrb	r3, [r7, #21]
 8004d38:	3301      	adds	r3, #1
 8004d3a:	757b      	strb	r3, [r7, #21]
 8004d3c:	687b      	ldr	r3, [r7, #4]
 8004d3e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8004d42:	7d7a      	ldrb	r2, [r7, #21]
 8004d44:	429a      	cmp	r2, r3
 8004d46:	d3db      	bcc.n	8004d00 <can_reschedule_expire_timer_I+0x20>
                min_ticks_to_expire = ticks_to_expire;
            }
        }
    }

    struct can_tx_frame_s* frame = NULL;
 8004d48:	2300      	movs	r3, #0
 8004d4a:	60bb      	str	r3, [r7, #8]
 8004d4c:	e00d      	b.n	8004d6a <can_reschedule_expire_timer_I+0x8a>
    while (can_tx_queue_iterate_I(&instance->tx_queue, &frame)) {
        systime_t ticks_to_expire = can_tx_frame_time_until_expire_X(frame, t_now);
 8004d4e:	68ba      	ldr	r2, [r7, #8]
 8004d50:	8a7b      	ldrh	r3, [r7, #18]
 8004d52:	4610      	mov	r0, r2
 8004d54:	4619      	mov	r1, r3
 8004d56:	f001 ff61 	bl	8006c1c <can_tx_frame_time_until_expire_X>
 8004d5a:	4603      	mov	r3, r0
 8004d5c:	81fb      	strh	r3, [r7, #14]
        if (ticks_to_expire < min_ticks_to_expire) {
 8004d5e:	89fa      	ldrh	r2, [r7, #14]
 8004d60:	8afb      	ldrh	r3, [r7, #22]
 8004d62:	429a      	cmp	r2, r3
 8004d64:	d201      	bcs.n	8004d6a <can_reschedule_expire_timer_I+0x8a>
            min_ticks_to_expire = ticks_to_expire;
 8004d66:	89fb      	ldrh	r3, [r7, #14]
 8004d68:	82fb      	strh	r3, [r7, #22]
            }
        }
    }

    struct can_tx_frame_s* frame = NULL;
    while (can_tx_queue_iterate_I(&instance->tx_queue, &frame)) {
 8004d6a:	687b      	ldr	r3, [r7, #4]
 8004d6c:	f103 023c 	add.w	r2, r3, #60	; 0x3c
 8004d70:	f107 0308 	add.w	r3, r7, #8
 8004d74:	4610      	mov	r0, r2
 8004d76:	4619      	mov	r1, r3
 8004d78:	f001 fe74 	bl	8006a64 <can_tx_queue_iterate_I>
 8004d7c:	4603      	mov	r3, r0
 8004d7e:	2b00      	cmp	r3, #0
 8004d80:	d1e5      	bne.n	8004d4e <can_reschedule_expire_timer_I+0x6e>
        if (ticks_to_expire < min_ticks_to_expire) {
            min_ticks_to_expire = ticks_to_expire;
        }
    }

    worker_thread_timer_task_reschedule_I(&WT_EXPIRE, &instance->expire_timer_task, min_ticks_to_expire);
 8004d82:	687b      	ldr	r3, [r7, #4]
 8004d84:	f103 02cc 	add.w	r2, r3, #204	; 0xcc
 8004d88:	8afb      	ldrh	r3, [r7, #22]
 8004d8a:	4804      	ldr	r0, [pc, #16]	; (8004d9c <can_reschedule_expire_timer_I+0xbc>)
 8004d8c:	4611      	mov	r1, r2
 8004d8e:	461a      	mov	r2, r3
 8004d90:	f003 f8c8 	bl	8007f24 <worker_thread_timer_task_reschedule_I>
}
 8004d94:	3718      	adds	r7, #24
 8004d96:	46bd      	mov	sp, r7
 8004d98:	bd80      	pop	{r7, pc}
 8004d9a:	bf00      	nop
 8004d9c:	20000a3c 	.word	0x20000a3c

08004da0 <can_reschedule_expire_timer.lto_priv.103>:

static void can_reschedule_expire_timer(struct can_instance_s* instance) {
 8004da0:	b580      	push	{r7, lr}
 8004da2:	b082      	sub	sp, #8
 8004da4:	af00      	add	r7, sp, #0
 8004da6:	6078      	str	r0, [r7, #4]
    chSysLock();
 8004da8:	f001 ffec 	bl	8006d84 <chSysLock.lto_priv.61>
    can_reschedule_expire_timer_I(instance);
 8004dac:	6878      	ldr	r0, [r7, #4]
 8004dae:	f7ff ff97 	bl	8004ce0 <can_reschedule_expire_timer_I>
    chSchRescheduleS();
 8004db2:	f005 faf1 	bl	800a398 <chSchRescheduleS>
    chSysUnlock();
 8004db6:	f001 ffed 	bl	8006d94 <chSysUnlock.lto_priv.58>
}
 8004dba:	3708      	adds	r7, #8
 8004dbc:	46bd      	mov	sp, r7
 8004dbe:	bd80      	pop	{r7, pc}

08004dc0 <can_tx_frame_completed_I>:

static void can_tx_frame_completed_I(struct can_instance_s* instance, struct can_tx_frame_s* frame, bool success, systime_t completion_systime) {
 8004dc0:	b580      	push	{r7, lr}
 8004dc2:	b088      	sub	sp, #32
 8004dc4:	af02      	add	r7, sp, #8
 8004dc6:	60f8      	str	r0, [r7, #12]
 8004dc8:	60b9      	str	r1, [r7, #8]
 8004dca:	4611      	mov	r1, r2
 8004dcc:	461a      	mov	r2, r3
 8004dce:	460b      	mov	r3, r1
 8004dd0:	71fb      	strb	r3, [r7, #7]
 8004dd2:	4613      	mov	r3, r2
 8004dd4:	80bb      	strh	r3, [r7, #4]
    chDbgCheckClassI();
 8004dd6:	f004 feef 	bl	8009bb8 <chDbgCheckClassI>

    if (frame->completion_topic) {
 8004dda:	68bb      	ldr	r3, [r7, #8]
 8004ddc:	695b      	ldr	r3, [r3, #20]
 8004dde:	2b00      	cmp	r3, #0
 8004de0:	d017      	beq.n	8004e12 <can_tx_frame_completed_I+0x52>
        struct can_transmit_completion_msg_s msg = { success, completion_systime };
 8004de2:	79fb      	ldrb	r3, [r7, #7]
 8004de4:	b29b      	uxth	r3, r3
 8004de6:	82bb      	strh	r3, [r7, #20]
 8004de8:	88bb      	ldrh	r3, [r7, #4]
 8004dea:	2b00      	cmp	r3, #0
 8004dec:	bf14      	ite	ne
 8004dee:	2301      	movne	r3, #1
 8004df0:	2300      	moveq	r3, #0
 8004df2:	b2db      	uxtb	r3, r3
 8004df4:	75bb      	strb	r3, [r7, #22]
        worker_thread_publisher_task_publish_I(&instance->tx_publisher_task, frame->completion_topic, sizeof(struct can_transmit_completion_msg_s), pubsub_copy_writer_func, &msg);
 8004df6:	68fb      	ldr	r3, [r7, #12]
 8004df8:	f103 018c 	add.w	r1, r3, #140	; 0x8c
 8004dfc:	68bb      	ldr	r3, [r7, #8]
 8004dfe:	695a      	ldr	r2, [r3, #20]
 8004e00:	f107 0314 	add.w	r3, r7, #20
 8004e04:	9300      	str	r3, [sp, #0]
 8004e06:	4608      	mov	r0, r1
 8004e08:	4611      	mov	r1, r2
 8004e0a:	2204      	movs	r2, #4
 8004e0c:	4b05      	ldr	r3, [pc, #20]	; (8004e24 <can_tx_frame_completed_I+0x64>)
 8004e0e:	f000 ffe9 	bl	8005de4 <worker_thread_publisher_task_publish_I>
    }
    chPoolFreeI(&instance->frame_pool, frame);
 8004e12:	68fb      	ldr	r3, [r7, #12]
 8004e14:	3330      	adds	r3, #48	; 0x30
 8004e16:	4618      	mov	r0, r3
 8004e18:	68b9      	ldr	r1, [r7, #8]
 8004e1a:	f003 ff51 	bl	8008cc0 <chPoolFreeI>
}
 8004e1e:	3718      	adds	r7, #24
 8004e20:	46bd      	mov	sp, r7
 8004e22:	bd80      	pop	{r7, pc}
 8004e24:	080078a9 	.word	0x080078a9

08004e28 <can_tx_frame_completed>:

static void can_tx_frame_completed(struct can_instance_s* instance, struct can_tx_frame_s* frame, bool success, systime_t completion_systime) {
 8004e28:	b580      	push	{r7, lr}
 8004e2a:	b086      	sub	sp, #24
 8004e2c:	af00      	add	r7, sp, #0
 8004e2e:	60f8      	str	r0, [r7, #12]
 8004e30:	60b9      	str	r1, [r7, #8]
 8004e32:	4611      	mov	r1, r2
 8004e34:	461a      	mov	r2, r3
 8004e36:	460b      	mov	r3, r1
 8004e38:	71fb      	strb	r3, [r7, #7]
 8004e3a:	4613      	mov	r3, r2
 8004e3c:	80bb      	strh	r3, [r7, #4]
    if (frame->completion_topic) {
 8004e3e:	68bb      	ldr	r3, [r7, #8]
 8004e40:	695b      	ldr	r3, [r3, #20]
 8004e42:	2b00      	cmp	r3, #0
 8004e44:	d012      	beq.n	8004e6c <can_tx_frame_completed+0x44>
        struct can_transmit_completion_msg_s msg = { success, completion_systime };
 8004e46:	79fb      	ldrb	r3, [r7, #7]
 8004e48:	b29b      	uxth	r3, r3
 8004e4a:	82bb      	strh	r3, [r7, #20]
 8004e4c:	88bb      	ldrh	r3, [r7, #4]
 8004e4e:	2b00      	cmp	r3, #0
 8004e50:	bf14      	ite	ne
 8004e52:	2301      	movne	r3, #1
 8004e54:	2300      	moveq	r3, #0
 8004e56:	b2db      	uxtb	r3, r3
 8004e58:	75bb      	strb	r3, [r7, #22]
        pubsub_publish_message(frame->completion_topic, sizeof(struct can_transmit_completion_msg_s), pubsub_copy_writer_func, &msg);
 8004e5a:	68bb      	ldr	r3, [r7, #8]
 8004e5c:	695a      	ldr	r2, [r3, #20]
 8004e5e:	f107 0314 	add.w	r3, r7, #20
 8004e62:	4610      	mov	r0, r2
 8004e64:	2104      	movs	r1, #4
 8004e66:	4a06      	ldr	r2, [pc, #24]	; (8004e80 <can_tx_frame_completed+0x58>)
 8004e68:	f002 fd66 	bl	8007938 <pubsub_publish_message>
    }
    chPoolFree(&instance->frame_pool, frame);
 8004e6c:	68fb      	ldr	r3, [r7, #12]
 8004e6e:	3330      	adds	r3, #48	; 0x30
 8004e70:	4618      	mov	r0, r3
 8004e72:	68b9      	ldr	r1, [r7, #8]
 8004e74:	f003 ff42 	bl	8008cfc <chPoolFree>
}
 8004e78:	3718      	adds	r7, #24
 8004e7a:	46bd      	mov	sp, r7
 8004e7c:	bd80      	pop	{r7, pc}
 8004e7e:	bf00      	nop
 8004e80:	080078a9 	.word	0x080078a9

08004e84 <can_expire_handler>:

static void can_expire_handler(struct worker_thread_timer_task_s* task) {
 8004e84:	b580      	push	{r7, lr}
 8004e86:	b086      	sub	sp, #24
 8004e88:	af00      	add	r7, sp, #0
 8004e8a:	6078      	str	r0, [r7, #4]
    struct can_instance_s* instance = worker_thread_task_get_user_context(task);
 8004e8c:	6878      	ldr	r0, [r7, #4]
 8004e8e:	f003 f8ab 	bl	8007fe8 <worker_thread_task_get_user_context>
 8004e92:	6138      	str	r0, [r7, #16]

    // Abort expired mailboxes
    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8004e94:	2300      	movs	r3, #0
 8004e96:	75fb      	strb	r3, [r7, #23]
 8004e98:	e02d      	b.n	8004ef6 <can_expire_handler+0x72>
        chSysLock();
 8004e9a:	f001 ff73 	bl	8006d84 <chSysLock.lto_priv.61>
        if (instance->tx_mailbox[i].state == CAN_TX_MAILBOX_PENDING && can_tx_frame_expired_X(instance->tx_mailbox[i].frame)) {
 8004e9e:	7dfb      	ldrb	r3, [r7, #23]
 8004ea0:	693a      	ldr	r2, [r7, #16]
 8004ea2:	3302      	adds	r3, #2
 8004ea4:	00db      	lsls	r3, r3, #3
 8004ea6:	4413      	add	r3, r2
 8004ea8:	7a1b      	ldrb	r3, [r3, #8]
 8004eaa:	2b01      	cmp	r3, #1
 8004eac:	d11e      	bne.n	8004eec <can_expire_handler+0x68>
 8004eae:	7dfb      	ldrb	r3, [r7, #23]
 8004eb0:	693a      	ldr	r2, [r7, #16]
 8004eb2:	3302      	adds	r3, #2
 8004eb4:	00db      	lsls	r3, r3, #3
 8004eb6:	4413      	add	r3, r2
 8004eb8:	685b      	ldr	r3, [r3, #4]
 8004eba:	4618      	mov	r0, r3
 8004ebc:	f001 fe98 	bl	8006bf0 <can_tx_frame_expired_X>
 8004ec0:	4603      	mov	r3, r0
 8004ec2:	2b00      	cmp	r3, #0
 8004ec4:	d012      	beq.n	8004eec <can_expire_handler+0x68>
            if (instance->driver_iface->abort_tx_mailbox_I(instance->driver_ctx, i)) {
 8004ec6:	693b      	ldr	r3, [r7, #16]
 8004ec8:	691b      	ldr	r3, [r3, #16]
 8004eca:	689b      	ldr	r3, [r3, #8]
 8004ecc:	693a      	ldr	r2, [r7, #16]
 8004ece:	68d1      	ldr	r1, [r2, #12]
 8004ed0:	7dfa      	ldrb	r2, [r7, #23]
 8004ed2:	4608      	mov	r0, r1
 8004ed4:	4611      	mov	r1, r2
 8004ed6:	4798      	blx	r3
 8004ed8:	4603      	mov	r3, r0
 8004eda:	2b00      	cmp	r3, #0
 8004edc:	d006      	beq.n	8004eec <can_expire_handler+0x68>
                instance->tx_mailbox[i].state = CAN_TX_MAILBOX_ABORTING;
 8004ede:	7dfb      	ldrb	r3, [r7, #23]
 8004ee0:	693a      	ldr	r2, [r7, #16]
 8004ee2:	3302      	adds	r3, #2
 8004ee4:	00db      	lsls	r3, r3, #3
 8004ee6:	4413      	add	r3, r2
 8004ee8:	2202      	movs	r2, #2
 8004eea:	721a      	strb	r2, [r3, #8]
            }
        }
        chSysUnlock();
 8004eec:	f001 ff52 	bl	8006d94 <chSysUnlock.lto_priv.58>

static void can_expire_handler(struct worker_thread_timer_task_s* task) {
    struct can_instance_s* instance = worker_thread_task_get_user_context(task);

    // Abort expired mailboxes
    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8004ef0:	7dfb      	ldrb	r3, [r7, #23]
 8004ef2:	3301      	adds	r3, #1
 8004ef4:	75fb      	strb	r3, [r7, #23]
 8004ef6:	693b      	ldr	r3, [r7, #16]
 8004ef8:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8004efc:	7dfa      	ldrb	r2, [r7, #23]
 8004efe:	429a      	cmp	r2, r3
 8004f00:	d3cb      	bcc.n	8004e9a <can_expire_handler+0x16>
 8004f02:	e007      	b.n	8004f14 <can_expire_handler+0x90>
    }

    // Abort expired queue items
    struct can_tx_frame_s* frame;
    while ((frame = can_tx_queue_pop_expired(&instance->tx_queue)) != NULL) {
        can_tx_frame_completed(instance, frame, false, chVTGetSystemTimeX());
 8004f04:	f001 ff62 	bl	8006dcc <chVTGetSystemTimeX.lto_priv.75>
 8004f08:	4603      	mov	r3, r0
 8004f0a:	6938      	ldr	r0, [r7, #16]
 8004f0c:	68f9      	ldr	r1, [r7, #12]
 8004f0e:	2200      	movs	r2, #0
 8004f10:	f7ff ff8a 	bl	8004e28 <can_tx_frame_completed>
        chSysUnlock();
    }

    // Abort expired queue items
    struct can_tx_frame_s* frame;
    while ((frame = can_tx_queue_pop_expired(&instance->tx_queue)) != NULL) {
 8004f14:	693b      	ldr	r3, [r7, #16]
 8004f16:	333c      	adds	r3, #60	; 0x3c
 8004f18:	4618      	mov	r0, r3
 8004f1a:	f001 fe1f 	bl	8006b5c <can_tx_queue_pop_expired>
 8004f1e:	60f8      	str	r0, [r7, #12]
 8004f20:	68fb      	ldr	r3, [r7, #12]
 8004f22:	2b00      	cmp	r3, #0
 8004f24:	d1ee      	bne.n	8004f04 <can_expire_handler+0x80>
        can_tx_frame_completed(instance, frame, false, chVTGetSystemTimeX());
    }

    can_try_enqueue_waiting_frame(instance);
 8004f26:	6938      	ldr	r0, [r7, #16]
 8004f28:	f7ff fecc 	bl	8004cc4 <can_try_enqueue_waiting_frame.lto_priv.104>

    can_reschedule_expire_timer(instance);
 8004f2c:	6938      	ldr	r0, [r7, #16]
 8004f2e:	f7ff ff37 	bl	8004da0 <can_reschedule_expire_timer.lto_priv.103>
}
 8004f32:	3718      	adds	r7, #24
 8004f34:	46bd      	mov	sp, r7
 8004f36:	bd80      	pop	{r7, pc}

08004f38 <can_driver_tx_request_complete_I>:

void can_driver_tx_request_complete_I(struct can_instance_s* instance, uint8_t mb_idx, bool transmit_success, systime_t completion_systime) {
 8004f38:	b580      	push	{r7, lr}
 8004f3a:	b082      	sub	sp, #8
 8004f3c:	af00      	add	r7, sp, #0
 8004f3e:	6078      	str	r0, [r7, #4]
 8004f40:	4608      	mov	r0, r1
 8004f42:	4611      	mov	r1, r2
 8004f44:	461a      	mov	r2, r3
 8004f46:	4603      	mov	r3, r0
 8004f48:	70fb      	strb	r3, [r7, #3]
 8004f4a:	460b      	mov	r3, r1
 8004f4c:	70bb      	strb	r3, [r7, #2]
 8004f4e:	4613      	mov	r3, r2
 8004f50:	803b      	strh	r3, [r7, #0]
    chDbgCheckClassI();
 8004f52:	f004 fe31 	bl	8009bb8 <chDbgCheckClassI>
    chDbgCheck(instance->tx_mailbox[mb_idx].state == CAN_TX_MAILBOX_PENDING || instance->tx_mailbox[mb_idx].state == CAN_TX_MAILBOX_ABORTING);
 8004f56:	78fb      	ldrb	r3, [r7, #3]
 8004f58:	687a      	ldr	r2, [r7, #4]
 8004f5a:	3302      	adds	r3, #2
 8004f5c:	00db      	lsls	r3, r3, #3
 8004f5e:	4413      	add	r3, r2
 8004f60:	7a1b      	ldrb	r3, [r3, #8]
 8004f62:	2b01      	cmp	r3, #1
 8004f64:	d00a      	beq.n	8004f7c <can_driver_tx_request_complete_I+0x44>
 8004f66:	78fb      	ldrb	r3, [r7, #3]
 8004f68:	687a      	ldr	r2, [r7, #4]
 8004f6a:	3302      	adds	r3, #2
 8004f6c:	00db      	lsls	r3, r3, #3
 8004f6e:	4413      	add	r3, r2
 8004f70:	7a1b      	ldrb	r3, [r3, #8]
 8004f72:	2b02      	cmp	r3, #2
 8004f74:	d002      	beq.n	8004f7c <can_driver_tx_request_complete_I+0x44>
 8004f76:	480d      	ldr	r0, [pc, #52]	; (8004fac <can_driver_tx_request_complete_I+0x74>)
 8004f78:	f004 fd40 	bl	80099fc <chSysHalt>

    can_tx_frame_completed_I(instance, instance->tx_mailbox[mb_idx].frame, transmit_success, completion_systime);
 8004f7c:	78fb      	ldrb	r3, [r7, #3]
 8004f7e:	687a      	ldr	r2, [r7, #4]
 8004f80:	3302      	adds	r3, #2
 8004f82:	00db      	lsls	r3, r3, #3
 8004f84:	4413      	add	r3, r2
 8004f86:	6859      	ldr	r1, [r3, #4]
 8004f88:	78ba      	ldrb	r2, [r7, #2]
 8004f8a:	883b      	ldrh	r3, [r7, #0]
 8004f8c:	6878      	ldr	r0, [r7, #4]
 8004f8e:	f7ff ff17 	bl	8004dc0 <can_tx_frame_completed_I>
    instance->tx_mailbox[mb_idx].state = CAN_TX_MAILBOX_EMPTY;
 8004f92:	78fb      	ldrb	r3, [r7, #3]
 8004f94:	687a      	ldr	r2, [r7, #4]
 8004f96:	3302      	adds	r3, #2
 8004f98:	00db      	lsls	r3, r3, #3
 8004f9a:	4413      	add	r3, r2
 8004f9c:	2200      	movs	r2, #0
 8004f9e:	721a      	strb	r2, [r3, #8]

    can_try_enqueue_waiting_frame_I(instance);
 8004fa0:	6878      	ldr	r0, [r7, #4]
 8004fa2:	f7ff fe07 	bl	8004bb4 <can_try_enqueue_waiting_frame_I>
}
 8004fa6:	3708      	adds	r7, #8
 8004fa8:	46bd      	mov	sp, r7
 8004faa:	bd80      	pop	{r7, pc}
 8004fac:	0800d1b0 	.word	0x0800d1b0

08004fb0 <can_fill_rx_frame_I>:
struct can_fill_rx_frame_params_s {
    systime_t rx_systime;
    struct can_frame_s* frame;
};

static void can_fill_rx_frame_I(size_t msg_size, void* msg, void* ctx) {
 8004fb0:	b590      	push	{r4, r7, lr}
 8004fb2:	b087      	sub	sp, #28
 8004fb4:	af00      	add	r7, sp, #0
 8004fb6:	60f8      	str	r0, [r7, #12]
 8004fb8:	60b9      	str	r1, [r7, #8]
 8004fba:	607a      	str	r2, [r7, #4]
    (void)msg_size;

    chDbgCheckClassI();
 8004fbc:	f004 fdfc 	bl	8009bb8 <chDbgCheckClassI>

    struct can_fill_rx_frame_params_s* params = ctx;
 8004fc0:	687b      	ldr	r3, [r7, #4]
 8004fc2:	617b      	str	r3, [r7, #20]
    struct can_rx_frame_s* frame = msg;
 8004fc4:	68bb      	ldr	r3, [r7, #8]
 8004fc6:	613b      	str	r3, [r7, #16]

    frame->content = *params->frame;
 8004fc8:	697b      	ldr	r3, [r7, #20]
 8004fca:	685b      	ldr	r3, [r3, #4]
 8004fcc:	693a      	ldr	r2, [r7, #16]
 8004fce:	4614      	mov	r4, r2
 8004fd0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8004fd2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    frame->rx_systime = params->rx_systime;
 8004fd6:	697b      	ldr	r3, [r7, #20]
 8004fd8:	881a      	ldrh	r2, [r3, #0]
 8004fda:	693b      	ldr	r3, [r7, #16]
 8004fdc:	821a      	strh	r2, [r3, #16]
}
 8004fde:	371c      	adds	r7, #28
 8004fe0:	46bd      	mov	sp, r7
 8004fe2:	bd90      	pop	{r4, r7, pc}

08004fe4 <can_driver_rx_frame_received_I>:

void can_driver_rx_frame_received_I(struct can_instance_s* instance, uint8_t mb_idx, systime_t rx_systime, struct can_frame_s* frame) {
 8004fe4:	b580      	push	{r7, lr}
 8004fe6:	b088      	sub	sp, #32
 8004fe8:	af02      	add	r7, sp, #8
 8004fea:	60f8      	str	r0, [r7, #12]
 8004fec:	607b      	str	r3, [r7, #4]
 8004fee:	460b      	mov	r3, r1
 8004ff0:	72fb      	strb	r3, [r7, #11]
 8004ff2:	4613      	mov	r3, r2
 8004ff4:	813b      	strh	r3, [r7, #8]
    (void)mb_idx;

    chDbgCheckClassI();
 8004ff6:	f004 fddf 	bl	8009bb8 <chDbgCheckClassI>

    struct can_fill_rx_frame_params_s can_fill_rx_frame_params = {rx_systime, frame};
 8004ffa:	893b      	ldrh	r3, [r7, #8]
 8004ffc:	823b      	strh	r3, [r7, #16]
 8004ffe:	687b      	ldr	r3, [r7, #4]
 8005000:	617b      	str	r3, [r7, #20]
    worker_thread_publisher_task_publish_I(&instance->rx_publisher_task, &instance->rx_topic, sizeof(struct can_rx_frame_s), can_fill_rx_frame_I, &can_fill_rx_frame_params);
 8005002:	68fb      	ldr	r3, [r7, #12]
 8005004:	f103 014c 	add.w	r1, r3, #76	; 0x4c
 8005008:	68fb      	ldr	r3, [r7, #12]
 800500a:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800500e:	f107 0310 	add.w	r3, r7, #16
 8005012:	9300      	str	r3, [sp, #0]
 8005014:	4608      	mov	r0, r1
 8005016:	4611      	mov	r1, r2
 8005018:	2214      	movs	r2, #20
 800501a:	4b04      	ldr	r3, [pc, #16]	; (800502c <can_driver_rx_frame_received_I+0x48>)
 800501c:	f000 fee2 	bl	8005de4 <worker_thread_publisher_task_publish_I>
    instance->baudrate_confirmed = true;
 8005020:	68fb      	ldr	r3, [r7, #12]
 8005022:	2201      	movs	r2, #1
 8005024:	721a      	strb	r2, [r3, #8]
}
 8005026:	3718      	adds	r7, #24
 8005028:	46bd      	mov	sp, r7
 800502a:	bd80      	pop	{r7, pc}
 800502c:	08004fb1 	.word	0x08004fb1

08005030 <LL_US2ST.lto_priv.55>:
 * @param[in] usec      number of microseconds
 * @return              The number of ticks.
 *
 * @api
 */
static inline systime_t LL_US2ST(unsigned int usec) {
 8005030:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8005034:	b086      	sub	sp, #24
 8005036:	af00      	add	r7, sp, #0
 8005038:	60f8      	str	r0, [r7, #12]
  uint64_t ticks = (((uint64_t)usec * (uint64_t)CH_CFG_ST_FREQUENCY) + 999999ULL)
 800503a:	68f9      	ldr	r1, [r7, #12]
 800503c:	460c      	mov	r4, r1
 800503e:	f04f 0500 	mov.w	r5, #0
 8005042:	4620      	mov	r0, r4
 8005044:	4629      	mov	r1, r5
 8005046:	ea4f 0b81 	mov.w	fp, r1, lsl #2
 800504a:	ea4b 7b90 	orr.w	fp, fp, r0, lsr #30
 800504e:	ea4f 0a80 	mov.w	sl, r0, lsl #2
 8005052:	4650      	mov	r0, sl
 8005054:	4659      	mov	r1, fp
 8005056:	014b      	lsls	r3, r1, #5
 8005058:	ea43 63d0 	orr.w	r3, r3, r0, lsr #27
 800505c:	0142      	lsls	r2, r0, #5
 800505e:	1a12      	subs	r2, r2, r0
 8005060:	eb63 0301 	sbc.w	r3, r3, r1
 8005064:	18a4      	adds	r4, r4, r2
 8005066:	eb45 0503 	adc.w	r5, r5, r3
 800506a:	4622      	mov	r2, r4
 800506c:	462b      	mov	r3, r5
 800506e:	0099      	lsls	r1, r3, #2
 8005070:	6079      	str	r1, [r7, #4]
 8005072:	6879      	ldr	r1, [r7, #4]
 8005074:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
 8005078:	6079      	str	r1, [r7, #4]
 800507a:	0091      	lsls	r1, r2, #2
 800507c:	6039      	str	r1, [r7, #0]
 800507e:	e9d7 0100 	ldrd	r0, r1, [r7]
 8005082:	1880      	adds	r0, r0, r2
 8005084:	eb41 0103 	adc.w	r1, r1, r3
 8005088:	4602      	mov	r2, r0
 800508a:	460b      	mov	r3, r1
 800508c:	ea4f 1903 	mov.w	r9, r3, lsl #4
 8005090:	ea49 7912 	orr.w	r9, r9, r2, lsr #28
 8005094:	ea4f 1802 	mov.w	r8, r2, lsl #4
 8005098:	4642      	mov	r2, r8
 800509a:	464b      	mov	r3, r9
 800509c:	4610      	mov	r0, r2
 800509e:	4619      	mov	r1, r3
 80050a0:	4a11      	ldr	r2, [pc, #68]	; (80050e8 <LL_US2ST.lto_priv.55+0xb8>)
 80050a2:	f04f 0300 	mov.w	r3, #0
 80050a6:	1812      	adds	r2, r2, r0
 80050a8:	eb43 0301 	adc.w	r3, r3, r1
 80050ac:	4610      	mov	r0, r2
 80050ae:	4619      	mov	r1, r3
 80050b0:	4a0e      	ldr	r2, [pc, #56]	; (80050ec <LL_US2ST.lto_priv.55+0xbc>)
 80050b2:	f04f 0300 	mov.w	r3, #0
 80050b6:	f7fe f927 	bl	8003308 <__aeabi_uldivmod>
 80050ba:	4602      	mov	r2, r0
 80050bc:	460b      	mov	r3, r1
 80050be:	e9c7 2304 	strd	r2, r3, [r7, #16]
                   / 1000000ULL;

  chDbgAssert(ticks <= (uint64_t)TIME_MAXIMUM, "conversion overflow");
 80050c2:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 80050c6:	f64f 70fe 	movw	r0, #65534	; 0xfffe
 80050ca:	f04f 0100 	mov.w	r1, #0
 80050ce:	4299      	cmp	r1, r3
 80050d0:	bf08      	it	eq
 80050d2:	4290      	cmpeq	r0, r2
 80050d4:	d202      	bcs.n	80050dc <LL_US2ST.lto_priv.55+0xac>
 80050d6:	4806      	ldr	r0, [pc, #24]	; (80050f0 <LL_US2ST.lto_priv.55+0xc0>)
 80050d8:	f004 fc90 	bl	80099fc <chSysHalt>

  return (systime_t)ticks;
 80050dc:	8a3b      	ldrh	r3, [r7, #16]
}
 80050de:	4618      	mov	r0, r3
 80050e0:	3718      	adds	r7, #24
 80050e2:	46bd      	mov	sp, r7
 80050e4:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 80050e8:	000f423f 	.word	0x000f423f
 80050ec:	000f4240 	.word	0x000f4240
 80050f0:	0800d1e4 	.word	0x0800d1e4

080050f4 <is_baudrate_valid>:

static uint8_t baudrate_idx = 0;
static void autobaud_timer_task_func(struct worker_thread_timer_task_s* task);
static struct worker_thread_timer_task_s autobaud_timer_task;

static bool is_baudrate_valid(uint32_t baudrate) {
 80050f4:	b480      	push	{r7}
 80050f6:	b085      	sub	sp, #20
 80050f8:	af00      	add	r7, sp, #0
 80050fa:	6078      	str	r0, [r7, #4]
    for (uint8_t i=0; i<LEN(valid_baudrates); i++) {
 80050fc:	2300      	movs	r3, #0
 80050fe:	73fb      	strb	r3, [r7, #15]
 8005100:	e00b      	b.n	800511a <is_baudrate_valid+0x26>
        if (baudrate == valid_baudrates[i]) {
 8005102:	7bfb      	ldrb	r3, [r7, #15]
 8005104:	4a0a      	ldr	r2, [pc, #40]	; (8005130 <is_baudrate_valid+0x3c>)
 8005106:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800510a:	687b      	ldr	r3, [r7, #4]
 800510c:	429a      	cmp	r2, r3
 800510e:	d101      	bne.n	8005114 <is_baudrate_valid+0x20>
            return true;
 8005110:	2301      	movs	r3, #1
 8005112:	e006      	b.n	8005122 <is_baudrate_valid+0x2e>
static uint8_t baudrate_idx = 0;
static void autobaud_timer_task_func(struct worker_thread_timer_task_s* task);
static struct worker_thread_timer_task_s autobaud_timer_task;

static bool is_baudrate_valid(uint32_t baudrate) {
    for (uint8_t i=0; i<LEN(valid_baudrates); i++) {
 8005114:	7bfb      	ldrb	r3, [r7, #15]
 8005116:	3301      	adds	r3, #1
 8005118:	73fb      	strb	r3, [r7, #15]
 800511a:	7bfb      	ldrb	r3, [r7, #15]
 800511c:	2b03      	cmp	r3, #3
 800511e:	d9f0      	bls.n	8005102 <is_baudrate_valid+0xe>
        if (baudrate == valid_baudrates[i]) {
            return true;
        }
    }
    return false;
 8005120:	2300      	movs	r3, #0
}
 8005122:	4618      	mov	r0, r3
 8005124:	3714      	adds	r7, #20
 8005126:	46bd      	mov	sp, r7
 8005128:	f85d 7b04 	ldr.w	r7, [sp], #4
 800512c:	4770      	bx	lr
 800512e:	bf00      	nop
 8005130:	0800d1d4 	.word	0x0800d1d4

08005134 <_local_ctor_37>:

RUN_AFTER(CAN_INIT) {
 8005134:	b580      	push	{r7, lr}
 8005136:	b086      	sub	sp, #24
 8005138:	af02      	add	r7, sp, #8
    uint32_t canbus_baud = 1000000;
 800513a:	4b38      	ldr	r3, [pc, #224]	; (800521c <_local_ctor_37+0xe8>)
 800513c:	60fb      	str	r3, [r7, #12]
    bool canbus_autobaud_enable = true;
 800513e:	2301      	movs	r3, #1
 8005140:	72fb      	strb	r3, [r7, #11]

#ifdef MODULE_APP_DESCRIPTOR_ENABLED
    if (is_baudrate_valid(shared_get_parameters(&shared_app_descriptor)->canbus_baudrate)) {
 8005142:	4837      	ldr	r0, [pc, #220]	; (8005220 <_local_ctor_37+0xec>)
 8005144:	f003 fb16 	bl	8008774 <shared_get_parameters>
 8005148:	4603      	mov	r3, r0
 800514a:	789a      	ldrb	r2, [r3, #2]
 800514c:	0852      	lsrs	r2, r2, #1
 800514e:	b2d2      	uxtb	r2, r2
 8005150:	78d9      	ldrb	r1, [r3, #3]
 8005152:	01c9      	lsls	r1, r1, #7
 8005154:	430a      	orrs	r2, r1
 8005156:	7919      	ldrb	r1, [r3, #4]
 8005158:	03c9      	lsls	r1, r1, #15
 800515a:	430a      	orrs	r2, r1
 800515c:	795b      	ldrb	r3, [r3, #5]
 800515e:	05db      	lsls	r3, r3, #23
 8005160:	4313      	orrs	r3, r2
 8005162:	4618      	mov	r0, r3
 8005164:	f7ff ffc6 	bl	80050f4 <is_baudrate_valid>
 8005168:	4603      	mov	r3, r0
 800516a:	2b00      	cmp	r3, #0
 800516c:	d010      	beq.n	8005190 <_local_ctor_37+0x5c>
        canbus_baud = shared_get_parameters(&shared_app_descriptor)->canbus_baudrate;
 800516e:	482c      	ldr	r0, [pc, #176]	; (8005220 <_local_ctor_37+0xec>)
 8005170:	f003 fb00 	bl	8008774 <shared_get_parameters>
 8005174:	4603      	mov	r3, r0
 8005176:	789a      	ldrb	r2, [r3, #2]
 8005178:	0852      	lsrs	r2, r2, #1
 800517a:	b2d2      	uxtb	r2, r2
 800517c:	78d9      	ldrb	r1, [r3, #3]
 800517e:	01c9      	lsls	r1, r1, #7
 8005180:	430a      	orrs	r2, r1
 8005182:	7919      	ldrb	r1, [r3, #4]
 8005184:	03c9      	lsls	r1, r1, #15
 8005186:	430a      	orrs	r2, r1
 8005188:	795b      	ldrb	r3, [r3, #5]
 800518a:	05db      	lsls	r3, r3, #23
 800518c:	4313      	orrs	r3, r2
 800518e:	60fb      	str	r3, [r7, #12]
    }

    if (shared_get_parameters(&shared_app_descriptor)->canbus_disable_auto_baud) {
 8005190:	4823      	ldr	r0, [pc, #140]	; (8005220 <_local_ctor_37+0xec>)
 8005192:	f003 faef 	bl	8008774 <shared_get_parameters>
 8005196:	4603      	mov	r3, r0
 8005198:	789b      	ldrb	r3, [r3, #2]
 800519a:	f003 0301 	and.w	r3, r3, #1
 800519e:	b2db      	uxtb	r3, r3
 80051a0:	2b00      	cmp	r3, #0
 80051a2:	d001      	beq.n	80051a8 <_local_ctor_37+0x74>
        canbus_autobaud_enable = false;
 80051a4:	2300      	movs	r3, #0
 80051a6:	72fb      	strb	r3, [r7, #11]
        canbus_baud = boot_msg.canbus_info.baudrate;
        canbus_autobaud_enable = false;
    }
#endif

    for (uint8_t i=0; i<LEN(valid_baudrates); i++) {
 80051a8:	2300      	movs	r3, #0
 80051aa:	72bb      	strb	r3, [r7, #10]
 80051ac:	e00d      	b.n	80051ca <_local_ctor_37+0x96>
        if (canbus_baud == valid_baudrates[i]) {
 80051ae:	7abb      	ldrb	r3, [r7, #10]
 80051b0:	4a1c      	ldr	r2, [pc, #112]	; (8005224 <_local_ctor_37+0xf0>)
 80051b2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80051b6:	68fb      	ldr	r3, [r7, #12]
 80051b8:	429a      	cmp	r2, r3
 80051ba:	d103      	bne.n	80051c4 <_local_ctor_37+0x90>
            baudrate_idx = i;
 80051bc:	4a1a      	ldr	r2, [pc, #104]	; (8005228 <_local_ctor_37+0xf4>)
 80051be:	7abb      	ldrb	r3, [r7, #10]
 80051c0:	7013      	strb	r3, [r2, #0]
 80051c2:	e005      	b.n	80051d0 <_local_ctor_37+0x9c>
        canbus_baud = boot_msg.canbus_info.baudrate;
        canbus_autobaud_enable = false;
    }
#endif

    for (uint8_t i=0; i<LEN(valid_baudrates); i++) {
 80051c4:	7abb      	ldrb	r3, [r7, #10]
 80051c6:	3301      	adds	r3, #1
 80051c8:	72bb      	strb	r3, [r7, #10]
 80051ca:	7abb      	ldrb	r3, [r7, #10]
 80051cc:	2b03      	cmp	r3, #3
 80051ce:	d9ee      	bls.n	80051ae <_local_ctor_37+0x7a>
            baudrate_idx = i;
            break;
        }
    }

    struct can_instance_s* can_instance = NULL;
 80051d0:	2300      	movs	r3, #0
 80051d2:	607b      	str	r3, [r7, #4]
 80051d4:	e007      	b.n	80051e6 <_local_ctor_37+0xb2>
    while (can_iterate_instances(&can_instance)) {
        can_start(can_instance, canbus_autobaud_enable, true, canbus_baud);
 80051d6:	687a      	ldr	r2, [r7, #4]
 80051d8:	7afb      	ldrb	r3, [r7, #11]
 80051da:	4610      	mov	r0, r2
 80051dc:	4619      	mov	r1, r3
 80051de:	2201      	movs	r2, #1
 80051e0:	68fb      	ldr	r3, [r7, #12]
 80051e2:	f001 ff29 	bl	8007038 <can_start>
            break;
        }
    }

    struct can_instance_s* can_instance = NULL;
    while (can_iterate_instances(&can_instance)) {
 80051e6:	1d3b      	adds	r3, r7, #4
 80051e8:	4618      	mov	r0, r3
 80051ea:	f001 fe15 	bl	8006e18 <can_iterate_instances>
 80051ee:	4603      	mov	r3, r0
 80051f0:	2b00      	cmp	r3, #0
 80051f2:	d1f0      	bne.n	80051d6 <_local_ctor_37+0xa2>
        can_start(can_instance, canbus_autobaud_enable, true, canbus_baud);
    }

    if (canbus_autobaud_enable) {
 80051f4:	7afb      	ldrb	r3, [r7, #11]
 80051f6:	2b00      	cmp	r3, #0
 80051f8:	d00c      	beq.n	8005214 <_local_ctor_37+0xe0>
        worker_thread_add_timer_task(&WT, &autobaud_timer_task, autobaud_timer_task_func, NULL, LL_US2ST(CAN_AUTOBAUD_SWITCH_INTERVAL_US), false);
 80051fa:	4808      	ldr	r0, [pc, #32]	; (800521c <_local_ctor_37+0xe8>)
 80051fc:	f7ff ff18 	bl	8005030 <LL_US2ST.lto_priv.55>
 8005200:	4603      	mov	r3, r0
 8005202:	9300      	str	r3, [sp, #0]
 8005204:	2300      	movs	r3, #0
 8005206:	9301      	str	r3, [sp, #4]
 8005208:	4808      	ldr	r0, [pc, #32]	; (800522c <_local_ctor_37+0xf8>)
 800520a:	4909      	ldr	r1, [pc, #36]	; (8005230 <_local_ctor_37+0xfc>)
 800520c:	4a09      	ldr	r2, [pc, #36]	; (8005234 <_local_ctor_37+0x100>)
 800520e:	2300      	movs	r3, #0
 8005210:	f002 fe4e 	bl	8007eb0 <worker_thread_add_timer_task>
    }
}
 8005214:	3710      	adds	r7, #16
 8005216:	46bd      	mov	sp, r7
 8005218:	bd80      	pop	{r7, pc}
 800521a:	bf00      	nop
 800521c:	000f4240 	.word	0x000f4240
 8005220:	08003160 	.word	0x08003160
 8005224:	0800d1d4 	.word	0x0800d1d4
 8005228:	200013e8 	.word	0x200013e8
 800522c:	20000a20 	.word	0x20000a20
 8005230:	200013ec 	.word	0x200013ec
 8005234:	08005239 	.word	0x08005239

08005238 <autobaud_timer_task_func>:

static void autobaud_timer_task_func(struct worker_thread_timer_task_s* task) {
 8005238:	b580      	push	{r7, lr}
 800523a:	b084      	sub	sp, #16
 800523c:	af00      	add	r7, sp, #0
 800523e:	6078      	str	r0, [r7, #4]
    baudrate_idx = (baudrate_idx + 1) % LEN(valid_baudrates);
 8005240:	4b20      	ldr	r3, [pc, #128]	; (80052c4 <autobaud_timer_task_func+0x8c>)
 8005242:	781b      	ldrb	r3, [r3, #0]
 8005244:	3301      	adds	r3, #1
 8005246:	b2db      	uxtb	r3, r3
 8005248:	f003 0303 	and.w	r3, r3, #3
 800524c:	b2da      	uxtb	r2, r3
 800524e:	4b1d      	ldr	r3, [pc, #116]	; (80052c4 <autobaud_timer_task_func+0x8c>)
 8005250:	701a      	strb	r2, [r3, #0]

    bool autobaud_complete = true;
 8005252:	2301      	movs	r3, #1
 8005254:	73fb      	strb	r3, [r7, #15]
    struct can_instance_s* can_instance = NULL;
 8005256:	2300      	movs	r3, #0
 8005258:	60bb      	str	r3, [r7, #8]
 800525a:	e019      	b.n	8005290 <autobaud_timer_task_func+0x58>
    while (can_iterate_instances(&can_instance)) {
        if (can_get_baudrate_confirmed(can_instance)) {
 800525c:	68bb      	ldr	r3, [r7, #8]
 800525e:	4618      	mov	r0, r3
 8005260:	f001 fea0 	bl	8006fa4 <can_get_baudrate_confirmed>
 8005264:	4603      	mov	r3, r0
 8005266:	2b00      	cmp	r3, #0
 8005268:	d005      	beq.n	8005276 <autobaud_timer_task_func+0x3e>
            can_set_silent_mode(can_instance, false);
 800526a:	68bb      	ldr	r3, [r7, #8]
 800526c:	4618      	mov	r0, r3
 800526e:	2100      	movs	r1, #0
 8005270:	f001 fe32 	bl	8006ed8 <can_set_silent_mode>
 8005274:	e00c      	b.n	8005290 <autobaud_timer_task_func+0x58>
        } else {
            can_set_baudrate(can_instance, valid_baudrates[baudrate_idx]);
 8005276:	68ba      	ldr	r2, [r7, #8]
 8005278:	4b12      	ldr	r3, [pc, #72]	; (80052c4 <autobaud_timer_task_func+0x8c>)
 800527a:	781b      	ldrb	r3, [r3, #0]
 800527c:	4619      	mov	r1, r3
 800527e:	4b12      	ldr	r3, [pc, #72]	; (80052c8 <autobaud_timer_task_func+0x90>)
 8005280:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8005284:	4610      	mov	r0, r2
 8005286:	4619      	mov	r1, r3
 8005288:	f001 fe6a 	bl	8006f60 <can_set_baudrate>
            autobaud_complete = false;
 800528c:	2300      	movs	r3, #0
 800528e:	73fb      	strb	r3, [r7, #15]
static void autobaud_timer_task_func(struct worker_thread_timer_task_s* task) {
    baudrate_idx = (baudrate_idx + 1) % LEN(valid_baudrates);

    bool autobaud_complete = true;
    struct can_instance_s* can_instance = NULL;
    while (can_iterate_instances(&can_instance)) {
 8005290:	f107 0308 	add.w	r3, r7, #8
 8005294:	4618      	mov	r0, r3
 8005296:	f001 fdbf 	bl	8006e18 <can_iterate_instances>
 800529a:	4603      	mov	r3, r0
 800529c:	2b00      	cmp	r3, #0
 800529e:	d1dd      	bne.n	800525c <autobaud_timer_task_func+0x24>
            can_set_baudrate(can_instance, valid_baudrates[baudrate_idx]);
            autobaud_complete = false;
        }
    }

    if (!autobaud_complete) {
 80052a0:	7bfb      	ldrb	r3, [r7, #15]
 80052a2:	f083 0301 	eor.w	r3, r3, #1
 80052a6:	b2db      	uxtb	r3, r3
 80052a8:	2b00      	cmp	r3, #0
 80052aa:	d008      	beq.n	80052be <autobaud_timer_task_func+0x86>
        worker_thread_timer_task_reschedule(&WT, task, LL_US2ST(CAN_AUTOBAUD_SWITCH_INTERVAL_US));
 80052ac:	4807      	ldr	r0, [pc, #28]	; (80052cc <autobaud_timer_task_func+0x94>)
 80052ae:	f7ff febf 	bl	8005030 <LL_US2ST.lto_priv.55>
 80052b2:	4603      	mov	r3, r0
 80052b4:	4806      	ldr	r0, [pc, #24]	; (80052d0 <autobaud_timer_task_func+0x98>)
 80052b6:	6879      	ldr	r1, [r7, #4]
 80052b8:	461a      	mov	r2, r3
 80052ba:	f002 fe49 	bl	8007f50 <worker_thread_timer_task_reschedule>
    }
}
 80052be:	3710      	adds	r7, #16
 80052c0:	46bd      	mov	sp, r7
 80052c2:	bd80      	pop	{r7, pc}
 80052c4:	200013e8 	.word	0x200013e8
 80052c8:	0800d1d4 	.word	0x0800d1d4
 80052cc:	000f4240 	.word	0x000f4240
 80052d0:	20000a20 	.word	0x20000a20

080052d4 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80052d4:	b480      	push	{r7}
 80052d6:	b083      	sub	sp, #12
 80052d8:	af00      	add	r7, sp, #0
 80052da:	2320      	movs	r3, #32
 80052dc:	607b      	str	r3, [r7, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80052de:	687b      	ldr	r3, [r7, #4]
 80052e0:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80052e4:	370c      	adds	r7, #12
 80052e6:	46bd      	mov	sp, r7
 80052e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80052ec:	4770      	bx	lr
 80052ee:	bf00      	nop

080052f0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80052f0:	b480      	push	{r7}
 80052f2:	b083      	sub	sp, #12
 80052f4:	af00      	add	r7, sp, #0
 80052f6:	2300      	movs	r3, #0
 80052f8:	607b      	str	r3, [r7, #4]
 80052fa:	687b      	ldr	r3, [r7, #4]
 80052fc:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005300:	370c      	adds	r7, #12
 8005302:	46bd      	mov	sp, r7
 8005304:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005308:	4770      	bx	lr
 800530a:	bf00      	nop

0800530c <chSysLock.lto_priv.62>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800530c:	b580      	push	{r7, lr}
 800530e:	af00      	add	r7, sp, #0

  port_lock();
 8005310:	f7ff ffe0 	bl	80052d4 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005314:	f004 fbc0 	bl	8009a98 <_dbg_check_lock>
}
 8005318:	bd80      	pop	{r7, pc}
 800531a:	bf00      	nop

0800531c <chSysUnlock.lto_priv.59>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800531c:	b580      	push	{r7, lr}
 800531e:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8005320:	f004 fbd0 	bl	8009ac4 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005324:	4b09      	ldr	r3, [pc, #36]	; (800534c <chSysUnlock.lto_priv.59+0x30>)
 8005326:	681b      	ldr	r3, [r3, #0]
 8005328:	4a08      	ldr	r2, [pc, #32]	; (800534c <chSysUnlock.lto_priv.59+0x30>)
 800532a:	4293      	cmp	r3, r2
 800532c:	d00a      	beq.n	8005344 <chSysUnlock.lto_priv.59+0x28>
 800532e:	4b07      	ldr	r3, [pc, #28]	; (800534c <chSysUnlock.lto_priv.59+0x30>)
 8005330:	699b      	ldr	r3, [r3, #24]
 8005332:	689a      	ldr	r2, [r3, #8]
 8005334:	4b05      	ldr	r3, [pc, #20]	; (800534c <chSysUnlock.lto_priv.59+0x30>)
 8005336:	681b      	ldr	r3, [r3, #0]
 8005338:	689b      	ldr	r3, [r3, #8]
 800533a:	429a      	cmp	r2, r3
 800533c:	d202      	bcs.n	8005344 <chSysUnlock.lto_priv.59+0x28>
 800533e:	4804      	ldr	r0, [pc, #16]	; (8005350 <chSysUnlock.lto_priv.59+0x34>)
 8005340:	f004 fb5c 	bl	80099fc <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8005344:	f7ff ffd4 	bl	80052f0 <port_unlock>
}
 8005348:	bd80      	pop	{r7, pc}
 800534a:	bf00      	nop
 800534c:	20001330 	.word	0x20001330
 8005350:	0800d1fc 	.word	0x0800d1fc

08005354 <LL_US2ST.lto_priv.56>:
 * @param[in] usec      number of microseconds
 * @return              The number of ticks.
 *
 * @api
 */
static inline systime_t LL_US2ST(unsigned int usec) {
 8005354:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8005358:	b086      	sub	sp, #24
 800535a:	af00      	add	r7, sp, #0
 800535c:	60f8      	str	r0, [r7, #12]
  uint64_t ticks = (((uint64_t)usec * (uint64_t)CH_CFG_ST_FREQUENCY) + 999999ULL)
 800535e:	68f9      	ldr	r1, [r7, #12]
 8005360:	460c      	mov	r4, r1
 8005362:	f04f 0500 	mov.w	r5, #0
 8005366:	4620      	mov	r0, r4
 8005368:	4629      	mov	r1, r5
 800536a:	ea4f 0b81 	mov.w	fp, r1, lsl #2
 800536e:	ea4b 7b90 	orr.w	fp, fp, r0, lsr #30
 8005372:	ea4f 0a80 	mov.w	sl, r0, lsl #2
 8005376:	4650      	mov	r0, sl
 8005378:	4659      	mov	r1, fp
 800537a:	014b      	lsls	r3, r1, #5
 800537c:	ea43 63d0 	orr.w	r3, r3, r0, lsr #27
 8005380:	0142      	lsls	r2, r0, #5
 8005382:	1a12      	subs	r2, r2, r0
 8005384:	eb63 0301 	sbc.w	r3, r3, r1
 8005388:	18a4      	adds	r4, r4, r2
 800538a:	eb45 0503 	adc.w	r5, r5, r3
 800538e:	4622      	mov	r2, r4
 8005390:	462b      	mov	r3, r5
 8005392:	0099      	lsls	r1, r3, #2
 8005394:	6079      	str	r1, [r7, #4]
 8005396:	6879      	ldr	r1, [r7, #4]
 8005398:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
 800539c:	6079      	str	r1, [r7, #4]
 800539e:	0091      	lsls	r1, r2, #2
 80053a0:	6039      	str	r1, [r7, #0]
 80053a2:	e9d7 0100 	ldrd	r0, r1, [r7]
 80053a6:	1880      	adds	r0, r0, r2
 80053a8:	eb41 0103 	adc.w	r1, r1, r3
 80053ac:	4602      	mov	r2, r0
 80053ae:	460b      	mov	r3, r1
 80053b0:	ea4f 1903 	mov.w	r9, r3, lsl #4
 80053b4:	ea49 7912 	orr.w	r9, r9, r2, lsr #28
 80053b8:	ea4f 1802 	mov.w	r8, r2, lsl #4
 80053bc:	4642      	mov	r2, r8
 80053be:	464b      	mov	r3, r9
 80053c0:	4610      	mov	r0, r2
 80053c2:	4619      	mov	r1, r3
 80053c4:	4a11      	ldr	r2, [pc, #68]	; (800540c <LL_US2ST.lto_priv.56+0xb8>)
 80053c6:	f04f 0300 	mov.w	r3, #0
 80053ca:	1812      	adds	r2, r2, r0
 80053cc:	eb43 0301 	adc.w	r3, r3, r1
 80053d0:	4610      	mov	r0, r2
 80053d2:	4619      	mov	r1, r3
 80053d4:	4a0e      	ldr	r2, [pc, #56]	; (8005410 <LL_US2ST.lto_priv.56+0xbc>)
 80053d6:	f04f 0300 	mov.w	r3, #0
 80053da:	f7fd ff95 	bl	8003308 <__aeabi_uldivmod>
 80053de:	4602      	mov	r2, r0
 80053e0:	460b      	mov	r3, r1
 80053e2:	e9c7 2304 	strd	r2, r3, [r7, #16]
                   / 1000000ULL;

  chDbgAssert(ticks <= (uint64_t)TIME_MAXIMUM, "conversion overflow");
 80053e6:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 80053ea:	f64f 70fe 	movw	r0, #65534	; 0xfffe
 80053ee:	f04f 0100 	mov.w	r1, #0
 80053f2:	4299      	cmp	r1, r3
 80053f4:	bf08      	it	eq
 80053f6:	4290      	cmpeq	r0, r2
 80053f8:	d202      	bcs.n	8005400 <LL_US2ST.lto_priv.56+0xac>
 80053fa:	4806      	ldr	r0, [pc, #24]	; (8005414 <LL_US2ST.lto_priv.56+0xc0>)
 80053fc:	f004 fafe 	bl	80099fc <chSysHalt>

  return (systime_t)ticks;
 8005400:	8a3b      	ldrh	r3, [r7, #16]
}
 8005402:	4618      	mov	r0, r3
 8005404:	3718      	adds	r7, #24
 8005406:	46bd      	mov	sp, r7
 8005408:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 800540c:	000f423f 	.word	0x000f423f
 8005410:	000f4240 	.word	0x000f4240
 8005414:	0800d1f0 	.word	0x0800d1f0

08005418 <chCoreAllocAlignedI.lto_priv.3>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8005418:	b580      	push	{r7, lr}
 800541a:	b082      	sub	sp, #8
 800541c:	af00      	add	r7, sp, #0
 800541e:	6078      	str	r0, [r7, #4]
 8005420:	6039      	str	r1, [r7, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8005422:	6878      	ldr	r0, [r7, #4]
 8005424:	6839      	ldr	r1, [r7, #0]
 8005426:	2200      	movs	r2, #0
 8005428:	f003 fb14 	bl	8008a54 <chCoreAllocAlignedWithOffsetI>
 800542c:	4603      	mov	r3, r0
}
 800542e:	4618      	mov	r0, r3
 8005430:	3708      	adds	r7, #8
 8005432:	46bd      	mov	sp, r7
 8005434:	bd80      	pop	{r7, pc}
 8005436:	bf00      	nop

08005438 <chCoreAlloc.lto_priv.54>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
static inline void *chCoreAlloc(size_t size) {
 8005438:	b580      	push	{r7, lr}
 800543a:	b082      	sub	sp, #8
 800543c:	af00      	add	r7, sp, #0
 800543e:	6078      	str	r0, [r7, #4]

  return chCoreAllocAlignedWithOffset(size, PORT_NATURAL_ALIGN, 0U);
 8005440:	6878      	ldr	r0, [r7, #4]
 8005442:	2104      	movs	r1, #4
 8005444:	2200      	movs	r2, #0
 8005446:	f003 fb49 	bl	8008adc <chCoreAllocAlignedWithOffset>
 800544a:	4603      	mov	r3, r0
}
 800544c:	4618      	mov	r0, r3
 800544e:	3708      	adds	r7, #8
 8005450:	46bd      	mov	sp, r7
 8005452:	bd80      	pop	{r7, pc}

08005454 <_local_ctor_100>:
#ifdef MODULE_PARAM_ENABLED
#include <modules/param/param.h>
PARAM_DEFINE_UINT8_PARAM_STATIC(node_id_param, "uavcan.node_id", 0, 0, 125)
#endif

RUN_ON(UAVCAN_INIT) {
 8005454:	b580      	push	{r7, lr}
 8005456:	b082      	sub	sp, #8
 8005458:	af02      	add	r7, sp, #8
    uavcan_init(0);
 800545a:	2000      	movs	r0, #0
 800545c:	f000 f818 	bl	8005490 <uavcan_init>

    worker_thread_add_timer_task(&WT_RX, &stale_transfer_cleanup_task, stale_transfer_cleanup_task_func, NULL, LL_US2ST(CANARD_RECOMMENDED_STALE_TRANSFER_CLEANUP_INTERVAL_USEC), true);
 8005460:	4807      	ldr	r0, [pc, #28]	; (8005480 <_local_ctor_100+0x2c>)
 8005462:	f7ff ff77 	bl	8005354 <LL_US2ST.lto_priv.56>
 8005466:	4603      	mov	r3, r0
 8005468:	9300      	str	r3, [sp, #0]
 800546a:	2301      	movs	r3, #1
 800546c:	9301      	str	r3, [sp, #4]
 800546e:	4805      	ldr	r0, [pc, #20]	; (8005484 <_local_ctor_100+0x30>)
 8005470:	4905      	ldr	r1, [pc, #20]	; (8005488 <_local_ctor_100+0x34>)
 8005472:	4a06      	ldr	r2, [pc, #24]	; (800548c <_local_ctor_100+0x38>)
 8005474:	2300      	movs	r3, #0
 8005476:	f002 fd1b 	bl	8007eb0 <worker_thread_add_timer_task>
}
 800547a:	46bd      	mov	sp, r7
 800547c:	bd80      	pop	{r7, pc}
 800547e:	bf00      	nop
 8005480:	000f4240 	.word	0x000f4240
 8005484:	20000a3c 	.word	0x20000a3c
 8005488:	20001400 	.word	0x20001400
 800548c:	08003d75 	.word	0x08003d75

08005490 <uavcan_init>:

static void uavcan_init(uint8_t can_dev_idx) {
 8005490:	b580      	push	{r7, lr}
 8005492:	b08c      	sub	sp, #48	; 0x30
 8005494:	af02      	add	r7, sp, #8
 8005496:	4603      	mov	r3, r0
 8005498:	71fb      	strb	r3, [r7, #7]
    struct uavcan_instance_s* instance;
    struct can_instance_s* can_instance;
    void* transfer_id_map_working_area;

    if (!(can_instance = can_get_instance(can_dev_idx))) { goto fail; }
 800549a:	79fb      	ldrb	r3, [r7, #7]
 800549c:	4618      	mov	r0, r3
 800549e:	f001 fce3 	bl	8006e68 <can_get_instance>
 80054a2:	61f8      	str	r0, [r7, #28]
 80054a4:	69fb      	ldr	r3, [r7, #28]
 80054a6:	2b00      	cmp	r3, #0
 80054a8:	f000 808a 	beq.w	80055c0 <uavcan_init+0x130>
    if (!(instance = chCoreAlloc(sizeof(struct uavcan_instance_s)))) { goto fail; }
 80054ac:	2074      	movs	r0, #116	; 0x74
 80054ae:	f7ff ffc3 	bl	8005438 <chCoreAlloc.lto_priv.54>
 80054b2:	61b8      	str	r0, [r7, #24]
 80054b4:	69bb      	ldr	r3, [r7, #24]
 80054b6:	2b00      	cmp	r3, #0
 80054b8:	f000 8082 	beq.w	80055c0 <uavcan_init+0x130>
    memset(instance, 0, sizeof(struct uavcan_instance_s));
 80054bc:	69b8      	ldr	r0, [r7, #24]
 80054be:	2100      	movs	r1, #0
 80054c0:	2274      	movs	r2, #116	; 0x74
 80054c2:	f007 fbbb 	bl	800cc3c <memset>
    instance->can_instance = can_instance;
 80054c6:	69bb      	ldr	r3, [r7, #24]
 80054c8:	69fa      	ldr	r2, [r7, #28]
 80054ca:	605a      	str	r2, [r3, #4]
    if (!(transfer_id_map_working_area = chCoreAlloc(UAVCAN_TRANSFER_ID_MAP_WORKING_AREA_SIZE))) { goto fail; }
 80054cc:	2080      	movs	r0, #128	; 0x80
 80054ce:	f7ff ffb3 	bl	8005438 <chCoreAlloc.lto_priv.54>
 80054d2:	6178      	str	r0, [r7, #20]
 80054d4:	697b      	ldr	r3, [r7, #20]
 80054d6:	2b00      	cmp	r3, #0
 80054d8:	d072      	beq.n	80055c0 <uavcan_init+0x130>
    uavcan_transfer_id_map_init(&instance->transfer_id_map, UAVCAN_TRANSFER_ID_MAP_WORKING_AREA_SIZE, transfer_id_map_working_area);
 80054da:	69bb      	ldr	r3, [r7, #24]
 80054dc:	3330      	adds	r3, #48	; 0x30
 80054de:	4618      	mov	r0, r3
 80054e0:	2180      	movs	r1, #128	; 0x80
 80054e2:	697a      	ldr	r2, [r7, #20]
 80054e4:	f7fe fdca 	bl	800407c <uavcan_transfer_id_map_init.lto_priv.74>
    if(!(instance->canard_memory_pool = chCoreAlloc(UAVCAN_CANARD_MEMORY_POOL_SIZE))) { goto fail; }
 80054e8:	f44f 7040 	mov.w	r0, #768	; 0x300
 80054ec:	f7ff ffa4 	bl	8005438 <chCoreAlloc.lto_priv.54>
 80054f0:	4602      	mov	r2, r0
 80054f2:	69bb      	ldr	r3, [r7, #24]
 80054f4:	62da      	str	r2, [r3, #44]	; 0x2c
 80054f6:	69bb      	ldr	r3, [r7, #24]
 80054f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80054fa:	2b00      	cmp	r3, #0
 80054fc:	d060      	beq.n	80055c0 <uavcan_init+0x130>
    canardInit(&instance->canard, instance->canard_memory_pool, UAVCAN_CANARD_MEMORY_POOL_SIZE, uavcan_on_transfer_rx, uavcan_should_accept_transfer, instance);
 80054fe:	69bb      	ldr	r3, [r7, #24]
 8005500:	f103 0108 	add.w	r1, r3, #8
 8005504:	69bb      	ldr	r3, [r7, #24]
 8005506:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005508:	4b30      	ldr	r3, [pc, #192]	; (80055cc <uavcan_init+0x13c>)
 800550a:	9300      	str	r3, [sp, #0]
 800550c:	69bb      	ldr	r3, [r7, #24]
 800550e:	9301      	str	r3, [sp, #4]
 8005510:	4608      	mov	r0, r1
 8005512:	4611      	mov	r1, r2
 8005514:	f44f 7240 	mov.w	r2, #768	; 0x300
 8005518:	4b2d      	ldr	r3, [pc, #180]	; (80055d0 <uavcan_init+0x140>)
 800551a:	f005 ff09 	bl	800b330 <canardInit>
    struct pubsub_topic_s* can_rx_topic = can_get_rx_topic(instance->can_instance);
 800551e:	69bb      	ldr	r3, [r7, #24]
 8005520:	685b      	ldr	r3, [r3, #4]
 8005522:	4618      	mov	r0, r3
 8005524:	f001 fcc0 	bl	8006ea8 <can_get_rx_topic>
 8005528:	6138      	str	r0, [r7, #16]
    if (!can_rx_topic) { goto fail; }
 800552a:	693b      	ldr	r3, [r7, #16]
 800552c:	2b00      	cmp	r3, #0
 800552e:	d047      	beq.n	80055c0 <uavcan_init+0x130>
    worker_thread_add_listener_task(&WT_RX, &instance->rx_listener_task, can_rx_topic, uavcan_can_rx_handler, instance); // TODO configurable thread
 8005530:	69bb      	ldr	r3, [r7, #24]
 8005532:	f103 0238 	add.w	r2, r3, #56	; 0x38
 8005536:	69bb      	ldr	r3, [r7, #24]
 8005538:	9300      	str	r3, [sp, #0]
 800553a:	4826      	ldr	r0, [pc, #152]	; (80055d4 <uavcan_init+0x144>)
 800553c:	4611      	mov	r1, r2
 800553e:	693a      	ldr	r2, [r7, #16]
 8005540:	4b25      	ldr	r3, [pc, #148]	; (80055d8 <uavcan_init+0x148>)
 8005542:	f002 fd63 	bl	800800c <worker_thread_add_listener_task>

    can_set_auto_retransmit_mode(instance->can_instance, false);
 8005546:	69bb      	ldr	r3, [r7, #24]
 8005548:	685b      	ldr	r3, [r3, #4]
 800554a:	4618      	mov	r0, r3
 800554c:	2100      	movs	r1, #0
 800554e:	f001 fce5 	bl	8006f1c <can_set_auto_retransmit_mode>

    LINKED_LIST_APPEND(struct uavcan_instance_s, uavcan_instance_list_head, instance);
 8005552:	69bb      	ldr	r3, [r7, #24]
 8005554:	2200      	movs	r2, #0
 8005556:	671a      	str	r2, [r3, #112]	; 0x70
 8005558:	4b20      	ldr	r3, [pc, #128]	; (80055dc <uavcan_init+0x14c>)
 800555a:	627b      	str	r3, [r7, #36]	; 0x24
 800555c:	e003      	b.n	8005566 <uavcan_init+0xd6>
 800555e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005560:	681b      	ldr	r3, [r3, #0]
 8005562:	3370      	adds	r3, #112	; 0x70
 8005564:	627b      	str	r3, [r7, #36]	; 0x24
 8005566:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005568:	681b      	ldr	r3, [r3, #0]
 800556a:	2b00      	cmp	r3, #0
 800556c:	d1f7      	bne.n	800555e <uavcan_init+0xce>
 800556e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005570:	69ba      	ldr	r2, [r7, #24]
 8005572:	601a      	str	r2, [r3, #0]

    instance->idx = uavcan_get_idx(instance);
 8005574:	69b8      	ldr	r0, [r7, #24]
 8005576:	f7fe fc59 	bl	8003e2c <uavcan_get_idx.lto_priv.73>
 800557a:	4603      	mov	r3, r0
 800557c:	461a      	mov	r2, r3
 800557e:	69bb      	ldr	r3, [r7, #24]
 8005580:	701a      	strb	r2, [r3, #0]

    uint8_t node_id = 0;
 8005582:	2300      	movs	r3, #0
 8005584:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

#ifdef MODULE_APP_DESCRIPTOR_ENABLED
    {
        const struct shared_app_parameters_s* shared_parameters = shared_get_parameters(&shared_app_descriptor);
 8005588:	4815      	ldr	r0, [pc, #84]	; (80055e0 <uavcan_init+0x150>)
 800558a:	f003 f8f3 	bl	8008774 <shared_get_parameters>
 800558e:	60f8      	str	r0, [r7, #12]
        if (shared_parameters && shared_parameters->canbus_local_node_id > 0 && shared_parameters->canbus_local_node_id <= 127) {
 8005590:	68fb      	ldr	r3, [r7, #12]
 8005592:	2b00      	cmp	r3, #0
 8005594:	d00d      	beq.n	80055b2 <uavcan_init+0x122>
 8005596:	68fb      	ldr	r3, [r7, #12]
 8005598:	799b      	ldrb	r3, [r3, #6]
 800559a:	2b00      	cmp	r3, #0
 800559c:	d009      	beq.n	80055b2 <uavcan_init+0x122>
 800559e:	68fb      	ldr	r3, [r7, #12]
 80055a0:	799b      	ldrb	r3, [r3, #6]
 80055a2:	b2db      	uxtb	r3, r3
 80055a4:	b25b      	sxtb	r3, r3
 80055a6:	2b00      	cmp	r3, #0
 80055a8:	db03      	blt.n	80055b2 <uavcan_init+0x122>
            node_id = shared_parameters->canbus_local_node_id;
 80055aa:	68fb      	ldr	r3, [r7, #12]
 80055ac:	799b      	ldrb	r3, [r3, #6]
 80055ae:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    if (node_id_param != 0) {
        node_id = node_id_param;
    }
#endif

    _uavcan_set_node_id(instance, node_id);
 80055b2:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 80055b6:	69b8      	ldr	r0, [r7, #24]
 80055b8:	4619      	mov	r1, r3
 80055ba:	f000 f8df 	bl	800577c <_uavcan_set_node_id>
 80055be:	e002      	b.n	80055c6 <uavcan_init+0x136>

    return;

fail:
    chSysHalt(NULL);
 80055c0:	2000      	movs	r0, #0
 80055c2:	f004 fa1b 	bl	80099fc <chSysHalt>
}
 80055c6:	3728      	adds	r7, #40	; 0x28
 80055c8:	46bd      	mov	sp, r7
 80055ca:	bd80      	pop	{r7, pc}
 80055cc:	08003ff1 	.word	0x08003ff1
 80055d0:	08003f5d 	.word	0x08003f5d
 80055d4:	20000a3c 	.word	0x20000a3c
 80055d8:	08005d85 	.word	0x08005d85
 80055dc:	20001414 	.word	0x20001414
 80055e0:	08003160 	.word	0x08003160

080055e4 <uavcan_iterate_instances.lto_priv.47>:

static bool uavcan_iterate_instances(struct uavcan_instance_s** instance_ptr) {
 80055e4:	b480      	push	{r7}
 80055e6:	b083      	sub	sp, #12
 80055e8:	af00      	add	r7, sp, #0
 80055ea:	6078      	str	r0, [r7, #4]
    if (!instance_ptr) {
 80055ec:	687b      	ldr	r3, [r7, #4]
 80055ee:	2b00      	cmp	r3, #0
 80055f0:	d101      	bne.n	80055f6 <uavcan_iterate_instances.lto_priv.47+0x12>
        return false;
 80055f2:	2300      	movs	r3, #0
 80055f4:	e014      	b.n	8005620 <uavcan_iterate_instances.lto_priv.47+0x3c>
    }

    if (!(*instance_ptr)) {
 80055f6:	687b      	ldr	r3, [r7, #4]
 80055f8:	681b      	ldr	r3, [r3, #0]
 80055fa:	2b00      	cmp	r3, #0
 80055fc:	d104      	bne.n	8005608 <uavcan_iterate_instances.lto_priv.47+0x24>
        *instance_ptr = uavcan_instance_list_head;
 80055fe:	4b0b      	ldr	r3, [pc, #44]	; (800562c <uavcan_iterate_instances.lto_priv.47+0x48>)
 8005600:	681a      	ldr	r2, [r3, #0]
 8005602:	687b      	ldr	r3, [r7, #4]
 8005604:	601a      	str	r2, [r3, #0]
 8005606:	e004      	b.n	8005612 <uavcan_iterate_instances.lto_priv.47+0x2e>
    } else {
        *instance_ptr = (*instance_ptr)->next;
 8005608:	687b      	ldr	r3, [r7, #4]
 800560a:	681b      	ldr	r3, [r3, #0]
 800560c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800560e:	687b      	ldr	r3, [r7, #4]
 8005610:	601a      	str	r2, [r3, #0]
    }

    return *instance_ptr != NULL;
 8005612:	687b      	ldr	r3, [r7, #4]
 8005614:	681b      	ldr	r3, [r3, #0]
 8005616:	2b00      	cmp	r3, #0
 8005618:	bf14      	ite	ne
 800561a:	2301      	movne	r3, #1
 800561c:	2300      	moveq	r3, #0
 800561e:	b2db      	uxtb	r3, r3
}
 8005620:	4618      	mov	r0, r3
 8005622:	370c      	adds	r7, #12
 8005624:	46bd      	mov	sp, r7
 8005626:	f85d 7b04 	ldr.w	r7, [sp], #4
 800562a:	4770      	bx	lr
 800562c:	20001414 	.word	0x20001414

08005630 <_uavcan_get_message_topic>:

static struct pubsub_topic_s* _uavcan_get_message_topic(struct uavcan_instance_s* instance, const struct uavcan_message_descriptor_s* msg_descriptor) {
 8005630:	b580      	push	{r7, lr}
 8005632:	b084      	sub	sp, #16
 8005634:	af00      	add	r7, sp, #0
 8005636:	6078      	str	r0, [r7, #4]
 8005638:	6039      	str	r1, [r7, #0]
    if (!instance) {
 800563a:	687b      	ldr	r3, [r7, #4]
 800563c:	2b00      	cmp	r3, #0
 800563e:	d101      	bne.n	8005644 <_uavcan_get_message_topic+0x14>
        return NULL;
 8005640:	2300      	movs	r3, #0
 8005642:	e042      	b.n	80056ca <_uavcan_get_message_topic+0x9a>
    }

    chSysLock();
 8005644:	f7ff fe62 	bl	800530c <chSysLock.lto_priv.62>

    // attempt to find existing item in receive list
    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
 8005648:	687b      	ldr	r3, [r7, #4]
 800564a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800564c:	60fb      	str	r3, [r7, #12]
 800564e:	e002      	b.n	8005656 <_uavcan_get_message_topic+0x26>
    while (rx_list_item && rx_list_item->msg_descriptor != msg_descriptor) {
        rx_list_item = rx_list_item->next;
 8005650:	68fb      	ldr	r3, [r7, #12]
 8005652:	691b      	ldr	r3, [r3, #16]
 8005654:	60fb      	str	r3, [r7, #12]

    chSysLock();

    // attempt to find existing item in receive list
    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
    while (rx_list_item && rx_list_item->msg_descriptor != msg_descriptor) {
 8005656:	68fb      	ldr	r3, [r7, #12]
 8005658:	2b00      	cmp	r3, #0
 800565a:	d004      	beq.n	8005666 <_uavcan_get_message_topic+0x36>
 800565c:	68fb      	ldr	r3, [r7, #12]
 800565e:	681a      	ldr	r2, [r3, #0]
 8005660:	683b      	ldr	r3, [r7, #0]
 8005662:	429a      	cmp	r2, r3
 8005664:	d1f4      	bne.n	8005650 <_uavcan_get_message_topic+0x20>
        rx_list_item = rx_list_item->next;
    }

    if (rx_list_item) {
 8005666:	68fb      	ldr	r3, [r7, #12]
 8005668:	2b00      	cmp	r3, #0
 800566a:	d004      	beq.n	8005676 <_uavcan_get_message_topic+0x46>
        chSysUnlock();
 800566c:	f7ff fe56 	bl	800531c <chSysUnlock.lto_priv.59>
        return &rx_list_item->topic;
 8005670:	68fb      	ldr	r3, [r7, #12]
 8005672:	3304      	adds	r3, #4
 8005674:	e029      	b.n	80056ca <_uavcan_get_message_topic+0x9a>
    }

    // create new item in receive list
    rx_list_item = chPoolAllocI(&rx_list_pool);
 8005676:	4817      	ldr	r0, [pc, #92]	; (80056d4 <_uavcan_get_message_topic+0xa4>)
 8005678:	f003 fae4 	bl	8008c44 <chPoolAllocI>
 800567c:	60f8      	str	r0, [r7, #12]
    if (!rx_list_item) {
 800567e:	68fb      	ldr	r3, [r7, #12]
 8005680:	2b00      	cmp	r3, #0
 8005682:	d103      	bne.n	800568c <_uavcan_get_message_topic+0x5c>
        chSysUnlock();
 8005684:	f7ff fe4a 	bl	800531c <chSysUnlock.lto_priv.59>
        return NULL;
 8005688:	2300      	movs	r3, #0
 800568a:	e01e      	b.n	80056ca <_uavcan_get_message_topic+0x9a>
    }

    // populate it
    rx_list_item->msg_descriptor = msg_descriptor;
 800568c:	68fb      	ldr	r3, [r7, #12]
 800568e:	683a      	ldr	r2, [r7, #0]
 8005690:	601a      	str	r2, [r3, #0]
    pubsub_init_topic(&rx_list_item->topic, NULL);
 8005692:	68fb      	ldr	r3, [r7, #12]
 8005694:	3304      	adds	r3, #4
 8005696:	4618      	mov	r0, r3
 8005698:	2100      	movs	r1, #0
 800569a:	f002 f867 	bl	800776c <pubsub_init_topic>

    // append it
    LINKED_LIST_APPEND(struct uavcan_rx_list_item_s, instance->rx_list_head, rx_list_item);
 800569e:	68fb      	ldr	r3, [r7, #12]
 80056a0:	2200      	movs	r2, #0
 80056a2:	611a      	str	r2, [r3, #16]
 80056a4:	687b      	ldr	r3, [r7, #4]
 80056a6:	336c      	adds	r3, #108	; 0x6c
 80056a8:	60bb      	str	r3, [r7, #8]
 80056aa:	e003      	b.n	80056b4 <_uavcan_get_message_topic+0x84>
 80056ac:	68bb      	ldr	r3, [r7, #8]
 80056ae:	681b      	ldr	r3, [r3, #0]
 80056b0:	3310      	adds	r3, #16
 80056b2:	60bb      	str	r3, [r7, #8]
 80056b4:	68bb      	ldr	r3, [r7, #8]
 80056b6:	681b      	ldr	r3, [r3, #0]
 80056b8:	2b00      	cmp	r3, #0
 80056ba:	d1f7      	bne.n	80056ac <_uavcan_get_message_topic+0x7c>
 80056bc:	68bb      	ldr	r3, [r7, #8]
 80056be:	68fa      	ldr	r2, [r7, #12]
 80056c0:	601a      	str	r2, [r3, #0]

    chSysUnlock();
 80056c2:	f7ff fe2b 	bl	800531c <chSysUnlock.lto_priv.59>

    return &rx_list_item->topic;
 80056c6:	68fb      	ldr	r3, [r7, #12]
 80056c8:	3304      	adds	r3, #4
}
 80056ca:	4618      	mov	r0, r3
 80056cc:	3710      	adds	r7, #16
 80056ce:	46bd      	mov	sp, r7
 80056d0:	bd80      	pop	{r7, pc}
 80056d2:	bf00      	nop
 80056d4:	20000a0c 	.word	0x20000a0c

080056d8 <uavcan_get_message_topic>:

struct pubsub_topic_s* uavcan_get_message_topic(uint8_t uavcan_idx, const struct uavcan_message_descriptor_s* msg_descriptor) {
 80056d8:	b580      	push	{r7, lr}
 80056da:	b082      	sub	sp, #8
 80056dc:	af00      	add	r7, sp, #0
 80056de:	4603      	mov	r3, r0
 80056e0:	6039      	str	r1, [r7, #0]
 80056e2:	71fb      	strb	r3, [r7, #7]
    return _uavcan_get_message_topic(uavcan_get_instance(uavcan_idx), msg_descriptor);
 80056e4:	79fb      	ldrb	r3, [r7, #7]
 80056e6:	4618      	mov	r0, r3
 80056e8:	f7fe fb60 	bl	8003dac <uavcan_get_instance.lto_priv.71>
 80056ec:	4603      	mov	r3, r0
 80056ee:	4618      	mov	r0, r3
 80056f0:	6839      	ldr	r1, [r7, #0]
 80056f2:	f7ff ff9d 	bl	8005630 <_uavcan_get_message_topic>
 80056f6:	4603      	mov	r3, r0
}
 80056f8:	4618      	mov	r0, r3
 80056fa:	3708      	adds	r7, #8
 80056fc:	46bd      	mov	sp, r7
 80056fe:	bd80      	pop	{r7, pc}

08005700 <_uavcan_get_message_data_type_id.lto_priv.46>:

static uint16_t _uavcan_get_message_data_type_id(struct uavcan_instance_s* instance, const struct uavcan_message_descriptor_s* msg_descriptor) {
 8005700:	b480      	push	{r7}
 8005702:	b083      	sub	sp, #12
 8005704:	af00      	add	r7, sp, #0
 8005706:	6078      	str	r0, [r7, #4]
 8005708:	6039      	str	r1, [r7, #0]
    (void)instance;

    if (msg_descriptor) {
 800570a:	683b      	ldr	r3, [r7, #0]
 800570c:	2b00      	cmp	r3, #0
 800570e:	d002      	beq.n	8005716 <_uavcan_get_message_data_type_id.lto_priv.46+0x16>
        return msg_descriptor->default_data_type_id;
 8005710:	683b      	ldr	r3, [r7, #0]
 8005712:	891b      	ldrh	r3, [r3, #8]
 8005714:	e000      	b.n	8005718 <_uavcan_get_message_data_type_id.lto_priv.46+0x18>
    } else {
        return 0;
 8005716:	2300      	movs	r3, #0
    }
}
 8005718:	4618      	mov	r0, r3
 800571a:	370c      	adds	r7, #12
 800571c:	46bd      	mov	sp, r7
 800571e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005722:	4770      	bx	lr

08005724 <_uavcan_get_node_id>:

uint16_t uavcan_get_message_data_type_id(uint8_t uavcan_idx, const struct uavcan_message_descriptor_s* msg_descriptor) {
    return _uavcan_get_message_data_type_id(uavcan_get_instance(uavcan_idx), msg_descriptor);
}

static uint8_t _uavcan_get_node_id(struct uavcan_instance_s* instance) {
 8005724:	b580      	push	{r7, lr}
 8005726:	b084      	sub	sp, #16
 8005728:	af00      	add	r7, sp, #0
 800572a:	6078      	str	r0, [r7, #4]
    if (!instance) {
 800572c:	687b      	ldr	r3, [r7, #4]
 800572e:	2b00      	cmp	r3, #0
 8005730:	d101      	bne.n	8005736 <_uavcan_get_node_id+0x12>
        return 0;
 8005732:	2300      	movs	r3, #0
 8005734:	e00b      	b.n	800574e <_uavcan_get_node_id+0x2a>
    }

    chSysLock();
 8005736:	f7ff fde9 	bl	800530c <chSysLock.lto_priv.62>
    uint8_t ret = canardGetLocalNodeID(&instance->canard);
 800573a:	687b      	ldr	r3, [r7, #4]
 800573c:	3308      	adds	r3, #8
 800573e:	4618      	mov	r0, r3
 8005740:	f005 fe52 	bl	800b3e8 <canardGetLocalNodeID>
 8005744:	4603      	mov	r3, r0
 8005746:	73fb      	strb	r3, [r7, #15]
    chSysUnlock();
 8005748:	f7ff fde8 	bl	800531c <chSysUnlock.lto_priv.59>
    return ret;
 800574c:	7bfb      	ldrb	r3, [r7, #15]
}
 800574e:	4618      	mov	r0, r3
 8005750:	3710      	adds	r7, #16
 8005752:	46bd      	mov	sp, r7
 8005754:	bd80      	pop	{r7, pc}
 8005756:	bf00      	nop

08005758 <uavcan_get_node_id>:

uint8_t uavcan_get_node_id(uint8_t uavcan_idx) {
 8005758:	b580      	push	{r7, lr}
 800575a:	b082      	sub	sp, #8
 800575c:	af00      	add	r7, sp, #0
 800575e:	4603      	mov	r3, r0
 8005760:	71fb      	strb	r3, [r7, #7]
    return _uavcan_get_node_id(uavcan_get_instance(uavcan_idx));
 8005762:	79fb      	ldrb	r3, [r7, #7]
 8005764:	4618      	mov	r0, r3
 8005766:	f7fe fb21 	bl	8003dac <uavcan_get_instance.lto_priv.71>
 800576a:	4603      	mov	r3, r0
 800576c:	4618      	mov	r0, r3
 800576e:	f7ff ffd9 	bl	8005724 <_uavcan_get_node_id>
 8005772:	4603      	mov	r3, r0
}
 8005774:	4618      	mov	r0, r3
 8005776:	3708      	adds	r7, #8
 8005778:	46bd      	mov	sp, r7
 800577a:	bd80      	pop	{r7, pc}

0800577c <_uavcan_set_node_id>:

static void _uavcan_set_node_id(struct uavcan_instance_s* instance, uint8_t node_id) {
 800577c:	b580      	push	{r7, lr}
 800577e:	b082      	sub	sp, #8
 8005780:	af00      	add	r7, sp, #0
 8005782:	6078      	str	r0, [r7, #4]
 8005784:	460b      	mov	r3, r1
 8005786:	70fb      	strb	r3, [r7, #3]
    if (!instance) {
 8005788:	687b      	ldr	r3, [r7, #4]
 800578a:	2b00      	cmp	r3, #0
 800578c:	d017      	beq.n	80057be <_uavcan_set_node_id+0x42>
        return;
    }

    can_set_auto_retransmit_mode(instance->can_instance, node_id != 0);
 800578e:	687b      	ldr	r3, [r7, #4]
 8005790:	685a      	ldr	r2, [r3, #4]
 8005792:	78fb      	ldrb	r3, [r7, #3]
 8005794:	2b00      	cmp	r3, #0
 8005796:	bf14      	ite	ne
 8005798:	2301      	movne	r3, #1
 800579a:	2300      	moveq	r3, #0
 800579c:	b2db      	uxtb	r3, r3
 800579e:	4610      	mov	r0, r2
 80057a0:	4619      	mov	r1, r3
 80057a2:	f001 fbbb 	bl	8006f1c <can_set_auto_retransmit_mode>
    chSysLock();
 80057a6:	f7ff fdb1 	bl	800530c <chSysLock.lto_priv.62>
    canardSetLocalNodeID(&instance->canard, node_id);
 80057aa:	687b      	ldr	r3, [r7, #4]
 80057ac:	f103 0208 	add.w	r2, r3, #8
 80057b0:	78fb      	ldrb	r3, [r7, #3]
 80057b2:	4610      	mov	r0, r2
 80057b4:	4619      	mov	r1, r3
 80057b6:	f005 fdfd 	bl	800b3b4 <canardSetLocalNodeID>
    chSysUnlock();
 80057ba:	f7ff fdaf 	bl	800531c <chSysUnlock.lto_priv.59>
}
 80057be:	3708      	adds	r7, #8
 80057c0:	46bd      	mov	sp, r7
 80057c2:	bd80      	pop	{r7, pc}

080057c4 <uavcan_set_node_id>:

void uavcan_set_node_id(uint8_t uavcan_idx, uint8_t node_id) {
 80057c4:	b580      	push	{r7, lr}
 80057c6:	b082      	sub	sp, #8
 80057c8:	af00      	add	r7, sp, #0
 80057ca:	4603      	mov	r3, r0
 80057cc:	460a      	mov	r2, r1
 80057ce:	71fb      	strb	r3, [r7, #7]
 80057d0:	4613      	mov	r3, r2
 80057d2:	71bb      	strb	r3, [r7, #6]
    return _uavcan_set_node_id(uavcan_get_instance(uavcan_idx), node_id);
 80057d4:	79fb      	ldrb	r3, [r7, #7]
 80057d6:	4618      	mov	r0, r3
 80057d8:	f7fe fae8 	bl	8003dac <uavcan_get_instance.lto_priv.71>
 80057dc:	4602      	mov	r2, r0
 80057de:	79bb      	ldrb	r3, [r7, #6]
 80057e0:	4610      	mov	r0, r2
 80057e2:	4619      	mov	r1, r3
 80057e4:	f7ff ffca 	bl	800577c <_uavcan_set_node_id>
}
 80057e8:	3708      	adds	r7, #8
 80057ea:	46bd      	mov	sp, r7
 80057ec:	bd80      	pop	{r7, pc}
 80057ee:	bf00      	nop

080057f0 <copy_bit_array>:

/**
 * Bit array copy routine, originally developed by Ben Dyer for Libuavcan. Thanks Ben.
 */

static void __attribute__((optimize("O3"))) copy_bit_array(const uint8_t* src, uint32_t src_offset, uint32_t src_len, uint8_t* dst, uint32_t dst_offset) {
 80057f0:	e92d 4f70 	stmdb	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}
    // Normalizing inputs
    src += src_offset / 8;
    dst += dst_offset / 8;

    src_offset %= 8;
 80057f4:	f001 0607 	and.w	r6, r1, #7

/**
 * Bit array copy routine, originally developed by Ben Dyer for Libuavcan. Thanks Ben.
 */

static void __attribute__((optimize("O3"))) copy_bit_array(const uint8_t* src, uint32_t src_offset, uint32_t src_len, uint8_t* dst, uint32_t dst_offset) {
 80057f8:	9c08      	ldr	r4, [sp, #32]
    dst += dst_offset / 8;

    src_offset %= 8;
    dst_offset %= 8;

    const size_t last_bit = src_offset + src_len;
 80057fa:	4432      	add	r2, r6
    while (last_bit - src_offset)
 80057fc:	4296      	cmp	r6, r2
 * Bit array copy routine, originally developed by Ben Dyer for Libuavcan. Thanks Ben.
 */

static void __attribute__((optimize("O3"))) copy_bit_array(const uint8_t* src, uint32_t src_offset, uint32_t src_len, uint8_t* dst, uint32_t dst_offset) {
    // Normalizing inputs
    src += src_offset / 8;
 80057fe:	ea4f 01d1 	mov.w	r1, r1, lsr #3
    dst += dst_offset / 8;
 8005802:	ea4f 09d4 	mov.w	r9, r4, lsr #3

    src_offset %= 8;
    dst_offset %= 8;
 8005806:	f004 0c07 	and.w	ip, r4, #7

    const size_t last_bit = src_offset + src_len;
    while (last_bit - src_offset)
 800580a:	d02d      	beq.n	8005868 <copy_bit_array+0x78>
 800580c:	4408      	add	r0, r1
        const uint8_t dst_bit_offset = (uint8_t)(dst_offset % 8U);

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
 800580e:	f44f 417f 	mov.w	r1, #65280	; 0xff00
    dst_offset %= 8;

    const size_t last_bit = src_offset + src_len;
    while (last_bit - src_offset)
    {
        const uint8_t src_bit_offset = (uint8_t)(src_offset % 8U);
 8005812:	f006 0b07 	and.w	fp, r6, #7
        const uint8_t dst_bit_offset = (uint8_t)(dst_offset % 8U);
 8005816:	f00c 0507 	and.w	r5, ip, #7

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);
 800581a:	455d      	cmp	r5, fp
 800581c:	462c      	mov	r4, r5
 800581e:	bf38      	it	cc
 8005820:	465c      	movcc	r4, fp
 8005822:	ebc6 0e02 	rsb	lr, r6, r2
 8005826:	f1c4 0408 	rsb	r4, r4, #8
 800582a:	45a6      	cmp	lr, r4
 800582c:	bf28      	it	cs
 800582e:	46a6      	movcs	lr, r4

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);
 8005830:	08f4      	lsrs	r4, r6, #3
 8005832:	f810 a004 	ldrb.w	sl, [r0, r4]
 8005836:	eb09 08dc 	add.w	r8, r9, ip, lsr #3
        const uint8_t dst_bit_offset = (uint8_t)(dst_offset % 8U);

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
 800583a:	fa21 f40e 	lsr.w	r4, r1, lr
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);
 800583e:	fa0a fa0b 	lsl.w	sl, sl, fp
 8005842:	b2e4      	uxtb	r4, r4

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));
 8005844:	f813 b008 	ldrb.w	fp, [r3, r8]

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);
 8005848:	fa4a fa05 	asr.w	sl, sl, r5
        const uint8_t dst_bit_offset = (uint8_t)(dst_offset % 8U);

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
 800584c:	fa44 f505 	asr.w	r5, r4, r5
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));
 8005850:	ea05 0a0a 	and.w	sl, r5, sl
 8005854:	ea2b 0405 	bic.w	r4, fp, r5

        src_offset += copy_bits;
 8005858:	4476      	add	r6, lr
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));
 800585a:	ea4a 0404 	orr.w	r4, sl, r4

    src_offset %= 8;
    dst_offset %= 8;

    const size_t last_bit = src_offset + src_len;
    while (last_bit - src_offset)
 800585e:	42b2      	cmp	r2, r6
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));

        src_offset += copy_bits;
        dst_offset += copy_bits;
 8005860:	44f4      	add	ip, lr
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));
 8005862:	f803 4008 	strb.w	r4, [r3, r8]

    src_offset %= 8;
    dst_offset %= 8;

    const size_t last_bit = src_offset + src_len;
    while (last_bit - src_offset)
 8005866:	d1d4      	bne.n	8005812 <copy_bit_array+0x22>
 8005868:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}

0800586c <uavcan_transmit_chunk_handler>:
}

static void __attribute__((optimize("O3"))) uavcan_transmit_chunk_handler(uint8_t* chunk, size_t bitlen, void* ctx) {
    struct uavcan_transmit_state_s* tx_state = ctx;

    if (tx_state->failed || bitlen == 0) {
 800586c:	7813      	ldrb	r3, [r2, #0]
 800586e:	2b00      	cmp	r3, #0
 8005870:	d146      	bne.n	8005900 <uavcan_transmit_chunk_handler+0x94>
 8005872:	2900      	cmp	r1, #0
 8005874:	d044      	beq.n	8005900 <uavcan_transmit_chunk_handler+0x94>
        src_offset += copy_bits;
        dst_offset += copy_bits;
    }
}

static void __attribute__((optimize("O3"))) uavcan_transmit_chunk_handler(uint8_t* chunk, size_t bitlen, void* ctx) {
 8005876:	e92d 4f70 	stmdb	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}

    if (tx_state->failed || bitlen == 0) {
        return;
    }

    if (!tx_state->frame_list_tail) {
 800587a:	68d4      	ldr	r4, [r2, #12]
        src_offset += copy_bits;
        dst_offset += copy_bits;
    }
}

static void __attribute__((optimize("O3"))) uavcan_transmit_chunk_handler(uint8_t* chunk, size_t bitlen, void* ctx) {
 800587c:	b082      	sub	sp, #8
 800587e:	460e      	mov	r6, r1
 8005880:	4680      	mov	r8, r0
 8005882:	4615      	mov	r5, r2

    if (tx_state->failed || bitlen == 0) {
        return;
    }

    if (!tx_state->frame_list_tail) {
 8005884:	2c00      	cmp	r4, #0
 8005886:	d050      	beq.n	800592a <uavcan_transmit_chunk_handler+0xbe>
        src_offset += copy_bits;
        dst_offset += copy_bits;
    }
}

static void __attribute__((optimize("O3"))) uavcan_transmit_chunk_handler(uint8_t* chunk, size_t bitlen, void* ctx) {
 8005888:	f04f 0b00 	mov.w	fp, #0

    while (chunk_bit_ofs < bitlen) {
        size_t frame_copy_bits = MIN(bitlen-chunk_bit_ofs, 7*8-tx_state->frame_bit_ofs);
        if (frame_copy_bits == 0) {
            bool make_room_for_crc = tx_state->frame_list_head->next == NULL;
            tx_state->frame_list_tail = can_allocate_tx_frame_and_append(tx_state->instance->can_instance, &tx_state->frame_list_head);
 800588c:	f105 0a08 	add.w	sl, r5, #8
 8005890:	e017      	b.n	80058c2 <uavcan_transmit_chunk_handler+0x56>
 8005892:	686a      	ldr	r2, [r5, #4]
    size_t chunk_bit_ofs = 0;

    while (chunk_bit_ofs < bitlen) {
        size_t frame_copy_bits = MIN(bitlen-chunk_bit_ofs, 7*8-tx_state->frame_bit_ofs);
        if (frame_copy_bits == 0) {
            bool make_room_for_crc = tx_state->frame_list_head->next == NULL;
 8005894:	68ab      	ldr	r3, [r5, #8]
            tx_state->frame_list_tail = can_allocate_tx_frame_and_append(tx_state->instance->can_instance, &tx_state->frame_list_head);
 8005896:	6850      	ldr	r0, [r2, #4]
 8005898:	4651      	mov	r1, sl
    size_t chunk_bit_ofs = 0;

    while (chunk_bit_ofs < bitlen) {
        size_t frame_copy_bits = MIN(bitlen-chunk_bit_ofs, 7*8-tx_state->frame_bit_ofs);
        if (frame_copy_bits == 0) {
            bool make_room_for_crc = tx_state->frame_list_head->next == NULL;
 800589a:	f8d3 9018 	ldr.w	r9, [r3, #24]
            tx_state->frame_list_tail = can_allocate_tx_frame_and_append(tx_state->instance->can_instance, &tx_state->frame_list_head);
 800589e:	f001 fc2b 	bl	80070f8 <can_allocate_tx_frame_and_append>
 80058a2:	60e8      	str	r0, [r5, #12]
            if (!tx_state->frame_list_tail) {
 80058a4:	b368      	cbz	r0, 8005902 <uavcan_transmit_chunk_handler+0x96>
                tx_state->failed = true;
                return;
            }
            memset(tx_state->frame_list_tail->content.data, 0, 8);
 80058a6:	7204      	strb	r4, [r0, #8]
 80058a8:	7244      	strb	r4, [r0, #9]
 80058aa:	7284      	strb	r4, [r0, #10]
 80058ac:	72c4      	strb	r4, [r0, #11]
 80058ae:	7304      	strb	r4, [r0, #12]
 80058b0:	7344      	strb	r4, [r0, #13]
 80058b2:	7384      	strb	r4, [r0, #14]
 80058b4:	73c4      	strb	r4, [r0, #15]
            if (make_room_for_crc) {
 80058b6:	f1b9 0f00 	cmp.w	r9, #0
 80058ba:	d027      	beq.n	800590c <uavcan_transmit_chunk_handler+0xa0>
                memcpy(tx_state->frame_list_tail->content.data, &tx_state->frame_list_head->content.data[5], 2);
                memmove(&tx_state->frame_list_head->content.data[2], tx_state->frame_list_head->content.data, 5);
                tx_state->frame_bit_ofs = 16;
            } else {
                tx_state->frame_bit_ofs = 0;
 80058bc:	612c      	str	r4, [r5, #16]
        memset(tx_state->frame_list_tail->content.data, 0, 8);
    }

    size_t chunk_bit_ofs = 0;

    while (chunk_bit_ofs < bitlen) {
 80058be:	455e      	cmp	r6, fp
 80058c0:	d921      	bls.n	8005906 <uavcan_transmit_chunk_handler+0x9a>
        size_t frame_copy_bits = MIN(bitlen-chunk_bit_ofs, 7*8-tx_state->frame_bit_ofs);
 80058c2:	692a      	ldr	r2, [r5, #16]
 80058c4:	ebcb 0406 	rsb	r4, fp, r6
 80058c8:	f1c2 0338 	rsb	r3, r2, #56	; 0x38
 80058cc:	429c      	cmp	r4, r3
 80058ce:	bf28      	it	cs
 80058d0:	461c      	movcs	r4, r3
        if (frame_copy_bits == 0) {
 80058d2:	2c00      	cmp	r4, #0
 80058d4:	d0dd      	beq.n	8005892 <uavcan_transmit_chunk_handler+0x26>
                tx_state->frame_bit_ofs = 0;
            }
            continue;
        }

        copy_bit_array(chunk, chunk_bit_ofs, frame_copy_bits, tx_state->frame_list_tail->content.data, tx_state->frame_bit_ofs);
 80058d6:	68eb      	ldr	r3, [r5, #12]
 80058d8:	4659      	mov	r1, fp
 80058da:	9200      	str	r2, [sp, #0]
 80058dc:	3308      	adds	r3, #8
 80058de:	4622      	mov	r2, r4
 80058e0:	4640      	mov	r0, r8
 80058e2:	f7ff ff85 	bl	80057f0 <copy_bit_array>
        chunk_bit_ofs += frame_copy_bits;
        tx_state->frame_bit_ofs += frame_copy_bits;
 80058e6:	692b      	ldr	r3, [r5, #16]
        tx_state->frame_list_tail->content.DLC = (tx_state->frame_bit_ofs+7)/8 + 1;
 80058e8:	68ea      	ldr	r2, [r5, #12]
            continue;
        }

        copy_bit_array(chunk, chunk_bit_ofs, frame_copy_bits, tx_state->frame_list_tail->content.data, tx_state->frame_bit_ofs);
        chunk_bit_ofs += frame_copy_bits;
        tx_state->frame_bit_ofs += frame_copy_bits;
 80058ea:	4423      	add	r3, r4
 80058ec:	612b      	str	r3, [r5, #16]
        tx_state->frame_list_tail->content.DLC = (tx_state->frame_bit_ofs+7)/8 + 1;
 80058ee:	3307      	adds	r3, #7
 80058f0:	7811      	ldrb	r1, [r2, #0]
 80058f2:	08db      	lsrs	r3, r3, #3
 80058f4:	3301      	adds	r3, #1
 80058f6:	f363 0185 	bfi	r1, r3, #2, #4
            }
            continue;
        }

        copy_bit_array(chunk, chunk_bit_ofs, frame_copy_bits, tx_state->frame_list_tail->content.data, tx_state->frame_bit_ofs);
        chunk_bit_ofs += frame_copy_bits;
 80058fa:	44a3      	add	fp, r4
        tx_state->frame_bit_ofs += frame_copy_bits;
        tx_state->frame_list_tail->content.DLC = (tx_state->frame_bit_ofs+7)/8 + 1;
 80058fc:	7011      	strb	r1, [r2, #0]
 80058fe:	e7de      	b.n	80058be <uavcan_transmit_chunk_handler+0x52>
 8005900:	4770      	bx	lr
    }

    if (!tx_state->frame_list_tail) {
        tx_state->frame_list_tail = can_allocate_tx_frame_and_append(tx_state->instance->can_instance, &tx_state->frame_list_head);
        if (!tx_state->frame_list_tail) {
            tx_state->failed = true;
 8005902:	2301      	movs	r3, #1
 8005904:	702b      	strb	r3, [r5, #0]
        copy_bit_array(chunk, chunk_bit_ofs, frame_copy_bits, tx_state->frame_list_tail->content.data, tx_state->frame_bit_ofs);
        chunk_bit_ofs += frame_copy_bits;
        tx_state->frame_bit_ofs += frame_copy_bits;
        tx_state->frame_list_tail->content.DLC = (tx_state->frame_bit_ofs+7)/8 + 1;
    }
}
 8005906:	b002      	add	sp, #8
 8005908:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}
                tx_state->failed = true;
                return;
            }
            memset(tx_state->frame_list_tail->content.data, 0, 8);
            if (make_room_for_crc) {
                memcpy(tx_state->frame_list_tail->content.data, &tx_state->frame_list_head->content.data[5], 2);
 800590c:	68aa      	ldr	r2, [r5, #8]
 800590e:	68eb      	ldr	r3, [r5, #12]
 8005910:	f8b2 100d 	ldrh.w	r1, [r2, #13]
                memmove(&tx_state->frame_list_head->content.data[2], tx_state->frame_list_head->content.data, 5);
 8005914:	2205      	movs	r2, #5
                tx_state->failed = true;
                return;
            }
            memset(tx_state->frame_list_tail->content.data, 0, 8);
            if (make_room_for_crc) {
                memcpy(tx_state->frame_list_tail->content.data, &tx_state->frame_list_head->content.data[5], 2);
 8005916:	8119      	strh	r1, [r3, #8]
                memmove(&tx_state->frame_list_head->content.data[2], tx_state->frame_list_head->content.data, 5);
 8005918:	68a9      	ldr	r1, [r5, #8]
 800591a:	f101 000a 	add.w	r0, r1, #10
 800591e:	3108      	adds	r1, #8
 8005920:	f007 f971 	bl	800cc06 <memmove>
                tx_state->frame_bit_ofs = 16;
 8005924:	2310      	movs	r3, #16
 8005926:	612b      	str	r3, [r5, #16]
 8005928:	e7c9      	b.n	80058be <uavcan_transmit_chunk_handler+0x52>
    if (tx_state->failed || bitlen == 0) {
        return;
    }

    if (!tx_state->frame_list_tail) {
        tx_state->frame_list_tail = can_allocate_tx_frame_and_append(tx_state->instance->can_instance, &tx_state->frame_list_head);
 800592a:	6853      	ldr	r3, [r2, #4]
 800592c:	f102 0108 	add.w	r1, r2, #8
 8005930:	6858      	ldr	r0, [r3, #4]
 8005932:	f001 fbe1 	bl	80070f8 <can_allocate_tx_frame_and_append>
 8005936:	60e8      	str	r0, [r5, #12]
        if (!tx_state->frame_list_tail) {
 8005938:	2800      	cmp	r0, #0
 800593a:	d0e2      	beq.n	8005902 <uavcan_transmit_chunk_handler+0x96>
            tx_state->failed = true;
            return;
        }
        memset(tx_state->frame_list_tail->content.data, 0, 8);
 800593c:	7204      	strb	r4, [r0, #8]
 800593e:	7244      	strb	r4, [r0, #9]
 8005940:	7284      	strb	r4, [r0, #10]
 8005942:	72c4      	strb	r4, [r0, #11]
 8005944:	7304      	strb	r4, [r0, #12]
 8005946:	7344      	strb	r4, [r0, #13]
 8005948:	7384      	strb	r4, [r0, #14]
 800594a:	73c4      	strb	r4, [r0, #15]
 800594c:	e79c      	b.n	8005888 <uavcan_transmit_chunk_handler+0x1c>
 800594e:	bf00      	nop

08005950 <_uavcan_send>:
        tx_state->frame_bit_ofs += frame_copy_bits;
        tx_state->frame_list_tail->content.DLC = (tx_state->frame_bit_ofs+7)/8 + 1;
    }
}

static bool _uavcan_send(struct uavcan_instance_s* instance, const struct uavcan_message_descriptor_s* const msg_descriptor, uint16_t data_type_id, uint8_t priority, uint8_t transfer_id, uint8_t dest_node_id, void* msg_data) {
 8005950:	b580      	push	{r7, lr}
 8005952:	b08e      	sub	sp, #56	; 0x38
 8005954:	af00      	add	r7, sp, #0
 8005956:	60f8      	str	r0, [r7, #12]
 8005958:	60b9      	str	r1, [r7, #8]
 800595a:	4611      	mov	r1, r2
 800595c:	461a      	mov	r2, r3
 800595e:	460b      	mov	r3, r1
 8005960:	80fb      	strh	r3, [r7, #6]
 8005962:	4613      	mov	r3, r2
 8005964:	717b      	strb	r3, [r7, #5]
    if (!instance || !msg_descriptor || !msg_descriptor->serializer_func || !msg_data) {
 8005966:	68fb      	ldr	r3, [r7, #12]
 8005968:	2b00      	cmp	r3, #0
 800596a:	d009      	beq.n	8005980 <_uavcan_send+0x30>
 800596c:	68bb      	ldr	r3, [r7, #8]
 800596e:	2b00      	cmp	r3, #0
 8005970:	d006      	beq.n	8005980 <_uavcan_send+0x30>
 8005972:	68bb      	ldr	r3, [r7, #8]
 8005974:	695b      	ldr	r3, [r3, #20]
 8005976:	2b00      	cmp	r3, #0
 8005978:	d002      	beq.n	8005980 <_uavcan_send+0x30>
 800597a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800597c:	2b00      	cmp	r3, #0
 800597e:	d101      	bne.n	8005984 <_uavcan_send+0x34>
        return false;
 8005980:	2300      	movs	r3, #0
 8005982:	e17f      	b.n	8005c84 <_uavcan_send+0x334>
    }

    if (_uavcan_get_node_id(instance) == 0 && (data_type_id > 0b11 || msg_descriptor->transfer_type != CanardTransferTypeBroadcast)) {
 8005984:	68f8      	ldr	r0, [r7, #12]
 8005986:	f7ff fecd 	bl	8005724 <_uavcan_get_node_id>
 800598a:	4603      	mov	r3, r0
 800598c:	2b00      	cmp	r3, #0
 800598e:	d108      	bne.n	80059a2 <_uavcan_send+0x52>
 8005990:	88fb      	ldrh	r3, [r7, #6]
 8005992:	2b03      	cmp	r3, #3
 8005994:	d803      	bhi.n	800599e <_uavcan_send+0x4e>
 8005996:	68bb      	ldr	r3, [r7, #8]
 8005998:	7a9b      	ldrb	r3, [r3, #10]
 800599a:	2b02      	cmp	r3, #2
 800599c:	d001      	beq.n	80059a2 <_uavcan_send+0x52>
        return false;
 800599e:	2300      	movs	r3, #0
 80059a0:	e170      	b.n	8005c84 <_uavcan_send+0x334>
    }

    if (msg_descriptor->transfer_type != CanardTransferTypeBroadcast && data_type_id > 0xff) {
 80059a2:	68bb      	ldr	r3, [r7, #8]
 80059a4:	7a9b      	ldrb	r3, [r3, #10]
 80059a6:	2b02      	cmp	r3, #2
 80059a8:	d004      	beq.n	80059b4 <_uavcan_send+0x64>
 80059aa:	88fb      	ldrh	r3, [r7, #6]
 80059ac:	2bff      	cmp	r3, #255	; 0xff
 80059ae:	d901      	bls.n	80059b4 <_uavcan_send+0x64>
        return false;
 80059b0:	2300      	movs	r3, #0
 80059b2:	e167      	b.n	8005c84 <_uavcan_send+0x334>
    }

    if (_uavcan_get_node_id(instance) > 127) {
 80059b4:	68f8      	ldr	r0, [r7, #12]
 80059b6:	f7ff feb5 	bl	8005724 <_uavcan_get_node_id>
 80059ba:	4603      	mov	r3, r0
 80059bc:	b2db      	uxtb	r3, r3
 80059be:	b25b      	sxtb	r3, r3
 80059c0:	2b00      	cmp	r3, #0
 80059c2:	da01      	bge.n	80059c8 <_uavcan_send+0x78>
        return false;
 80059c4:	2300      	movs	r3, #0
 80059c6:	e15d      	b.n	8005c84 <_uavcan_send+0x334>
    }

    struct uavcan_transmit_state_s tx_state = {
 80059c8:	2300      	movs	r3, #0
 80059ca:	763b      	strb	r3, [r7, #24]
 80059cc:	68fb      	ldr	r3, [r7, #12]
 80059ce:	61fb      	str	r3, [r7, #28]
 80059d0:	2300      	movs	r3, #0
 80059d2:	623b      	str	r3, [r7, #32]
 80059d4:	2300      	movs	r3, #0
 80059d6:	627b      	str	r3, [r7, #36]	; 0x24
 80059d8:	2300      	movs	r3, #0
 80059da:	62bb      	str	r3, [r7, #40]	; 0x28
        false, instance, NULL, NULL, 0
    };

    msg_descriptor->serializer_func(msg_data, uavcan_transmit_chunk_handler, &tx_state);
 80059dc:	68bb      	ldr	r3, [r7, #8]
 80059de:	695b      	ldr	r3, [r3, #20]
 80059e0:	f107 0218 	add.w	r2, r7, #24
 80059e4:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 80059e6:	49a9      	ldr	r1, [pc, #676]	; (8005c8c <_uavcan_send+0x33c>)
 80059e8:	4798      	blx	r3
    if (tx_state.failed || !tx_state.frame_list_head) {
 80059ea:	7e3b      	ldrb	r3, [r7, #24]
 80059ec:	2b00      	cmp	r3, #0
 80059ee:	d102      	bne.n	80059f6 <_uavcan_send+0xa6>
 80059f0:	6a3b      	ldr	r3, [r7, #32]
 80059f2:	2b00      	cmp	r3, #0
 80059f4:	d10a      	bne.n	8005a0c <_uavcan_send+0xbc>
        can_free_tx_frames(instance->can_instance, &tx_state.frame_list_head);
 80059f6:	68fb      	ldr	r3, [r7, #12]
 80059f8:	685a      	ldr	r2, [r3, #4]
 80059fa:	f107 0318 	add.w	r3, r7, #24
 80059fe:	3308      	adds	r3, #8
 8005a00:	4610      	mov	r0, r2
 8005a02:	4619      	mov	r1, r3
 8005a04:	f7ff f804 	bl	8004a10 <can_free_tx_frames>
        return false;
 8005a08:	2300      	movs	r3, #0
 8005a0a:	e13b      	b.n	8005c84 <_uavcan_send+0x334>
    }

    LED_ON;
 8005a0c:	4ba0      	ldr	r3, [pc, #640]	; (8005c90 <_uavcan_send+0x340>)
 8005a0e:	2202      	movs	r2, #2
 8005a10:	611a      	str	r2, [r3, #16]

    uint32_t can_id = 0;
 8005a12:	2300      	movs	r3, #0
 8005a14:	637b      	str	r3, [r7, #52]	; 0x34
    can_id |= (uint32_t)(priority&0x1f) << 24;
 8005a16:	797b      	ldrb	r3, [r7, #5]
 8005a18:	f003 031f 	and.w	r3, r3, #31
 8005a1c:	061b      	lsls	r3, r3, #24
 8005a1e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8005a20:	4313      	orrs	r3, r2
 8005a22:	637b      	str	r3, [r7, #52]	; 0x34
    if (msg_descriptor->transfer_type == CanardTransferTypeBroadcast) {
 8005a24:	68bb      	ldr	r3, [r7, #8]
 8005a26:	7a9b      	ldrb	r3, [r3, #10]
 8005a28:	2b02      	cmp	r3, #2
 8005a2a:	d105      	bne.n	8005a38 <_uavcan_send+0xe8>
        can_id |= (uint32_t)(data_type_id) << 8;
 8005a2c:	88fb      	ldrh	r3, [r7, #6]
 8005a2e:	021b      	lsls	r3, r3, #8
 8005a30:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8005a32:	4313      	orrs	r3, r2
 8005a34:	637b      	str	r3, [r7, #52]	; 0x34
 8005a36:	e018      	b.n	8005a6a <_uavcan_send+0x11a>
    } else {
        can_id |= data_type_id<<16;
 8005a38:	88fb      	ldrh	r3, [r7, #6]
 8005a3a:	041b      	lsls	r3, r3, #16
 8005a3c:	461a      	mov	r2, r3
 8005a3e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005a40:	4313      	orrs	r3, r2
 8005a42:	637b      	str	r3, [r7, #52]	; 0x34
        if (msg_descriptor->transfer_type == CanardTransferTypeRequest) {
 8005a44:	68bb      	ldr	r3, [r7, #8]
 8005a46:	7a9b      	ldrb	r3, [r3, #10]
 8005a48:	2b01      	cmp	r3, #1
 8005a4a:	d103      	bne.n	8005a54 <_uavcan_send+0x104>
            can_id |= 1<<15;
 8005a4c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005a4e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8005a52:	637b      	str	r3, [r7, #52]	; 0x34
        }
        can_id |= dest_node_id<<8;
 8005a54:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
 8005a58:	021b      	lsls	r3, r3, #8
 8005a5a:	461a      	mov	r2, r3
 8005a5c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005a5e:	4313      	orrs	r3, r2
 8005a60:	637b      	str	r3, [r7, #52]	; 0x34
        can_id |= 1<<7;
 8005a62:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005a64:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8005a68:	637b      	str	r3, [r7, #52]	; 0x34
    }

    if (_uavcan_get_node_id(instance) == 0) {
 8005a6a:	68f8      	ldr	r0, [r7, #12]
 8005a6c:	f7ff fe5a 	bl	8005724 <_uavcan_get_node_id>
 8005a70:	4603      	mov	r3, r0
 8005a72:	2b00      	cmp	r3, #0
 8005a74:	d110      	bne.n	8005a98 <_uavcan_send+0x148>
        can_id |= (uint32_t)(crc16_ccitt(tx_state.frame_list_head->content.data, 7, 0xffff) & 0xfffc)<<8;
 8005a76:	6a3b      	ldr	r3, [r7, #32]
 8005a78:	3308      	adds	r3, #8
 8005a7a:	4618      	mov	r0, r3
 8005a7c:	2107      	movs	r1, #7
 8005a7e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8005a82:	f001 fb8b 	bl	800719c <crc16_ccitt>
 8005a86:	4603      	mov	r3, r0
 8005a88:	461a      	mov	r2, r3
 8005a8a:	f64f 73fc 	movw	r3, #65532	; 0xfffc
 8005a8e:	4013      	ands	r3, r2
 8005a90:	021b      	lsls	r3, r3, #8
 8005a92:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8005a94:	4313      	orrs	r3, r2
 8005a96:	637b      	str	r3, [r7, #52]	; 0x34
    }

    can_id |= _uavcan_get_node_id(instance);
 8005a98:	68f8      	ldr	r0, [r7, #12]
 8005a9a:	f7ff fe43 	bl	8005724 <_uavcan_get_node_id>
 8005a9e:	4603      	mov	r3, r0
 8005aa0:	461a      	mov	r2, r3
 8005aa2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005aa4:	4313      	orrs	r3, r2
 8005aa6:	637b      	str	r3, [r7, #52]	; 0x34

    uint8_t toggle = 0;
 8005aa8:	2300      	movs	r3, #0
 8005aaa:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    struct can_tx_frame_s* frame = tx_state.frame_list_head;
 8005aae:	6a3b      	ldr	r3, [r7, #32]
 8005ab0:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005ab2:	e088      	b.n	8005bc6 <_uavcan_send+0x276>
    while (frame != NULL) {
        frame->content.IDE = 1;
 8005ab4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005ab6:	7813      	ldrb	r3, [r2, #0]
 8005ab8:	f043 0302 	orr.w	r3, r3, #2
 8005abc:	7013      	strb	r3, [r2, #0]
        frame->content.RTR = 0;
 8005abe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005ac0:	7813      	ldrb	r3, [r2, #0]
 8005ac2:	f36f 0300 	bfc	r3, #0, #1
 8005ac6:	7013      	strb	r3, [r2, #0]
        frame->content.EID = can_id;
 8005ac8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005aca:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 8005ace:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005ad0:	6853      	ldr	r3, [r2, #4]
 8005ad2:	f361 031c 	bfi	r3, r1, #0, #29
 8005ad6:	6053      	str	r3, [r2, #4]
        if (frame == tx_state.frame_list_head) {
 8005ad8:	6a3a      	ldr	r2, [r7, #32]
 8005ada:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005adc:	429a      	cmp	r2, r3
 8005ade:	d115      	bne.n	8005b0c <_uavcan_send+0x1bc>
            frame->content.data[frame->content.DLC-1] |= 1<<7;
 8005ae0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005ae2:	781b      	ldrb	r3, [r3, #0]
 8005ae4:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8005ae8:	b2db      	uxtb	r3, r3
 8005aea:	3b01      	subs	r3, #1
 8005aec:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005aee:	7812      	ldrb	r2, [r2, #0]
 8005af0:	f3c2 0283 	ubfx	r2, r2, #2, #4
 8005af4:	b2d2      	uxtb	r2, r2
 8005af6:	3a01      	subs	r2, #1
 8005af8:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8005afa:	440a      	add	r2, r1
 8005afc:	7a12      	ldrb	r2, [r2, #8]
 8005afe:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8005b02:	b2d1      	uxtb	r1, r2
 8005b04:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005b06:	4413      	add	r3, r2
 8005b08:	460a      	mov	r2, r1
 8005b0a:	721a      	strb	r2, [r3, #8]
        }
        if (frame == tx_state.frame_list_tail) {
 8005b0c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005b0e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005b10:	429a      	cmp	r2, r3
 8005b12:	d115      	bne.n	8005b40 <_uavcan_send+0x1f0>
            frame->content.data[frame->content.DLC-1] |= 1<<6;
 8005b14:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005b16:	781b      	ldrb	r3, [r3, #0]
 8005b18:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8005b1c:	b2db      	uxtb	r3, r3
 8005b1e:	3b01      	subs	r3, #1
 8005b20:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005b22:	7812      	ldrb	r2, [r2, #0]
 8005b24:	f3c2 0283 	ubfx	r2, r2, #2, #4
 8005b28:	b2d2      	uxtb	r2, r2
 8005b2a:	3a01      	subs	r2, #1
 8005b2c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8005b2e:	440a      	add	r2, r1
 8005b30:	7a12      	ldrb	r2, [r2, #8]
 8005b32:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8005b36:	b2d1      	uxtb	r1, r2
 8005b38:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005b3a:	4413      	add	r3, r2
 8005b3c:	460a      	mov	r2, r1
 8005b3e:	721a      	strb	r2, [r3, #8]
        }
        frame->content.data[frame->content.DLC-1] |= toggle << 5;
 8005b40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005b42:	781b      	ldrb	r3, [r3, #0]
 8005b44:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8005b48:	b2db      	uxtb	r3, r3
 8005b4a:	3b01      	subs	r3, #1
 8005b4c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005b4e:	7812      	ldrb	r2, [r2, #0]
 8005b50:	f3c2 0283 	ubfx	r2, r2, #2, #4
 8005b54:	b2d2      	uxtb	r2, r2
 8005b56:	3a01      	subs	r2, #1
 8005b58:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8005b5a:	440a      	add	r2, r1
 8005b5c:	7a12      	ldrb	r2, [r2, #8]
 8005b5e:	b2d1      	uxtb	r1, r2
 8005b60:	f897 2033 	ldrb.w	r2, [r7, #51]	; 0x33
 8005b64:	0152      	lsls	r2, r2, #5
 8005b66:	b2d2      	uxtb	r2, r2
 8005b68:	430a      	orrs	r2, r1
 8005b6a:	b2d2      	uxtb	r2, r2
 8005b6c:	b2d1      	uxtb	r1, r2
 8005b6e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005b70:	4413      	add	r3, r2
 8005b72:	460a      	mov	r2, r1
 8005b74:	721a      	strb	r2, [r3, #8]
        frame->content.data[frame->content.DLC-1] |= transfer_id&0x1f;
 8005b76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005b78:	781b      	ldrb	r3, [r3, #0]
 8005b7a:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8005b7e:	b2db      	uxtb	r3, r3
 8005b80:	3b01      	subs	r3, #1
 8005b82:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005b84:	7812      	ldrb	r2, [r2, #0]
 8005b86:	f3c2 0283 	ubfx	r2, r2, #2, #4
 8005b8a:	b2d2      	uxtb	r2, r2
 8005b8c:	3a01      	subs	r2, #1
 8005b8e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8005b90:	440a      	add	r2, r1
 8005b92:	7a12      	ldrb	r2, [r2, #8]
 8005b94:	b2d1      	uxtb	r1, r2
 8005b96:	f897 2040 	ldrb.w	r2, [r7, #64]	; 0x40
 8005b9a:	f002 021f 	and.w	r2, r2, #31
 8005b9e:	b2d2      	uxtb	r2, r2
 8005ba0:	430a      	orrs	r2, r1
 8005ba2:	b2d2      	uxtb	r2, r2
 8005ba4:	b2d1      	uxtb	r1, r2
 8005ba6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005ba8:	4413      	add	r3, r2
 8005baa:	460a      	mov	r2, r1
 8005bac:	721a      	strb	r2, [r3, #8]

        toggle = toggle?0:1;
 8005bae:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8005bb2:	2b00      	cmp	r3, #0
 8005bb4:	bf0c      	ite	eq
 8005bb6:	2301      	moveq	r3, #1
 8005bb8:	2300      	movne	r3, #0
 8005bba:	b2db      	uxtb	r3, r3
 8005bbc:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

        frame = frame->next;
 8005bc0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005bc2:	699b      	ldr	r3, [r3, #24]
 8005bc4:	62fb      	str	r3, [r7, #44]	; 0x2c

    can_id |= _uavcan_get_node_id(instance);

    uint8_t toggle = 0;
    struct can_tx_frame_s* frame = tx_state.frame_list_head;
    while (frame != NULL) {
 8005bc6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005bc8:	2b00      	cmp	r3, #0
 8005bca:	f47f af73 	bne.w	8005ab4 <_uavcan_send+0x164>
        toggle = toggle?0:1;

        frame = frame->next;
    }

    if (tx_state.frame_list_head != tx_state.frame_list_tail) {
 8005bce:	6a3a      	ldr	r2, [r7, #32]
 8005bd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005bd2:	429a      	cmp	r2, r3
 8005bd4:	d046      	beq.n	8005c64 <_uavcan_send+0x314>
        uint16_t crc16 = crc16_ccitt((void*)&msg_descriptor->data_type_signature, 8, 0xffff);
 8005bd6:	68bb      	ldr	r3, [r7, #8]
 8005bd8:	4618      	mov	r0, r3
 8005bda:	2108      	movs	r1, #8
 8005bdc:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8005be0:	f001 fadc 	bl	800719c <crc16_ccitt>
 8005be4:	4603      	mov	r3, r0
 8005be6:	82fb      	strh	r3, [r7, #22]

        frame = tx_state.frame_list_head;
 8005be8:	6a3b      	ldr	r3, [r7, #32]
 8005bea:	62fb      	str	r3, [r7, #44]	; 0x2c
        crc16 = crc16_ccitt(&frame->content.data[2], 5, crc16);
 8005bec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005bee:	f103 020a 	add.w	r2, r3, #10
 8005bf2:	8afb      	ldrh	r3, [r7, #22]
 8005bf4:	4610      	mov	r0, r2
 8005bf6:	2105      	movs	r1, #5
 8005bf8:	461a      	mov	r2, r3
 8005bfa:	f001 facf 	bl	800719c <crc16_ccitt>
 8005bfe:	4603      	mov	r3, r0
 8005c00:	82fb      	strh	r3, [r7, #22]
        frame = frame->next;
 8005c02:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005c04:	699b      	ldr	r3, [r3, #24]
 8005c06:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005c08:	e00d      	b.n	8005c26 <_uavcan_send+0x2d6>

        while (frame->next != NULL) {
            crc16 = crc16_ccitt(&frame->content.data[0], 7, crc16);
 8005c0a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005c0c:	f103 0208 	add.w	r2, r3, #8
 8005c10:	8afb      	ldrh	r3, [r7, #22]
 8005c12:	4610      	mov	r0, r2
 8005c14:	2107      	movs	r1, #7
 8005c16:	461a      	mov	r2, r3
 8005c18:	f001 fac0 	bl	800719c <crc16_ccitt>
 8005c1c:	4603      	mov	r3, r0
 8005c1e:	82fb      	strh	r3, [r7, #22]
            frame = frame->next;
 8005c20:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005c22:	699b      	ldr	r3, [r3, #24]
 8005c24:	62fb      	str	r3, [r7, #44]	; 0x2c

        frame = tx_state.frame_list_head;
        crc16 = crc16_ccitt(&frame->content.data[2], 5, crc16);
        frame = frame->next;

        while (frame->next != NULL) {
 8005c26:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005c28:	699b      	ldr	r3, [r3, #24]
 8005c2a:	2b00      	cmp	r3, #0
 8005c2c:	d1ed      	bne.n	8005c0a <_uavcan_send+0x2ba>
            crc16 = crc16_ccitt(&frame->content.data[0], 7, crc16);
            frame = frame->next;
        }
        crc16 = crc16_ccitt(&frame->content.data[0], frame->content.DLC-1, crc16);
 8005c2e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005c30:	f103 0208 	add.w	r2, r3, #8
 8005c34:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005c36:	781b      	ldrb	r3, [r3, #0]
 8005c38:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8005c3c:	b2db      	uxtb	r3, r3
 8005c3e:	3b01      	subs	r3, #1
 8005c40:	4619      	mov	r1, r3
 8005c42:	8afb      	ldrh	r3, [r7, #22]
 8005c44:	4610      	mov	r0, r2
 8005c46:	461a      	mov	r2, r3
 8005c48:	f001 faa8 	bl	800719c <crc16_ccitt>
 8005c4c:	4603      	mov	r3, r0
 8005c4e:	82fb      	strh	r3, [r7, #22]
        memcpy(tx_state.frame_list_head->content.data, &crc16, 2);
 8005c50:	6a3b      	ldr	r3, [r7, #32]
 8005c52:	f103 0208 	add.w	r2, r3, #8
 8005c56:	f107 0316 	add.w	r3, r7, #22
 8005c5a:	4610      	mov	r0, r2
 8005c5c:	4619      	mov	r1, r3
 8005c5e:	2202      	movs	r2, #2
 8005c60:	f006 ffc6 	bl	800cbf0 <memcpy>
    }

    can_enqueue_tx_frames(instance->can_instance, &tx_state.frame_list_head, TIME_INFINITE, NULL);
 8005c64:	68fb      	ldr	r3, [r7, #12]
 8005c66:	685a      	ldr	r2, [r3, #4]
 8005c68:	f107 0318 	add.w	r3, r7, #24
 8005c6c:	3308      	adds	r3, #8
 8005c6e:	4610      	mov	r0, r2
 8005c70:	4619      	mov	r1, r3
 8005c72:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8005c76:	2300      	movs	r3, #0
 8005c78:	f001 fa52 	bl	8007120 <can_enqueue_tx_frames>

    LED_OFF;
 8005c7c:	4b04      	ldr	r3, [pc, #16]	; (8005c90 <_uavcan_send+0x340>)
 8005c7e:	2202      	movs	r2, #2
 8005c80:	615a      	str	r2, [r3, #20]

    return true;
 8005c82:	2301      	movs	r3, #1
}
 8005c84:	4618      	mov	r0, r3
 8005c86:	3738      	adds	r7, #56	; 0x38
 8005c88:	46bd      	mov	sp, r7
 8005c8a:	bd80      	pop	{r7, pc}
 8005c8c:	0800586d 	.word	0x0800586d
 8005c90:	40010c00 	.word	0x40010c00

08005c94 <uavcan_broadcast>:

bool uavcan_broadcast(uint8_t uavcan_idx, const struct uavcan_message_descriptor_s* const msg_descriptor, uint8_t priority, void* msg_data) {
 8005c94:	b590      	push	{r4, r7, lr}
 8005c96:	b08d      	sub	sp, #52	; 0x34
 8005c98:	af04      	add	r7, sp, #16
 8005c9a:	60b9      	str	r1, [r7, #8]
 8005c9c:	607b      	str	r3, [r7, #4]
 8005c9e:	4603      	mov	r3, r0
 8005ca0:	73fb      	strb	r3, [r7, #15]
 8005ca2:	4613      	mov	r3, r2
 8005ca4:	73bb      	strb	r3, [r7, #14]
    struct uavcan_instance_s* instance = uavcan_get_instance(uavcan_idx);
 8005ca6:	7bfb      	ldrb	r3, [r7, #15]
 8005ca8:	4618      	mov	r0, r3
 8005caa:	f7fe f87f 	bl	8003dac <uavcan_get_instance.lto_priv.71>
 8005cae:	61f8      	str	r0, [r7, #28]
    if (!instance) {
 8005cb0:	69fb      	ldr	r3, [r7, #28]
 8005cb2:	2b00      	cmp	r3, #0
 8005cb4:	d101      	bne.n	8005cba <uavcan_broadcast+0x26>
        return false;
 8005cb6:	2300      	movs	r3, #0
 8005cb8:	e02b      	b.n	8005d12 <uavcan_broadcast+0x7e>
    }

    uint16_t data_type_id = msg_descriptor->default_data_type_id;
 8005cba:	68bb      	ldr	r3, [r7, #8]
 8005cbc:	891b      	ldrh	r3, [r3, #8]
 8005cbe:	837b      	strh	r3, [r7, #26]
    chSysLock();
 8005cc0:	f7ff fb24 	bl	800530c <chSysLock.lto_priv.62>
    uint8_t* transfer_id = uavcan_transfer_id_map_retrieve(&instance->transfer_id_map, false, data_type_id, 0);
 8005cc4:	69fb      	ldr	r3, [r7, #28]
 8005cc6:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8005cca:	8b7b      	ldrh	r3, [r7, #26]
 8005ccc:	4610      	mov	r0, r2
 8005cce:	2100      	movs	r1, #0
 8005cd0:	461a      	mov	r2, r3
 8005cd2:	2300      	movs	r3, #0
 8005cd4:	f7fe f9f2 	bl	80040bc <uavcan_transfer_id_map_retrieve.lto_priv.72>
 8005cd8:	6178      	str	r0, [r7, #20]
    chSysUnlock();
 8005cda:	f7ff fb1f 	bl	800531c <chSysUnlock.lto_priv.59>
    if(_uavcan_send(instance, msg_descriptor, data_type_id, priority, *transfer_id, 0, msg_data)) {
 8005cde:	697b      	ldr	r3, [r7, #20]
 8005ce0:	781b      	ldrb	r3, [r3, #0]
 8005ce2:	8b7a      	ldrh	r2, [r7, #26]
 8005ce4:	7bbc      	ldrb	r4, [r7, #14]
 8005ce6:	9300      	str	r3, [sp, #0]
 8005ce8:	2300      	movs	r3, #0
 8005cea:	9301      	str	r3, [sp, #4]
 8005cec:	687b      	ldr	r3, [r7, #4]
 8005cee:	9302      	str	r3, [sp, #8]
 8005cf0:	69f8      	ldr	r0, [r7, #28]
 8005cf2:	68b9      	ldr	r1, [r7, #8]
 8005cf4:	4623      	mov	r3, r4
 8005cf6:	f7ff fe2b 	bl	8005950 <_uavcan_send>
 8005cfa:	4603      	mov	r3, r0
 8005cfc:	2b00      	cmp	r3, #0
 8005cfe:	d007      	beq.n	8005d10 <uavcan_broadcast+0x7c>
        (*transfer_id)++;
 8005d00:	697b      	ldr	r3, [r7, #20]
 8005d02:	781b      	ldrb	r3, [r3, #0]
 8005d04:	3301      	adds	r3, #1
 8005d06:	b2da      	uxtb	r2, r3
 8005d08:	697b      	ldr	r3, [r7, #20]
 8005d0a:	701a      	strb	r2, [r3, #0]
        return true;
 8005d0c:	2301      	movs	r3, #1
 8005d0e:	e000      	b.n	8005d12 <uavcan_broadcast+0x7e>
    } else {
        return false;
 8005d10:	2300      	movs	r3, #0
    }
}
 8005d12:	4618      	mov	r0, r3
 8005d14:	3724      	adds	r7, #36	; 0x24
 8005d16:	46bd      	mov	sp, r7
 8005d18:	bd90      	pop	{r4, r7, pc}
 8005d1a:	bf00      	nop

08005d1c <uavcan_respond>:
    } else {
        return false;
    }
}

bool uavcan_respond(uint8_t uavcan_idx, const struct uavcan_deserialized_message_s* const req_msg, void* msg_data) {
 8005d1c:	b590      	push	{r4, r7, lr}
 8005d1e:	b08d      	sub	sp, #52	; 0x34
 8005d20:	af04      	add	r7, sp, #16
 8005d22:	4603      	mov	r3, r0
 8005d24:	60b9      	str	r1, [r7, #8]
 8005d26:	607a      	str	r2, [r7, #4]
 8005d28:	73fb      	strb	r3, [r7, #15]
    struct uavcan_instance_s* instance = uavcan_get_instance(uavcan_idx);
 8005d2a:	7bfb      	ldrb	r3, [r7, #15]
 8005d2c:	4618      	mov	r0, r3
 8005d2e:	f7fe f83d 	bl	8003dac <uavcan_get_instance.lto_priv.71>
 8005d32:	61f8      	str	r0, [r7, #28]
    if (!instance) {
 8005d34:	69fb      	ldr	r3, [r7, #28]
 8005d36:	2b00      	cmp	r3, #0
 8005d38:	d101      	bne.n	8005d3e <uavcan_respond+0x22>
        return false;
 8005d3a:	2300      	movs	r3, #0
 8005d3c:	e01d      	b.n	8005d7a <uavcan_respond+0x5e>
    }

    const struct uavcan_message_descriptor_s* msg_descriptor = req_msg->descriptor->resp_descriptor;
 8005d3e:	68bb      	ldr	r3, [r7, #8]
 8005d40:	685b      	ldr	r3, [r3, #4]
 8005d42:	69db      	ldr	r3, [r3, #28]
 8005d44:	61bb      	str	r3, [r7, #24]
    uint8_t priority = req_msg->priority;
 8005d46:	68bb      	ldr	r3, [r7, #8]
 8005d48:	7adb      	ldrb	r3, [r3, #11]
 8005d4a:	75fb      	strb	r3, [r7, #23]
    uint8_t transfer_id = req_msg->transfer_id;
 8005d4c:	68bb      	ldr	r3, [r7, #8]
 8005d4e:	7a9b      	ldrb	r3, [r3, #10]
 8005d50:	75bb      	strb	r3, [r7, #22]
    uint8_t dest_node_id = req_msg->source_node_id;
 8005d52:	68bb      	ldr	r3, [r7, #8]
 8005d54:	7b1b      	ldrb	r3, [r3, #12]
 8005d56:	757b      	strb	r3, [r7, #21]
    uint16_t data_type_id = msg_descriptor->default_data_type_id;
 8005d58:	69bb      	ldr	r3, [r7, #24]
 8005d5a:	891b      	ldrh	r3, [r3, #8]
 8005d5c:	827b      	strh	r3, [r7, #18]
    return _uavcan_send(instance, msg_descriptor, data_type_id, priority, transfer_id, dest_node_id, msg_data);
 8005d5e:	8a7a      	ldrh	r2, [r7, #18]
 8005d60:	7dfc      	ldrb	r4, [r7, #23]
 8005d62:	7dbb      	ldrb	r3, [r7, #22]
 8005d64:	9300      	str	r3, [sp, #0]
 8005d66:	7d7b      	ldrb	r3, [r7, #21]
 8005d68:	9301      	str	r3, [sp, #4]
 8005d6a:	687b      	ldr	r3, [r7, #4]
 8005d6c:	9302      	str	r3, [sp, #8]
 8005d6e:	69f8      	ldr	r0, [r7, #28]
 8005d70:	69b9      	ldr	r1, [r7, #24]
 8005d72:	4623      	mov	r3, r4
 8005d74:	f7ff fdec 	bl	8005950 <_uavcan_send>
 8005d78:	4603      	mov	r3, r0
}
 8005d7a:	4618      	mov	r0, r3
 8005d7c:	3724      	adds	r7, #36	; 0x24
 8005d7e:	46bd      	mov	sp, r7
 8005d80:	bd90      	pop	{r4, r7, pc}
 8005d82:	bf00      	nop

08005d84 <uavcan_can_rx_handler>:

static void uavcan_can_rx_handler(size_t msg_size, const void* msg, void* ctx) {
 8005d84:	b580      	push	{r7, lr}
 8005d86:	b08c      	sub	sp, #48	; 0x30
 8005d88:	af00      	add	r7, sp, #0
 8005d8a:	60f8      	str	r0, [r7, #12]
 8005d8c:	60b9      	str	r1, [r7, #8]
 8005d8e:	607a      	str	r2, [r7, #4]
    (void) msg_size;
    struct uavcan_instance_s* instance = ctx;
 8005d90:	687b      	ldr	r3, [r7, #4]
 8005d92:	62fb      	str	r3, [r7, #44]	; 0x2c

    const struct can_rx_frame_s* frame = msg;
 8005d94:	68bb      	ldr	r3, [r7, #8]
 8005d96:	62bb      	str	r3, [r7, #40]	; 0x28

    palSetPadMode(GPIOB, 3, PAL_MODE_OUTPUT_PUSHPULL);
 8005d98:	4811      	ldr	r0, [pc, #68]	; (8005de0 <uavcan_can_rx_handler+0x5c>)
 8005d9a:	2108      	movs	r1, #8
 8005d9c:	2206      	movs	r2, #6
 8005d9e:	f002 fbaf 	bl	8008500 <_pal_lld_setgroupmode>
    palSetPad(GPIOB, 3);
 8005da2:	4b0f      	ldr	r3, [pc, #60]	; (8005de0 <uavcan_can_rx_handler+0x5c>)
 8005da4:	2208      	movs	r2, #8
 8005da6:	611a      	str	r2, [r3, #16]
    CanardCANFrame canard_frame = convert_can_frame_to_CanardCANFrame(&frame->content);
 8005da8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005daa:	f107 0210 	add.w	r2, r7, #16
 8005dae:	4610      	mov	r0, r2
 8005db0:	4619      	mov	r1, r3
 8005db2:	f7fe f85b 	bl	8003e6c <convert_can_frame_to_CanardCANFrame.lto_priv.70>

    uint64_t timestamp = micros64();
 8005db6:	f001 faa3 	bl	8007300 <micros64>
 8005dba:	e9c7 0108 	strd	r0, r1, [r7, #32]
    canardHandleRxFrame(&instance->canard, &canard_frame, timestamp);
 8005dbe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005dc0:	f103 0208 	add.w	r2, r3, #8
 8005dc4:	f107 0310 	add.w	r3, r7, #16
 8005dc8:	4610      	mov	r0, r2
 8005dca:	4619      	mov	r1, r3
 8005dcc:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8005dd0:	f005 fb16 	bl	800b400 <canardHandleRxFrame>
    palClearPad(GPIOB, 3);
 8005dd4:	4b02      	ldr	r3, [pc, #8]	; (8005de0 <uavcan_can_rx_handler+0x5c>)
 8005dd6:	2208      	movs	r2, #8
 8005dd8:	615a      	str	r2, [r3, #20]
}
 8005dda:	3730      	adds	r7, #48	; 0x30
 8005ddc:	46bd      	mov	sp, r7
 8005dde:	bd80      	pop	{r7, pc}
 8005de0:	40010c00 	.word	0x40010c00

08005de4 <worker_thread_publisher_task_publish_I>:
    chSysLock();
    LINKED_LIST_REMOVE(struct worker_thread_publisher_task_s, worker_thread->publisher_task_list_head, task);
    chSysUnlock();
}

bool worker_thread_publisher_task_publish_I(struct worker_thread_publisher_task_s* task, struct pubsub_topic_s* topic, size_t size, pubsub_message_writer_func_ptr writer_cb, void* ctx) {
 8005de4:	b580      	push	{r7, lr}
 8005de6:	b086      	sub	sp, #24
 8005de8:	af00      	add	r7, sp, #0
 8005dea:	60f8      	str	r0, [r7, #12]
 8005dec:	60b9      	str	r1, [r7, #8]
 8005dee:	607a      	str	r2, [r7, #4]
 8005df0:	603b      	str	r3, [r7, #0]
    chDbgCheckClassI();
 8005df2:	f003 fee1 	bl	8009bb8 <chDbgCheckClassI>

    if (size > task->msg_max_size) {
 8005df6:	68fb      	ldr	r3, [r7, #12]
 8005df8:	681a      	ldr	r2, [r3, #0]
 8005dfa:	687b      	ldr	r3, [r7, #4]
 8005dfc:	429a      	cmp	r2, r3
 8005dfe:	d201      	bcs.n	8005e04 <worker_thread_publisher_task_publish_I+0x20>
        return false;
 8005e00:	2300      	movs	r3, #0
 8005e02:	e02c      	b.n	8005e5e <worker_thread_publisher_task_publish_I+0x7a>
    }

    struct worker_thread_publisher_msg_s* msg = chPoolAllocI(&task->pool);
 8005e04:	68fb      	ldr	r3, [r7, #12]
 8005e06:	3304      	adds	r3, #4
 8005e08:	4618      	mov	r0, r3
 8005e0a:	f002 ff1b 	bl	8008c44 <chPoolAllocI>
 8005e0e:	6178      	str	r0, [r7, #20]

    if (!msg || !topic) {
 8005e10:	697b      	ldr	r3, [r7, #20]
 8005e12:	2b00      	cmp	r3, #0
 8005e14:	d002      	beq.n	8005e1c <worker_thread_publisher_task_publish_I+0x38>
 8005e16:	68bb      	ldr	r3, [r7, #8]
 8005e18:	2b00      	cmp	r3, #0
 8005e1a:	d101      	bne.n	8005e20 <worker_thread_publisher_task_publish_I+0x3c>
        return false;
 8005e1c:	2300      	movs	r3, #0
 8005e1e:	e01e      	b.n	8005e5e <worker_thread_publisher_task_publish_I+0x7a>
    }

    msg->topic = topic;
 8005e20:	697b      	ldr	r3, [r7, #20]
 8005e22:	68ba      	ldr	r2, [r7, #8]
 8005e24:	601a      	str	r2, [r3, #0]
    msg->size = size;
 8005e26:	697b      	ldr	r3, [r7, #20]
 8005e28:	687a      	ldr	r2, [r7, #4]
 8005e2a:	605a      	str	r2, [r3, #4]

    if (writer_cb) {
 8005e2c:	683b      	ldr	r3, [r7, #0]
 8005e2e:	2b00      	cmp	r3, #0
 8005e30:	d007      	beq.n	8005e42 <worker_thread_publisher_task_publish_I+0x5e>
        writer_cb(size, msg->data, ctx);
 8005e32:	697b      	ldr	r3, [r7, #20]
 8005e34:	f103 0208 	add.w	r2, r3, #8
 8005e38:	683b      	ldr	r3, [r7, #0]
 8005e3a:	6878      	ldr	r0, [r7, #4]
 8005e3c:	4611      	mov	r1, r2
 8005e3e:	6a3a      	ldr	r2, [r7, #32]
 8005e40:	4798      	blx	r3
    }

    chMBPostI(&task->mailbox, (msg_t)msg);
 8005e42:	68fb      	ldr	r3, [r7, #12]
 8005e44:	f103 0210 	add.w	r2, r3, #16
 8005e48:	697b      	ldr	r3, [r7, #20]
 8005e4a:	4610      	mov	r0, r2
 8005e4c:	4619      	mov	r1, r3
 8005e4e:	f003 fd5b 	bl	8009908 <chMBPostI>

    worker_thread_wake_I(task->worker_thread);
 8005e52:	68fb      	ldr	r3, [r7, #12]
 8005e54:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005e56:	4618      	mov	r0, r3
 8005e58:	f000 f8be 	bl	8005fd8 <worker_thread_wake_I.lto_priv.136>
    return true;
 8005e5c:	2301      	movs	r3, #1
}
 8005e5e:	4618      	mov	r0, r3
 8005e60:	3718      	adds	r7, #24
 8005e62:	46bd      	mov	sp, r7
 8005e64:	bd80      	pop	{r7, pc}
 8005e66:	bf00      	nop

08005e68 <worker_thread_takeover>:
#endif

void worker_thread_takeover(struct worker_thread_s* worker_thread) {
 8005e68:	b580      	push	{r7, lr}
 8005e6a:	b088      	sub	sp, #32
 8005e6c:	af00      	add	r7, sp, #0
 8005e6e:	6078      	str	r0, [r7, #4]
    chRegSetThreadName(worker_thread->name);
 8005e70:	687b      	ldr	r3, [r7, #4]
 8005e72:	681b      	ldr	r3, [r3, #0]
 8005e74:	4618      	mov	r0, r3
 8005e76:	f001 ff4b 	bl	8007d10 <chRegSetThreadName.lto_priv.107>
    chThdSetPriority(worker_thread->priority);
 8005e7a:	687b      	ldr	r3, [r7, #4]
 8005e7c:	685b      	ldr	r3, [r3, #4]
 8005e7e:	4618      	mov	r0, r3
 8005e80:	f003 f8e6 	bl	8009050 <chThdSetPriority>
    worker_thread->thread = chThdGetSelfX();
 8005e84:	f001 ff38 	bl	8007cf8 <chThdGetSelfX.lto_priv.106>
 8005e88:	4602      	mov	r2, r0
 8005e8a:	687b      	ldr	r3, [r7, #4]
 8005e8c:	609a      	str	r2, [r3, #8]

    while (true) {
#ifdef MODULE_PUBSUB_ENABLED
        // Handle publisher tasks
        {
            chSysLock();
 8005e8e:	f001 ff07 	bl	8007ca0 <chSysLock.lto_priv.98>
            struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
 8005e92:	687b      	ldr	r3, [r7, #4]
 8005e94:	699b      	ldr	r3, [r3, #24]
 8005e96:	61fb      	str	r3, [r7, #28]
            chSysUnlock();
 8005e98:	f001 ff0a 	bl	8007cb0 <chSysUnlock.lto_priv.96>
 8005e9c:	e025      	b.n	8005eea <worker_thread_takeover+0x82>
            while (task) {
                struct worker_thread_publisher_msg_s* msg;
                while (chMBFetch(&task->mailbox, (msg_t*)&msg, TIME_IMMEDIATE) == MSG_OK) {
                    pubsub_publish_message(msg->topic, msg->size, pubsub_copy_writer_func, msg->data);
 8005e9e:	68fb      	ldr	r3, [r7, #12]
 8005ea0:	6819      	ldr	r1, [r3, #0]
 8005ea2:	68fb      	ldr	r3, [r7, #12]
 8005ea4:	685a      	ldr	r2, [r3, #4]
 8005ea6:	68fb      	ldr	r3, [r7, #12]
 8005ea8:	3308      	adds	r3, #8
 8005eaa:	4608      	mov	r0, r1
 8005eac:	4611      	mov	r1, r2
 8005eae:	4a43      	ldr	r2, [pc, #268]	; (8005fbc <worker_thread_takeover+0x154>)
 8005eb0:	f001 fd42 	bl	8007938 <pubsub_publish_message>
                    chPoolFree(&task->pool, msg);
 8005eb4:	69fb      	ldr	r3, [r7, #28]
 8005eb6:	1d1a      	adds	r2, r3, #4
 8005eb8:	68fb      	ldr	r3, [r7, #12]
 8005eba:	4610      	mov	r0, r2
 8005ebc:	4619      	mov	r1, r3
 8005ebe:	f002 ff1d 	bl	8008cfc <chPoolFree>
            chSysLock();
            struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
            chSysUnlock();
            while (task) {
                struct worker_thread_publisher_msg_s* msg;
                while (chMBFetch(&task->mailbox, (msg_t*)&msg, TIME_IMMEDIATE) == MSG_OK) {
 8005ec2:	69fb      	ldr	r3, [r7, #28]
 8005ec4:	f103 0210 	add.w	r2, r3, #16
 8005ec8:	f107 030c 	add.w	r3, r7, #12
 8005ecc:	4610      	mov	r0, r2
 8005ece:	4619      	mov	r1, r3
 8005ed0:	2200      	movs	r2, #0
 8005ed2:	f002 fd01 	bl	80088d8 <chMBFetch>
 8005ed6:	4603      	mov	r3, r0
 8005ed8:	2b00      	cmp	r3, #0
 8005eda:	d0e0      	beq.n	8005e9e <worker_thread_takeover+0x36>
                    pubsub_publish_message(msg->topic, msg->size, pubsub_copy_writer_func, msg->data);
                    chPoolFree(&task->pool, msg);
                }
                chSysLock();
 8005edc:	f001 fee0 	bl	8007ca0 <chSysLock.lto_priv.98>
                task = task->next;
 8005ee0:	69fb      	ldr	r3, [r7, #28]
 8005ee2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8005ee4:	61fb      	str	r3, [r7, #28]
                chSysUnlock();
 8005ee6:	f001 fee3 	bl	8007cb0 <chSysUnlock.lto_priv.96>
        // Handle publisher tasks
        {
            chSysLock();
            struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
            chSysUnlock();
            while (task) {
 8005eea:	69fb      	ldr	r3, [r7, #28]
 8005eec:	2b00      	cmp	r3, #0
 8005eee:	d1e8      	bne.n	8005ec2 <worker_thread_takeover+0x5a>
            }
        }

        // Check for immediately available messages on listener tasks, handle one
        {
            chSysLock();
 8005ef0:	f001 fed6 	bl	8007ca0 <chSysLock.lto_priv.98>
            struct worker_thread_listener_task_s* listener_task = worker_thread->listener_task_list_head;
 8005ef4:	687b      	ldr	r3, [r7, #4]
 8005ef6:	695b      	ldr	r3, [r3, #20]
 8005ef8:	61bb      	str	r3, [r7, #24]
            chSysUnlock();
 8005efa:	f001 fed9 	bl	8007cb0 <chSysUnlock.lto_priv.96>
 8005efe:	e00e      	b.n	8005f1e <worker_thread_takeover+0xb6>
            while (listener_task) {
                if (pubsub_listener_handle_one_timeout(&listener_task->listener, TIME_IMMEDIATE)) {
 8005f00:	69bb      	ldr	r3, [r7, #24]
 8005f02:	4618      	mov	r0, r3
 8005f04:	2100      	movs	r1, #0
 8005f06:	f001 fda3 	bl	8007a50 <pubsub_listener_handle_one_timeout>
 8005f0a:	4603      	mov	r3, r0
 8005f0c:	2b00      	cmp	r3, #0
 8005f0e:	d109      	bne.n	8005f24 <worker_thread_takeover+0xbc>
                    break;
                }
                chSysLock();
 8005f10:	f001 fec6 	bl	8007ca0 <chSysLock.lto_priv.98>
                listener_task = listener_task->next;
 8005f14:	69bb      	ldr	r3, [r7, #24]
 8005f16:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005f18:	61bb      	str	r3, [r7, #24]
                chSysUnlock();
 8005f1a:	f001 fec9 	bl	8007cb0 <chSysUnlock.lto_priv.96>
        // Check for immediately available messages on listener tasks, handle one
        {
            chSysLock();
            struct worker_thread_listener_task_s* listener_task = worker_thread->listener_task_list_head;
            chSysUnlock();
            while (listener_task) {
 8005f1e:	69bb      	ldr	r3, [r7, #24]
 8005f20:	2b00      	cmp	r3, #0
 8005f22:	d1ed      	bne.n	8005f00 <worker_thread_takeover+0x98>
                listener_task = listener_task->next;
                chSysUnlock();
            }
        }
#endif
        chSysLock();
 8005f24:	f001 febc 	bl	8007ca0 <chSysLock.lto_priv.98>
        systime_t tnow_ticks = chVTGetSystemTimeX();
 8005f28:	f001 fede 	bl	8007ce8 <chVTGetSystemTimeX.lto_priv.89>
 8005f2c:	4603      	mov	r3, r0
 8005f2e:	82fb      	strh	r3, [r7, #22]
        systime_t ticks_to_next_timer_task = worker_thread_get_ticks_to_timer_task_I(worker_thread->timer_task_list_head, tnow_ticks);
 8005f30:	687b      	ldr	r3, [r7, #4]
 8005f32:	691a      	ldr	r2, [r3, #16]
 8005f34:	8afb      	ldrh	r3, [r7, #22]
 8005f36:	4610      	mov	r0, r2
 8005f38:	4619      	mov	r1, r3
 8005f3a:	f000 f8e9 	bl	8006110 <worker_thread_get_ticks_to_timer_task_I>
 8005f3e:	4603      	mov	r3, r0
 8005f40:	82bb      	strh	r3, [r7, #20]
        if (ticks_to_next_timer_task == TIME_IMMEDIATE) {
 8005f42:	8abb      	ldrh	r3, [r7, #20]
 8005f44:	2b00      	cmp	r3, #0
 8005f46:	d11c      	bne.n	8005f82 <worker_thread_takeover+0x11a>
            // Task is due - pop the task off the task list, run it, reschedule if task is auto-repeat
            struct worker_thread_timer_task_s* next_timer_task = worker_thread->timer_task_list_head;
 8005f48:	687b      	ldr	r3, [r7, #4]
 8005f4a:	691b      	ldr	r3, [r3, #16]
 8005f4c:	613b      	str	r3, [r7, #16]
            worker_thread->timer_task_list_head = next_timer_task->next;
 8005f4e:	693b      	ldr	r3, [r7, #16]
 8005f50:	691a      	ldr	r2, [r3, #16]
 8005f52:	687b      	ldr	r3, [r7, #4]
 8005f54:	611a      	str	r2, [r3, #16]

            chSysUnlock();
 8005f56:	f001 feab 	bl	8007cb0 <chSysUnlock.lto_priv.96>

            // Perform task
            next_timer_task->task_func(next_timer_task);
 8005f5a:	693b      	ldr	r3, [r7, #16]
 8005f5c:	681b      	ldr	r3, [r3, #0]
 8005f5e:	6938      	ldr	r0, [r7, #16]
 8005f60:	4798      	blx	r3
            next_timer_task->timer_begin_systime = tnow_ticks;
 8005f62:	693b      	ldr	r3, [r7, #16]
 8005f64:	8afa      	ldrh	r2, [r7, #22]
 8005f66:	815a      	strh	r2, [r3, #10]

            if (next_timer_task->auto_repeat) {
 8005f68:	693b      	ldr	r3, [r7, #16]
 8005f6a:	7b1b      	ldrb	r3, [r3, #12]
 8005f6c:	2b00      	cmp	r3, #0
 8005f6e:	d08e      	beq.n	8005e8e <worker_thread_takeover+0x26>
                // Re-insert task
                chSysLock();
 8005f70:	f001 fe96 	bl	8007ca0 <chSysLock.lto_priv.98>
                worker_thread_insert_timer_task_I(worker_thread, next_timer_task);
 8005f74:	6878      	ldr	r0, [r7, #4]
 8005f76:	6939      	ldr	r1, [r7, #16]
 8005f78:	f000 f88a 	bl	8006090 <worker_thread_insert_timer_task_I.lto_priv.137>
                chSysUnlock();
 8005f7c:	f001 fe98 	bl	8007cb0 <chSysUnlock.lto_priv.96>
 8005f80:	e785      	b.n	8005e8e <worker_thread_takeover+0x26>
            }
        } else {
#ifdef MODULE_PUBSUB_ENABLED
            // If a listener task is due, we should not sleep until we've handled it
            if (worker_thread_get_any_listener_task_due_I(worker_thread)) {
 8005f82:	6878      	ldr	r0, [r7, #4]
 8005f84:	f000 f95a 	bl	800623c <worker_thread_get_any_listener_task_due_I>
 8005f88:	4603      	mov	r3, r0
 8005f8a:	2b00      	cmp	r3, #0
 8005f8c:	d002      	beq.n	8005f94 <worker_thread_takeover+0x12c>
                chSysUnlock();
 8005f8e:	f001 fe8f 	bl	8007cb0 <chSysUnlock.lto_priv.96>
 8005f92:	e77c      	b.n	8005e8e <worker_thread_takeover+0x26>
                continue;
            }

            // If a publisher task is due, we should not sleep until we've handled it
            if (worker_thread_get_any_publisher_task_due_I(worker_thread)) {
 8005f94:	6878      	ldr	r0, [r7, #4]
 8005f96:	f000 f901 	bl	800619c <worker_thread_get_any_publisher_task_due_I>
 8005f9a:	4603      	mov	r3, r0
 8005f9c:	2b00      	cmp	r3, #0
 8005f9e:	d002      	beq.n	8005fa6 <worker_thread_takeover+0x13e>
                chSysUnlock();
 8005fa0:	f001 fe86 	bl	8007cb0 <chSysUnlock.lto_priv.96>
 8005fa4:	e773      	b.n	8005e8e <worker_thread_takeover+0x26>
                continue;
            }
#endif

            // No task due - go to sleep until there is a task
            chThdSuspendTimeoutS(&worker_thread->suspend_trp, ticks_to_next_timer_task);
 8005fa6:	687b      	ldr	r3, [r7, #4]
 8005fa8:	f103 020c 	add.w	r2, r3, #12
 8005fac:	8abb      	ldrh	r3, [r7, #20]
 8005fae:	4610      	mov	r0, r2
 8005fb0:	4619      	mov	r1, r3
 8005fb2:	f003 f881 	bl	80090b8 <chThdSuspendTimeoutS>

            chSysUnlock();
 8005fb6:	f001 fe7b 	bl	8007cb0 <chSysUnlock.lto_priv.96>
 8005fba:	e768      	b.n	8005e8e <worker_thread_takeover+0x26>
 8005fbc:	080078a9 	.word	0x080078a9

08005fc0 <worker_thread_func.lto_priv.111>:
        }
    }
}

static THD_FUNCTION(worker_thread_func, arg) {
 8005fc0:	b580      	push	{r7, lr}
 8005fc2:	b084      	sub	sp, #16
 8005fc4:	af00      	add	r7, sp, #0
 8005fc6:	6078      	str	r0, [r7, #4]
    struct worker_thread_s* worker_thread = arg;
 8005fc8:	687b      	ldr	r3, [r7, #4]
 8005fca:	60fb      	str	r3, [r7, #12]
    worker_thread_takeover(worker_thread);
 8005fcc:	68f8      	ldr	r0, [r7, #12]
 8005fce:	f7ff ff4b 	bl	8005e68 <worker_thread_takeover>
}
 8005fd2:	3710      	adds	r7, #16
 8005fd4:	46bd      	mov	sp, r7
 8005fd6:	bd80      	pop	{r7, pc}

08005fd8 <worker_thread_wake_I.lto_priv.136>:

static void worker_thread_wake_I(struct worker_thread_s* worker_thread) {
 8005fd8:	b580      	push	{r7, lr}
 8005fda:	b082      	sub	sp, #8
 8005fdc:	af00      	add	r7, sp, #0
 8005fde:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
 8005fe0:	f003 fdea 	bl	8009bb8 <chDbgCheckClassI>

    chThdResumeI(&worker_thread->suspend_trp, MSG_TIMEOUT);
 8005fe4:	687b      	ldr	r3, [r7, #4]
 8005fe6:	330c      	adds	r3, #12
 8005fe8:	4618      	mov	r0, r3
 8005fea:	f04f 31ff 	mov.w	r1, #4294967295
 8005fee:	f003 f88b 	bl	8009108 <chThdResumeI>
}
 8005ff2:	3708      	adds	r7, #8
 8005ff4:	46bd      	mov	sp, r7
 8005ff6:	bd80      	pop	{r7, pc}

08005ff8 <worker_thread_wake.lto_priv.134>:

static void worker_thread_wake(struct worker_thread_s* worker_thread) {
 8005ff8:	b580      	push	{r7, lr}
 8005ffa:	b082      	sub	sp, #8
 8005ffc:	af00      	add	r7, sp, #0
 8005ffe:	6078      	str	r0, [r7, #4]
    chThdResume(&worker_thread->suspend_trp, MSG_TIMEOUT);
 8006000:	687b      	ldr	r3, [r7, #4]
 8006002:	330c      	adds	r3, #12
 8006004:	4618      	mov	r0, r3
 8006006:	f04f 31ff 	mov.w	r1, #4294967295
 800600a:	f003 f8bf 	bl	800918c <chThdResume>
}
 800600e:	3708      	adds	r7, #8
 8006010:	46bd      	mov	sp, r7
 8006012:	bd80      	pop	{r7, pc}

08006014 <worker_thread_init_timer_task.lto_priv.138>:

static void worker_thread_init_timer_task(struct worker_thread_timer_task_s* task, systime_t timer_begin_systime, systime_t timer_expiration_ticks, bool auto_repeat, timer_task_handler_func_ptr task_func, void* ctx) {
 8006014:	b480      	push	{r7}
 8006016:	b085      	sub	sp, #20
 8006018:	af00      	add	r7, sp, #0
 800601a:	60f8      	str	r0, [r7, #12]
 800601c:	4608      	mov	r0, r1
 800601e:	4611      	mov	r1, r2
 8006020:	461a      	mov	r2, r3
 8006022:	4603      	mov	r3, r0
 8006024:	817b      	strh	r3, [r7, #10]
 8006026:	460b      	mov	r3, r1
 8006028:	813b      	strh	r3, [r7, #8]
 800602a:	4613      	mov	r3, r2
 800602c:	71fb      	strb	r3, [r7, #7]
    task->task_func = task_func;
 800602e:	68fb      	ldr	r3, [r7, #12]
 8006030:	69ba      	ldr	r2, [r7, #24]
 8006032:	601a      	str	r2, [r3, #0]
    task->ctx = ctx;
 8006034:	68fb      	ldr	r3, [r7, #12]
 8006036:	69fa      	ldr	r2, [r7, #28]
 8006038:	605a      	str	r2, [r3, #4]
    task->timer_expiration_ticks = timer_expiration_ticks;
 800603a:	68fb      	ldr	r3, [r7, #12]
 800603c:	893a      	ldrh	r2, [r7, #8]
 800603e:	811a      	strh	r2, [r3, #8]
    task->auto_repeat = auto_repeat;
 8006040:	68fb      	ldr	r3, [r7, #12]
 8006042:	79fa      	ldrb	r2, [r7, #7]
 8006044:	731a      	strb	r2, [r3, #12]
    task->timer_begin_systime = timer_begin_systime;
 8006046:	68fb      	ldr	r3, [r7, #12]
 8006048:	897a      	ldrh	r2, [r7, #10]
 800604a:	815a      	strh	r2, [r3, #10]
}
 800604c:	3714      	adds	r7, #20
 800604e:	46bd      	mov	sp, r7
 8006050:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006054:	4770      	bx	lr
 8006056:	bf00      	nop

08006058 <worker_thread_timer_task_is_registered_I>:

static bool worker_thread_timer_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* check_task) {
 8006058:	b580      	push	{r7, lr}
 800605a:	b084      	sub	sp, #16
 800605c:	af00      	add	r7, sp, #0
 800605e:	6078      	str	r0, [r7, #4]
 8006060:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 8006062:	f003 fda9 	bl	8009bb8 <chDbgCheckClassI>

    struct worker_thread_timer_task_s* task = worker_thread->timer_task_list_head;
 8006066:	687b      	ldr	r3, [r7, #4]
 8006068:	691b      	ldr	r3, [r3, #16]
 800606a:	60fb      	str	r3, [r7, #12]
 800606c:	e008      	b.n	8006080 <worker_thread_timer_task_is_registered_I+0x28>
    while (task) {
        if (task == check_task) {
 800606e:	68fa      	ldr	r2, [r7, #12]
 8006070:	683b      	ldr	r3, [r7, #0]
 8006072:	429a      	cmp	r2, r3
 8006074:	d101      	bne.n	800607a <worker_thread_timer_task_is_registered_I+0x22>
            return true;
 8006076:	2301      	movs	r3, #1
 8006078:	e006      	b.n	8006088 <worker_thread_timer_task_is_registered_I+0x30>
        }
        task = task->next;
 800607a:	68fb      	ldr	r3, [r7, #12]
 800607c:	691b      	ldr	r3, [r3, #16]
 800607e:	60fb      	str	r3, [r7, #12]

static bool worker_thread_timer_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* check_task) {
    chDbgCheckClassI();

    struct worker_thread_timer_task_s* task = worker_thread->timer_task_list_head;
    while (task) {
 8006080:	68fb      	ldr	r3, [r7, #12]
 8006082:	2b00      	cmp	r3, #0
 8006084:	d1f3      	bne.n	800606e <worker_thread_timer_task_is_registered_I+0x16>
        if (task == check_task) {
            return true;
        }
        task = task->next;
    }
    return false;
 8006086:	2300      	movs	r3, #0
}
 8006088:	4618      	mov	r0, r3
 800608a:	3710      	adds	r7, #16
 800608c:	46bd      	mov	sp, r7
 800608e:	bd80      	pop	{r7, pc}

08006090 <worker_thread_insert_timer_task_I.lto_priv.137>:

static void worker_thread_insert_timer_task_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task) {
 8006090:	b580      	push	{r7, lr}
 8006092:	b084      	sub	sp, #16
 8006094:	af00      	add	r7, sp, #0
 8006096:	6078      	str	r0, [r7, #4]
 8006098:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 800609a:	f003 fd8d 	bl	8009bb8 <chDbgCheckClassI>
    chDbgCheck(!worker_thread_timer_task_is_registered_I(worker_thread, task));
 800609e:	6878      	ldr	r0, [r7, #4]
 80060a0:	6839      	ldr	r1, [r7, #0]
 80060a2:	f7ff ffd9 	bl	8006058 <worker_thread_timer_task_is_registered_I>
 80060a6:	4603      	mov	r3, r0
 80060a8:	2b00      	cmp	r3, #0
 80060aa:	d002      	beq.n	80060b2 <worker_thread_insert_timer_task_I.lto_priv.137+0x22>
 80060ac:	4817      	ldr	r0, [pc, #92]	; (800610c <worker_thread_insert_timer_task_I.lto_priv.137+0x7c>)
 80060ae:	f003 fca5 	bl	80099fc <chSysHalt>

    if (task->timer_expiration_ticks == TIME_INFINITE) {
 80060b2:	683b      	ldr	r3, [r7, #0]
 80060b4:	891b      	ldrh	r3, [r3, #8]
 80060b6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80060ba:	4293      	cmp	r3, r2
 80060bc:	d022      	beq.n	8006104 <worker_thread_insert_timer_task_I.lto_priv.137+0x74>
        return;
    }

    systime_t task_run_time = task->timer_begin_systime + task->timer_expiration_ticks;
 80060be:	683b      	ldr	r3, [r7, #0]
 80060c0:	895a      	ldrh	r2, [r3, #10]
 80060c2:	683b      	ldr	r3, [r7, #0]
 80060c4:	891b      	ldrh	r3, [r3, #8]
 80060c6:	4413      	add	r3, r2
 80060c8:	817b      	strh	r3, [r7, #10]
    struct worker_thread_timer_task_s** insert_ptr = &worker_thread->timer_task_list_head;
 80060ca:	687b      	ldr	r3, [r7, #4]
 80060cc:	3310      	adds	r3, #16
 80060ce:	60fb      	str	r3, [r7, #12]
 80060d0:	e003      	b.n	80060da <worker_thread_insert_timer_task_I.lto_priv.137+0x4a>
    while (*insert_ptr && task_run_time - (*insert_ptr)->timer_begin_systime >= (*insert_ptr)->timer_expiration_ticks) {
        insert_ptr = &(*insert_ptr)->next;
 80060d2:	68fb      	ldr	r3, [r7, #12]
 80060d4:	681b      	ldr	r3, [r3, #0]
 80060d6:	3310      	adds	r3, #16
 80060d8:	60fb      	str	r3, [r7, #12]
        return;
    }

    systime_t task_run_time = task->timer_begin_systime + task->timer_expiration_ticks;
    struct worker_thread_timer_task_s** insert_ptr = &worker_thread->timer_task_list_head;
    while (*insert_ptr && task_run_time - (*insert_ptr)->timer_begin_systime >= (*insert_ptr)->timer_expiration_ticks) {
 80060da:	68fb      	ldr	r3, [r7, #12]
 80060dc:	681b      	ldr	r3, [r3, #0]
 80060de:	2b00      	cmp	r3, #0
 80060e0:	d009      	beq.n	80060f6 <worker_thread_insert_timer_task_I.lto_priv.137+0x66>
 80060e2:	897b      	ldrh	r3, [r7, #10]
 80060e4:	68fa      	ldr	r2, [r7, #12]
 80060e6:	6812      	ldr	r2, [r2, #0]
 80060e8:	8952      	ldrh	r2, [r2, #10]
 80060ea:	1a9b      	subs	r3, r3, r2
 80060ec:	68fa      	ldr	r2, [r7, #12]
 80060ee:	6812      	ldr	r2, [r2, #0]
 80060f0:	8912      	ldrh	r2, [r2, #8]
 80060f2:	4293      	cmp	r3, r2
 80060f4:	daed      	bge.n	80060d2 <worker_thread_insert_timer_task_I.lto_priv.137+0x42>
        insert_ptr = &(*insert_ptr)->next;
    }
    task->next = *insert_ptr;
 80060f6:	68fb      	ldr	r3, [r7, #12]
 80060f8:	681a      	ldr	r2, [r3, #0]
 80060fa:	683b      	ldr	r3, [r7, #0]
 80060fc:	611a      	str	r2, [r3, #16]
    *insert_ptr = task;
 80060fe:	68fb      	ldr	r3, [r7, #12]
 8006100:	683a      	ldr	r2, [r7, #0]
 8006102:	601a      	str	r2, [r3, #0]
}
 8006104:	3710      	adds	r7, #16
 8006106:	46bd      	mov	sp, r7
 8006108:	bd80      	pop	{r7, pc}
 800610a:	bf00      	nop
 800610c:	0800d124 	.word	0x0800d124

08006110 <worker_thread_get_ticks_to_timer_task_I>:

static systime_t worker_thread_get_ticks_to_timer_task_I(struct worker_thread_timer_task_s* task, systime_t tnow_ticks) {
 8006110:	b580      	push	{r7, lr}
 8006112:	b084      	sub	sp, #16
 8006114:	af00      	add	r7, sp, #0
 8006116:	6078      	str	r0, [r7, #4]
 8006118:	460b      	mov	r3, r1
 800611a:	807b      	strh	r3, [r7, #2]
    chDbgCheckClassI();
 800611c:	f003 fd4c 	bl	8009bb8 <chDbgCheckClassI>

    if (task && task->timer_expiration_ticks != TIME_INFINITE) {
 8006120:	687b      	ldr	r3, [r7, #4]
 8006122:	2b00      	cmp	r3, #0
 8006124:	d017      	beq.n	8006156 <worker_thread_get_ticks_to_timer_task_I+0x46>
 8006126:	687b      	ldr	r3, [r7, #4]
 8006128:	891b      	ldrh	r3, [r3, #8]
 800612a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800612e:	4293      	cmp	r3, r2
 8006130:	d011      	beq.n	8006156 <worker_thread_get_ticks_to_timer_task_I+0x46>
        systime_t elapsed = tnow_ticks - task->timer_begin_systime;
 8006132:	687b      	ldr	r3, [r7, #4]
 8006134:	895b      	ldrh	r3, [r3, #10]
 8006136:	887a      	ldrh	r2, [r7, #2]
 8006138:	1ad3      	subs	r3, r2, r3
 800613a:	81fb      	strh	r3, [r7, #14]
        if (elapsed >= task->timer_expiration_ticks) {
 800613c:	687b      	ldr	r3, [r7, #4]
 800613e:	891b      	ldrh	r3, [r3, #8]
 8006140:	89fa      	ldrh	r2, [r7, #14]
 8006142:	429a      	cmp	r2, r3
 8006144:	d301      	bcc.n	800614a <worker_thread_get_ticks_to_timer_task_I+0x3a>
            return TIME_IMMEDIATE;
 8006146:	2300      	movs	r3, #0
 8006148:	e007      	b.n	800615a <worker_thread_get_ticks_to_timer_task_I+0x4a>
        } else {
            return task->timer_expiration_ticks - elapsed;
 800614a:	687b      	ldr	r3, [r7, #4]
 800614c:	891a      	ldrh	r2, [r3, #8]
 800614e:	89fb      	ldrh	r3, [r7, #14]
 8006150:	1ad3      	subs	r3, r2, r3
 8006152:	b29b      	uxth	r3, r3
 8006154:	e001      	b.n	800615a <worker_thread_get_ticks_to_timer_task_I+0x4a>
        }
    } else {
        return TIME_INFINITE;
 8006156:	f64f 73ff 	movw	r3, #65535	; 0xffff
    }
}
 800615a:	4618      	mov	r0, r3
 800615c:	3710      	adds	r7, #16
 800615e:	46bd      	mov	sp, r7
 8006160:	bd80      	pop	{r7, pc}
 8006162:	bf00      	nop

08006164 <worker_thread_publisher_task_is_registered_I.lto_priv.133>:

#ifdef MODULE_PUBSUB_ENABLED
static bool worker_thread_publisher_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_publisher_task_s* check_task) {
 8006164:	b580      	push	{r7, lr}
 8006166:	b084      	sub	sp, #16
 8006168:	af00      	add	r7, sp, #0
 800616a:	6078      	str	r0, [r7, #4]
 800616c:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 800616e:	f003 fd23 	bl	8009bb8 <chDbgCheckClassI>

    struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
 8006172:	687b      	ldr	r3, [r7, #4]
 8006174:	699b      	ldr	r3, [r3, #24]
 8006176:	60fb      	str	r3, [r7, #12]
 8006178:	e008      	b.n	800618c <worker_thread_publisher_task_is_registered_I.lto_priv.133+0x28>
    while (task) {
        if (task == check_task) {
 800617a:	68fa      	ldr	r2, [r7, #12]
 800617c:	683b      	ldr	r3, [r7, #0]
 800617e:	429a      	cmp	r2, r3
 8006180:	d101      	bne.n	8006186 <worker_thread_publisher_task_is_registered_I.lto_priv.133+0x22>
            return true;
 8006182:	2301      	movs	r3, #1
 8006184:	e006      	b.n	8006194 <worker_thread_publisher_task_is_registered_I.lto_priv.133+0x30>
        }
        task = task->next;
 8006186:	68fb      	ldr	r3, [r7, #12]
 8006188:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800618a:	60fb      	str	r3, [r7, #12]
#ifdef MODULE_PUBSUB_ENABLED
static bool worker_thread_publisher_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_publisher_task_s* check_task) {
    chDbgCheckClassI();

    struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
    while (task) {
 800618c:	68fb      	ldr	r3, [r7, #12]
 800618e:	2b00      	cmp	r3, #0
 8006190:	d1f3      	bne.n	800617a <worker_thread_publisher_task_is_registered_I.lto_priv.133+0x16>
        if (task == check_task) {
            return true;
        }
        task = task->next;
    }
    return false;
 8006192:	2300      	movs	r3, #0
}
 8006194:	4618      	mov	r0, r3
 8006196:	3710      	adds	r7, #16
 8006198:	46bd      	mov	sp, r7
 800619a:	bd80      	pop	{r7, pc}

0800619c <worker_thread_get_any_publisher_task_due_I>:

static bool worker_thread_get_any_publisher_task_due_I(struct worker_thread_s* worker_thread) {
 800619c:	b580      	push	{r7, lr}
 800619e:	b084      	sub	sp, #16
 80061a0:	af00      	add	r7, sp, #0
 80061a2:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
 80061a4:	f003 fd08 	bl	8009bb8 <chDbgCheckClassI>

    struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
 80061a8:	687b      	ldr	r3, [r7, #4]
 80061aa:	699b      	ldr	r3, [r3, #24]
 80061ac:	60fb      	str	r3, [r7, #12]
 80061ae:	e00c      	b.n	80061ca <worker_thread_get_any_publisher_task_due_I+0x2e>
    while (task) {
        if (chMBGetUsedCountI(&task->mailbox) != 0) {
 80061b0:	68fb      	ldr	r3, [r7, #12]
 80061b2:	3310      	adds	r3, #16
 80061b4:	4618      	mov	r0, r3
 80061b6:	f001 fdbb 	bl	8007d30 <chMBGetUsedCountI.lto_priv.105>
 80061ba:	4603      	mov	r3, r0
 80061bc:	2b00      	cmp	r3, #0
 80061be:	d001      	beq.n	80061c4 <worker_thread_get_any_publisher_task_due_I+0x28>
            return true;
 80061c0:	2301      	movs	r3, #1
 80061c2:	e006      	b.n	80061d2 <worker_thread_get_any_publisher_task_due_I+0x36>
        }
        task = task->next;
 80061c4:	68fb      	ldr	r3, [r7, #12]
 80061c6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80061c8:	60fb      	str	r3, [r7, #12]

static bool worker_thread_get_any_publisher_task_due_I(struct worker_thread_s* worker_thread) {
    chDbgCheckClassI();

    struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
    while (task) {
 80061ca:	68fb      	ldr	r3, [r7, #12]
 80061cc:	2b00      	cmp	r3, #0
 80061ce:	d1ef      	bne.n	80061b0 <worker_thread_get_any_publisher_task_due_I+0x14>
        if (chMBGetUsedCountI(&task->mailbox) != 0) {
            return true;
        }
        task = task->next;
    }
    return false;
 80061d0:	2300      	movs	r3, #0
}
 80061d2:	4618      	mov	r0, r3
 80061d4:	3710      	adds	r7, #16
 80061d6:	46bd      	mov	sp, r7
 80061d8:	bd80      	pop	{r7, pc}
 80061da:	bf00      	nop

080061dc <worker_thread_listener_task_is_registered_I>:

static bool worker_thread_listener_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* check_task) {
 80061dc:	b580      	push	{r7, lr}
 80061de:	b084      	sub	sp, #16
 80061e0:	af00      	add	r7, sp, #0
 80061e2:	6078      	str	r0, [r7, #4]
 80061e4:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 80061e6:	f003 fce7 	bl	8009bb8 <chDbgCheckClassI>

    struct worker_thread_listener_task_s* task = worker_thread->listener_task_list_head;
 80061ea:	687b      	ldr	r3, [r7, #4]
 80061ec:	695b      	ldr	r3, [r3, #20]
 80061ee:	60fb      	str	r3, [r7, #12]
 80061f0:	e008      	b.n	8006204 <worker_thread_listener_task_is_registered_I+0x28>
    while (task) {
        if (task == check_task) {
 80061f2:	68fa      	ldr	r2, [r7, #12]
 80061f4:	683b      	ldr	r3, [r7, #0]
 80061f6:	429a      	cmp	r2, r3
 80061f8:	d101      	bne.n	80061fe <worker_thread_listener_task_is_registered_I+0x22>
            return true;
 80061fa:	2301      	movs	r3, #1
 80061fc:	e006      	b.n	800620c <worker_thread_listener_task_is_registered_I+0x30>
        }
        task = task->next;
 80061fe:	68fb      	ldr	r3, [r7, #12]
 8006200:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006202:	60fb      	str	r3, [r7, #12]

static bool worker_thread_listener_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* check_task) {
    chDbgCheckClassI();

    struct worker_thread_listener_task_s* task = worker_thread->listener_task_list_head;
    while (task) {
 8006204:	68fb      	ldr	r3, [r7, #12]
 8006206:	2b00      	cmp	r3, #0
 8006208:	d1f3      	bne.n	80061f2 <worker_thread_listener_task_is_registered_I+0x16>
        if (task == check_task) {
            return true;
        }
        task = task->next;
    }
    return false;
 800620a:	2300      	movs	r3, #0
}
 800620c:	4618      	mov	r0, r3
 800620e:	3710      	adds	r7, #16
 8006210:	46bd      	mov	sp, r7
 8006212:	bd80      	pop	{r7, pc}

08006214 <worker_thread_listener_task_is_registered.lto_priv.135>:

static bool worker_thread_listener_task_is_registered(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* check_task) {
 8006214:	b580      	push	{r7, lr}
 8006216:	b084      	sub	sp, #16
 8006218:	af00      	add	r7, sp, #0
 800621a:	6078      	str	r0, [r7, #4]
 800621c:	6039      	str	r1, [r7, #0]
    chSysLock();
 800621e:	f001 fd3f 	bl	8007ca0 <chSysLock.lto_priv.98>
    bool ret = worker_thread_listener_task_is_registered_I(worker_thread, check_task);
 8006222:	6878      	ldr	r0, [r7, #4]
 8006224:	6839      	ldr	r1, [r7, #0]
 8006226:	f7ff ffd9 	bl	80061dc <worker_thread_listener_task_is_registered_I>
 800622a:	4603      	mov	r3, r0
 800622c:	73fb      	strb	r3, [r7, #15]
    chSysUnlock();
 800622e:	f001 fd3f 	bl	8007cb0 <chSysUnlock.lto_priv.96>
    return ret;
 8006232:	7bfb      	ldrb	r3, [r7, #15]
}
 8006234:	4618      	mov	r0, r3
 8006236:	3710      	adds	r7, #16
 8006238:	46bd      	mov	sp, r7
 800623a:	bd80      	pop	{r7, pc}

0800623c <worker_thread_get_any_listener_task_due_I>:

static bool worker_thread_get_any_listener_task_due_I(struct worker_thread_s* worker_thread) {
 800623c:	b580      	push	{r7, lr}
 800623e:	b084      	sub	sp, #16
 8006240:	af00      	add	r7, sp, #0
 8006242:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
 8006244:	f003 fcb8 	bl	8009bb8 <chDbgCheckClassI>

    struct worker_thread_listener_task_s* listener_task = worker_thread->listener_task_list_head;
 8006248:	687b      	ldr	r3, [r7, #4]
 800624a:	695b      	ldr	r3, [r3, #20]
 800624c:	60fb      	str	r3, [r7, #12]
 800624e:	e00b      	b.n	8006268 <worker_thread_get_any_listener_task_due_I+0x2c>
    while (listener_task) {
        if (pubsub_listener_has_message(&listener_task->listener)) {
 8006250:	68fb      	ldr	r3, [r7, #12]
 8006252:	4618      	mov	r0, r3
 8006254:	f001 fb16 	bl	8007884 <pubsub_listener_has_message>
 8006258:	4603      	mov	r3, r0
 800625a:	2b00      	cmp	r3, #0
 800625c:	d001      	beq.n	8006262 <worker_thread_get_any_listener_task_due_I+0x26>
            return true;
 800625e:	2301      	movs	r3, #1
 8006260:	e006      	b.n	8006270 <worker_thread_get_any_listener_task_due_I+0x34>
        }
        listener_task = listener_task->next;
 8006262:	68fb      	ldr	r3, [r7, #12]
 8006264:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006266:	60fb      	str	r3, [r7, #12]

static bool worker_thread_get_any_listener_task_due_I(struct worker_thread_s* worker_thread) {
    chDbgCheckClassI();

    struct worker_thread_listener_task_s* listener_task = worker_thread->listener_task_list_head;
    while (listener_task) {
 8006268:	68fb      	ldr	r3, [r7, #12]
 800626a:	2b00      	cmp	r3, #0
 800626c:	d1f0      	bne.n	8006250 <worker_thread_get_any_listener_task_due_I+0x14>
        if (pubsub_listener_has_message(&listener_task->listener)) {
            return true;
        }
        listener_task = listener_task->next;
    }
    return false;
 800626e:	2300      	movs	r3, #0
}
 8006270:	4618      	mov	r0, r3
 8006272:	3710      	adds	r7, #16
 8006274:	46bd      	mov	sp, r7
 8006276:	bd80      	pop	{r7, pc}

08006278 <port_lock.lto_priv.86>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006278:	b480      	push	{r7}
 800627a:	b083      	sub	sp, #12
 800627c:	af00      	add	r7, sp, #0
 800627e:	2320      	movs	r3, #32
 8006280:	607b      	str	r3, [r7, #4]
 8006282:	687b      	ldr	r3, [r7, #4]
 8006284:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006288:	370c      	adds	r7, #12
 800628a:	46bd      	mov	sp, r7
 800628c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006290:	4770      	bx	lr
 8006292:	bf00      	nop

08006294 <port_unlock.lto_priv.83>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006294:	b480      	push	{r7}
 8006296:	b083      	sub	sp, #12
 8006298:	af00      	add	r7, sp, #0
 800629a:	2300      	movs	r3, #0
 800629c:	607b      	str	r3, [r7, #4]
 800629e:	687b      	ldr	r3, [r7, #4]
 80062a0:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80062a4:	370c      	adds	r7, #12
 80062a6:	46bd      	mov	sp, r7
 80062a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80062ac:	4770      	bx	lr
 80062ae:	bf00      	nop

080062b0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80062b0:	b580      	push	{r7, lr}
 80062b2:	af00      	add	r7, sp, #0

  port_lock();
 80062b4:	f7ff ffe0 	bl	8006278 <port_lock.lto_priv.86>
}
 80062b8:	bd80      	pop	{r7, pc}
 80062ba:	bf00      	nop

080062bc <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80062bc:	b580      	push	{r7, lr}
 80062be:	af00      	add	r7, sp, #0

  port_unlock();
 80062c0:	f7ff ffe8 	bl	8006294 <port_unlock.lto_priv.83>
}
 80062c4:	bd80      	pop	{r7, pc}
 80062c6:	bf00      	nop

080062c8 <st_lld_get_counter.lto_priv.80>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 80062c8:	b480      	push	{r7}
 80062ca:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 80062cc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80062d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80062d2:	b29b      	uxth	r3, r3
}
 80062d4:	4618      	mov	r0, r3
 80062d6:	46bd      	mov	sp, r7
 80062d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80062dc:	4770      	bx	lr
 80062de:	bf00      	nop

080062e0 <port_timer_get_time.lto_priv.77>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 80062e0:	b580      	push	{r7, lr}
 80062e2:	af00      	add	r7, sp, #0

  return stGetCounter();
 80062e4:	f7ff fff0 	bl	80062c8 <st_lld_get_counter.lto_priv.80>
 80062e8:	4603      	mov	r3, r0
}
 80062ea:	4618      	mov	r0, r3
 80062ec:	bd80      	pop	{r7, pc}
 80062ee:	bf00      	nop

080062f0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80062f0:	b580      	push	{r7, lr}
 80062f2:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 80062f4:	f7ff ffdc 	bl	80062b0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80062f8:	f003 fbfa 	bl	8009af0 <_dbg_check_lock_from_isr>
}
 80062fc:	bd80      	pop	{r7, pc}
 80062fe:	bf00      	nop

08006300 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8006300:	b580      	push	{r7, lr}
 8006302:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
 8006304:	f003 fc0a 	bl	8009b1c <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8006308:	f7ff ffd8 	bl	80062bc <port_unlock_from_isr>
}
 800630c:	bd80      	pop	{r7, pc}
 800630e:	bf00      	nop

08006310 <chVTGetSystemTimeX.lto_priv.90>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8006310:	b580      	push	{r7, lr}
 8006312:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8006314:	f7ff ffe4 	bl	80062e0 <port_timer_get_time.lto_priv.77>
 8006318:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800631a:	4618      	mov	r0, r3
 800631c:	bd80      	pop	{r7, pc}
 800631e:	bf00      	nop

08006320 <_local_ctor_41>:
    CAN_TypeDef* can;
};

static struct can_driver_stm32_instance_s can1_instance;

RUN_ON(CAN_INIT) {
 8006320:	b580      	push	{r7, lr}
 8006322:	b082      	sub	sp, #8
 8006324:	af02      	add	r7, sp, #8
    // TODO make this index configurable and enable multiple instances
    can1_instance.can = CAN1;
 8006326:	4b09      	ldr	r3, [pc, #36]	; (800634c <_local_ctor_41+0x2c>)
 8006328:	4a09      	ldr	r2, [pc, #36]	; (8006350 <_local_ctor_41+0x30>)
 800632a:	605a      	str	r2, [r3, #4]
    can1_instance.frontend = can_driver_register(0, &can1_instance, &can_driver_stm32_iface, NUM_TX_MAILBOXES, NUM_RX_MAILBOXES, RX_FIFO_DEPTH);
 800632c:	2302      	movs	r3, #2
 800632e:	9300      	str	r3, [sp, #0]
 8006330:	2303      	movs	r3, #3
 8006332:	9301      	str	r3, [sp, #4]
 8006334:	2000      	movs	r0, #0
 8006336:	4905      	ldr	r1, [pc, #20]	; (800634c <_local_ctor_41+0x2c>)
 8006338:	4a06      	ldr	r2, [pc, #24]	; (8006354 <_local_ctor_41+0x34>)
 800633a:	2303      	movs	r3, #3
 800633c:	f7fe fb86 	bl	8004a4c <can_driver_register>
 8006340:	4602      	mov	r2, r0
 8006342:	4b02      	ldr	r3, [pc, #8]	; (800634c <_local_ctor_41+0x2c>)
 8006344:	601a      	str	r2, [r3, #0]
}
 8006346:	46bd      	mov	sp, r7
 8006348:	bd80      	pop	{r7, pc}
 800634a:	bf00      	nop
 800634c:	200013dc 	.word	0x200013dc
 8006350:	40006400 	.word	0x40006400
 8006354:	0800d148 	.word	0x0800d148

08006358 <can_driver_stm32_start.lto_priv.14>:

static void can_driver_stm32_start(void* ctx, bool silent, bool auto_retransmit, uint32_t baudrate) {
 8006358:	b580      	push	{r7, lr}
 800635a:	b08c      	sub	sp, #48	; 0x30
 800635c:	af00      	add	r7, sp, #0
 800635e:	60f8      	str	r0, [r7, #12]
 8006360:	607b      	str	r3, [r7, #4]
 8006362:	460b      	mov	r3, r1
 8006364:	72fb      	strb	r3, [r7, #11]
 8006366:	4613      	mov	r3, r2
 8006368:	72bb      	strb	r3, [r7, #10]
    struct can_driver_stm32_instance_s* instance = ctx;
 800636a:	68fb      	ldr	r3, [r7, #12]
 800636c:	62bb      	str	r3, [r7, #40]	; 0x28

    rccEnableCAN1(FALSE);
 800636e:	4a84      	ldr	r2, [pc, #528]	; (8006580 <can_driver_stm32_start.lto_priv.14+0x228>)
 8006370:	4b83      	ldr	r3, [pc, #524]	; (8006580 <can_driver_stm32_start.lto_priv.14+0x228>)
 8006372:	69db      	ldr	r3, [r3, #28]
 8006374:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8006378:	61d3      	str	r3, [r2, #28]

    instance->can->FMR = (instance->can->FMR & 0xFFFF0000) | CAN_FMR_FINIT;
 800637a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800637c:	685a      	ldr	r2, [r3, #4]
 800637e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006380:	685b      	ldr	r3, [r3, #4]
 8006382:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8006386:	0c1b      	lsrs	r3, r3, #16
 8006388:	041b      	lsls	r3, r3, #16
 800638a:	f043 0301 	orr.w	r3, r3, #1
 800638e:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    instance->can->sFilterRegister[0].FR1 = 0;
 8006392:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006394:	685b      	ldr	r3, [r3, #4]
 8006396:	2200      	movs	r2, #0
 8006398:	f8c3 2240 	str.w	r2, [r3, #576]	; 0x240
    instance->can->sFilterRegister[0].FR2 = 0;
 800639c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800639e:	685b      	ldr	r3, [r3, #4]
 80063a0:	2200      	movs	r2, #0
 80063a2:	f8c3 2244 	str.w	r2, [r3, #580]	; 0x244
    instance->can->FM1R = 0;
 80063a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80063a8:	685b      	ldr	r3, [r3, #4]
 80063aa:	2200      	movs	r2, #0
 80063ac:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
    instance->can->FFA1R = 0;
 80063b0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80063b2:	685b      	ldr	r3, [r3, #4]
 80063b4:	2200      	movs	r2, #0
 80063b6:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
    instance->can->FS1R = 1;
 80063ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80063bc:	685b      	ldr	r3, [r3, #4]
 80063be:	2201      	movs	r2, #1
 80063c0:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
    instance->can->FA1R = 1;
 80063c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80063c6:	685b      	ldr	r3, [r3, #4]
 80063c8:	2201      	movs	r2, #1
 80063ca:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c

    instance->can->FMR &= ~CAN_FMR_FINIT;
 80063ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80063d0:	685b      	ldr	r3, [r3, #4]
 80063d2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80063d4:	6852      	ldr	r2, [r2, #4]
 80063d6:	f8d2 2200 	ldr.w	r2, [r2, #512]	; 0x200
 80063da:	f022 0201 	bic.w	r2, r2, #1
 80063de:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200

    nvicEnableVector(STM32_CAN1_TX_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 80063e2:	2013      	movs	r0, #19
 80063e4:	210b      	movs	r1, #11
 80063e6:	f001 ff67 	bl	80082b8 <nvicEnableVector>
    nvicEnableVector(STM32_CAN1_RX0_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 80063ea:	2014      	movs	r0, #20
 80063ec:	210b      	movs	r1, #11
 80063ee:	f001 ff63 	bl	80082b8 <nvicEnableVector>
    nvicEnableVector(STM32_CAN1_SCE_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 80063f2:	2016      	movs	r0, #22
 80063f4:	210b      	movs	r1, #11
 80063f6:	f001 ff5f 	bl	80082b8 <nvicEnableVector>

    instance->can->MCR = CAN_MCR_INRQ;
 80063fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80063fc:	685b      	ldr	r3, [r3, #4]
 80063fe:	2201      	movs	r2, #1
 8006400:	601a      	str	r2, [r3, #0]
 8006402:	e000      	b.n	8006406 <can_driver_stm32_start.lto_priv.14+0xae>
    while((instance->can->MSR & CAN_MSR_INAK) == 0) {
        __asm__("nop");
 8006404:	bf00      	nop
    nvicEnableVector(STM32_CAN1_TX_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_RX0_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_SCE_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);

    instance->can->MCR = CAN_MCR_INRQ;
    while((instance->can->MSR & CAN_MSR_INAK) == 0) {
 8006406:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006408:	685b      	ldr	r3, [r3, #4]
 800640a:	685b      	ldr	r3, [r3, #4]
 800640c:	f003 0301 	and.w	r3, r3, #1
 8006410:	2b00      	cmp	r3, #0
 8006412:	d0f7      	beq.n	8006404 <can_driver_stm32_start.lto_priv.14+0xac>
    uint8_t bs1;
    uint8_t bs2;
    uint32_t prescaler;

    {
        const uint8_t max_quanta_per_bit = (baudrate >= 1000000) ? 10 : 17;
 8006414:	687b      	ldr	r3, [r7, #4]
 8006416:	4a5b      	ldr	r2, [pc, #364]	; (8006584 <can_driver_stm32_start.lto_priv.14+0x22c>)
 8006418:	4293      	cmp	r3, r2
 800641a:	d901      	bls.n	8006420 <can_driver_stm32_start.lto_priv.14+0xc8>
 800641c:	230a      	movs	r3, #10
 800641e:	e000      	b.n	8006422 <can_driver_stm32_start.lto_priv.14+0xca>
 8006420:	2311      	movs	r3, #17
 8006422:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        const uint32_t prescaler_bs = STM32_PCLK1 / baudrate;
 8006426:	4a58      	ldr	r2, [pc, #352]	; (8006588 <can_driver_stm32_start.lto_priv.14+0x230>)
 8006428:	687b      	ldr	r3, [r7, #4]
 800642a:	fbb2 f3f3 	udiv	r3, r2, r3
 800642e:	623b      	str	r3, [r7, #32]

        uint8_t bs1_bs2_sum = (uint8_t)(max_quanta_per_bit - 1);
 8006430:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8006434:	3b01      	subs	r3, #1
 8006436:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
 800643a:	e009      	b.n	8006450 <can_driver_stm32_start.lto_priv.14+0xf8>

        // Search for the highest valid prescalar value
        while ((prescaler_bs % (1 + bs1_bs2_sum)) != 0) {
            if (bs1_bs2_sum <= 2) {
 800643c:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8006440:	2b02      	cmp	r3, #2
 8006442:	f240 8099 	bls.w	8006578 <can_driver_stm32_start.lto_priv.14+0x220>
                return;
            }
            bs1_bs2_sum--;
 8006446:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 800644a:	3b01      	subs	r3, #1
 800644c:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
        const uint32_t prescaler_bs = STM32_PCLK1 / baudrate;

        uint8_t bs1_bs2_sum = (uint8_t)(max_quanta_per_bit - 1);

        // Search for the highest valid prescalar value
        while ((prescaler_bs % (1 + bs1_bs2_sum)) != 0) {
 8006450:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8006454:	3301      	adds	r3, #1
 8006456:	461a      	mov	r2, r3
 8006458:	6a3b      	ldr	r3, [r7, #32]
 800645a:	fbb3 f1f2 	udiv	r1, r3, r2
 800645e:	fb02 f201 	mul.w	r2, r2, r1
 8006462:	1a9b      	subs	r3, r3, r2
 8006464:	2b00      	cmp	r3, #0
 8006466:	d1e9      	bne.n	800643c <can_driver_stm32_start.lto_priv.14+0xe4>
                return;
            }
            bs1_bs2_sum--;
        }

        prescaler = prescaler_bs / (1 + bs1_bs2_sum);
 8006468:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 800646c:	3301      	adds	r3, #1
 800646e:	461a      	mov	r2, r3
 8006470:	6a3b      	ldr	r3, [r7, #32]
 8006472:	fbb3 f3f2 	udiv	r3, r3, r2
 8006476:	61fb      	str	r3, [r7, #28]
        if (prescaler < 1 || prescaler > 1024) {
 8006478:	69fb      	ldr	r3, [r7, #28]
 800647a:	2b00      	cmp	r3, #0
 800647c:	d07c      	beq.n	8006578 <can_driver_stm32_start.lto_priv.14+0x220>
 800647e:	69fb      	ldr	r3, [r7, #28]
 8006480:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8006484:	d878      	bhi.n	8006578 <can_driver_stm32_start.lto_priv.14+0x220>
            return;
        }

        // The recommended sample point location is 87.5% or 7/8. Compute the values of BS1 and BS2 that satisfy BS1+BS2 == bs1_bs2_sum and minimize ((1+BS1)/(1+BS1/BS2) - 7/8)
        bs1 = ((7 * bs1_bs2_sum - 1) + 4) / 8;
 8006486:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
 800648a:	4613      	mov	r3, r2
 800648c:	00db      	lsls	r3, r3, #3
 800648e:	1a9b      	subs	r3, r3, r2
 8006490:	3303      	adds	r3, #3
 8006492:	2b00      	cmp	r3, #0
 8006494:	da00      	bge.n	8006498 <can_driver_stm32_start.lto_priv.14+0x140>
 8006496:	3307      	adds	r3, #7
 8006498:	10db      	asrs	r3, r3, #3
 800649a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

        // Check sample point constraints
        const uint16_t max_sample_point_per_mille = 900;
 800649e:	f44f 7361 	mov.w	r3, #900	; 0x384
 80064a2:	837b      	strh	r3, [r7, #26]
        const uint16_t min_sample_point_per_mille = (baudrate >= 1000000) ? 750 : 850;
 80064a4:	687b      	ldr	r3, [r7, #4]
 80064a6:	4a37      	ldr	r2, [pc, #220]	; (8006584 <can_driver_stm32_start.lto_priv.14+0x22c>)
 80064a8:	4293      	cmp	r3, r2
 80064aa:	d902      	bls.n	80064b2 <can_driver_stm32_start.lto_priv.14+0x15a>
 80064ac:	f240 23ee 	movw	r3, #750	; 0x2ee
 80064b0:	e001      	b.n	80064b6 <can_driver_stm32_start.lto_priv.14+0x15e>
 80064b2:	f240 3352 	movw	r3, #850	; 0x352
 80064b6:	833b      	strh	r3, [r7, #24]

        if (1000 * (1 + bs1) / (1 + bs1_bs2_sum) >= max_sample_point_per_mille) {
 80064b8:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 80064bc:	3301      	adds	r3, #1
 80064be:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80064c2:	fb02 f203 	mul.w	r2, r2, r3
 80064c6:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 80064ca:	3301      	adds	r3, #1
 80064cc:	fb92 f2f3 	sdiv	r2, r2, r3
 80064d0:	8b7b      	ldrh	r3, [r7, #26]
 80064d2:	429a      	cmp	r2, r3
 80064d4:	db04      	blt.n	80064e0 <can_driver_stm32_start.lto_priv.14+0x188>
            bs1--;
 80064d6:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 80064da:	3b01      	subs	r3, #1
 80064dc:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        }

        if (1000 * (1 + bs1) / (1 + bs1_bs2_sum) < min_sample_point_per_mille) {
 80064e0:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 80064e4:	3301      	adds	r3, #1
 80064e6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80064ea:	fb02 f203 	mul.w	r2, r2, r3
 80064ee:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 80064f2:	3301      	adds	r3, #1
 80064f4:	fb92 f2f3 	sdiv	r2, r2, r3
 80064f8:	8b3b      	ldrh	r3, [r7, #24]
 80064fa:	429a      	cmp	r2, r3
 80064fc:	da04      	bge.n	8006508 <can_driver_stm32_start.lto_priv.14+0x1b0>
            bs1++;
 80064fe:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8006502:	3301      	adds	r3, #1
 8006504:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        }

        if (1000 * (1 + bs1) / (1 + bs1_bs2_sum) >= max_sample_point_per_mille) {
 8006508:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800650c:	3301      	adds	r3, #1
 800650e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8006512:	fb02 f203 	mul.w	r2, r2, r3
 8006516:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 800651a:	3301      	adds	r3, #1
 800651c:	fb92 f2f3 	sdiv	r2, r2, r3
 8006520:	8b7b      	ldrh	r3, [r7, #26]
 8006522:	429a      	cmp	r2, r3
 8006524:	da28      	bge.n	8006578 <can_driver_stm32_start.lto_priv.14+0x220>
            return;
        }

        bs2 = bs1_bs2_sum-bs1;
 8006526:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
 800652a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800652e:	1ad3      	subs	r3, r2, r3
 8006530:	75fb      	strb	r3, [r7, #23]
    }

    instance->can->BTR = (silent?CAN_BTR_SILM:0) | CAN_BTR_SJW(0) | CAN_BTR_TS1(bs1-1) | CAN_BTR_TS2(bs2-1) | CAN_BTR_BRP(prescaler - 1);
 8006532:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006534:	685b      	ldr	r3, [r3, #4]
 8006536:	7afa      	ldrb	r2, [r7, #11]
 8006538:	2a00      	cmp	r2, #0
 800653a:	d002      	beq.n	8006542 <can_driver_stm32_start.lto_priv.14+0x1ea>
 800653c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8006540:	e000      	b.n	8006544 <can_driver_stm32_start.lto_priv.14+0x1ec>
 8006542:	2200      	movs	r2, #0
 8006544:	f897 102f 	ldrb.w	r1, [r7, #47]	; 0x2f
 8006548:	3901      	subs	r1, #1
 800654a:	0409      	lsls	r1, r1, #16
 800654c:	430a      	orrs	r2, r1
 800654e:	7df9      	ldrb	r1, [r7, #23]
 8006550:	3901      	subs	r1, #1
 8006552:	0509      	lsls	r1, r1, #20
 8006554:	4311      	orrs	r1, r2
 8006556:	69fa      	ldr	r2, [r7, #28]
 8006558:	3a01      	subs	r2, #1
 800655a:	430a      	orrs	r2, r1
 800655c:	61da      	str	r2, [r3, #28]

    instance->can->MCR = CAN_MCR_ABOM | CAN_MCR_AWUM | (auto_retransmit?0:CAN_MCR_NART);
 800655e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006560:	685b      	ldr	r3, [r3, #4]
 8006562:	7aba      	ldrb	r2, [r7, #10]
 8006564:	2a00      	cmp	r2, #0
 8006566:	d001      	beq.n	800656c <can_driver_stm32_start.lto_priv.14+0x214>
 8006568:	2260      	movs	r2, #96	; 0x60
 800656a:	e000      	b.n	800656e <can_driver_stm32_start.lto_priv.14+0x216>
 800656c:	2270      	movs	r2, #112	; 0x70
 800656e:	601a      	str	r2, [r3, #0]

    instance->can->IER = CAN_IER_TMEIE | CAN_IER_FMPIE0; // TODO: review reference manual for other interrupt flags needed
 8006570:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006572:	685b      	ldr	r3, [r3, #4]
 8006574:	2203      	movs	r2, #3
 8006576:	615a      	str	r2, [r3, #20]
}
 8006578:	3730      	adds	r7, #48	; 0x30
 800657a:	46bd      	mov	sp, r7
 800657c:	bd80      	pop	{r7, pc}
 800657e:	bf00      	nop
 8006580:	40021000 	.word	0x40021000
 8006584:	000f423f 	.word	0x000f423f
 8006588:	02255100 	.word	0x02255100

0800658c <can_driver_stm32_stop.lto_priv.15>:

static void can_driver_stm32_stop(void* ctx) {
 800658c:	b580      	push	{r7, lr}
 800658e:	b084      	sub	sp, #16
 8006590:	af00      	add	r7, sp, #0
 8006592:	6078      	str	r0, [r7, #4]
    struct can_driver_stm32_instance_s* instance = ctx;
 8006594:	687b      	ldr	r3, [r7, #4]
 8006596:	60fb      	str	r3, [r7, #12]

    instance->can->MCR = 0x00010002;
 8006598:	68fb      	ldr	r3, [r7, #12]
 800659a:	685b      	ldr	r3, [r3, #4]
 800659c:	4a0b      	ldr	r2, [pc, #44]	; (80065cc <can_driver_stm32_stop.lto_priv.15+0x40>)
 800659e:	601a      	str	r2, [r3, #0]
    instance->can->IER = 0x00000000;
 80065a0:	68fb      	ldr	r3, [r7, #12]
 80065a2:	685b      	ldr	r3, [r3, #4]
 80065a4:	2200      	movs	r2, #0
 80065a6:	615a      	str	r2, [r3, #20]

    nvicDisableVector(STM32_CAN1_TX_NUMBER);
 80065a8:	2013      	movs	r0, #19
 80065aa:	f001 feb3 	bl	8008314 <nvicDisableVector>
    nvicDisableVector(STM32_CAN1_RX0_NUMBER);
 80065ae:	2014      	movs	r0, #20
 80065b0:	f001 feb0 	bl	8008314 <nvicDisableVector>
    nvicDisableVector(STM32_CAN1_SCE_NUMBER);
 80065b4:	2016      	movs	r0, #22
 80065b6:	f001 fead 	bl	8008314 <nvicDisableVector>

    rccDisableCAN1(FALSE);
 80065ba:	4a05      	ldr	r2, [pc, #20]	; (80065d0 <can_driver_stm32_stop.lto_priv.15+0x44>)
 80065bc:	4b04      	ldr	r3, [pc, #16]	; (80065d0 <can_driver_stm32_stop.lto_priv.15+0x44>)
 80065be:	69db      	ldr	r3, [r3, #28]
 80065c0:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 80065c4:	61d3      	str	r3, [r2, #28]
}
 80065c6:	3710      	adds	r7, #16
 80065c8:	46bd      	mov	sp, r7
 80065ca:	bd80      	pop	{r7, pc}
 80065cc:	00010002 	.word	0x00010002
 80065d0:	40021000 	.word	0x40021000

080065d4 <can_driver_stm32_abort_tx_mailbox_I>:

bool can_driver_stm32_abort_tx_mailbox_I(void* ctx, uint8_t mb_idx) {
 80065d4:	b580      	push	{r7, lr}
 80065d6:	b084      	sub	sp, #16
 80065d8:	af00      	add	r7, sp, #0
 80065da:	6078      	str	r0, [r7, #4]
 80065dc:	460b      	mov	r3, r1
 80065de:	70fb      	strb	r3, [r7, #3]
    struct can_driver_stm32_instance_s* instance = ctx;
 80065e0:	687b      	ldr	r3, [r7, #4]
 80065e2:	60fb      	str	r3, [r7, #12]

    chDbgCheckClassI();
 80065e4:	f003 fae8 	bl	8009bb8 <chDbgCheckClassI>

    switch(mb_idx) {
 80065e8:	78fb      	ldrb	r3, [r7, #3]
 80065ea:	2b01      	cmp	r3, #1
 80065ec:	d009      	beq.n	8006602 <can_driver_stm32_abort_tx_mailbox_I+0x2e>
 80065ee:	2b02      	cmp	r3, #2
 80065f0:	d00e      	beq.n	8006610 <can_driver_stm32_abort_tx_mailbox_I+0x3c>
 80065f2:	2b00      	cmp	r3, #0
 80065f4:	d113      	bne.n	800661e <can_driver_stm32_abort_tx_mailbox_I+0x4a>
        case 0:
            instance->can->TSR = CAN_TSR_ABRQ0;
 80065f6:	68fb      	ldr	r3, [r7, #12]
 80065f8:	685b      	ldr	r3, [r3, #4]
 80065fa:	2280      	movs	r2, #128	; 0x80
 80065fc:	609a      	str	r2, [r3, #8]
            return true;
 80065fe:	2301      	movs	r3, #1
 8006600:	e00e      	b.n	8006620 <can_driver_stm32_abort_tx_mailbox_I+0x4c>
        case 1:
            instance->can->TSR = CAN_TSR_ABRQ1;
 8006602:	68fb      	ldr	r3, [r7, #12]
 8006604:	685b      	ldr	r3, [r3, #4]
 8006606:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 800660a:	609a      	str	r2, [r3, #8]
            return true;
 800660c:	2301      	movs	r3, #1
 800660e:	e007      	b.n	8006620 <can_driver_stm32_abort_tx_mailbox_I+0x4c>
        case 2:
            instance->can->TSR = CAN_TSR_ABRQ2;
 8006610:	68fb      	ldr	r3, [r7, #12]
 8006612:	685b      	ldr	r3, [r3, #4]
 8006614:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 8006618:	609a      	str	r2, [r3, #8]
            return true;
 800661a:	2301      	movs	r3, #1
 800661c:	e000      	b.n	8006620 <can_driver_stm32_abort_tx_mailbox_I+0x4c>
    }
    return false;
 800661e:	2300      	movs	r3, #0
}
 8006620:	4618      	mov	r0, r3
 8006622:	3710      	adds	r7, #16
 8006624:	46bd      	mov	sp, r7
 8006626:	bd80      	pop	{r7, pc}

08006628 <can_driver_stm32_load_tx_mailbox_I>:

bool can_driver_stm32_load_tx_mailbox_I(void* ctx, uint8_t mb_idx, struct can_frame_s* frame) {
 8006628:	b580      	push	{r7, lr}
 800662a:	b086      	sub	sp, #24
 800662c:	af00      	add	r7, sp, #0
 800662e:	60f8      	str	r0, [r7, #12]
 8006630:	460b      	mov	r3, r1
 8006632:	607a      	str	r2, [r7, #4]
 8006634:	72fb      	strb	r3, [r7, #11]
    struct can_driver_stm32_instance_s* instance = ctx;
 8006636:	68fb      	ldr	r3, [r7, #12]
 8006638:	617b      	str	r3, [r7, #20]

    chDbgCheckClassI();
 800663a:	f003 fabd 	bl	8009bb8 <chDbgCheckClassI>

    CAN_TxMailBox_TypeDef* mailbox = &instance->can->sTxMailBox[mb_idx];
 800663e:	697b      	ldr	r3, [r7, #20]
 8006640:	685a      	ldr	r2, [r3, #4]
 8006642:	7afb      	ldrb	r3, [r7, #11]
 8006644:	3318      	adds	r3, #24
 8006646:	011b      	lsls	r3, r3, #4
 8006648:	4413      	add	r3, r2
 800664a:	613b      	str	r3, [r7, #16]

    mailbox->TDTR = frame->DLC;
 800664c:	687b      	ldr	r3, [r7, #4]
 800664e:	781b      	ldrb	r3, [r3, #0]
 8006650:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8006654:	b2db      	uxtb	r3, r3
 8006656:	461a      	mov	r2, r3
 8006658:	693b      	ldr	r3, [r7, #16]
 800665a:	605a      	str	r2, [r3, #4]
    mailbox->TDLR = frame->data32[0];
 800665c:	687b      	ldr	r3, [r7, #4]
 800665e:	689a      	ldr	r2, [r3, #8]
 8006660:	693b      	ldr	r3, [r7, #16]
 8006662:	609a      	str	r2, [r3, #8]
    mailbox->TDHR = frame->data32[1];
 8006664:	687b      	ldr	r3, [r7, #4]
 8006666:	68da      	ldr	r2, [r3, #12]
 8006668:	693b      	ldr	r3, [r7, #16]
 800666a:	60da      	str	r2, [r3, #12]

    if (frame->IDE) {
 800666c:	687b      	ldr	r3, [r7, #4]
 800666e:	781b      	ldrb	r3, [r3, #0]
 8006670:	f003 0302 	and.w	r3, r3, #2
 8006674:	b2db      	uxtb	r3, r3
 8006676:	2b00      	cmp	r3, #0
 8006678:	d014      	beq.n	80066a4 <can_driver_stm32_load_tx_mailbox_I+0x7c>
        mailbox->TIR = ((uint32_t)frame->EID << 3) | (frame->RTR ? CAN_TI0R_RTR : 0) | CAN_TI0R_IDE | CAN_TI0R_TXRQ;
 800667a:	687b      	ldr	r3, [r7, #4]
 800667c:	685b      	ldr	r3, [r3, #4]
 800667e:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8006682:	00da      	lsls	r2, r3, #3
 8006684:	687b      	ldr	r3, [r7, #4]
 8006686:	781b      	ldrb	r3, [r3, #0]
 8006688:	f003 0301 	and.w	r3, r3, #1
 800668c:	b2db      	uxtb	r3, r3
 800668e:	2b00      	cmp	r3, #0
 8006690:	d001      	beq.n	8006696 <can_driver_stm32_load_tx_mailbox_I+0x6e>
 8006692:	2302      	movs	r3, #2
 8006694:	e000      	b.n	8006698 <can_driver_stm32_load_tx_mailbox_I+0x70>
 8006696:	2300      	movs	r3, #0
 8006698:	4313      	orrs	r3, r2
 800669a:	f043 0205 	orr.w	r2, r3, #5
 800669e:	693b      	ldr	r3, [r7, #16]
 80066a0:	601a      	str	r2, [r3, #0]
 80066a2:	e014      	b.n	80066ce <can_driver_stm32_load_tx_mailbox_I+0xa6>
    } else {
        mailbox->TIR = ((uint32_t)frame->SID << 21) | (frame->RTR ? CAN_TI0R_RTR : 0) | CAN_TI0R_TXRQ;
 80066a4:	687b      	ldr	r3, [r7, #4]
 80066a6:	889b      	ldrh	r3, [r3, #4]
 80066a8:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80066ac:	b29b      	uxth	r3, r3
 80066ae:	055a      	lsls	r2, r3, #21
 80066b0:	687b      	ldr	r3, [r7, #4]
 80066b2:	781b      	ldrb	r3, [r3, #0]
 80066b4:	f003 0301 	and.w	r3, r3, #1
 80066b8:	b2db      	uxtb	r3, r3
 80066ba:	2b00      	cmp	r3, #0
 80066bc:	d001      	beq.n	80066c2 <can_driver_stm32_load_tx_mailbox_I+0x9a>
 80066be:	2302      	movs	r3, #2
 80066c0:	e000      	b.n	80066c4 <can_driver_stm32_load_tx_mailbox_I+0x9c>
 80066c2:	2300      	movs	r3, #0
 80066c4:	4313      	orrs	r3, r2
 80066c6:	f043 0201 	orr.w	r2, r3, #1
 80066ca:	693b      	ldr	r3, [r7, #16]
 80066cc:	601a      	str	r2, [r3, #0]
    }

    return true;
 80066ce:	2301      	movs	r3, #1
}
 80066d0:	4618      	mov	r0, r3
 80066d2:	3718      	adds	r7, #24
 80066d4:	46bd      	mov	sp, r7
 80066d6:	bd80      	pop	{r7, pc}

080066d8 <can_driver_stm32_retreive_rx_frame_I>:

static void can_driver_stm32_retreive_rx_frame_I(struct can_frame_s* frame, CAN_FIFOMailBox_TypeDef* mailbox) {
 80066d8:	b480      	push	{r7}
 80066da:	b083      	sub	sp, #12
 80066dc:	af00      	add	r7, sp, #0
 80066de:	6078      	str	r0, [r7, #4]
 80066e0:	6039      	str	r1, [r7, #0]
    frame->data32[0] = mailbox->RDLR;
 80066e2:	683b      	ldr	r3, [r7, #0]
 80066e4:	689a      	ldr	r2, [r3, #8]
 80066e6:	687b      	ldr	r3, [r7, #4]
 80066e8:	609a      	str	r2, [r3, #8]
    frame->data32[1] = mailbox->RDHR;
 80066ea:	683b      	ldr	r3, [r7, #0]
 80066ec:	68da      	ldr	r2, [r3, #12]
 80066ee:	687b      	ldr	r3, [r7, #4]
 80066f0:	60da      	str	r2, [r3, #12]
    frame->RTR = (mailbox->RIR & CAN_RI0R_RTR) != 0;
 80066f2:	683b      	ldr	r3, [r7, #0]
 80066f4:	681b      	ldr	r3, [r3, #0]
 80066f6:	f003 0302 	and.w	r3, r3, #2
 80066fa:	2b00      	cmp	r3, #0
 80066fc:	bf14      	ite	ne
 80066fe:	2301      	movne	r3, #1
 8006700:	2300      	moveq	r3, #0
 8006702:	b2d9      	uxtb	r1, r3
 8006704:	687a      	ldr	r2, [r7, #4]
 8006706:	7813      	ldrb	r3, [r2, #0]
 8006708:	f361 0300 	bfi	r3, r1, #0, #1
 800670c:	7013      	strb	r3, [r2, #0]
    frame->IDE = (mailbox->RIR & CAN_RI0R_IDE) != 0;
 800670e:	683b      	ldr	r3, [r7, #0]
 8006710:	681b      	ldr	r3, [r3, #0]
 8006712:	f003 0304 	and.w	r3, r3, #4
 8006716:	2b00      	cmp	r3, #0
 8006718:	bf14      	ite	ne
 800671a:	2301      	movne	r3, #1
 800671c:	2300      	moveq	r3, #0
 800671e:	b2d9      	uxtb	r1, r3
 8006720:	687a      	ldr	r2, [r7, #4]
 8006722:	7813      	ldrb	r3, [r2, #0]
 8006724:	f361 0341 	bfi	r3, r1, #1, #1
 8006728:	7013      	strb	r3, [r2, #0]
    if (frame->IDE) {
 800672a:	687b      	ldr	r3, [r7, #4]
 800672c:	781b      	ldrb	r3, [r3, #0]
 800672e:	f003 0302 	and.w	r3, r3, #2
 8006732:	b2db      	uxtb	r3, r3
 8006734:	2b00      	cmp	r3, #0
 8006736:	d00a      	beq.n	800674e <can_driver_stm32_retreive_rx_frame_I+0x76>
        frame->EID = (mailbox->RIR & (CAN_RI0R_STID|CAN_RI0R_EXID)) >> 3;
 8006738:	683b      	ldr	r3, [r7, #0]
 800673a:	681b      	ldr	r3, [r3, #0]
 800673c:	08db      	lsrs	r3, r3, #3
 800673e:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 8006742:	687a      	ldr	r2, [r7, #4]
 8006744:	6853      	ldr	r3, [r2, #4]
 8006746:	f361 031c 	bfi	r3, r1, #0, #29
 800674a:	6053      	str	r3, [r2, #4]
 800674c:	e00b      	b.n	8006766 <can_driver_stm32_retreive_rx_frame_I+0x8e>
    } else {
        frame->SID = (mailbox->RIR & CAN_RI0R_STID) >> 21;
 800674e:	683b      	ldr	r3, [r7, #0]
 8006750:	681b      	ldr	r3, [r3, #0]
 8006752:	0d5b      	lsrs	r3, r3, #21
 8006754:	b29b      	uxth	r3, r3
 8006756:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800675a:	b299      	uxth	r1, r3
 800675c:	687a      	ldr	r2, [r7, #4]
 800675e:	8893      	ldrh	r3, [r2, #4]
 8006760:	f361 030a 	bfi	r3, r1, #0, #11
 8006764:	8093      	strh	r3, [r2, #4]
    }
    frame->DLC = mailbox->RDTR & CAN_RDT0R_DLC;
 8006766:	683b      	ldr	r3, [r7, #0]
 8006768:	685b      	ldr	r3, [r3, #4]
 800676a:	b2db      	uxtb	r3, r3
 800676c:	f003 030f 	and.w	r3, r3, #15
 8006770:	b2d9      	uxtb	r1, r3
 8006772:	687a      	ldr	r2, [r7, #4]
 8006774:	7813      	ldrb	r3, [r2, #0]
 8006776:	f361 0385 	bfi	r3, r1, #2, #4
 800677a:	7013      	strb	r3, [r2, #0]
}
 800677c:	370c      	adds	r7, #12
 800677e:	46bd      	mov	sp, r7
 8006780:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006784:	4770      	bx	lr
 8006786:	bf00      	nop

08006788 <stm32_can_rx_handler>:

static void stm32_can_rx_handler(struct can_driver_stm32_instance_s* instance) {
 8006788:	b580      	push	{r7, lr}
 800678a:	b08c      	sub	sp, #48	; 0x30
 800678c:	af00      	add	r7, sp, #0
 800678e:	6078      	str	r0, [r7, #4]
    systime_t rx_systime = chVTGetSystemTimeX();
 8006790:	f7ff fdbe 	bl	8006310 <chVTGetSystemTimeX.lto_priv.90>
 8006794:	4603      	mov	r3, r0
 8006796:	85fb      	strh	r3, [r7, #46]	; 0x2e
    while (true) {
        chSysLockFromISR();
 8006798:	f7ff fdaa 	bl	80062f0 <chSysLockFromISR>
        if ((instance->can->RF0R & CAN_RF0R_FMP0) == 0) {
 800679c:	687b      	ldr	r3, [r7, #4]
 800679e:	685b      	ldr	r3, [r3, #4]
 80067a0:	68db      	ldr	r3, [r3, #12]
 80067a2:	f003 0303 	and.w	r3, r3, #3
 80067a6:	2b00      	cmp	r3, #0
 80067a8:	d102      	bne.n	80067b0 <stm32_can_rx_handler+0x28>
            chSysUnlockFromISR();
 80067aa:	f7ff fda9 	bl	8006300 <chSysUnlockFromISR>
 80067ae:	e019      	b.n	80067e4 <stm32_can_rx_handler+0x5c>
            break;
        }
        struct can_frame_s frame;
        can_driver_stm32_retreive_rx_frame_I(&frame, &instance->can->sFIFOMailBox[0]);
 80067b0:	687b      	ldr	r3, [r7, #4]
 80067b2:	685b      	ldr	r3, [r3, #4]
 80067b4:	f503 73d8 	add.w	r3, r3, #432	; 0x1b0
 80067b8:	f107 020c 	add.w	r2, r7, #12
 80067bc:	4610      	mov	r0, r2
 80067be:	4619      	mov	r1, r3
 80067c0:	f7ff ff8a 	bl	80066d8 <can_driver_stm32_retreive_rx_frame_I>
        can_driver_rx_frame_received_I(instance->frontend, 0, rx_systime, &frame);
 80067c4:	687b      	ldr	r3, [r7, #4]
 80067c6:	6819      	ldr	r1, [r3, #0]
 80067c8:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 80067ca:	f107 030c 	add.w	r3, r7, #12
 80067ce:	4608      	mov	r0, r1
 80067d0:	2100      	movs	r1, #0
 80067d2:	f7fe fc07 	bl	8004fe4 <can_driver_rx_frame_received_I>
        instance->can->RF0R = CAN_RF0R_RFOM0;
 80067d6:	687b      	ldr	r3, [r7, #4]
 80067d8:	685b      	ldr	r3, [r3, #4]
 80067da:	2220      	movs	r2, #32
 80067dc:	60da      	str	r2, [r3, #12]
        chSysUnlockFromISR();
 80067de:	f7ff fd8f 	bl	8006300 <chSysUnlockFromISR>
 80067e2:	e7d9      	b.n	8006798 <stm32_can_rx_handler+0x10>
    }

    while (true) {
        chSysLockFromISR();
 80067e4:	f7ff fd84 	bl	80062f0 <chSysLockFromISR>
        if ((instance->can->RF1R & CAN_RF1R_FMP1) == 0) {
 80067e8:	687b      	ldr	r3, [r7, #4]
 80067ea:	685b      	ldr	r3, [r3, #4]
 80067ec:	691b      	ldr	r3, [r3, #16]
 80067ee:	f003 0303 	and.w	r3, r3, #3
 80067f2:	2b00      	cmp	r3, #0
 80067f4:	d102      	bne.n	80067fc <stm32_can_rx_handler+0x74>
            chSysUnlockFromISR();
 80067f6:	f7ff fd83 	bl	8006300 <chSysUnlockFromISR>
 80067fa:	e019      	b.n	8006830 <stm32_can_rx_handler+0xa8>
            break;
        }
        struct can_frame_s frame;
        can_driver_stm32_retreive_rx_frame_I(&frame, &instance->can->sFIFOMailBox[1]);
 80067fc:	687b      	ldr	r3, [r7, #4]
 80067fe:	685b      	ldr	r3, [r3, #4]
 8006800:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
 8006804:	f107 021c 	add.w	r2, r7, #28
 8006808:	4610      	mov	r0, r2
 800680a:	4619      	mov	r1, r3
 800680c:	f7ff ff64 	bl	80066d8 <can_driver_stm32_retreive_rx_frame_I>
        can_driver_rx_frame_received_I(instance->frontend, 1, rx_systime, &frame);
 8006810:	687b      	ldr	r3, [r7, #4]
 8006812:	6819      	ldr	r1, [r3, #0]
 8006814:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 8006816:	f107 031c 	add.w	r3, r7, #28
 800681a:	4608      	mov	r0, r1
 800681c:	2101      	movs	r1, #1
 800681e:	f7fe fbe1 	bl	8004fe4 <can_driver_rx_frame_received_I>
        instance->can->RF1R = CAN_RF1R_RFOM1;
 8006822:	687b      	ldr	r3, [r7, #4]
 8006824:	685b      	ldr	r3, [r3, #4]
 8006826:	2220      	movs	r2, #32
 8006828:	611a      	str	r2, [r3, #16]
        chSysUnlockFromISR();
 800682a:	f7ff fd69 	bl	8006300 <chSysUnlockFromISR>
 800682e:	e7d9      	b.n	80067e4 <stm32_can_rx_handler+0x5c>
    }
}
 8006830:	3730      	adds	r7, #48	; 0x30
 8006832:	46bd      	mov	sp, r7
 8006834:	bd80      	pop	{r7, pc}
 8006836:	bf00      	nop

08006838 <stm32_can_tx_handler>:

static void stm32_can_tx_handler(struct can_driver_stm32_instance_s* instance) {
 8006838:	b580      	push	{r7, lr}
 800683a:	b084      	sub	sp, #16
 800683c:	af00      	add	r7, sp, #0
 800683e:	6078      	str	r0, [r7, #4]
    systime_t t_now = chVTGetSystemTimeX();
 8006840:	f7ff fd66 	bl	8006310 <chVTGetSystemTimeX.lto_priv.90>
 8006844:	4603      	mov	r3, r0
 8006846:	81fb      	strh	r3, [r7, #14]

    chSysLockFromISR();
 8006848:	f7ff fd52 	bl	80062f0 <chSysLockFromISR>
    if ((instance->can->TSR & CAN_TSR_RQCP0) != 0) {
 800684c:	687b      	ldr	r3, [r7, #4]
 800684e:	685b      	ldr	r3, [r3, #4]
 8006850:	689b      	ldr	r3, [r3, #8]
 8006852:	f003 0301 	and.w	r3, r3, #1
 8006856:	2b00      	cmp	r3, #0
 8006858:	d014      	beq.n	8006884 <stm32_can_tx_handler+0x4c>
        can_driver_tx_request_complete_I(instance->frontend, 0, (instance->can->TSR & CAN_TSR_TXOK0) != 0, t_now);
 800685a:	687b      	ldr	r3, [r7, #4]
 800685c:	6819      	ldr	r1, [r3, #0]
 800685e:	687b      	ldr	r3, [r7, #4]
 8006860:	685b      	ldr	r3, [r3, #4]
 8006862:	689b      	ldr	r3, [r3, #8]
 8006864:	f003 0302 	and.w	r3, r3, #2
 8006868:	2b00      	cmp	r3, #0
 800686a:	bf14      	ite	ne
 800686c:	2301      	movne	r3, #1
 800686e:	2300      	moveq	r3, #0
 8006870:	b2da      	uxtb	r2, r3
 8006872:	89fb      	ldrh	r3, [r7, #14]
 8006874:	4608      	mov	r0, r1
 8006876:	2100      	movs	r1, #0
 8006878:	f7fe fb5e 	bl	8004f38 <can_driver_tx_request_complete_I>
        instance->can->TSR = CAN_TSR_RQCP0;
 800687c:	687b      	ldr	r3, [r7, #4]
 800687e:	685b      	ldr	r3, [r3, #4]
 8006880:	2201      	movs	r2, #1
 8006882:	609a      	str	r2, [r3, #8]
    }

    if ((instance->can->TSR & CAN_TSR_RQCP1) != 0) {
 8006884:	687b      	ldr	r3, [r7, #4]
 8006886:	685b      	ldr	r3, [r3, #4]
 8006888:	689b      	ldr	r3, [r3, #8]
 800688a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800688e:	2b00      	cmp	r3, #0
 8006890:	d015      	beq.n	80068be <stm32_can_tx_handler+0x86>
        can_driver_tx_request_complete_I(instance->frontend, 1, (instance->can->TSR & CAN_TSR_TXOK1) != 0, t_now);
 8006892:	687b      	ldr	r3, [r7, #4]
 8006894:	6819      	ldr	r1, [r3, #0]
 8006896:	687b      	ldr	r3, [r7, #4]
 8006898:	685b      	ldr	r3, [r3, #4]
 800689a:	689b      	ldr	r3, [r3, #8]
 800689c:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80068a0:	2b00      	cmp	r3, #0
 80068a2:	bf14      	ite	ne
 80068a4:	2301      	movne	r3, #1
 80068a6:	2300      	moveq	r3, #0
 80068a8:	b2da      	uxtb	r2, r3
 80068aa:	89fb      	ldrh	r3, [r7, #14]
 80068ac:	4608      	mov	r0, r1
 80068ae:	2101      	movs	r1, #1
 80068b0:	f7fe fb42 	bl	8004f38 <can_driver_tx_request_complete_I>
        instance->can->TSR = CAN_TSR_RQCP1;
 80068b4:	687b      	ldr	r3, [r7, #4]
 80068b6:	685b      	ldr	r3, [r3, #4]
 80068b8:	f44f 7280 	mov.w	r2, #256	; 0x100
 80068bc:	609a      	str	r2, [r3, #8]
    }

    if ((instance->can->TSR & CAN_TSR_RQCP2) != 0) {
 80068be:	687b      	ldr	r3, [r7, #4]
 80068c0:	685b      	ldr	r3, [r3, #4]
 80068c2:	689b      	ldr	r3, [r3, #8]
 80068c4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80068c8:	2b00      	cmp	r3, #0
 80068ca:	d015      	beq.n	80068f8 <stm32_can_tx_handler+0xc0>
        can_driver_tx_request_complete_I(instance->frontend, 2, (instance->can->TSR & CAN_TSR_TXOK2) != 0, t_now);
 80068cc:	687b      	ldr	r3, [r7, #4]
 80068ce:	6819      	ldr	r1, [r3, #0]
 80068d0:	687b      	ldr	r3, [r7, #4]
 80068d2:	685b      	ldr	r3, [r3, #4]
 80068d4:	689b      	ldr	r3, [r3, #8]
 80068d6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80068da:	2b00      	cmp	r3, #0
 80068dc:	bf14      	ite	ne
 80068de:	2301      	movne	r3, #1
 80068e0:	2300      	moveq	r3, #0
 80068e2:	b2da      	uxtb	r2, r3
 80068e4:	89fb      	ldrh	r3, [r7, #14]
 80068e6:	4608      	mov	r0, r1
 80068e8:	2102      	movs	r1, #2
 80068ea:	f7fe fb25 	bl	8004f38 <can_driver_tx_request_complete_I>
        instance->can->TSR = CAN_TSR_RQCP2;
 80068ee:	687b      	ldr	r3, [r7, #4]
 80068f0:	685b      	ldr	r3, [r3, #4]
 80068f2:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80068f6:	609a      	str	r2, [r3, #8]
    }
    chSysUnlockFromISR();
 80068f8:	f7ff fd02 	bl	8006300 <chSysUnlockFromISR>
}
 80068fc:	3710      	adds	r7, #16
 80068fe:	46bd      	mov	sp, r7
 8006900:	bd80      	pop	{r7, pc}
 8006902:	bf00      	nop

08006904 <Vector8C>:

OSAL_IRQ_HANDLER(STM32_CAN1_TX_HANDLER) {
 8006904:	b580      	push	{r7, lr}
 8006906:	af00      	add	r7, sp, #0
    OSAL_IRQ_PROLOGUE();
 8006908:	f003 f91e 	bl	8009b48 <_dbg_check_enter_isr>

    stm32_can_tx_handler(&can1_instance);
 800690c:	4803      	ldr	r0, [pc, #12]	; (800691c <Vector8C+0x18>)
 800690e:	f7ff ff93 	bl	8006838 <stm32_can_tx_handler>

    OSAL_IRQ_EPILOGUE();
 8006912:	f003 f935 	bl	8009b80 <_dbg_check_leave_isr>
 8006916:	f002 fa3f 	bl	8008d98 <_port_irq_epilogue>
}
 800691a:	bd80      	pop	{r7, pc}
 800691c:	200013dc 	.word	0x200013dc

08006920 <Vector90>:

OSAL_IRQ_HANDLER(STM32_CAN1_RX0_HANDLER) {
 8006920:	b580      	push	{r7, lr}
 8006922:	af00      	add	r7, sp, #0
    OSAL_IRQ_PROLOGUE();
 8006924:	f003 f910 	bl	8009b48 <_dbg_check_enter_isr>

    stm32_can_rx_handler(&can1_instance);
 8006928:	4803      	ldr	r0, [pc, #12]	; (8006938 <Vector90+0x18>)
 800692a:	f7ff ff2d 	bl	8006788 <stm32_can_rx_handler>

    OSAL_IRQ_EPILOGUE();
 800692e:	f003 f927 	bl	8009b80 <_dbg_check_leave_isr>
 8006932:	f002 fa31 	bl	8008d98 <_port_irq_epilogue>
}
 8006936:	bd80      	pop	{r7, pc}
 8006938:	200013dc 	.word	0x200013dc

0800693c <port_lock.lto_priv.87>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800693c:	b480      	push	{r7}
 800693e:	b083      	sub	sp, #12
 8006940:	af00      	add	r7, sp, #0
 8006942:	2320      	movs	r3, #32
 8006944:	607b      	str	r3, [r7, #4]
 8006946:	687b      	ldr	r3, [r7, #4]
 8006948:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800694c:	370c      	adds	r7, #12
 800694e:	46bd      	mov	sp, r7
 8006950:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006954:	4770      	bx	lr
 8006956:	bf00      	nop

08006958 <port_unlock.lto_priv.84>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006958:	b480      	push	{r7}
 800695a:	b083      	sub	sp, #12
 800695c:	af00      	add	r7, sp, #0
 800695e:	2300      	movs	r3, #0
 8006960:	607b      	str	r3, [r7, #4]
 8006962:	687b      	ldr	r3, [r7, #4]
 8006964:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006968:	370c      	adds	r7, #12
 800696a:	46bd      	mov	sp, r7
 800696c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006970:	4770      	bx	lr
 8006972:	bf00      	nop

08006974 <chSysLock.lto_priv.99>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8006974:	b580      	push	{r7, lr}
 8006976:	af00      	add	r7, sp, #0

  port_lock();
 8006978:	f7ff ffe0 	bl	800693c <port_lock.lto_priv.87>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800697c:	f003 f88c 	bl	8009a98 <_dbg_check_lock>
}
 8006980:	bd80      	pop	{r7, pc}
 8006982:	bf00      	nop

08006984 <chSysUnlock.lto_priv.97>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8006984:	b580      	push	{r7, lr}
 8006986:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8006988:	f003 f89c 	bl	8009ac4 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800698c:	4b09      	ldr	r3, [pc, #36]	; (80069b4 <chSysUnlock.lto_priv.97+0x30>)
 800698e:	681b      	ldr	r3, [r3, #0]
 8006990:	4a08      	ldr	r2, [pc, #32]	; (80069b4 <chSysUnlock.lto_priv.97+0x30>)
 8006992:	4293      	cmp	r3, r2
 8006994:	d00a      	beq.n	80069ac <chSysUnlock.lto_priv.97+0x28>
 8006996:	4b07      	ldr	r3, [pc, #28]	; (80069b4 <chSysUnlock.lto_priv.97+0x30>)
 8006998:	699b      	ldr	r3, [r3, #24]
 800699a:	689a      	ldr	r2, [r3, #8]
 800699c:	4b05      	ldr	r3, [pc, #20]	; (80069b4 <chSysUnlock.lto_priv.97+0x30>)
 800699e:	681b      	ldr	r3, [r3, #0]
 80069a0:	689b      	ldr	r3, [r3, #8]
 80069a2:	429a      	cmp	r2, r3
 80069a4:	d202      	bcs.n	80069ac <chSysUnlock.lto_priv.97+0x28>
 80069a6:	4804      	ldr	r0, [pc, #16]	; (80069b8 <chSysUnlock.lto_priv.97+0x34>)
 80069a8:	f003 f828 	bl	80099fc <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 80069ac:	f7ff ffd4 	bl	8006958 <port_unlock.lto_priv.84>
}
 80069b0:	bd80      	pop	{r7, pc}
 80069b2:	bf00      	nop
 80069b4:	20001330 	.word	0x20001330
 80069b8:	0800d16c 	.word	0x0800d16c

080069bc <can_tx_queue_init>:

#if CH_DBG_ENABLE_CHECKS
static bool can_tx_queue_frame_exists_in_queue(struct can_tx_queue_s* instance, struct can_tx_frame_s* check_frame);
#endif

bool can_tx_queue_init(struct can_tx_queue_s* instance) {
 80069bc:	b480      	push	{r7}
 80069be:	b083      	sub	sp, #12
 80069c0:	af00      	add	r7, sp, #0
 80069c2:	6078      	str	r0, [r7, #4]
    instance->head = NULL;
 80069c4:	687b      	ldr	r3, [r7, #4]
 80069c6:	2200      	movs	r2, #0
 80069c8:	601a      	str	r2, [r3, #0]
    return true;
 80069ca:	2301      	movs	r3, #1
}
 80069cc:	4618      	mov	r0, r3
 80069ce:	370c      	adds	r7, #12
 80069d0:	46bd      	mov	sp, r7
 80069d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80069d6:	4770      	bx	lr

080069d8 <can_tx_queue_push_I>:

void can_tx_queue_push_I(struct can_tx_queue_s* instance, struct can_tx_frame_s* push_frame) {
 80069d8:	b580      	push	{r7, lr}
 80069da:	b084      	sub	sp, #16
 80069dc:	af00      	add	r7, sp, #0
 80069de:	6078      	str	r0, [r7, #4]
 80069e0:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 80069e2:	f003 f8e9 	bl	8009bb8 <chDbgCheckClassI>
    
#if CH_DBG_ENABLE_CHECKS
    chDbgCheck(!can_tx_queue_frame_exists_in_queue(instance, push_frame));
 80069e6:	6878      	ldr	r0, [r7, #4]
 80069e8:	6839      	ldr	r1, [r7, #0]
 80069ea:	f000 f8c9 	bl	8006b80 <can_tx_queue_frame_exists_in_queue>
 80069ee:	4603      	mov	r3, r0
 80069f0:	2b00      	cmp	r3, #0
 80069f2:	d002      	beq.n	80069fa <can_tx_queue_push_I+0x22>
 80069f4:	4812      	ldr	r0, [pc, #72]	; (8006a40 <can_tx_queue_push_I+0x68>)
 80069f6:	f003 f801 	bl	80099fc <chSysHalt>
#endif

    can_frame_priority_t push_frame_prio = can_get_tx_frame_priority_X(push_frame);
 80069fa:	6838      	ldr	r0, [r7, #0]
 80069fc:	f000 f984 	bl	8006d08 <can_get_tx_frame_priority_X>
 8006a00:	60b8      	str	r0, [r7, #8]

    struct can_tx_frame_s** insert_ptr = &instance->head;
 8006a02:	687b      	ldr	r3, [r7, #4]
 8006a04:	60fb      	str	r3, [r7, #12]
 8006a06:	e003      	b.n	8006a10 <can_tx_queue_push_I+0x38>
    while(*insert_ptr != NULL && push_frame_prio <= can_get_tx_frame_priority_X(*insert_ptr)) {
        insert_ptr = &(*insert_ptr)->next;
 8006a08:	68fb      	ldr	r3, [r7, #12]
 8006a0a:	681b      	ldr	r3, [r3, #0]
 8006a0c:	3318      	adds	r3, #24
 8006a0e:	60fb      	str	r3, [r7, #12]
#endif

    can_frame_priority_t push_frame_prio = can_get_tx_frame_priority_X(push_frame);

    struct can_tx_frame_s** insert_ptr = &instance->head;
    while(*insert_ptr != NULL && push_frame_prio <= can_get_tx_frame_priority_X(*insert_ptr)) {
 8006a10:	68fb      	ldr	r3, [r7, #12]
 8006a12:	681b      	ldr	r3, [r3, #0]
 8006a14:	2b00      	cmp	r3, #0
 8006a16:	d008      	beq.n	8006a2a <can_tx_queue_push_I+0x52>
 8006a18:	68fb      	ldr	r3, [r7, #12]
 8006a1a:	681b      	ldr	r3, [r3, #0]
 8006a1c:	4618      	mov	r0, r3
 8006a1e:	f000 f973 	bl	8006d08 <can_get_tx_frame_priority_X>
 8006a22:	4602      	mov	r2, r0
 8006a24:	68bb      	ldr	r3, [r7, #8]
 8006a26:	429a      	cmp	r2, r3
 8006a28:	d2ee      	bcs.n	8006a08 <can_tx_queue_push_I+0x30>
        insert_ptr = &(*insert_ptr)->next;
    }

    push_frame->next = *insert_ptr;
 8006a2a:	68fb      	ldr	r3, [r7, #12]
 8006a2c:	681a      	ldr	r2, [r3, #0]
 8006a2e:	683b      	ldr	r3, [r7, #0]
 8006a30:	619a      	str	r2, [r3, #24]
    *insert_ptr = push_frame;
 8006a32:	68fb      	ldr	r3, [r7, #12]
 8006a34:	683a      	ldr	r2, [r7, #0]
 8006a36:	601a      	str	r2, [r3, #0]
}
 8006a38:	3710      	adds	r7, #16
 8006a3a:	46bd      	mov	sp, r7
 8006a3c:	bd80      	pop	{r7, pc}
 8006a3e:	bf00      	nop
 8006a40:	0800d158 	.word	0x0800d158

08006a44 <can_tx_queue_push>:

void can_tx_queue_push(struct can_tx_queue_s* instance, struct can_tx_frame_s* push_frame) {
 8006a44:	b580      	push	{r7, lr}
 8006a46:	b082      	sub	sp, #8
 8006a48:	af00      	add	r7, sp, #0
 8006a4a:	6078      	str	r0, [r7, #4]
 8006a4c:	6039      	str	r1, [r7, #0]
    chSysLock();
 8006a4e:	f7ff ff91 	bl	8006974 <chSysLock.lto_priv.99>
    can_tx_queue_push_I(instance, push_frame);
 8006a52:	6878      	ldr	r0, [r7, #4]
 8006a54:	6839      	ldr	r1, [r7, #0]
 8006a56:	f7ff ffbf 	bl	80069d8 <can_tx_queue_push_I>
    chSysUnlock();
 8006a5a:	f7ff ff93 	bl	8006984 <chSysUnlock.lto_priv.97>
}
 8006a5e:	3708      	adds	r7, #8
 8006a60:	46bd      	mov	sp, r7
 8006a62:	bd80      	pop	{r7, pc}

08006a64 <can_tx_queue_iterate_I>:
    chSysLock();
    can_tx_queue_push_ahead_I(instance, push_frame);
    chSysUnlock();
}

bool can_tx_queue_iterate_I(struct can_tx_queue_s* instance, struct can_tx_frame_s** frame_ptr) {
 8006a64:	b580      	push	{r7, lr}
 8006a66:	b082      	sub	sp, #8
 8006a68:	af00      	add	r7, sp, #0
 8006a6a:	6078      	str	r0, [r7, #4]
 8006a6c:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 8006a6e:	f003 f8a3 	bl	8009bb8 <chDbgCheckClassI>
    chDbgCheck(frame_ptr != NULL);
 8006a72:	683b      	ldr	r3, [r7, #0]
 8006a74:	2b00      	cmp	r3, #0
 8006a76:	d102      	bne.n	8006a7e <can_tx_queue_iterate_I+0x1a>
 8006a78:	4810      	ldr	r0, [pc, #64]	; (8006abc <can_tx_queue_iterate_I+0x58>)
 8006a7a:	f002 ffbf 	bl	80099fc <chSysHalt>

    if (frame_ptr == NULL) {
 8006a7e:	683b      	ldr	r3, [r7, #0]
 8006a80:	2b00      	cmp	r3, #0
 8006a82:	d101      	bne.n	8006a88 <can_tx_queue_iterate_I+0x24>
        return false;
 8006a84:	2300      	movs	r3, #0
 8006a86:	e014      	b.n	8006ab2 <can_tx_queue_iterate_I+0x4e>
    }

    if (*frame_ptr == NULL) {
 8006a88:	683b      	ldr	r3, [r7, #0]
 8006a8a:	681b      	ldr	r3, [r3, #0]
 8006a8c:	2b00      	cmp	r3, #0
 8006a8e:	d104      	bne.n	8006a9a <can_tx_queue_iterate_I+0x36>
        *frame_ptr = instance->head;
 8006a90:	687b      	ldr	r3, [r7, #4]
 8006a92:	681a      	ldr	r2, [r3, #0]
 8006a94:	683b      	ldr	r3, [r7, #0]
 8006a96:	601a      	str	r2, [r3, #0]
 8006a98:	e004      	b.n	8006aa4 <can_tx_queue_iterate_I+0x40>
    } else {
        *frame_ptr = (*frame_ptr)->next;
 8006a9a:	683b      	ldr	r3, [r7, #0]
 8006a9c:	681b      	ldr	r3, [r3, #0]
 8006a9e:	699a      	ldr	r2, [r3, #24]
 8006aa0:	683b      	ldr	r3, [r7, #0]
 8006aa2:	601a      	str	r2, [r3, #0]
    }

    return *frame_ptr != NULL;
 8006aa4:	683b      	ldr	r3, [r7, #0]
 8006aa6:	681b      	ldr	r3, [r3, #0]
 8006aa8:	2b00      	cmp	r3, #0
 8006aaa:	bf14      	ite	ne
 8006aac:	2301      	movne	r3, #1
 8006aae:	2300      	moveq	r3, #0
 8006ab0:	b2db      	uxtb	r3, r3
}
 8006ab2:	4618      	mov	r0, r3
 8006ab4:	3708      	adds	r7, #8
 8006ab6:	46bd      	mov	sp, r7
 8006ab8:	bd80      	pop	{r7, pc}
 8006aba:	bf00      	nop
 8006abc:	0800d178 	.word	0x0800d178

08006ac0 <can_tx_queue_peek_I>:
#endif

    LINKED_LIST_REMOVE(struct can_tx_frame_s, instance->head, frame);
}

struct can_tx_frame_s* can_tx_queue_peek_I(struct can_tx_queue_s* instance) {
 8006ac0:	b580      	push	{r7, lr}
 8006ac2:	b082      	sub	sp, #8
 8006ac4:	af00      	add	r7, sp, #0
 8006ac6:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
 8006ac8:	f003 f876 	bl	8009bb8 <chDbgCheckClassI>
    
    return instance->head;
 8006acc:	687b      	ldr	r3, [r7, #4]
 8006ace:	681b      	ldr	r3, [r3, #0]
}
 8006ad0:	4618      	mov	r0, r3
 8006ad2:	3708      	adds	r7, #8
 8006ad4:	46bd      	mov	sp, r7
 8006ad6:	bd80      	pop	{r7, pc}

08006ad8 <can_tx_queue_pop_I>:
    struct can_tx_frame_s* ret = can_tx_queue_peek_I(instance);
    chSysUnlock();
    return ret;
}

void can_tx_queue_pop_I(struct can_tx_queue_s* instance) {
 8006ad8:	b580      	push	{r7, lr}
 8006ada:	b082      	sub	sp, #8
 8006adc:	af00      	add	r7, sp, #0
 8006ade:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
 8006ae0:	f003 f86a 	bl	8009bb8 <chDbgCheckClassI>

    if (instance->head) {
 8006ae4:	687b      	ldr	r3, [r7, #4]
 8006ae6:	681b      	ldr	r3, [r3, #0]
 8006ae8:	2b00      	cmp	r3, #0
 8006aea:	d004      	beq.n	8006af6 <can_tx_queue_pop_I+0x1e>
        instance->head = instance->head->next;
 8006aec:	687b      	ldr	r3, [r7, #4]
 8006aee:	681b      	ldr	r3, [r3, #0]
 8006af0:	699a      	ldr	r2, [r3, #24]
 8006af2:	687b      	ldr	r3, [r7, #4]
 8006af4:	601a      	str	r2, [r3, #0]
    }
}
 8006af6:	3708      	adds	r7, #8
 8006af8:	46bd      	mov	sp, r7
 8006afa:	bd80      	pop	{r7, pc}

08006afc <can_tx_queue_pop_expired_I>:
    chSysLock();
    can_tx_queue_pop_I(instance);
    chSysUnlock();
}

struct can_tx_frame_s* can_tx_queue_pop_expired_I(struct can_tx_queue_s* instance) {
 8006afc:	b580      	push	{r7, lr}
 8006afe:	b084      	sub	sp, #16
 8006b00:	af00      	add	r7, sp, #0
 8006b02:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
 8006b04:	f003 f858 	bl	8009bb8 <chDbgCheckClassI>
    
    struct can_tx_frame_s* ret = NULL;
 8006b08:	2300      	movs	r3, #0
 8006b0a:	60fb      	str	r3, [r7, #12]
    struct can_tx_frame_s** expired_ptr = &instance->head;
 8006b0c:	687b      	ldr	r3, [r7, #4]
 8006b0e:	60bb      	str	r3, [r7, #8]
 8006b10:	e003      	b.n	8006b1a <can_tx_queue_pop_expired_I+0x1e>
    while (*expired_ptr && !can_tx_frame_expired_X(*expired_ptr)) {
        expired_ptr = &(*expired_ptr)->next;
 8006b12:	68bb      	ldr	r3, [r7, #8]
 8006b14:	681b      	ldr	r3, [r3, #0]
 8006b16:	3318      	adds	r3, #24
 8006b18:	60bb      	str	r3, [r7, #8]
struct can_tx_frame_s* can_tx_queue_pop_expired_I(struct can_tx_queue_s* instance) {
    chDbgCheckClassI();
    
    struct can_tx_frame_s* ret = NULL;
    struct can_tx_frame_s** expired_ptr = &instance->head;
    while (*expired_ptr && !can_tx_frame_expired_X(*expired_ptr)) {
 8006b1a:	68bb      	ldr	r3, [r7, #8]
 8006b1c:	681b      	ldr	r3, [r3, #0]
 8006b1e:	2b00      	cmp	r3, #0
 8006b20:	d00a      	beq.n	8006b38 <can_tx_queue_pop_expired_I+0x3c>
 8006b22:	68bb      	ldr	r3, [r7, #8]
 8006b24:	681b      	ldr	r3, [r3, #0]
 8006b26:	4618      	mov	r0, r3
 8006b28:	f000 f862 	bl	8006bf0 <can_tx_frame_expired_X>
 8006b2c:	4603      	mov	r3, r0
 8006b2e:	f083 0301 	eor.w	r3, r3, #1
 8006b32:	b2db      	uxtb	r3, r3
 8006b34:	2b00      	cmp	r3, #0
 8006b36:	d1ec      	bne.n	8006b12 <can_tx_queue_pop_expired_I+0x16>
        expired_ptr = &(*expired_ptr)->next;
    }
    
    if (*expired_ptr) {
 8006b38:	68bb      	ldr	r3, [r7, #8]
 8006b3a:	681b      	ldr	r3, [r3, #0]
 8006b3c:	2b00      	cmp	r3, #0
 8006b3e:	d007      	beq.n	8006b50 <can_tx_queue_pop_expired_I+0x54>
        ret = *expired_ptr;
 8006b40:	68bb      	ldr	r3, [r7, #8]
 8006b42:	681b      	ldr	r3, [r3, #0]
 8006b44:	60fb      	str	r3, [r7, #12]
        *expired_ptr = (*expired_ptr)->next;
 8006b46:	68bb      	ldr	r3, [r7, #8]
 8006b48:	681b      	ldr	r3, [r3, #0]
 8006b4a:	699a      	ldr	r2, [r3, #24]
 8006b4c:	68bb      	ldr	r3, [r7, #8]
 8006b4e:	601a      	str	r2, [r3, #0]
    }
    
    return ret;
 8006b50:	68fb      	ldr	r3, [r7, #12]
}
 8006b52:	4618      	mov	r0, r3
 8006b54:	3710      	adds	r7, #16
 8006b56:	46bd      	mov	sp, r7
 8006b58:	bd80      	pop	{r7, pc}
 8006b5a:	bf00      	nop

08006b5c <can_tx_queue_pop_expired>:

struct can_tx_frame_s* can_tx_queue_pop_expired(struct can_tx_queue_s* instance) {
 8006b5c:	b580      	push	{r7, lr}
 8006b5e:	b084      	sub	sp, #16
 8006b60:	af00      	add	r7, sp, #0
 8006b62:	6078      	str	r0, [r7, #4]
    struct can_tx_frame_s* ret;
    chSysLock();
 8006b64:	f7ff ff06 	bl	8006974 <chSysLock.lto_priv.99>
    ret = can_tx_queue_pop_expired_I(instance);
 8006b68:	6878      	ldr	r0, [r7, #4]
 8006b6a:	f7ff ffc7 	bl	8006afc <can_tx_queue_pop_expired_I>
 8006b6e:	60f8      	str	r0, [r7, #12]
    chSysUnlock();
 8006b70:	f7ff ff08 	bl	8006984 <chSysUnlock.lto_priv.97>
    return ret;
 8006b74:	68fb      	ldr	r3, [r7, #12]
}
 8006b76:	4618      	mov	r0, r3
 8006b78:	3710      	adds	r7, #16
 8006b7a:	46bd      	mov	sp, r7
 8006b7c:	bd80      	pop	{r7, pc}
 8006b7e:	bf00      	nop

08006b80 <can_tx_queue_frame_exists_in_queue>:

#if CH_DBG_ENABLE_CHECKS
static bool can_tx_queue_frame_exists_in_queue(struct can_tx_queue_s* instance, struct can_tx_frame_s* check_frame) {
 8006b80:	b580      	push	{r7, lr}
 8006b82:	b084      	sub	sp, #16
 8006b84:	af00      	add	r7, sp, #0
 8006b86:	6078      	str	r0, [r7, #4]
 8006b88:	6039      	str	r1, [r7, #0]
    struct can_tx_frame_s* frame = NULL;
 8006b8a:	2300      	movs	r3, #0
 8006b8c:	60fb      	str	r3, [r7, #12]
 8006b8e:	e005      	b.n	8006b9c <can_tx_queue_frame_exists_in_queue+0x1c>
    while (can_tx_queue_iterate_I(instance, &frame)) {
        if (check_frame == frame) {
 8006b90:	68fb      	ldr	r3, [r7, #12]
 8006b92:	683a      	ldr	r2, [r7, #0]
 8006b94:	429a      	cmp	r2, r3
 8006b96:	d101      	bne.n	8006b9c <can_tx_queue_frame_exists_in_queue+0x1c>
            return true;
 8006b98:	2301      	movs	r3, #1
 8006b9a:	e009      	b.n	8006bb0 <can_tx_queue_frame_exists_in_queue+0x30>
}

#if CH_DBG_ENABLE_CHECKS
static bool can_tx_queue_frame_exists_in_queue(struct can_tx_queue_s* instance, struct can_tx_frame_s* check_frame) {
    struct can_tx_frame_s* frame = NULL;
    while (can_tx_queue_iterate_I(instance, &frame)) {
 8006b9c:	f107 030c 	add.w	r3, r7, #12
 8006ba0:	6878      	ldr	r0, [r7, #4]
 8006ba2:	4619      	mov	r1, r3
 8006ba4:	f7ff ff5e 	bl	8006a64 <can_tx_queue_iterate_I>
 8006ba8:	4603      	mov	r3, r0
 8006baa:	2b00      	cmp	r3, #0
 8006bac:	d1f0      	bne.n	8006b90 <can_tx_queue_frame_exists_in_queue+0x10>
        if (check_frame == frame) {
            return true;
        }
    }
    return false;
 8006bae:	2300      	movs	r3, #0
}
 8006bb0:	4618      	mov	r0, r3
 8006bb2:	3710      	adds	r7, #16
 8006bb4:	46bd      	mov	sp, r7
 8006bb6:	bd80      	pop	{r7, pc}

08006bb8 <st_lld_get_counter.lto_priv.81>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 8006bb8:	b480      	push	{r7}
 8006bba:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 8006bbc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006bc0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006bc2:	b29b      	uxth	r3, r3
}
 8006bc4:	4618      	mov	r0, r3
 8006bc6:	46bd      	mov	sp, r7
 8006bc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006bcc:	4770      	bx	lr
 8006bce:	bf00      	nop

08006bd0 <port_timer_get_time.lto_priv.78>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8006bd0:	b580      	push	{r7, lr}
 8006bd2:	af00      	add	r7, sp, #0

  return stGetCounter();
 8006bd4:	f7ff fff0 	bl	8006bb8 <st_lld_get_counter.lto_priv.81>
 8006bd8:	4603      	mov	r3, r0
}
 8006bda:	4618      	mov	r0, r3
 8006bdc:	bd80      	pop	{r7, pc}
 8006bde:	bf00      	nop

08006be0 <chVTGetSystemTimeX.lto_priv.91>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8006be0:	b580      	push	{r7, lr}
 8006be2:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8006be4:	f7ff fff4 	bl	8006bd0 <port_timer_get_time.lto_priv.78>
 8006be8:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8006bea:	4618      	mov	r0, r3
 8006bec:	bd80      	pop	{r7, pc}
 8006bee:	bf00      	nop

08006bf0 <can_tx_frame_expired_X>:
#include "can_helpers.h"

bool can_tx_frame_expired_X(struct can_tx_frame_s* frame) {
 8006bf0:	b580      	push	{r7, lr}
 8006bf2:	b082      	sub	sp, #8
 8006bf4:	af00      	add	r7, sp, #0
 8006bf6:	6078      	str	r0, [r7, #4]
    return chVTGetSystemTimeX() - frame->creation_systime > frame->tx_timeout;
 8006bf8:	f7ff fff2 	bl	8006be0 <chVTGetSystemTimeX.lto_priv.91>
 8006bfc:	4603      	mov	r3, r0
 8006bfe:	461a      	mov	r2, r3
 8006c00:	687b      	ldr	r3, [r7, #4]
 8006c02:	8a1b      	ldrh	r3, [r3, #16]
 8006c04:	1ad3      	subs	r3, r2, r3
 8006c06:	687a      	ldr	r2, [r7, #4]
 8006c08:	8a52      	ldrh	r2, [r2, #18]
 8006c0a:	4293      	cmp	r3, r2
 8006c0c:	bfcc      	ite	gt
 8006c0e:	2301      	movgt	r3, #1
 8006c10:	2300      	movle	r3, #0
 8006c12:	b2db      	uxtb	r3, r3
}
 8006c14:	4618      	mov	r0, r3
 8006c16:	3708      	adds	r7, #8
 8006c18:	46bd      	mov	sp, r7
 8006c1a:	bd80      	pop	{r7, pc}

08006c1c <can_tx_frame_time_until_expire_X>:

systime_t can_tx_frame_time_until_expire_X(struct can_tx_frame_s* frame, systime_t t_now) {
 8006c1c:	b480      	push	{r7}
 8006c1e:	b085      	sub	sp, #20
 8006c20:	af00      	add	r7, sp, #0
 8006c22:	6078      	str	r0, [r7, #4]
 8006c24:	460b      	mov	r3, r1
 8006c26:	807b      	strh	r3, [r7, #2]
    if (frame->tx_timeout == TIME_INFINITE) {
 8006c28:	687b      	ldr	r3, [r7, #4]
 8006c2a:	8a5b      	ldrh	r3, [r3, #18]
 8006c2c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006c30:	4293      	cmp	r3, r2
 8006c32:	d102      	bne.n	8006c3a <can_tx_frame_time_until_expire_X+0x1e>
        return TIME_INFINITE;
 8006c34:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8006c38:	e010      	b.n	8006c5c <can_tx_frame_time_until_expire_X+0x40>
    }

    systime_t time_elapsed = t_now - frame->creation_systime;
 8006c3a:	687b      	ldr	r3, [r7, #4]
 8006c3c:	8a1b      	ldrh	r3, [r3, #16]
 8006c3e:	887a      	ldrh	r2, [r7, #2]
 8006c40:	1ad3      	subs	r3, r2, r3
 8006c42:	81fb      	strh	r3, [r7, #14]
    if (time_elapsed > frame->tx_timeout) {
 8006c44:	687b      	ldr	r3, [r7, #4]
 8006c46:	8a5b      	ldrh	r3, [r3, #18]
 8006c48:	89fa      	ldrh	r2, [r7, #14]
 8006c4a:	429a      	cmp	r2, r3
 8006c4c:	d901      	bls.n	8006c52 <can_tx_frame_time_until_expire_X+0x36>
        return TIME_IMMEDIATE;
 8006c4e:	2300      	movs	r3, #0
 8006c50:	e004      	b.n	8006c5c <can_tx_frame_time_until_expire_X+0x40>
    }

    return frame->tx_timeout - time_elapsed;
 8006c52:	687b      	ldr	r3, [r7, #4]
 8006c54:	8a5a      	ldrh	r2, [r3, #18]
 8006c56:	89fb      	ldrh	r3, [r7, #14]
 8006c58:	1ad3      	subs	r3, r2, r3
 8006c5a:	b29b      	uxth	r3, r3
}
 8006c5c:	4618      	mov	r0, r3
 8006c5e:	3714      	adds	r7, #20
 8006c60:	46bd      	mov	sp, r7
 8006c62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006c66:	4770      	bx	lr

08006c68 <can_get_frame_priority_X>:

can_frame_priority_t can_get_frame_priority_X(const struct can_frame_s* frame) {
 8006c68:	b480      	push	{r7}
 8006c6a:	b085      	sub	sp, #20
 8006c6c:	af00      	add	r7, sp, #0
 8006c6e:	6078      	str	r0, [r7, #4]
    can_frame_priority_t ret = 0;
 8006c70:	2300      	movs	r3, #0
 8006c72:	60fb      	str	r3, [r7, #12]

    if (frame->IDE) {
 8006c74:	687b      	ldr	r3, [r7, #4]
 8006c76:	781b      	ldrb	r3, [r3, #0]
 8006c78:	f003 0302 	and.w	r3, r3, #2
 8006c7c:	b2db      	uxtb	r3, r3
 8006c7e:	2b00      	cmp	r3, #0
 8006c80:	d026      	beq.n	8006cd0 <can_get_frame_priority_X+0x68>
        ret |= ((frame->EID >> 18) & 0x7ff) << 21; // Identifier A
 8006c82:	687b      	ldr	r3, [r7, #4]
 8006c84:	685b      	ldr	r3, [r3, #4]
 8006c86:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8006c8a:	149b      	asrs	r3, r3, #18
 8006c8c:	055b      	lsls	r3, r3, #21
 8006c8e:	461a      	mov	r2, r3
 8006c90:	68fb      	ldr	r3, [r7, #12]
 8006c92:	4313      	orrs	r3, r2
 8006c94:	60fb      	str	r3, [r7, #12]
        ret |= 1<<20; // SRR
 8006c96:	68fb      	ldr	r3, [r7, #12]
 8006c98:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8006c9c:	60fb      	str	r3, [r7, #12]
        ret |= 1<<19; // EID
 8006c9e:	68fb      	ldr	r3, [r7, #12]
 8006ca0:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8006ca4:	60fb      	str	r3, [r7, #12]
        ret |= (frame->EID & 0x3ffff) << 1; // Identifier B
 8006ca6:	687b      	ldr	r3, [r7, #4]
 8006ca8:	685b      	ldr	r3, [r3, #4]
 8006caa:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8006cae:	f3c3 0311 	ubfx	r3, r3, #0, #18
 8006cb2:	005b      	lsls	r3, r3, #1
 8006cb4:	461a      	mov	r2, r3
 8006cb6:	68fb      	ldr	r3, [r7, #12]
 8006cb8:	4313      	orrs	r3, r2
 8006cba:	60fb      	str	r3, [r7, #12]
        ret |= frame->RTR; // RTR
 8006cbc:	687b      	ldr	r3, [r7, #4]
 8006cbe:	781b      	ldrb	r3, [r3, #0]
 8006cc0:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8006cc4:	b2db      	uxtb	r3, r3
 8006cc6:	461a      	mov	r2, r3
 8006cc8:	68fb      	ldr	r3, [r7, #12]
 8006cca:	4313      	orrs	r3, r2
 8006ccc:	60fb      	str	r3, [r7, #12]
 8006cce:	e013      	b.n	8006cf8 <can_get_frame_priority_X+0x90>
    } else {
        ret |= frame->SID << 21; // Identifier
 8006cd0:	687b      	ldr	r3, [r7, #4]
 8006cd2:	889b      	ldrh	r3, [r3, #4]
 8006cd4:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8006cd8:	b29b      	uxth	r3, r3
 8006cda:	055b      	lsls	r3, r3, #21
 8006cdc:	461a      	mov	r2, r3
 8006cde:	68fb      	ldr	r3, [r7, #12]
 8006ce0:	4313      	orrs	r3, r2
 8006ce2:	60fb      	str	r3, [r7, #12]
        ret |= frame->RTR << 20; // RTR
 8006ce4:	687b      	ldr	r3, [r7, #4]
 8006ce6:	781b      	ldrb	r3, [r3, #0]
 8006ce8:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8006cec:	b2db      	uxtb	r3, r3
 8006cee:	051b      	lsls	r3, r3, #20
 8006cf0:	461a      	mov	r2, r3
 8006cf2:	68fb      	ldr	r3, [r7, #12]
 8006cf4:	4313      	orrs	r3, r2
 8006cf6:	60fb      	str	r3, [r7, #12]
    }

    return ~ret;
 8006cf8:	68fb      	ldr	r3, [r7, #12]
 8006cfa:	43db      	mvns	r3, r3
}
 8006cfc:	4618      	mov	r0, r3
 8006cfe:	3714      	adds	r7, #20
 8006d00:	46bd      	mov	sp, r7
 8006d02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006d06:	4770      	bx	lr

08006d08 <can_get_tx_frame_priority_X>:

can_frame_priority_t can_get_tx_frame_priority_X(const struct can_tx_frame_s* frame) {
 8006d08:	b580      	push	{r7, lr}
 8006d0a:	b082      	sub	sp, #8
 8006d0c:	af00      	add	r7, sp, #0
 8006d0e:	6078      	str	r0, [r7, #4]
    return can_get_frame_priority_X(&frame->content);
 8006d10:	687b      	ldr	r3, [r7, #4]
 8006d12:	4618      	mov	r0, r3
 8006d14:	f7ff ffa8 	bl	8006c68 <can_get_frame_priority_X>
 8006d18:	4603      	mov	r3, r0
}
 8006d1a:	4618      	mov	r0, r3
 8006d1c:	3708      	adds	r7, #8
 8006d1e:	46bd      	mov	sp, r7
 8006d20:	bd80      	pop	{r7, pc}
 8006d22:	bf00      	nop

08006d24 <port_lock.lto_priv.88>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006d24:	b480      	push	{r7}
 8006d26:	b083      	sub	sp, #12
 8006d28:	af00      	add	r7, sp, #0
 8006d2a:	2320      	movs	r3, #32
 8006d2c:	607b      	str	r3, [r7, #4]
 8006d2e:	687b      	ldr	r3, [r7, #4]
 8006d30:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006d34:	370c      	adds	r7, #12
 8006d36:	46bd      	mov	sp, r7
 8006d38:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006d3c:	4770      	bx	lr
 8006d3e:	bf00      	nop

08006d40 <port_unlock.lto_priv.85>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006d40:	b480      	push	{r7}
 8006d42:	b083      	sub	sp, #12
 8006d44:	af00      	add	r7, sp, #0
 8006d46:	2300      	movs	r3, #0
 8006d48:	607b      	str	r3, [r7, #4]
 8006d4a:	687b      	ldr	r3, [r7, #4]
 8006d4c:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006d50:	370c      	adds	r7, #12
 8006d52:	46bd      	mov	sp, r7
 8006d54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006d58:	4770      	bx	lr
 8006d5a:	bf00      	nop

08006d5c <st_lld_get_counter.lto_priv.82>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 8006d5c:	b480      	push	{r7}
 8006d5e:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 8006d60:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006d64:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006d66:	b29b      	uxth	r3, r3
}
 8006d68:	4618      	mov	r0, r3
 8006d6a:	46bd      	mov	sp, r7
 8006d6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006d70:	4770      	bx	lr
 8006d72:	bf00      	nop

08006d74 <port_timer_get_time.lto_priv.79>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8006d74:	b580      	push	{r7, lr}
 8006d76:	af00      	add	r7, sp, #0

  return stGetCounter();
 8006d78:	f7ff fff0 	bl	8006d5c <st_lld_get_counter.lto_priv.82>
 8006d7c:	4603      	mov	r3, r0
}
 8006d7e:	4618      	mov	r0, r3
 8006d80:	bd80      	pop	{r7, pc}
 8006d82:	bf00      	nop

08006d84 <chSysLock.lto_priv.61>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8006d84:	b580      	push	{r7, lr}
 8006d86:	af00      	add	r7, sp, #0

  port_lock();
 8006d88:	f7ff ffcc 	bl	8006d24 <port_lock.lto_priv.88>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006d8c:	f002 fe84 	bl	8009a98 <_dbg_check_lock>
}
 8006d90:	bd80      	pop	{r7, pc}
 8006d92:	bf00      	nop

08006d94 <chSysUnlock.lto_priv.58>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8006d94:	b580      	push	{r7, lr}
 8006d96:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8006d98:	f002 fe94 	bl	8009ac4 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8006d9c:	4b09      	ldr	r3, [pc, #36]	; (8006dc4 <chSysUnlock.lto_priv.58+0x30>)
 8006d9e:	681b      	ldr	r3, [r3, #0]
 8006da0:	4a08      	ldr	r2, [pc, #32]	; (8006dc4 <chSysUnlock.lto_priv.58+0x30>)
 8006da2:	4293      	cmp	r3, r2
 8006da4:	d00a      	beq.n	8006dbc <chSysUnlock.lto_priv.58+0x28>
 8006da6:	4b07      	ldr	r3, [pc, #28]	; (8006dc4 <chSysUnlock.lto_priv.58+0x30>)
 8006da8:	699b      	ldr	r3, [r3, #24]
 8006daa:	689a      	ldr	r2, [r3, #8]
 8006dac:	4b05      	ldr	r3, [pc, #20]	; (8006dc4 <chSysUnlock.lto_priv.58+0x30>)
 8006dae:	681b      	ldr	r3, [r3, #0]
 8006db0:	689b      	ldr	r3, [r3, #8]
 8006db2:	429a      	cmp	r2, r3
 8006db4:	d202      	bcs.n	8006dbc <chSysUnlock.lto_priv.58+0x28>
 8006db6:	4804      	ldr	r0, [pc, #16]	; (8006dc8 <chSysUnlock.lto_priv.58+0x34>)
 8006db8:	f002 fe20 	bl	80099fc <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8006dbc:	f7ff ffc0 	bl	8006d40 <port_unlock.lto_priv.85>
}
 8006dc0:	bd80      	pop	{r7, pc}
 8006dc2:	bf00      	nop
 8006dc4:	20001330 	.word	0x20001330
 8006dc8:	0800d1a4 	.word	0x0800d1a4

08006dcc <chVTGetSystemTimeX.lto_priv.75>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8006dcc:	b580      	push	{r7, lr}
 8006dce:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8006dd0:	f7ff ffd0 	bl	8006d74 <port_timer_get_time.lto_priv.79>
 8006dd4:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8006dd6:	4618      	mov	r0, r3
 8006dd8:	bd80      	pop	{r7, pc}
 8006dda:	bf00      	nop

08006ddc <chCoreAllocAlignedI.lto_priv.2>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8006ddc:	b580      	push	{r7, lr}
 8006dde:	b082      	sub	sp, #8
 8006de0:	af00      	add	r7, sp, #0
 8006de2:	6078      	str	r0, [r7, #4]
 8006de4:	6039      	str	r1, [r7, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8006de6:	6878      	ldr	r0, [r7, #4]
 8006de8:	6839      	ldr	r1, [r7, #0]
 8006dea:	2200      	movs	r2, #0
 8006dec:	f001 fe32 	bl	8008a54 <chCoreAllocAlignedWithOffsetI>
 8006df0:	4603      	mov	r3, r0
}
 8006df2:	4618      	mov	r0, r3
 8006df4:	3708      	adds	r7, #8
 8006df6:	46bd      	mov	sp, r7
 8006df8:	bd80      	pop	{r7, pc}
 8006dfa:	bf00      	nop

08006dfc <chCoreAlloc.lto_priv.53>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
static inline void *chCoreAlloc(size_t size) {
 8006dfc:	b580      	push	{r7, lr}
 8006dfe:	b082      	sub	sp, #8
 8006e00:	af00      	add	r7, sp, #0
 8006e02:	6078      	str	r0, [r7, #4]

  return chCoreAllocAlignedWithOffset(size, PORT_NATURAL_ALIGN, 0U);
 8006e04:	6878      	ldr	r0, [r7, #4]
 8006e06:	2104      	movs	r1, #4
 8006e08:	2200      	movs	r2, #0
 8006e0a:	f001 fe67 	bl	8008adc <chCoreAllocAlignedWithOffset>
 8006e0e:	4603      	mov	r3, r0
}
 8006e10:	4618      	mov	r0, r3
 8006e12:	3708      	adds	r7, #8
 8006e14:	46bd      	mov	sp, r7
 8006e16:	bd80      	pop	{r7, pc}

08006e18 <can_iterate_instances>:
static void can_reschedule_expire_timer_I(struct can_instance_s* instance);
static void can_reschedule_expire_timer(struct can_instance_s* instance);
static void can_try_enqueue_waiting_frame_I(struct can_instance_s* instance);
static void can_try_enqueue_waiting_frame(struct can_instance_s* instance);

bool can_iterate_instances(struct can_instance_s** instance_ptr) {
 8006e18:	b480      	push	{r7}
 8006e1a:	b083      	sub	sp, #12
 8006e1c:	af00      	add	r7, sp, #0
 8006e1e:	6078      	str	r0, [r7, #4]
    if (!instance_ptr) {
 8006e20:	687b      	ldr	r3, [r7, #4]
 8006e22:	2b00      	cmp	r3, #0
 8006e24:	d101      	bne.n	8006e2a <can_iterate_instances+0x12>
        return false;
 8006e26:	2300      	movs	r3, #0
 8006e28:	e015      	b.n	8006e56 <can_iterate_instances+0x3e>
    }

    if (!(*instance_ptr)) {
 8006e2a:	687b      	ldr	r3, [r7, #4]
 8006e2c:	681b      	ldr	r3, [r3, #0]
 8006e2e:	2b00      	cmp	r3, #0
 8006e30:	d104      	bne.n	8006e3c <can_iterate_instances+0x24>
        *instance_ptr = can_instance_list_head;
 8006e32:	4b0c      	ldr	r3, [pc, #48]	; (8006e64 <can_iterate_instances+0x4c>)
 8006e34:	681a      	ldr	r2, [r3, #0]
 8006e36:	687b      	ldr	r3, [r7, #4]
 8006e38:	601a      	str	r2, [r3, #0]
 8006e3a:	e005      	b.n	8006e48 <can_iterate_instances+0x30>
    } else {
        *instance_ptr = (*instance_ptr)->next;
 8006e3c:	687b      	ldr	r3, [r7, #4]
 8006e3e:	681b      	ldr	r3, [r3, #0]
 8006e40:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8006e44:	687b      	ldr	r3, [r7, #4]
 8006e46:	601a      	str	r2, [r3, #0]
    }

    return *instance_ptr != NULL;
 8006e48:	687b      	ldr	r3, [r7, #4]
 8006e4a:	681b      	ldr	r3, [r3, #0]
 8006e4c:	2b00      	cmp	r3, #0
 8006e4e:	bf14      	ite	ne
 8006e50:	2301      	movne	r3, #1
 8006e52:	2300      	moveq	r3, #0
 8006e54:	b2db      	uxtb	r3, r3
}
 8006e56:	4618      	mov	r0, r3
 8006e58:	370c      	adds	r7, #12
 8006e5a:	46bd      	mov	sp, r7
 8006e5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e60:	4770      	bx	lr
 8006e62:	bf00      	nop
 8006e64:	200013e4 	.word	0x200013e4

08006e68 <can_get_instance>:

struct can_instance_s* can_get_instance(uint8_t can_idx) {
 8006e68:	b480      	push	{r7}
 8006e6a:	b085      	sub	sp, #20
 8006e6c:	af00      	add	r7, sp, #0
 8006e6e:	4603      	mov	r3, r0
 8006e70:	71fb      	strb	r3, [r7, #7]
    for (struct can_instance_s* instance = can_instance_list_head; instance != NULL; instance = instance->next) {
 8006e72:	4b0c      	ldr	r3, [pc, #48]	; (8006ea4 <can_get_instance+0x3c>)
 8006e74:	681b      	ldr	r3, [r3, #0]
 8006e76:	60fb      	str	r3, [r7, #12]
 8006e78:	e00a      	b.n	8006e90 <can_get_instance+0x28>
        if (instance->idx == can_idx) {
 8006e7a:	68fb      	ldr	r3, [r7, #12]
 8006e7c:	781b      	ldrb	r3, [r3, #0]
 8006e7e:	79fa      	ldrb	r2, [r7, #7]
 8006e80:	429a      	cmp	r2, r3
 8006e82:	d101      	bne.n	8006e88 <can_get_instance+0x20>
            return instance;
 8006e84:	68fb      	ldr	r3, [r7, #12]
 8006e86:	e007      	b.n	8006e98 <can_get_instance+0x30>

    return *instance_ptr != NULL;
}

struct can_instance_s* can_get_instance(uint8_t can_idx) {
    for (struct can_instance_s* instance = can_instance_list_head; instance != NULL; instance = instance->next) {
 8006e88:	68fb      	ldr	r3, [r7, #12]
 8006e8a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8006e8e:	60fb      	str	r3, [r7, #12]
 8006e90:	68fb      	ldr	r3, [r7, #12]
 8006e92:	2b00      	cmp	r3, #0
 8006e94:	d1f1      	bne.n	8006e7a <can_get_instance+0x12>
        if (instance->idx == can_idx) {
            return instance;
        }
    }

    return NULL;
 8006e96:	2300      	movs	r3, #0
}
 8006e98:	4618      	mov	r0, r3
 8006e9a:	3714      	adds	r7, #20
 8006e9c:	46bd      	mov	sp, r7
 8006e9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006ea2:	4770      	bx	lr
 8006ea4:	200013e4 	.word	0x200013e4

08006ea8 <can_get_rx_topic>:

struct pubsub_topic_s* can_get_rx_topic(struct can_instance_s* instance) {
 8006ea8:	b580      	push	{r7, lr}
 8006eaa:	b082      	sub	sp, #8
 8006eac:	af00      	add	r7, sp, #0
 8006eae:	6078      	str	r0, [r7, #4]
    chDbgCheck(instance != NULL);
 8006eb0:	687b      	ldr	r3, [r7, #4]
 8006eb2:	2b00      	cmp	r3, #0
 8006eb4:	d102      	bne.n	8006ebc <can_get_rx_topic+0x14>
 8006eb6:	4807      	ldr	r0, [pc, #28]	; (8006ed4 <can_get_rx_topic+0x2c>)
 8006eb8:	f002 fda0 	bl	80099fc <chSysHalt>
    if (!instance) {
 8006ebc:	687b      	ldr	r3, [r7, #4]
 8006ebe:	2b00      	cmp	r3, #0
 8006ec0:	d101      	bne.n	8006ec6 <can_get_rx_topic+0x1e>
        return NULL;
 8006ec2:	2300      	movs	r3, #0
 8006ec4:	e001      	b.n	8006eca <can_get_rx_topic+0x22>
    }

    return &instance->rx_topic;
 8006ec6:	687b      	ldr	r3, [r7, #4]
 8006ec8:	3340      	adds	r3, #64	; 0x40
}
 8006eca:	4618      	mov	r0, r3
 8006ecc:	3708      	adds	r7, #8
 8006ece:	46bd      	mov	sp, r7
 8006ed0:	bd80      	pop	{r7, pc}
 8006ed2:	bf00      	nop
 8006ed4:	0800d190 	.word	0x0800d190

08006ed8 <can_set_silent_mode>:
    }

    return instance->baudrate;
}

void can_set_silent_mode(struct can_instance_s* instance, bool silent) {
 8006ed8:	b580      	push	{r7, lr}
 8006eda:	b082      	sub	sp, #8
 8006edc:	af00      	add	r7, sp, #0
 8006ede:	6078      	str	r0, [r7, #4]
 8006ee0:	460b      	mov	r3, r1
 8006ee2:	70fb      	strb	r3, [r7, #3]
    if (!instance) {
 8006ee4:	687b      	ldr	r3, [r7, #4]
 8006ee6:	2b00      	cmp	r3, #0
 8006ee8:	d014      	beq.n	8006f14 <can_set_silent_mode+0x3c>
        return;
    }

    chSysLock();
 8006eea:	f7ff ff4b 	bl	8006d84 <chSysLock.lto_priv.61>
    if (instance->started && instance->silent != silent) {
 8006eee:	687b      	ldr	r3, [r7, #4]
 8006ef0:	785b      	ldrb	r3, [r3, #1]
 8006ef2:	2b00      	cmp	r3, #0
 8006ef4:	d00c      	beq.n	8006f10 <can_set_silent_mode+0x38>
 8006ef6:	687b      	ldr	r3, [r7, #4]
 8006ef8:	789b      	ldrb	r3, [r3, #2]
 8006efa:	78fa      	ldrb	r2, [r7, #3]
 8006efc:	429a      	cmp	r2, r3
 8006efe:	d007      	beq.n	8006f10 <can_set_silent_mode+0x38>
        can_start_I(instance, silent, instance->auto_retransmit, instance->baudrate);
 8006f00:	687b      	ldr	r3, [r7, #4]
 8006f02:	78da      	ldrb	r2, [r3, #3]
 8006f04:	687b      	ldr	r3, [r7, #4]
 8006f06:	685b      	ldr	r3, [r3, #4]
 8006f08:	78f9      	ldrb	r1, [r7, #3]
 8006f0a:	6878      	ldr	r0, [r7, #4]
 8006f0c:	f000 f85c 	bl	8006fc8 <can_start_I>
    }
    chSysUnlock();
 8006f10:	f7ff ff40 	bl	8006d94 <chSysUnlock.lto_priv.58>
}
 8006f14:	3708      	adds	r7, #8
 8006f16:	46bd      	mov	sp, r7
 8006f18:	bd80      	pop	{r7, pc}
 8006f1a:	bf00      	nop

08006f1c <can_set_auto_retransmit_mode>:

void can_set_auto_retransmit_mode(struct can_instance_s* instance, bool auto_retransmit) {
 8006f1c:	b580      	push	{r7, lr}
 8006f1e:	b082      	sub	sp, #8
 8006f20:	af00      	add	r7, sp, #0
 8006f22:	6078      	str	r0, [r7, #4]
 8006f24:	460b      	mov	r3, r1
 8006f26:	70fb      	strb	r3, [r7, #3]
    if (!instance) {
 8006f28:	687b      	ldr	r3, [r7, #4]
 8006f2a:	2b00      	cmp	r3, #0
 8006f2c:	d014      	beq.n	8006f58 <can_set_auto_retransmit_mode+0x3c>
        return;
    }

    chSysLock();
 8006f2e:	f7ff ff29 	bl	8006d84 <chSysLock.lto_priv.61>
    if (instance->started && instance->auto_retransmit != auto_retransmit) {
 8006f32:	687b      	ldr	r3, [r7, #4]
 8006f34:	785b      	ldrb	r3, [r3, #1]
 8006f36:	2b00      	cmp	r3, #0
 8006f38:	d00c      	beq.n	8006f54 <can_set_auto_retransmit_mode+0x38>
 8006f3a:	687b      	ldr	r3, [r7, #4]
 8006f3c:	78db      	ldrb	r3, [r3, #3]
 8006f3e:	78fa      	ldrb	r2, [r7, #3]
 8006f40:	429a      	cmp	r2, r3
 8006f42:	d007      	beq.n	8006f54 <can_set_auto_retransmit_mode+0x38>
        can_start_I(instance, instance->silent, auto_retransmit, instance->baudrate);
 8006f44:	687b      	ldr	r3, [r7, #4]
 8006f46:	7899      	ldrb	r1, [r3, #2]
 8006f48:	687b      	ldr	r3, [r7, #4]
 8006f4a:	685b      	ldr	r3, [r3, #4]
 8006f4c:	78fa      	ldrb	r2, [r7, #3]
 8006f4e:	6878      	ldr	r0, [r7, #4]
 8006f50:	f000 f83a 	bl	8006fc8 <can_start_I>
    }
    chSysUnlock();
 8006f54:	f7ff ff1e 	bl	8006d94 <chSysUnlock.lto_priv.58>
}
 8006f58:	3708      	adds	r7, #8
 8006f5a:	46bd      	mov	sp, r7
 8006f5c:	bd80      	pop	{r7, pc}
 8006f5e:	bf00      	nop

08006f60 <can_set_baudrate>:

void can_set_baudrate(struct can_instance_s* instance, uint32_t baudrate) {
 8006f60:	b580      	push	{r7, lr}
 8006f62:	b082      	sub	sp, #8
 8006f64:	af00      	add	r7, sp, #0
 8006f66:	6078      	str	r0, [r7, #4]
 8006f68:	6039      	str	r1, [r7, #0]
    if (!instance) {
 8006f6a:	687b      	ldr	r3, [r7, #4]
 8006f6c:	2b00      	cmp	r3, #0
 8006f6e:	d016      	beq.n	8006f9e <can_set_baudrate+0x3e>
        return;
    }

    chSysLock();
 8006f70:	f7ff ff08 	bl	8006d84 <chSysLock.lto_priv.61>
    if (instance->started && instance->baudrate != baudrate) {
 8006f74:	687b      	ldr	r3, [r7, #4]
 8006f76:	785b      	ldrb	r3, [r3, #1]
 8006f78:	2b00      	cmp	r3, #0
 8006f7a:	d00e      	beq.n	8006f9a <can_set_baudrate+0x3a>
 8006f7c:	687b      	ldr	r3, [r7, #4]
 8006f7e:	685a      	ldr	r2, [r3, #4]
 8006f80:	683b      	ldr	r3, [r7, #0]
 8006f82:	429a      	cmp	r2, r3
 8006f84:	d009      	beq.n	8006f9a <can_set_baudrate+0x3a>
        can_start_I(instance, instance->silent, instance->auto_retransmit, baudrate);
 8006f86:	687b      	ldr	r3, [r7, #4]
 8006f88:	789a      	ldrb	r2, [r3, #2]
 8006f8a:	687b      	ldr	r3, [r7, #4]
 8006f8c:	78db      	ldrb	r3, [r3, #3]
 8006f8e:	6878      	ldr	r0, [r7, #4]
 8006f90:	4611      	mov	r1, r2
 8006f92:	461a      	mov	r2, r3
 8006f94:	683b      	ldr	r3, [r7, #0]
 8006f96:	f000 f817 	bl	8006fc8 <can_start_I>
    }
    chSysUnlock();
 8006f9a:	f7ff fefb 	bl	8006d94 <chSysUnlock.lto_priv.58>
}
 8006f9e:	3708      	adds	r7, #8
 8006fa0:	46bd      	mov	sp, r7
 8006fa2:	bd80      	pop	{r7, pc}

08006fa4 <can_get_baudrate_confirmed>:

bool can_get_baudrate_confirmed(struct can_instance_s* instance) {
 8006fa4:	b480      	push	{r7}
 8006fa6:	b083      	sub	sp, #12
 8006fa8:	af00      	add	r7, sp, #0
 8006faa:	6078      	str	r0, [r7, #4]
    if (!instance) {
 8006fac:	687b      	ldr	r3, [r7, #4]
 8006fae:	2b00      	cmp	r3, #0
 8006fb0:	d101      	bne.n	8006fb6 <can_get_baudrate_confirmed+0x12>
        return false;
 8006fb2:	2300      	movs	r3, #0
 8006fb4:	e001      	b.n	8006fba <can_get_baudrate_confirmed+0x16>
    }

    return instance->baudrate_confirmed;
 8006fb6:	687b      	ldr	r3, [r7, #4]
 8006fb8:	7a1b      	ldrb	r3, [r3, #8]
}
 8006fba:	4618      	mov	r0, r3
 8006fbc:	370c      	adds	r7, #12
 8006fbe:	46bd      	mov	sp, r7
 8006fc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006fc4:	4770      	bx	lr
 8006fc6:	bf00      	nop

08006fc8 <can_start_I>:

void can_start_I(struct can_instance_s* instance, bool silent, bool auto_retransmit, uint32_t baudrate) {
 8006fc8:	b590      	push	{r4, r7, lr}
 8006fca:	b085      	sub	sp, #20
 8006fcc:	af00      	add	r7, sp, #0
 8006fce:	60f8      	str	r0, [r7, #12]
 8006fd0:	607b      	str	r3, [r7, #4]
 8006fd2:	460b      	mov	r3, r1
 8006fd4:	72fb      	strb	r3, [r7, #11]
 8006fd6:	4613      	mov	r3, r2
 8006fd8:	72bb      	strb	r3, [r7, #10]
    chDbgCheckClassI();
 8006fda:	f002 fded 	bl	8009bb8 <chDbgCheckClassI>
    if (!instance) {
 8006fde:	68fb      	ldr	r3, [r7, #12]
 8006fe0:	2b00      	cmp	r3, #0
 8006fe2:	d026      	beq.n	8007032 <can_start_I+0x6a>
        return;
    }

    if (instance->started) {
 8006fe4:	68fb      	ldr	r3, [r7, #12]
 8006fe6:	785b      	ldrb	r3, [r3, #1]
 8006fe8:	2b00      	cmp	r3, #0
 8006fea:	d002      	beq.n	8006ff2 <can_start_I+0x2a>
        // TODO prevent dropped frames when re-starting CAN driver
        can_stop_I(instance);
 8006fec:	68f8      	ldr	r0, [r7, #12]
 8006fee:	f000 f83b 	bl	8007068 <can_stop_I>
    }

    instance->driver_iface->start(instance->driver_ctx, silent, auto_retransmit, baudrate);
 8006ff2:	68fb      	ldr	r3, [r7, #12]
 8006ff4:	691b      	ldr	r3, [r3, #16]
 8006ff6:	681c      	ldr	r4, [r3, #0]
 8006ff8:	68fb      	ldr	r3, [r7, #12]
 8006ffa:	68d9      	ldr	r1, [r3, #12]
 8006ffc:	7afa      	ldrb	r2, [r7, #11]
 8006ffe:	7abb      	ldrb	r3, [r7, #10]
 8007000:	4608      	mov	r0, r1
 8007002:	4611      	mov	r1, r2
 8007004:	461a      	mov	r2, r3
 8007006:	687b      	ldr	r3, [r7, #4]
 8007008:	47a0      	blx	r4
    instance->started = true;
 800700a:	68fb      	ldr	r3, [r7, #12]
 800700c:	2201      	movs	r2, #1
 800700e:	705a      	strb	r2, [r3, #1]
    instance->silent = silent;
 8007010:	68fb      	ldr	r3, [r7, #12]
 8007012:	7afa      	ldrb	r2, [r7, #11]
 8007014:	709a      	strb	r2, [r3, #2]
    instance->auto_retransmit = auto_retransmit;
 8007016:	68fb      	ldr	r3, [r7, #12]
 8007018:	7aba      	ldrb	r2, [r7, #10]
 800701a:	70da      	strb	r2, [r3, #3]
    if (baudrate != instance->baudrate) {
 800701c:	68fb      	ldr	r3, [r7, #12]
 800701e:	685a      	ldr	r2, [r3, #4]
 8007020:	687b      	ldr	r3, [r7, #4]
 8007022:	429a      	cmp	r2, r3
 8007024:	d002      	beq.n	800702c <can_start_I+0x64>
        instance->baudrate_confirmed = false;
 8007026:	68fb      	ldr	r3, [r7, #12]
 8007028:	2200      	movs	r2, #0
 800702a:	721a      	strb	r2, [r3, #8]
    }
    instance->baudrate = baudrate;
 800702c:	68fb      	ldr	r3, [r7, #12]
 800702e:	687a      	ldr	r2, [r7, #4]
 8007030:	605a      	str	r2, [r3, #4]
}
 8007032:	3714      	adds	r7, #20
 8007034:	46bd      	mov	sp, r7
 8007036:	bd90      	pop	{r4, r7, pc}

08007038 <can_start>:

void can_start(struct can_instance_s* instance, bool silent, bool auto_retransmit, uint32_t baudrate) {
 8007038:	b580      	push	{r7, lr}
 800703a:	b084      	sub	sp, #16
 800703c:	af00      	add	r7, sp, #0
 800703e:	60f8      	str	r0, [r7, #12]
 8007040:	607b      	str	r3, [r7, #4]
 8007042:	460b      	mov	r3, r1
 8007044:	72fb      	strb	r3, [r7, #11]
 8007046:	4613      	mov	r3, r2
 8007048:	72bb      	strb	r3, [r7, #10]
    chSysLock();
 800704a:	f7ff fe9b 	bl	8006d84 <chSysLock.lto_priv.61>
    can_start_I(instance, silent, auto_retransmit, baudrate);
 800704e:	7afa      	ldrb	r2, [r7, #11]
 8007050:	7abb      	ldrb	r3, [r7, #10]
 8007052:	68f8      	ldr	r0, [r7, #12]
 8007054:	4611      	mov	r1, r2
 8007056:	461a      	mov	r2, r3
 8007058:	687b      	ldr	r3, [r7, #4]
 800705a:	f7ff ffb5 	bl	8006fc8 <can_start_I>
    chSysUnlock();
 800705e:	f7ff fe99 	bl	8006d94 <chSysUnlock.lto_priv.58>
}
 8007062:	3710      	adds	r7, #16
 8007064:	46bd      	mov	sp, r7
 8007066:	bd80      	pop	{r7, pc}

08007068 <can_stop_I>:

void can_stop_I(struct can_instance_s* instance) {
 8007068:	b580      	push	{r7, lr}
 800706a:	b082      	sub	sp, #8
 800706c:	af00      	add	r7, sp, #0
 800706e:	6078      	str	r0, [r7, #4]
    if (!instance) {
 8007070:	687b      	ldr	r3, [r7, #4]
 8007072:	2b00      	cmp	r3, #0
 8007074:	d00d      	beq.n	8007092 <can_stop_I+0x2a>
        return;
    }

    if (instance->started) {
 8007076:	687b      	ldr	r3, [r7, #4]
 8007078:	785b      	ldrb	r3, [r3, #1]
 800707a:	2b00      	cmp	r3, #0
 800707c:	d009      	beq.n	8007092 <can_stop_I+0x2a>
        instance->driver_iface->stop(instance->driver_ctx);
 800707e:	687b      	ldr	r3, [r7, #4]
 8007080:	691b      	ldr	r3, [r3, #16]
 8007082:	685b      	ldr	r3, [r3, #4]
 8007084:	687a      	ldr	r2, [r7, #4]
 8007086:	68d2      	ldr	r2, [r2, #12]
 8007088:	4610      	mov	r0, r2
 800708a:	4798      	blx	r3
        instance->started = true;
 800708c:	687b      	ldr	r3, [r7, #4]
 800708e:	2201      	movs	r2, #1
 8007090:	705a      	strb	r2, [r3, #1]
    }
}
 8007092:	3708      	adds	r7, #8
 8007094:	46bd      	mov	sp, r7
 8007096:	bd80      	pop	{r7, pc}

08007098 <can_allocate_tx_frame_and_append_I>:
    chSysLock();
    can_stop_I(instance);
    chSysUnlock();
}

struct can_tx_frame_s* can_allocate_tx_frame_and_append_I(struct can_instance_s* instance, struct can_tx_frame_s** frame_list) {
 8007098:	b580      	push	{r7, lr}
 800709a:	b084      	sub	sp, #16
 800709c:	af00      	add	r7, sp, #0
 800709e:	6078      	str	r0, [r7, #4]
 80070a0:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 80070a2:	f002 fd89 	bl	8009bb8 <chDbgCheckClassI>
    
    if (!instance || !frame_list) {
 80070a6:	687b      	ldr	r3, [r7, #4]
 80070a8:	2b00      	cmp	r3, #0
 80070aa:	d002      	beq.n	80070b2 <can_allocate_tx_frame_and_append_I+0x1a>
 80070ac:	683b      	ldr	r3, [r7, #0]
 80070ae:	2b00      	cmp	r3, #0
 80070b0:	d101      	bne.n	80070b6 <can_allocate_tx_frame_and_append_I+0x1e>
        return NULL;
 80070b2:	2300      	movs	r3, #0
 80070b4:	e01c      	b.n	80070f0 <can_allocate_tx_frame_and_append_I+0x58>
    }
    
    struct can_tx_frame_s* new_frame = chPoolAllocI(&instance->frame_pool);
 80070b6:	687b      	ldr	r3, [r7, #4]
 80070b8:	3330      	adds	r3, #48	; 0x30
 80070ba:	4618      	mov	r0, r3
 80070bc:	f001 fdc2 	bl	8008c44 <chPoolAllocI>
 80070c0:	60b8      	str	r0, [r7, #8]
    if (!new_frame) {
 80070c2:	68bb      	ldr	r3, [r7, #8]
 80070c4:	2b00      	cmp	r3, #0
 80070c6:	d101      	bne.n	80070cc <can_allocate_tx_frame_and_append_I+0x34>
        return NULL;
 80070c8:	2300      	movs	r3, #0
 80070ca:	e011      	b.n	80070f0 <can_allocate_tx_frame_and_append_I+0x58>
    }
    
    LINKED_LIST_APPEND(struct can_tx_frame_s, *frame_list, new_frame);
 80070cc:	68bb      	ldr	r3, [r7, #8]
 80070ce:	2200      	movs	r2, #0
 80070d0:	619a      	str	r2, [r3, #24]
 80070d2:	683b      	ldr	r3, [r7, #0]
 80070d4:	60fb      	str	r3, [r7, #12]
 80070d6:	e003      	b.n	80070e0 <can_allocate_tx_frame_and_append_I+0x48>
 80070d8:	68fb      	ldr	r3, [r7, #12]
 80070da:	681b      	ldr	r3, [r3, #0]
 80070dc:	3318      	adds	r3, #24
 80070de:	60fb      	str	r3, [r7, #12]
 80070e0:	68fb      	ldr	r3, [r7, #12]
 80070e2:	681b      	ldr	r3, [r3, #0]
 80070e4:	2b00      	cmp	r3, #0
 80070e6:	d1f7      	bne.n	80070d8 <can_allocate_tx_frame_and_append_I+0x40>
 80070e8:	68fb      	ldr	r3, [r7, #12]
 80070ea:	68ba      	ldr	r2, [r7, #8]
 80070ec:	601a      	str	r2, [r3, #0]

    return new_frame;
 80070ee:	68bb      	ldr	r3, [r7, #8]
}
 80070f0:	4618      	mov	r0, r3
 80070f2:	3710      	adds	r7, #16
 80070f4:	46bd      	mov	sp, r7
 80070f6:	bd80      	pop	{r7, pc}

080070f8 <can_allocate_tx_frame_and_append>:

struct can_tx_frame_s* can_allocate_tx_frame_and_append(struct can_instance_s* instance, struct can_tx_frame_s** frame_list) {
 80070f8:	b580      	push	{r7, lr}
 80070fa:	b084      	sub	sp, #16
 80070fc:	af00      	add	r7, sp, #0
 80070fe:	6078      	str	r0, [r7, #4]
 8007100:	6039      	str	r1, [r7, #0]
    chSysLock();
 8007102:	f7ff fe3f 	bl	8006d84 <chSysLock.lto_priv.61>
    struct can_tx_frame_s* ret = can_allocate_tx_frame_and_append_I(instance, frame_list);
 8007106:	6878      	ldr	r0, [r7, #4]
 8007108:	6839      	ldr	r1, [r7, #0]
 800710a:	f7ff ffc5 	bl	8007098 <can_allocate_tx_frame_and_append_I>
 800710e:	60f8      	str	r0, [r7, #12]
    chSysUnlock();
 8007110:	f7ff fe40 	bl	8006d94 <chSysUnlock.lto_priv.58>
    return ret;
 8007114:	68fb      	ldr	r3, [r7, #12]
}
 8007116:	4618      	mov	r0, r3
 8007118:	3710      	adds	r7, #16
 800711a:	46bd      	mov	sp, r7
 800711c:	bd80      	pop	{r7, pc}
 800711e:	bf00      	nop

08007120 <can_enqueue_tx_frames>:
        }
    }
    return ret;
}

void can_enqueue_tx_frames(struct can_instance_s* instance, struct can_tx_frame_s** frame_list, systime_t tx_timeout, struct pubsub_topic_s* completion_topic) {
 8007120:	b580      	push	{r7, lr}
 8007122:	b088      	sub	sp, #32
 8007124:	af00      	add	r7, sp, #0
 8007126:	60f8      	str	r0, [r7, #12]
 8007128:	60b9      	str	r1, [r7, #8]
 800712a:	603b      	str	r3, [r7, #0]
 800712c:	4613      	mov	r3, r2
 800712e:	80fb      	strh	r3, [r7, #6]
    if (!instance) {
 8007130:	68fb      	ldr	r3, [r7, #12]
 8007132:	2b00      	cmp	r3, #0
 8007134:	d02f      	beq.n	8007196 <can_enqueue_tx_frames+0x76>
        return;
    }
    
    systime_t t_now = chVTGetSystemTimeX();
 8007136:	f7ff fe49 	bl	8006dcc <chVTGetSystemTimeX.lto_priv.75>
 800713a:	4603      	mov	r3, r0
 800713c:	837b      	strh	r3, [r7, #26]

    struct can_tx_frame_s* frame = *frame_list;
 800713e:	68bb      	ldr	r3, [r7, #8]
 8007140:	681b      	ldr	r3, [r3, #0]
 8007142:	61fb      	str	r3, [r7, #28]
 8007144:	e01b      	b.n	800717e <can_enqueue_tx_frames+0x5e>
    while (frame != NULL) {
        struct can_tx_frame_s* next_frame = frame->next;
 8007146:	69fb      	ldr	r3, [r7, #28]
 8007148:	699b      	ldr	r3, [r3, #24]
 800714a:	617b      	str	r3, [r7, #20]

        frame->creation_systime = t_now;
 800714c:	69fb      	ldr	r3, [r7, #28]
 800714e:	8b7a      	ldrh	r2, [r7, #26]
 8007150:	821a      	strh	r2, [r3, #16]
        frame->tx_timeout = tx_timeout;
 8007152:	69fb      	ldr	r3, [r7, #28]
 8007154:	88fa      	ldrh	r2, [r7, #6]
 8007156:	825a      	strh	r2, [r3, #18]
        if (!frame->next) {
 8007158:	69fb      	ldr	r3, [r7, #28]
 800715a:	699b      	ldr	r3, [r3, #24]
 800715c:	2b00      	cmp	r3, #0
 800715e:	d103      	bne.n	8007168 <can_enqueue_tx_frames+0x48>
            frame->completion_topic = completion_topic;
 8007160:	69fb      	ldr	r3, [r7, #28]
 8007162:	683a      	ldr	r2, [r7, #0]
 8007164:	615a      	str	r2, [r3, #20]
 8007166:	e002      	b.n	800716e <can_enqueue_tx_frames+0x4e>
        } else {
            frame->completion_topic = NULL;
 8007168:	69fb      	ldr	r3, [r7, #28]
 800716a:	2200      	movs	r2, #0
 800716c:	615a      	str	r2, [r3, #20]
        }
        can_tx_queue_push(&instance->tx_queue, frame);
 800716e:	68fb      	ldr	r3, [r7, #12]
 8007170:	333c      	adds	r3, #60	; 0x3c
 8007172:	4618      	mov	r0, r3
 8007174:	69f9      	ldr	r1, [r7, #28]
 8007176:	f7ff fc65 	bl	8006a44 <can_tx_queue_push>

        frame = next_frame;
 800717a:	697b      	ldr	r3, [r7, #20]
 800717c:	61fb      	str	r3, [r7, #28]
    }
    
    systime_t t_now = chVTGetSystemTimeX();

    struct can_tx_frame_s* frame = *frame_list;
    while (frame != NULL) {
 800717e:	69fb      	ldr	r3, [r7, #28]
 8007180:	2b00      	cmp	r3, #0
 8007182:	d1e0      	bne.n	8007146 <can_enqueue_tx_frames+0x26>
        can_tx_queue_push(&instance->tx_queue, frame);

        frame = next_frame;
    }

    *frame_list = NULL;
 8007184:	68bb      	ldr	r3, [r7, #8]
 8007186:	2200      	movs	r2, #0
 8007188:	601a      	str	r2, [r3, #0]

    can_try_enqueue_waiting_frame(instance);
 800718a:	68f8      	ldr	r0, [r7, #12]
 800718c:	f7fd fd9a 	bl	8004cc4 <can_try_enqueue_waiting_frame.lto_priv.104>
    can_reschedule_expire_timer(instance);
 8007190:	68f8      	ldr	r0, [r7, #12]
 8007192:	f7fd fe05 	bl	8004da0 <can_reschedule_expire_timer.lto_priv.103>
}
 8007196:	3720      	adds	r7, #32
 8007198:	46bd      	mov	sp, r7
 800719a:	bd80      	pop	{r7, pc}

0800719c <crc16_ccitt>:
        *hash ^= (uint64_t)buf[i];
        *hash *= FNV_1_PRIME_64;
    }
}

uint16_t crc16_ccitt(const void *buf, size_t len, uint16_t crc) {
 800719c:	b480      	push	{r7}
 800719e:	b087      	sub	sp, #28
 80071a0:	af00      	add	r7, sp, #0
 80071a2:	60f8      	str	r0, [r7, #12]
 80071a4:	60b9      	str	r1, [r7, #8]
 80071a6:	4613      	mov	r3, r2
 80071a8:	80fb      	strh	r3, [r7, #6]
    for (size_t i = 0; i < len; i++) {
 80071aa:	2300      	movs	r3, #0
 80071ac:	617b      	str	r3, [r7, #20]
 80071ae:	e026      	b.n	80071fe <crc16_ccitt+0x62>
        crc = crc ^ (((uint8_t*)buf)[i] << 8);
 80071b0:	68fa      	ldr	r2, [r7, #12]
 80071b2:	697b      	ldr	r3, [r7, #20]
 80071b4:	4413      	add	r3, r2
 80071b6:	781b      	ldrb	r3, [r3, #0]
 80071b8:	021b      	lsls	r3, r3, #8
 80071ba:	b29a      	uxth	r2, r3
 80071bc:	88fb      	ldrh	r3, [r7, #6]
 80071be:	4053      	eors	r3, r2
 80071c0:	b29b      	uxth	r3, r3
 80071c2:	80fb      	strh	r3, [r7, #6]
        for (int j = 0; j < 8; j++) {
 80071c4:	2300      	movs	r3, #0
 80071c6:	613b      	str	r3, [r7, #16]
 80071c8:	e013      	b.n	80071f2 <crc16_ccitt+0x56>
            if (crc & 0x8000) {
 80071ca:	88fb      	ldrh	r3, [r7, #6]
 80071cc:	b21b      	sxth	r3, r3
 80071ce:	2b00      	cmp	r3, #0
 80071d0:	da09      	bge.n	80071e6 <crc16_ccitt+0x4a>
                crc = (crc << 1) ^ 0x1021;
 80071d2:	88fb      	ldrh	r3, [r7, #6]
 80071d4:	005b      	lsls	r3, r3, #1
 80071d6:	b29b      	uxth	r3, r3
 80071d8:	f483 5381 	eor.w	r3, r3, #4128	; 0x1020
 80071dc:	f083 0301 	eor.w	r3, r3, #1
 80071e0:	b29b      	uxth	r3, r3
 80071e2:	80fb      	strh	r3, [r7, #6]
 80071e4:	e002      	b.n	80071ec <crc16_ccitt+0x50>
            } else {
                crc = (crc << 1);
 80071e6:	88fb      	ldrh	r3, [r7, #6]
 80071e8:	005b      	lsls	r3, r3, #1
 80071ea:	80fb      	strh	r3, [r7, #6]
}

uint16_t crc16_ccitt(const void *buf, size_t len, uint16_t crc) {
    for (size_t i = 0; i < len; i++) {
        crc = crc ^ (((uint8_t*)buf)[i] << 8);
        for (int j = 0; j < 8; j++) {
 80071ec:	693b      	ldr	r3, [r7, #16]
 80071ee:	3301      	adds	r3, #1
 80071f0:	613b      	str	r3, [r7, #16]
 80071f2:	693b      	ldr	r3, [r7, #16]
 80071f4:	2b07      	cmp	r3, #7
 80071f6:	dde8      	ble.n	80071ca <crc16_ccitt+0x2e>
        *hash *= FNV_1_PRIME_64;
    }
}

uint16_t crc16_ccitt(const void *buf, size_t len, uint16_t crc) {
    for (size_t i = 0; i < len; i++) {
 80071f8:	697b      	ldr	r3, [r7, #20]
 80071fa:	3301      	adds	r3, #1
 80071fc:	617b      	str	r3, [r7, #20]
 80071fe:	697a      	ldr	r2, [r7, #20]
 8007200:	68bb      	ldr	r3, [r7, #8]
 8007202:	429a      	cmp	r2, r3
 8007204:	d3d4      	bcc.n	80071b0 <crc16_ccitt+0x14>
                crc = (crc << 1);
            }
        }
    }

    return crc;
 8007206:	88fb      	ldrh	r3, [r7, #6]
}
 8007208:	4618      	mov	r0, r3
 800720a:	371c      	adds	r7, #28
 800720c:	46bd      	mov	sp, r7
 800720e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007212:	4770      	bx	lr

08007214 <_local_ctor_5.lto_priv.131>:
#include <common/ctor.h>

#include <ch.h>

RUN_ON(CH_SYS_INIT) {
 8007214:	b580      	push	{r7, lr}
 8007216:	af00      	add	r7, sp, #0
    chSysInit();
 8007218:	f002 fbbe 	bl	8009998 <chSysInit>
}
 800721c:	bd80      	pop	{r7, pc}
 800721e:	bf00      	nop

08007220 <_local_ctor_5.lto_priv.132>:
#include <common/ctor.h>

#include <hal.h>

RUN_ON(CH_HAL_INIT) {
 8007220:	b580      	push	{r7, lr}
 8007222:	af00      	add	r7, sp, #0
    halInit();
 8007224:	f001 fdf2 	bl	8008e0c <halInit>
}
 8007228:	bd80      	pop	{r7, pc}
 800722a:	bf00      	nop

0800722c <st_lld_get_counter.lto_priv.116>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 800722c:	b480      	push	{r7}
 800722e:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 8007230:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8007234:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007236:	b29b      	uxth	r3, r3
}
 8007238:	4618      	mov	r0, r3
 800723a:	46bd      	mov	sp, r7
 800723c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007240:	4770      	bx	lr
 8007242:	bf00      	nop

08007244 <port_timer_get_time.lto_priv.113>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8007244:	b580      	push	{r7, lr}
 8007246:	af00      	add	r7, sp, #0

  return stGetCounter();
 8007248:	f7ff fff0 	bl	800722c <st_lld_get_counter.lto_priv.116>
 800724c:	4603      	mov	r3, r0
}
 800724e:	4618      	mov	r0, r3
 8007250:	bd80      	pop	{r7, pc}
 8007252:	bf00      	nop

08007254 <chVTGetSystemTimeX.lto_priv.124>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8007254:	b580      	push	{r7, lr}
 8007256:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8007258:	f7ff fff4 	bl	8007244 <port_timer_get_time.lto_priv.113>
 800725c:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800725e:	4618      	mov	r0, r3
 8007260:	bd80      	pop	{r7, pc}
 8007262:	bf00      	nop

08007264 <_local_ctor_39>:

static struct worker_thread_timer_task_s timing_state_update_task;

static void timing_state_update_task_func(struct worker_thread_timer_task_s* task);

RUN_AFTER(WORKER_THREADS_INIT) {
 8007264:	b580      	push	{r7, lr}
 8007266:	b082      	sub	sp, #8
 8007268:	af02      	add	r7, sp, #8
    worker_thread_add_timer_task(&WT, &timing_state_update_task, timing_state_update_task_func, NULL, S2ST(10), true);
 800726a:	f248 63a0 	movw	r3, #34464	; 0x86a0
 800726e:	9300      	str	r3, [sp, #0]
 8007270:	2301      	movs	r3, #1
 8007272:	9301      	str	r3, [sp, #4]
 8007274:	4803      	ldr	r0, [pc, #12]	; (8007284 <_local_ctor_39+0x20>)
 8007276:	4904      	ldr	r1, [pc, #16]	; (8007288 <_local_ctor_39+0x24>)
 8007278:	4a04      	ldr	r2, [pc, #16]	; (800728c <_local_ctor_39+0x28>)
 800727a:	2300      	movs	r3, #0
 800727c:	f000 fe18 	bl	8007eb0 <worker_thread_add_timer_task>
}
 8007280:	46bd      	mov	sp, r7
 8007282:	bd80      	pop	{r7, pc}
 8007284:	20000a20 	.word	0x20000a20
 8007288:	200013c4 	.word	0x200013c4
 800728c:	080073bd 	.word	0x080073bd

08007290 <micros>:
    uint32_t delta_ticks = systime_now-timing_state[idx].update_systime;
    uint32_t delta_ms = delta_ticks / (CH_CFG_ST_FREQUENCY/1000);
    return ((uint32_t)timing_state[idx].update_seconds*1000) + delta_ms;
}

uint32_t micros(void) {
 8007290:	b580      	push	{r7, lr}
 8007292:	b084      	sub	sp, #16
 8007294:	af00      	add	r7, sp, #0
    uint8_t idx = timing_state_idx;
 8007296:	4b16      	ldr	r3, [pc, #88]	; (80072f0 <micros+0x60>)
 8007298:	781b      	ldrb	r3, [r3, #0]
 800729a:	73fb      	strb	r3, [r7, #15]
    systime_t systime_now = chVTGetSystemTimeX();
 800729c:	f7ff ffda 	bl	8007254 <chVTGetSystemTimeX.lto_priv.124>
 80072a0:	4603      	mov	r3, r0
 80072a2:	81bb      	strh	r3, [r7, #12]
    uint32_t delta_ticks = systime_now-timing_state[idx].update_systime;
 80072a4:	89bb      	ldrh	r3, [r7, #12]
 80072a6:	7bfa      	ldrb	r2, [r7, #15]
 80072a8:	4912      	ldr	r1, [pc, #72]	; (80072f4 <micros+0x64>)
 80072aa:	0112      	lsls	r2, r2, #4
 80072ac:	440a      	add	r2, r1
 80072ae:	3208      	adds	r2, #8
 80072b0:	8812      	ldrh	r2, [r2, #0]
 80072b2:	1a9b      	subs	r3, r3, r2
 80072b4:	60bb      	str	r3, [r7, #8]
    uint32_t delta_us = delta_ticks * (1000000.0f/CH_CFG_ST_FREQUENCY);
 80072b6:	68b8      	ldr	r0, [r7, #8]
 80072b8:	f7fc fbb4 	bl	8003a24 <__aeabi_ui2f>
 80072bc:	4603      	mov	r3, r0
 80072be:	4618      	mov	r0, r3
 80072c0:	490d      	ldr	r1, [pc, #52]	; (80072f8 <micros+0x68>)
 80072c2:	f7fc fc07 	bl	8003ad4 <__aeabi_fmul>
 80072c6:	4603      	mov	r3, r0
 80072c8:	4618      	mov	r0, r3
 80072ca:	f7fb fffd 	bl	80032c8 <__aeabi_f2uiz>
 80072ce:	4603      	mov	r3, r0
 80072d0:	607b      	str	r3, [r7, #4]
    return ((uint32_t)timing_state[idx].update_seconds*1000000) + delta_us;
 80072d2:	7bfb      	ldrb	r3, [r7, #15]
 80072d4:	4a07      	ldr	r2, [pc, #28]	; (80072f4 <micros+0x64>)
 80072d6:	011b      	lsls	r3, r3, #4
 80072d8:	4413      	add	r3, r2
 80072da:	e9d3 2300 	ldrd	r2, r3, [r3]
 80072de:	4b07      	ldr	r3, [pc, #28]	; (80072fc <micros+0x6c>)
 80072e0:	fb03 f202 	mul.w	r2, r3, r2
 80072e4:	687b      	ldr	r3, [r7, #4]
 80072e6:	4413      	add	r3, r2
}
 80072e8:	4618      	mov	r0, r3
 80072ea:	3710      	adds	r7, #16
 80072ec:	46bd      	mov	sp, r7
 80072ee:	bd80      	pop	{r7, pc}
 80072f0:	200013c0 	.word	0x200013c0
 80072f4:	200013a0 	.word	0x200013a0
 80072f8:	42c80000 	.word	0x42c80000
 80072fc:	000f4240 	.word	0x000f4240

08007300 <micros64>:

uint64_t micros64(void) {
 8007300:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8007304:	b084      	sub	sp, #16
 8007306:	af00      	add	r7, sp, #0
    uint8_t idx = timing_state_idx;
 8007308:	4b29      	ldr	r3, [pc, #164]	; (80073b0 <micros64+0xb0>)
 800730a:	781b      	ldrb	r3, [r3, #0]
 800730c:	73fb      	strb	r3, [r7, #15]
    systime_t systime_now = chVTGetSystemTimeX();
 800730e:	f7ff ffa1 	bl	8007254 <chVTGetSystemTimeX.lto_priv.124>
 8007312:	4603      	mov	r3, r0
 8007314:	81bb      	strh	r3, [r7, #12]
    uint32_t delta_ticks = systime_now-timing_state[idx].update_systime;
 8007316:	89bb      	ldrh	r3, [r7, #12]
 8007318:	7bfa      	ldrb	r2, [r7, #15]
 800731a:	4926      	ldr	r1, [pc, #152]	; (80073b4 <micros64+0xb4>)
 800731c:	0112      	lsls	r2, r2, #4
 800731e:	440a      	add	r2, r1
 8007320:	3208      	adds	r2, #8
 8007322:	8812      	ldrh	r2, [r2, #0]
 8007324:	1a9b      	subs	r3, r3, r2
 8007326:	60bb      	str	r3, [r7, #8]
    uint32_t delta_us = delta_ticks * (1000000.0f/CH_CFG_ST_FREQUENCY);
 8007328:	68b8      	ldr	r0, [r7, #8]
 800732a:	f7fc fb7b 	bl	8003a24 <__aeabi_ui2f>
 800732e:	4603      	mov	r3, r0
 8007330:	4618      	mov	r0, r3
 8007332:	4921      	ldr	r1, [pc, #132]	; (80073b8 <micros64+0xb8>)
 8007334:	f7fc fbce 	bl	8003ad4 <__aeabi_fmul>
 8007338:	4603      	mov	r3, r0
 800733a:	4618      	mov	r0, r3
 800733c:	f7fb ffc4 	bl	80032c8 <__aeabi_f2uiz>
 8007340:	4603      	mov	r3, r0
 8007342:	607b      	str	r3, [r7, #4]
    return (timing_state[idx].update_seconds*1000000) + delta_us;
 8007344:	7bfb      	ldrb	r3, [r7, #15]
 8007346:	4a1b      	ldr	r2, [pc, #108]	; (80073b4 <micros64+0xb4>)
 8007348:	011b      	lsls	r3, r3, #4
 800734a:	4413      	add	r3, r2
 800734c:	e9d3 0100 	ldrd	r0, r1, [r3]
 8007350:	4602      	mov	r2, r0
 8007352:	460b      	mov	r3, r1
 8007354:	ea4f 2b43 	mov.w	fp, r3, lsl #9
 8007358:	ea4b 5bd2 	orr.w	fp, fp, r2, lsr #23
 800735c:	ea4f 2a42 	mov.w	sl, r2, lsl #9
 8007360:	4652      	mov	r2, sl
 8007362:	465b      	mov	r3, fp
 8007364:	015d      	lsls	r5, r3, #5
 8007366:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 800736a:	0154      	lsls	r4, r2, #5
 800736c:	1aa4      	subs	r4, r4, r2
 800736e:	eb65 0503 	sbc.w	r5, r5, r3
 8007372:	1824      	adds	r4, r4, r0
 8007374:	eb45 0501 	adc.w	r5, r5, r1
 8007378:	ea4f 1985 	mov.w	r9, r5, lsl #6
 800737c:	ea49 6994 	orr.w	r9, r9, r4, lsr #26
 8007380:	ea4f 1884 	mov.w	r8, r4, lsl #6
 8007384:	ebb8 0804 	subs.w	r8, r8, r4
 8007388:	eb69 0905 	sbc.w	r9, r9, r5
 800738c:	eb10 0008 	adds.w	r0, r0, r8
 8007390:	eb41 0109 	adc.w	r1, r1, r9
 8007394:	687b      	ldr	r3, [r7, #4]
 8007396:	461a      	mov	r2, r3
 8007398:	f04f 0300 	mov.w	r3, #0
 800739c:	1812      	adds	r2, r2, r0
 800739e:	eb43 0301 	adc.w	r3, r3, r1
}
 80073a2:	4610      	mov	r0, r2
 80073a4:	4619      	mov	r1, r3
 80073a6:	3710      	adds	r7, #16
 80073a8:	46bd      	mov	sp, r7
 80073aa:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 80073ae:	bf00      	nop
 80073b0:	200013c0 	.word	0x200013c0
 80073b4:	200013a0 	.word	0x200013a0
 80073b8:	42c80000 	.word	0x42c80000

080073bc <timing_state_update_task_func>:
void usleep(uint32_t delay) {
    uint32_t tbegin = micros();
    while (micros()-tbegin < delay);
}

static void timing_state_update_task_func(struct worker_thread_timer_task_s* task) {
 80073bc:	b590      	push	{r4, r7, lr}
 80073be:	b085      	sub	sp, #20
 80073c0:	af00      	add	r7, sp, #0
 80073c2:	6078      	str	r0, [r7, #4]
    (void)task;
    uint8_t next_timing_state_idx = (timing_state_idx+1) % 2;
 80073c4:	4b27      	ldr	r3, [pc, #156]	; (8007464 <timing_state_update_task_func+0xa8>)
 80073c6:	781b      	ldrb	r3, [r3, #0]
 80073c8:	b2db      	uxtb	r3, r3
 80073ca:	1c5a      	adds	r2, r3, #1
 80073cc:	4b26      	ldr	r3, [pc, #152]	; (8007468 <timing_state_update_task_func+0xac>)
 80073ce:	4013      	ands	r3, r2
 80073d0:	2b00      	cmp	r3, #0
 80073d2:	da03      	bge.n	80073dc <timing_state_update_task_func+0x20>
 80073d4:	3b01      	subs	r3, #1
 80073d6:	f063 0301 	orn	r3, r3, #1
 80073da:	3301      	adds	r3, #1
 80073dc:	73fb      	strb	r3, [r7, #15]

    systime_t systime_now = chVTGetSystemTimeX();
 80073de:	f7ff ff39 	bl	8007254 <chVTGetSystemTimeX.lto_priv.124>
 80073e2:	4603      	mov	r3, r0
 80073e4:	81bb      	strh	r3, [r7, #12]
    uint32_t delta_ticks = systime_now-timing_state[timing_state_idx].update_systime;
 80073e6:	89bb      	ldrh	r3, [r7, #12]
 80073e8:	4a1e      	ldr	r2, [pc, #120]	; (8007464 <timing_state_update_task_func+0xa8>)
 80073ea:	7812      	ldrb	r2, [r2, #0]
 80073ec:	b2d2      	uxtb	r2, r2
 80073ee:	491f      	ldr	r1, [pc, #124]	; (800746c <timing_state_update_task_func+0xb0>)
 80073f0:	0112      	lsls	r2, r2, #4
 80073f2:	440a      	add	r2, r1
 80073f4:	3208      	adds	r2, #8
 80073f6:	8812      	ldrh	r2, [r2, #0]
 80073f8:	1a9b      	subs	r3, r3, r2
 80073fa:	60bb      	str	r3, [r7, #8]

    timing_state[next_timing_state_idx].update_seconds = timing_state[timing_state_idx].update_seconds + delta_ticks / CH_CFG_ST_FREQUENCY;
 80073fc:	7bfc      	ldrb	r4, [r7, #15]
 80073fe:	4b19      	ldr	r3, [pc, #100]	; (8007464 <timing_state_update_task_func+0xa8>)
 8007400:	781b      	ldrb	r3, [r3, #0]
 8007402:	b2db      	uxtb	r3, r3
 8007404:	4a19      	ldr	r2, [pc, #100]	; (800746c <timing_state_update_task_func+0xb0>)
 8007406:	011b      	lsls	r3, r3, #4
 8007408:	4413      	add	r3, r2
 800740a:	e9d3 0100 	ldrd	r0, r1, [r3]
 800740e:	68bb      	ldr	r3, [r7, #8]
 8007410:	4a17      	ldr	r2, [pc, #92]	; (8007470 <timing_state_update_task_func+0xb4>)
 8007412:	fba2 2303 	umull	r2, r3, r2, r3
 8007416:	0b5b      	lsrs	r3, r3, #13
 8007418:	461a      	mov	r2, r3
 800741a:	f04f 0300 	mov.w	r3, #0
 800741e:	1812      	adds	r2, r2, r0
 8007420:	eb43 0301 	adc.w	r3, r3, r1
 8007424:	4811      	ldr	r0, [pc, #68]	; (800746c <timing_state_update_task_func+0xb0>)
 8007426:	0121      	lsls	r1, r4, #4
 8007428:	4401      	add	r1, r0
 800742a:	e9c1 2300 	strd	r2, r3, [r1]
    timing_state[next_timing_state_idx].update_systime = systime_now - (delta_ticks % CH_CFG_ST_FREQUENCY);
 800742e:	7bf9      	ldrb	r1, [r7, #15]
 8007430:	68ba      	ldr	r2, [r7, #8]
 8007432:	4b0f      	ldr	r3, [pc, #60]	; (8007470 <timing_state_update_task_func+0xb4>)
 8007434:	fba3 0302 	umull	r0, r3, r3, r2
 8007438:	0b5b      	lsrs	r3, r3, #13
 800743a:	f242 7010 	movw	r0, #10000	; 0x2710
 800743e:	fb00 f303 	mul.w	r3, r0, r3
 8007442:	1ad3      	subs	r3, r2, r3
 8007444:	b29b      	uxth	r3, r3
 8007446:	89ba      	ldrh	r2, [r7, #12]
 8007448:	1ad3      	subs	r3, r2, r3
 800744a:	b298      	uxth	r0, r3
 800744c:	4a07      	ldr	r2, [pc, #28]	; (800746c <timing_state_update_task_func+0xb0>)
 800744e:	010b      	lsls	r3, r1, #4
 8007450:	4413      	add	r3, r2
 8007452:	3308      	adds	r3, #8
 8007454:	4602      	mov	r2, r0
 8007456:	801a      	strh	r2, [r3, #0]

    timing_state_idx = next_timing_state_idx;
 8007458:	4a02      	ldr	r2, [pc, #8]	; (8007464 <timing_state_update_task_func+0xa8>)
 800745a:	7bfb      	ldrb	r3, [r7, #15]
 800745c:	7013      	strb	r3, [r2, #0]
}
 800745e:	3714      	adds	r7, #20
 8007460:	46bd      	mov	sp, r7
 8007462:	bd90      	pop	{r4, r7, pc}
 8007464:	200013c0 	.word	0x200013c0
 8007468:	80000001 	.word	0x80000001
 800746c:	200013a0 	.word	0x200013a0
 8007470:	d1b71759 	.word	0xd1b71759

08007474 <system_get_restart_allowed>:

void system_set_restart_allowed_cb(restart_allowed_func_ptr_t cb) {
    restart_allowed_cb = cb;
}

bool system_get_restart_allowed(void) {
 8007474:	b580      	push	{r7, lr}
 8007476:	af00      	add	r7, sp, #0
    return !restart_allowed_cb || restart_allowed_cb();
 8007478:	4b08      	ldr	r3, [pc, #32]	; (800749c <system_get_restart_allowed+0x28>)
 800747a:	681b      	ldr	r3, [r3, #0]
 800747c:	2b00      	cmp	r3, #0
 800747e:	d005      	beq.n	800748c <system_get_restart_allowed+0x18>
 8007480:	4b06      	ldr	r3, [pc, #24]	; (800749c <system_get_restart_allowed+0x28>)
 8007482:	681b      	ldr	r3, [r3, #0]
 8007484:	4798      	blx	r3
 8007486:	4603      	mov	r3, r0
 8007488:	2b00      	cmp	r3, #0
 800748a:	d001      	beq.n	8007490 <system_get_restart_allowed+0x1c>
 800748c:	2301      	movs	r3, #1
 800748e:	e000      	b.n	8007492 <system_get_restart_allowed+0x1e>
 8007490:	2300      	movs	r3, #0
 8007492:	f003 0301 	and.w	r3, r3, #1
 8007496:	b2db      	uxtb	r3, r3
}
 8007498:	4618      	mov	r0, r3
 800749a:	bd80      	pop	{r7, pc}
 800749c:	200013d8 	.word	0x200013d8

080074a0 <fifoallocator_init>:

#define FIFOALLOCATOR_ALIGN(ptr) ((void*)(((size_t)(ptr) + (sizeof(void*)-1)) & ~(sizeof(void*)-1)))

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size);

void fifoallocator_init(struct fifoallocator_instance_s* instance, size_t memory_pool_size, void* memory_pool) {
 80074a0:	b480      	push	{r7}
 80074a2:	b085      	sub	sp, #20
 80074a4:	af00      	add	r7, sp, #0
 80074a6:	60f8      	str	r0, [r7, #12]
 80074a8:	60b9      	str	r1, [r7, #8]
 80074aa:	607a      	str	r2, [r7, #4]
    if (!instance || !memory_pool) {
 80074ac:	68fb      	ldr	r3, [r7, #12]
 80074ae:	2b00      	cmp	r3, #0
 80074b0:	d00e      	beq.n	80074d0 <fifoallocator_init+0x30>
 80074b2:	687b      	ldr	r3, [r7, #4]
 80074b4:	2b00      	cmp	r3, #0
 80074b6:	d00b      	beq.n	80074d0 <fifoallocator_init+0x30>
        return;
    }

    instance->memory_pool = memory_pool;
 80074b8:	68fb      	ldr	r3, [r7, #12]
 80074ba:	687a      	ldr	r2, [r7, #4]
 80074bc:	601a      	str	r2, [r3, #0]
    instance->memory_pool_size = memory_pool_size;
 80074be:	68fb      	ldr	r3, [r7, #12]
 80074c0:	68ba      	ldr	r2, [r7, #8]
 80074c2:	605a      	str	r2, [r3, #4]
    instance->newest = NULL;
 80074c4:	68fb      	ldr	r3, [r7, #12]
 80074c6:	2200      	movs	r2, #0
 80074c8:	609a      	str	r2, [r3, #8]
    instance->oldest = NULL;
 80074ca:	68fb      	ldr	r3, [r7, #12]
 80074cc:	2200      	movs	r2, #0
 80074ce:	60da      	str	r2, [r3, #12]
}
 80074d0:	3714      	adds	r7, #20
 80074d2:	46bd      	mov	sp, r7
 80074d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80074d8:	4770      	bx	lr
 80074da:	bf00      	nop

080074dc <fifoallocator_allocate>:

void* fifoallocator_allocate(struct fifoallocator_instance_s* instance, size_t data_size) {
 80074dc:	b580      	push	{r7, lr}
 80074de:	b084      	sub	sp, #16
 80074e0:	af00      	add	r7, sp, #0
 80074e2:	6078      	str	r0, [r7, #4]
 80074e4:	6039      	str	r1, [r7, #0]

    if (!instance || !instance->memory_pool) {
 80074e6:	687b      	ldr	r3, [r7, #4]
 80074e8:	2b00      	cmp	r3, #0
 80074ea:	d003      	beq.n	80074f4 <fifoallocator_allocate+0x18>
 80074ec:	687b      	ldr	r3, [r7, #4]
 80074ee:	681b      	ldr	r3, [r3, #0]
 80074f0:	2b00      	cmp	r3, #0
 80074f2:	d101      	bne.n	80074f8 <fifoallocator_allocate+0x1c>
        return NULL;
 80074f4:	2300      	movs	r3, #0
 80074f6:	e06c      	b.n	80075d2 <fifoallocator_allocate+0xf6>
    }

    size_t insert_block_size = data_size+sizeof(struct fifoallocator_block_s);
 80074f8:	683b      	ldr	r3, [r7, #0]
 80074fa:	3308      	adds	r3, #8
 80074fc:	60bb      	str	r3, [r7, #8]

    struct fifoallocator_block_s* insert_block;
    if (instance->newest) {
 80074fe:	687b      	ldr	r3, [r7, #4]
 8007500:	689b      	ldr	r3, [r3, #8]
 8007502:	2b00      	cmp	r3, #0
 8007504:	d008      	beq.n	8007518 <fifoallocator_allocate+0x3c>
        insert_block = (struct fifoallocator_block_s*)((uint8_t*)instance->newest->data + instance->newest->data_size);
 8007506:	687b      	ldr	r3, [r7, #4]
 8007508:	689a      	ldr	r2, [r3, #8]
 800750a:	687b      	ldr	r3, [r7, #4]
 800750c:	689b      	ldr	r3, [r3, #8]
 800750e:	685b      	ldr	r3, [r3, #4]
 8007510:	3308      	adds	r3, #8
 8007512:	4413      	add	r3, r2
 8007514:	60fb      	str	r3, [r7, #12]
 8007516:	e002      	b.n	800751e <fifoallocator_allocate+0x42>
    } else {
        insert_block = (struct fifoallocator_block_s*)instance->memory_pool;
 8007518:	687b      	ldr	r3, [r7, #4]
 800751a:	681b      	ldr	r3, [r3, #0]
 800751c:	60fb      	str	r3, [r7, #12]
    }

    insert_block = FIFOALLOCATOR_ALIGN(insert_block);
 800751e:	68fb      	ldr	r3, [r7, #12]
 8007520:	3303      	adds	r3, #3
 8007522:	f023 0303 	bic.w	r3, r3, #3
 8007526:	60fb      	str	r3, [r7, #12]

    // Check if the block to be inserted is inside the memory pool
    if (!fifoallocator_block_in_range(instance, insert_block, insert_block_size)) {
 8007528:	6878      	ldr	r0, [r7, #4]
 800752a:	68f9      	ldr	r1, [r7, #12]
 800752c:	68ba      	ldr	r2, [r7, #8]
 800752e:	f000 f89b 	bl	8007668 <fifoallocator_block_in_range>
 8007532:	4603      	mov	r3, r0
 8007534:	f083 0301 	eor.w	r3, r3, #1
 8007538:	b2db      	uxtb	r3, r3
 800753a:	2b00      	cmp	r3, #0
 800753c:	d01b      	beq.n	8007576 <fifoallocator_allocate+0x9a>
        // The block doesn't fit. Move it to the beginning of the memory pool.
        insert_block = FIFOALLOCATOR_ALIGN((struct fifoallocator_block_s*)instance->memory_pool);
 800753e:	687b      	ldr	r3, [r7, #4]
 8007540:	681b      	ldr	r3, [r3, #0]
 8007542:	3303      	adds	r3, #3
 8007544:	f023 0303 	bic.w	r3, r3, #3
 8007548:	60fb      	str	r3, [r7, #12]

        if (!fifoallocator_block_in_range(instance, insert_block, insert_block_size)) {
 800754a:	6878      	ldr	r0, [r7, #4]
 800754c:	68f9      	ldr	r1, [r7, #12]
 800754e:	68ba      	ldr	r2, [r7, #8]
 8007550:	f000 f88a 	bl	8007668 <fifoallocator_block_in_range>
 8007554:	4603      	mov	r3, r0
 8007556:	f083 0301 	eor.w	r3, r3, #1
 800755a:	b2db      	uxtb	r3, r3
 800755c:	2b00      	cmp	r3, #0
 800755e:	d001      	beq.n	8007564 <fifoallocator_allocate+0x88>
            // Block does not fit in pool
            return NULL;
 8007560:	2300      	movs	r3, #0
 8007562:	e036      	b.n	80075d2 <fifoallocator_allocate+0xf6>
        }

        if ((size_t)instance->oldest > (size_t)instance->newest) {
 8007564:	687b      	ldr	r3, [r7, #4]
 8007566:	68db      	ldr	r3, [r3, #12]
 8007568:	461a      	mov	r2, r3
 800756a:	687b      	ldr	r3, [r7, #4]
 800756c:	689b      	ldr	r3, [r3, #8]
 800756e:	429a      	cmp	r2, r3
 8007570:	d901      	bls.n	8007576 <fifoallocator_allocate+0x9a>
            // Allocated blocks wrap, beginning of memory pool is allocated
            return NULL;
 8007572:	2300      	movs	r3, #0
 8007574:	e02d      	b.n	80075d2 <fifoallocator_allocate+0xf6>
        }
    }

    // Check if the insert block overlaps with the oldest block
    if (instance->oldest && (size_t)instance->oldest >= (size_t)insert_block && (size_t)instance->oldest < (size_t)insert_block+insert_block_size) {
 8007576:	687b      	ldr	r3, [r7, #4]
 8007578:	68db      	ldr	r3, [r3, #12]
 800757a:	2b00      	cmp	r3, #0
 800757c:	d00f      	beq.n	800759e <fifoallocator_allocate+0xc2>
 800757e:	687b      	ldr	r3, [r7, #4]
 8007580:	68db      	ldr	r3, [r3, #12]
 8007582:	461a      	mov	r2, r3
 8007584:	68fb      	ldr	r3, [r7, #12]
 8007586:	429a      	cmp	r2, r3
 8007588:	d309      	bcc.n	800759e <fifoallocator_allocate+0xc2>
 800758a:	687b      	ldr	r3, [r7, #4]
 800758c:	68db      	ldr	r3, [r3, #12]
 800758e:	4619      	mov	r1, r3
 8007590:	68fa      	ldr	r2, [r7, #12]
 8007592:	68bb      	ldr	r3, [r7, #8]
 8007594:	4413      	add	r3, r2
 8007596:	4299      	cmp	r1, r3
 8007598:	d201      	bcs.n	800759e <fifoallocator_allocate+0xc2>
        return NULL;
 800759a:	2300      	movs	r3, #0
 800759c:	e019      	b.n	80075d2 <fifoallocator_allocate+0xf6>
    }

    insert_block->next_oldest = NULL;
 800759e:	68fb      	ldr	r3, [r7, #12]
 80075a0:	2200      	movs	r2, #0
 80075a2:	601a      	str	r2, [r3, #0]
    insert_block->data_size = data_size;
 80075a4:	68fb      	ldr	r3, [r7, #12]
 80075a6:	683a      	ldr	r2, [r7, #0]
 80075a8:	605a      	str	r2, [r3, #4]

    if (instance->newest) {
 80075aa:	687b      	ldr	r3, [r7, #4]
 80075ac:	689b      	ldr	r3, [r3, #8]
 80075ae:	2b00      	cmp	r3, #0
 80075b0:	d003      	beq.n	80075ba <fifoallocator_allocate+0xde>
        instance->newest->next_oldest = insert_block;
 80075b2:	687b      	ldr	r3, [r7, #4]
 80075b4:	689b      	ldr	r3, [r3, #8]
 80075b6:	68fa      	ldr	r2, [r7, #12]
 80075b8:	601a      	str	r2, [r3, #0]
    }

    instance->newest = insert_block;
 80075ba:	687b      	ldr	r3, [r7, #4]
 80075bc:	68fa      	ldr	r2, [r7, #12]
 80075be:	609a      	str	r2, [r3, #8]

    if (!instance->oldest) {
 80075c0:	687b      	ldr	r3, [r7, #4]
 80075c2:	68db      	ldr	r3, [r3, #12]
 80075c4:	2b00      	cmp	r3, #0
 80075c6:	d102      	bne.n	80075ce <fifoallocator_allocate+0xf2>
        instance->oldest = insert_block;
 80075c8:	687b      	ldr	r3, [r7, #4]
 80075ca:	68fa      	ldr	r2, [r7, #12]
 80075cc:	60da      	str	r2, [r3, #12]
    }

    return insert_block->data;
 80075ce:	68fb      	ldr	r3, [r7, #12]
 80075d0:	3308      	adds	r3, #8
}
 80075d2:	4618      	mov	r0, r3
 80075d4:	3710      	adds	r7, #16
 80075d6:	46bd      	mov	sp, r7
 80075d8:	bd80      	pop	{r7, pc}
 80075da:	bf00      	nop

080075dc <fifoallocator_peek_oldest>:

void* fifoallocator_peek_oldest(struct fifoallocator_instance_s* instance) {
 80075dc:	b480      	push	{r7}
 80075de:	b083      	sub	sp, #12
 80075e0:	af00      	add	r7, sp, #0
 80075e2:	6078      	str	r0, [r7, #4]
    if (!instance || !instance->oldest) {
 80075e4:	687b      	ldr	r3, [r7, #4]
 80075e6:	2b00      	cmp	r3, #0
 80075e8:	d003      	beq.n	80075f2 <fifoallocator_peek_oldest+0x16>
 80075ea:	687b      	ldr	r3, [r7, #4]
 80075ec:	68db      	ldr	r3, [r3, #12]
 80075ee:	2b00      	cmp	r3, #0
 80075f0:	d101      	bne.n	80075f6 <fifoallocator_peek_oldest+0x1a>
        return NULL;
 80075f2:	2300      	movs	r3, #0
 80075f4:	e002      	b.n	80075fc <fifoallocator_peek_oldest+0x20>
    }

    return instance->oldest->data;
 80075f6:	687b      	ldr	r3, [r7, #4]
 80075f8:	68db      	ldr	r3, [r3, #12]
 80075fa:	3308      	adds	r3, #8
}
 80075fc:	4618      	mov	r0, r3
 80075fe:	370c      	adds	r7, #12
 8007600:	46bd      	mov	sp, r7
 8007602:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007606:	4770      	bx	lr

08007608 <fifoallocator_get_block_size>:

size_t fifoallocator_get_block_size(const void* block) {
 8007608:	b480      	push	{r7}
 800760a:	b083      	sub	sp, #12
 800760c:	af00      	add	r7, sp, #0
 800760e:	6078      	str	r0, [r7, #4]
    if (!block) {
 8007610:	687b      	ldr	r3, [r7, #4]
 8007612:	2b00      	cmp	r3, #0
 8007614:	d101      	bne.n	800761a <fifoallocator_get_block_size+0x12>
        return 0;
 8007616:	2300      	movs	r3, #0
 8007618:	e002      	b.n	8007620 <fifoallocator_get_block_size+0x18>
    }

    return ((struct fifoallocator_block_s*)((uint8_t*)block - offsetof(struct fifoallocator_block_s, data)))->data_size;
 800761a:	687b      	ldr	r3, [r7, #4]
 800761c:	3b08      	subs	r3, #8
 800761e:	685b      	ldr	r3, [r3, #4]
}
 8007620:	4618      	mov	r0, r3
 8007622:	370c      	adds	r7, #12
 8007624:	46bd      	mov	sp, r7
 8007626:	f85d 7b04 	ldr.w	r7, [sp], #4
 800762a:	4770      	bx	lr

0800762c <fifoallocator_pop_oldest>:

void fifoallocator_pop_oldest(struct fifoallocator_instance_s* instance) {
 800762c:	b480      	push	{r7}
 800762e:	b083      	sub	sp, #12
 8007630:	af00      	add	r7, sp, #0
 8007632:	6078      	str	r0, [r7, #4]
    if (!instance || !instance->oldest) {
 8007634:	687b      	ldr	r3, [r7, #4]
 8007636:	2b00      	cmp	r3, #0
 8007638:	d011      	beq.n	800765e <fifoallocator_pop_oldest+0x32>
 800763a:	687b      	ldr	r3, [r7, #4]
 800763c:	68db      	ldr	r3, [r3, #12]
 800763e:	2b00      	cmp	r3, #0
 8007640:	d00d      	beq.n	800765e <fifoallocator_pop_oldest+0x32>
        return;
    }

    if (instance->newest == instance->oldest) {
 8007642:	687b      	ldr	r3, [r7, #4]
 8007644:	689a      	ldr	r2, [r3, #8]
 8007646:	687b      	ldr	r3, [r7, #4]
 8007648:	68db      	ldr	r3, [r3, #12]
 800764a:	429a      	cmp	r2, r3
 800764c:	d102      	bne.n	8007654 <fifoallocator_pop_oldest+0x28>
        instance->newest = NULL;
 800764e:	687b      	ldr	r3, [r7, #4]
 8007650:	2200      	movs	r2, #0
 8007652:	609a      	str	r2, [r3, #8]
    }

    instance->oldest = instance->oldest->next_oldest;
 8007654:	687b      	ldr	r3, [r7, #4]
 8007656:	68db      	ldr	r3, [r3, #12]
 8007658:	681a      	ldr	r2, [r3, #0]
 800765a:	687b      	ldr	r3, [r7, #4]
 800765c:	60da      	str	r2, [r3, #12]
}
 800765e:	370c      	adds	r7, #12
 8007660:	46bd      	mov	sp, r7
 8007662:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007666:	4770      	bx	lr

08007668 <fifoallocator_block_in_range>:

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size) {
 8007668:	b480      	push	{r7}
 800766a:	b085      	sub	sp, #20
 800766c:	af00      	add	r7, sp, #0
 800766e:	60f8      	str	r0, [r7, #12]
 8007670:	60b9      	str	r1, [r7, #8]
 8007672:	607a      	str	r2, [r7, #4]
    return instance && instance->memory_pool &&
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
 8007674:	68fb      	ldr	r3, [r7, #12]
 8007676:	2b00      	cmp	r3, #0
 8007678:	d017      	beq.n	80076aa <fifoallocator_block_in_range+0x42>

    instance->oldest = instance->oldest->next_oldest;
}

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size) {
    return instance && instance->memory_pool &&
 800767a:	68fb      	ldr	r3, [r7, #12]
 800767c:	681b      	ldr	r3, [r3, #0]
 800767e:	2b00      	cmp	r3, #0
 8007680:	d013      	beq.n	80076aa <fifoallocator_block_in_range+0x42>
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
 8007682:	68bb      	ldr	r3, [r7, #8]
 8007684:	68fa      	ldr	r2, [r7, #12]
 8007686:	6812      	ldr	r2, [r2, #0]
 8007688:	1a9a      	subs	r2, r3, r2
 800768a:	68fb      	ldr	r3, [r7, #12]
 800768c:	685b      	ldr	r3, [r3, #4]

    instance->oldest = instance->oldest->next_oldest;
}

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size) {
    return instance && instance->memory_pool &&
 800768e:	429a      	cmp	r2, r3
 8007690:	d20b      	bcs.n	80076aa <fifoallocator_block_in_range+0x42>
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
           (size_t)block+block_size-(size_t)instance->memory_pool <= instance->memory_pool_size;
 8007692:	68ba      	ldr	r2, [r7, #8]
 8007694:	687b      	ldr	r3, [r7, #4]
 8007696:	4413      	add	r3, r2
 8007698:	68fa      	ldr	r2, [r7, #12]
 800769a:	6812      	ldr	r2, [r2, #0]
 800769c:	1a9a      	subs	r2, r3, r2
 800769e:	68fb      	ldr	r3, [r7, #12]
 80076a0:	685b      	ldr	r3, [r3, #4]
    instance->oldest = instance->oldest->next_oldest;
}

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size) {
    return instance && instance->memory_pool &&
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
 80076a2:	429a      	cmp	r2, r3
 80076a4:	d801      	bhi.n	80076aa <fifoallocator_block_in_range+0x42>
 80076a6:	2301      	movs	r3, #1
 80076a8:	e000      	b.n	80076ac <fifoallocator_block_in_range+0x44>
 80076aa:	2300      	movs	r3, #0

    instance->oldest = instance->oldest->next_oldest;
}

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size) {
    return instance && instance->memory_pool &&
 80076ac:	f003 0301 	and.w	r3, r3, #1
 80076b0:	b2db      	uxtb	r3, r3
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
           (size_t)block+block_size-(size_t)instance->memory_pool <= instance->memory_pool_size;
}
 80076b2:	4618      	mov	r0, r3
 80076b4:	3714      	adds	r7, #20
 80076b6:	46bd      	mov	sp, r7
 80076b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80076bc:	4770      	bx	lr
 80076be:	bf00      	nop

080076c0 <port_lock.lto_priv.121>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80076c0:	b480      	push	{r7}
 80076c2:	b083      	sub	sp, #12
 80076c4:	af00      	add	r7, sp, #0
 80076c6:	2320      	movs	r3, #32
 80076c8:	607b      	str	r3, [r7, #4]
 80076ca:	687b      	ldr	r3, [r7, #4]
 80076cc:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80076d0:	370c      	adds	r7, #12
 80076d2:	46bd      	mov	sp, r7
 80076d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80076d8:	4770      	bx	lr
 80076da:	bf00      	nop

080076dc <port_unlock.lto_priv.119>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80076dc:	b480      	push	{r7}
 80076de:	b083      	sub	sp, #12
 80076e0:	af00      	add	r7, sp, #0
 80076e2:	2300      	movs	r3, #0
 80076e4:	607b      	str	r3, [r7, #4]
 80076e6:	687b      	ldr	r3, [r7, #4]
 80076e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80076ec:	370c      	adds	r7, #12
 80076ee:	46bd      	mov	sp, r7
 80076f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80076f4:	4770      	bx	lr
 80076f6:	bf00      	nop

080076f8 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80076f8:	b580      	push	{r7, lr}
 80076fa:	af00      	add	r7, sp, #0

  port_lock();
 80076fc:	f7ff ffe0 	bl	80076c0 <port_lock.lto_priv.121>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007700:	f002 f9ca 	bl	8009a98 <_dbg_check_lock>
}
 8007704:	bd80      	pop	{r7, pc}
 8007706:	bf00      	nop

08007708 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8007708:	b580      	push	{r7, lr}
 800770a:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 800770c:	f002 f9da 	bl	8009ac4 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007710:	4b09      	ldr	r3, [pc, #36]	; (8007738 <chSysUnlock+0x30>)
 8007712:	681b      	ldr	r3, [r3, #0]
 8007714:	4a08      	ldr	r2, [pc, #32]	; (8007738 <chSysUnlock+0x30>)
 8007716:	4293      	cmp	r3, r2
 8007718:	d00a      	beq.n	8007730 <chSysUnlock+0x28>
 800771a:	4b07      	ldr	r3, [pc, #28]	; (8007738 <chSysUnlock+0x30>)
 800771c:	699b      	ldr	r3, [r3, #24]
 800771e:	689a      	ldr	r2, [r3, #8]
 8007720:	4b05      	ldr	r3, [pc, #20]	; (8007738 <chSysUnlock+0x30>)
 8007722:	681b      	ldr	r3, [r3, #0]
 8007724:	689b      	ldr	r3, [r3, #8]
 8007726:	429a      	cmp	r2, r3
 8007728:	d202      	bcs.n	8007730 <chSysUnlock+0x28>
 800772a:	4804      	ldr	r0, [pc, #16]	; (800773c <chSysUnlock+0x34>)
 800772c:	f002 f966 	bl	80099fc <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8007730:	f7ff ffd4 	bl	80076dc <port_unlock.lto_priv.119>
}
 8007734:	bd80      	pop	{r7, pc}
 8007736:	bf00      	nop
 8007738:	20001330 	.word	0x20001330
 800773c:	0800d088 	.word	0x0800d088

08007740 <pubsub_create_topic_group>:
#error Please define PUBSUB_DEFAULT_TOPIC_GROUP in framework_conf.h.
#endif

PUBSUB_TOPIC_GROUP_DECLARE_EXTERN(PUBSUB_DEFAULT_TOPIC_GROUP);

void pubsub_create_topic_group(struct pubsub_topic_group_s* topic_group, size_t memory_pool_size, void* memory_pool) {
 8007740:	b580      	push	{r7, lr}
 8007742:	b084      	sub	sp, #16
 8007744:	af00      	add	r7, sp, #0
 8007746:	60f8      	str	r0, [r7, #12]
 8007748:	60b9      	str	r1, [r7, #8]
 800774a:	607a      	str	r2, [r7, #4]
    if (!topic_group || !memory_pool) {
 800774c:	68fb      	ldr	r3, [r7, #12]
 800774e:	2b00      	cmp	r3, #0
 8007750:	d008      	beq.n	8007764 <pubsub_create_topic_group+0x24>
 8007752:	687b      	ldr	r3, [r7, #4]
 8007754:	2b00      	cmp	r3, #0
 8007756:	d005      	beq.n	8007764 <pubsub_create_topic_group+0x24>
        return;
    }

    fifoallocator_init(&topic_group->allocator, memory_pool_size, memory_pool);
 8007758:	68fb      	ldr	r3, [r7, #12]
 800775a:	4618      	mov	r0, r3
 800775c:	68b9      	ldr	r1, [r7, #8]
 800775e:	687a      	ldr	r2, [r7, #4]
 8007760:	f7ff fe9e 	bl	80074a0 <fifoallocator_init>
}
 8007764:	3710      	adds	r7, #16
 8007766:	46bd      	mov	sp, r7
 8007768:	bd80      	pop	{r7, pc}
 800776a:	bf00      	nop

0800776c <pubsub_init_topic>:

void pubsub_init_topic(struct pubsub_topic_s* topic, struct pubsub_topic_group_s* topic_group) {
 800776c:	b480      	push	{r7}
 800776e:	b083      	sub	sp, #12
 8007770:	af00      	add	r7, sp, #0
 8007772:	6078      	str	r0, [r7, #4]
 8007774:	6039      	str	r1, [r7, #0]
    if (!topic) {
 8007776:	687b      	ldr	r3, [r7, #4]
 8007778:	2b00      	cmp	r3, #0
 800777a:	d00d      	beq.n	8007798 <pubsub_init_topic+0x2c>
        return;
    }

    if (!topic_group) {
 800777c:	683b      	ldr	r3, [r7, #0]
 800777e:	2b00      	cmp	r3, #0
 8007780:	d101      	bne.n	8007786 <pubsub_init_topic+0x1a>
        topic_group = &PUBSUB_DEFAULT_TOPIC_GROUP;
 8007782:	4b08      	ldr	r3, [pc, #32]	; (80077a4 <pubsub_init_topic+0x38>)
 8007784:	603b      	str	r3, [r7, #0]
    }

    topic->message_list_tail = NULL;
 8007786:	687b      	ldr	r3, [r7, #4]
 8007788:	2200      	movs	r2, #0
 800778a:	601a      	str	r2, [r3, #0]
    topic->group = topic_group;
 800778c:	687b      	ldr	r3, [r7, #4]
 800778e:	683a      	ldr	r2, [r7, #0]
 8007790:	605a      	str	r2, [r3, #4]
    topic->listener_list_head = NULL;
 8007792:	687b      	ldr	r3, [r7, #4]
 8007794:	2200      	movs	r2, #0
 8007796:	609a      	str	r2, [r3, #8]
}
 8007798:	370c      	adds	r7, #12
 800779a:	46bd      	mov	sp, r7
 800779c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80077a0:	4770      	bx	lr
 80077a2:	bf00      	nop
 80077a4:	20000a58 	.word	0x20000a58

080077a8 <pubsub_listener_init_and_register>:

void pubsub_listener_init_and_register(struct pubsub_listener_s* listener, struct pubsub_topic_s* topic, pubsub_message_handler_func_ptr handler_cb, void* handler_cb_ctx) {
 80077a8:	b580      	push	{r7, lr}
 80077aa:	b086      	sub	sp, #24
 80077ac:	af00      	add	r7, sp, #0
 80077ae:	60f8      	str	r0, [r7, #12]
 80077b0:	60b9      	str	r1, [r7, #8]
 80077b2:	607a      	str	r2, [r7, #4]
 80077b4:	603b      	str	r3, [r7, #0]
    if (!topic || !topic->group || !listener) {
 80077b6:	68bb      	ldr	r3, [r7, #8]
 80077b8:	2b00      	cmp	r3, #0
 80077ba:	d036      	beq.n	800782a <pubsub_listener_init_and_register+0x82>
 80077bc:	68bb      	ldr	r3, [r7, #8]
 80077be:	685b      	ldr	r3, [r3, #4]
 80077c0:	2b00      	cmp	r3, #0
 80077c2:	d032      	beq.n	800782a <pubsub_listener_init_and_register+0x82>
 80077c4:	68fb      	ldr	r3, [r7, #12]
 80077c6:	2b00      	cmp	r3, #0
 80077c8:	d02f      	beq.n	800782a <pubsub_listener_init_and_register+0x82>
        return;
    }

    // initialize listener
    listener->topic = topic;
 80077ca:	68fb      	ldr	r3, [r7, #12]
 80077cc:	68ba      	ldr	r2, [r7, #8]
 80077ce:	601a      	str	r2, [r3, #0]
    listener->next_message = NULL;
 80077d0:	68fb      	ldr	r3, [r7, #12]
 80077d2:	2200      	movs	r2, #0
 80077d4:	605a      	str	r2, [r3, #4]
    listener->waiting_thread_reference_ptr = NULL;
 80077d6:	68fb      	ldr	r3, [r7, #12]
 80077d8:	2200      	movs	r2, #0
 80077da:	609a      	str	r2, [r3, #8]
    listener->handler_cb = handler_cb;
 80077dc:	68fb      	ldr	r3, [r7, #12]
 80077de:	687a      	ldr	r2, [r7, #4]
 80077e0:	60da      	str	r2, [r3, #12]
    listener->handler_cb_ctx = handler_cb_ctx;
 80077e2:	68fb      	ldr	r3, [r7, #12]
 80077e4:	683a      	ldr	r2, [r7, #0]
 80077e6:	611a      	str	r2, [r3, #16]
    chMtxObjectInit(&listener->mtx);
 80077e8:	68fb      	ldr	r3, [r7, #12]
 80077ea:	3318      	adds	r3, #24
 80077ec:	4618      	mov	r0, r3
 80077ee:	f001 fe11 	bl	8009414 <chMtxObjectInit>
    listener->next = NULL;
 80077f2:	68fb      	ldr	r3, [r7, #12]
 80077f4:	2200      	movs	r2, #0
 80077f6:	62da      	str	r2, [r3, #44]	; 0x2c
    listener->misses = 0;
 80077f8:	68fb      	ldr	r3, [r7, #12]
 80077fa:	2200      	movs	r2, #0
 80077fc:	615a      	str	r2, [r3, #20]

    // append listener to topic's listener list
    chSysLock();
 80077fe:	f7ff ff7b 	bl	80076f8 <chSysLock>
    LINKED_LIST_APPEND(struct pubsub_listener_s, topic->listener_list_head, listener);
 8007802:	68fb      	ldr	r3, [r7, #12]
 8007804:	2200      	movs	r2, #0
 8007806:	62da      	str	r2, [r3, #44]	; 0x2c
 8007808:	68bb      	ldr	r3, [r7, #8]
 800780a:	3308      	adds	r3, #8
 800780c:	617b      	str	r3, [r7, #20]
 800780e:	e003      	b.n	8007818 <pubsub_listener_init_and_register+0x70>
 8007810:	697b      	ldr	r3, [r7, #20]
 8007812:	681b      	ldr	r3, [r3, #0]
 8007814:	332c      	adds	r3, #44	; 0x2c
 8007816:	617b      	str	r3, [r7, #20]
 8007818:	697b      	ldr	r3, [r7, #20]
 800781a:	681b      	ldr	r3, [r3, #0]
 800781c:	2b00      	cmp	r3, #0
 800781e:	d1f7      	bne.n	8007810 <pubsub_listener_init_and_register+0x68>
 8007820:	697b      	ldr	r3, [r7, #20]
 8007822:	68fa      	ldr	r2, [r7, #12]
 8007824:	601a      	str	r2, [r3, #0]
    chSysUnlock();
 8007826:	f7ff ff6f 	bl	8007708 <chSysUnlock>
}
 800782a:	3718      	adds	r7, #24
 800782c:	46bd      	mov	sp, r7
 800782e:	bd80      	pop	{r7, pc}

08007830 <pubsub_listener_unregister>:

void pubsub_listener_unregister(struct pubsub_listener_s* listener) {
 8007830:	b580      	push	{r7, lr}
 8007832:	b084      	sub	sp, #16
 8007834:	af00      	add	r7, sp, #0
 8007836:	6078      	str	r0, [r7, #4]
    if (!listener) {
 8007838:	687b      	ldr	r3, [r7, #4]
 800783a:	2b00      	cmp	r3, #0
 800783c:	d01e      	beq.n	800787c <pubsub_listener_unregister+0x4c>
        return;
    }

    // remove listener from topic's listener list
    chSysLock();
 800783e:	f7ff ff5b 	bl	80076f8 <chSysLock>
    LINKED_LIST_REMOVE(struct pubsub_listener_s, listener->topic->listener_list_head, listener);
 8007842:	687b      	ldr	r3, [r7, #4]
 8007844:	681b      	ldr	r3, [r3, #0]
 8007846:	3308      	adds	r3, #8
 8007848:	60fb      	str	r3, [r7, #12]
 800784a:	e003      	b.n	8007854 <pubsub_listener_unregister+0x24>
 800784c:	68fb      	ldr	r3, [r7, #12]
 800784e:	681b      	ldr	r3, [r3, #0]
 8007850:	332c      	adds	r3, #44	; 0x2c
 8007852:	60fb      	str	r3, [r7, #12]
 8007854:	68fb      	ldr	r3, [r7, #12]
 8007856:	681b      	ldr	r3, [r3, #0]
 8007858:	2b00      	cmp	r3, #0
 800785a:	d004      	beq.n	8007866 <pubsub_listener_unregister+0x36>
 800785c:	68fb      	ldr	r3, [r7, #12]
 800785e:	681a      	ldr	r2, [r3, #0]
 8007860:	687b      	ldr	r3, [r7, #4]
 8007862:	429a      	cmp	r2, r3
 8007864:	d1f2      	bne.n	800784c <pubsub_listener_unregister+0x1c>
 8007866:	68fb      	ldr	r3, [r7, #12]
 8007868:	681b      	ldr	r3, [r3, #0]
 800786a:	2b00      	cmp	r3, #0
 800786c:	d004      	beq.n	8007878 <pubsub_listener_unregister+0x48>
 800786e:	68fb      	ldr	r3, [r7, #12]
 8007870:	681b      	ldr	r3, [r3, #0]
 8007872:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8007874:	68fb      	ldr	r3, [r7, #12]
 8007876:	601a      	str	r2, [r3, #0]
    chSysUnlock();
 8007878:	f7ff ff46 	bl	8007708 <chSysUnlock>
}
 800787c:	3710      	adds	r7, #16
 800787e:	46bd      	mov	sp, r7
 8007880:	bd80      	pop	{r7, pc}
 8007882:	bf00      	nop

08007884 <pubsub_listener_has_message>:
    chMtxLock(&listener->mtx);
    listener->next_message = NULL;
    chMtxUnlock(&listener->mtx);
}

bool pubsub_listener_has_message(struct pubsub_listener_s* listener) {
 8007884:	b480      	push	{r7}
 8007886:	b083      	sub	sp, #12
 8007888:	af00      	add	r7, sp, #0
 800788a:	6078      	str	r0, [r7, #4]
    return listener->next_message != NULL;
 800788c:	687b      	ldr	r3, [r7, #4]
 800788e:	685b      	ldr	r3, [r3, #4]
 8007890:	2b00      	cmp	r3, #0
 8007892:	bf14      	ite	ne
 8007894:	2301      	movne	r3, #1
 8007896:	2300      	moveq	r3, #0
 8007898:	b2db      	uxtb	r3, r3
}
 800789a:	4618      	mov	r0, r3
 800789c:	370c      	adds	r7, #12
 800789e:	46bd      	mov	sp, r7
 80078a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80078a4:	4770      	bx	lr
 80078a6:	bf00      	nop

080078a8 <pubsub_copy_writer_func>:

void pubsub_copy_writer_func(size_t msg_size, void* msg, void* ctx) {
 80078a8:	b580      	push	{r7, lr}
 80078aa:	b084      	sub	sp, #16
 80078ac:	af00      	add	r7, sp, #0
 80078ae:	60f8      	str	r0, [r7, #12]
 80078b0:	60b9      	str	r1, [r7, #8]
 80078b2:	607a      	str	r2, [r7, #4]
    memcpy(msg, ctx, msg_size);
 80078b4:	68b8      	ldr	r0, [r7, #8]
 80078b6:	6879      	ldr	r1, [r7, #4]
 80078b8:	68fa      	ldr	r2, [r7, #12]
 80078ba:	f005 f999 	bl	800cbf0 <memcpy>
}
 80078be:	3710      	adds	r7, #16
 80078c0:	46bd      	mov	sp, r7
 80078c2:	bd80      	pop	{r7, pc}

080078c4 <pubsub_delete_message_S>:

static void pubsub_delete_message_S(struct pubsub_message_s* message_to_delete) {
 80078c4:	b580      	push	{r7, lr}
 80078c6:	b084      	sub	sp, #16
 80078c8:	af00      	add	r7, sp, #0
 80078ca:	6078      	str	r0, [r7, #4]
    struct pubsub_listener_s* listener = message_to_delete->topic->listener_list_head;
 80078cc:	687b      	ldr	r3, [r7, #4]
 80078ce:	681b      	ldr	r3, [r3, #0]
 80078d0:	689b      	ldr	r3, [r3, #8]
 80078d2:	60fb      	str	r3, [r7, #12]

    if (message_to_delete->topic->message_list_tail == message_to_delete) {
 80078d4:	687b      	ldr	r3, [r7, #4]
 80078d6:	681b      	ldr	r3, [r3, #0]
 80078d8:	681a      	ldr	r2, [r3, #0]
 80078da:	687b      	ldr	r3, [r7, #4]
 80078dc:	429a      	cmp	r2, r3
 80078de:	d124      	bne.n	800792a <pubsub_delete_message_S+0x66>
        message_to_delete->topic->message_list_tail = NULL;
 80078e0:	687b      	ldr	r3, [r7, #4]
 80078e2:	681b      	ldr	r3, [r3, #0]
 80078e4:	2200      	movs	r2, #0
 80078e6:	601a      	str	r2, [r3, #0]
 80078e8:	e01f      	b.n	800792a <pubsub_delete_message_S+0x66>
    }

    while (listener) {
        if (listener->next_message == message_to_delete) {
 80078ea:	68fb      	ldr	r3, [r7, #12]
 80078ec:	685a      	ldr	r2, [r3, #4]
 80078ee:	687b      	ldr	r3, [r7, #4]
 80078f0:	429a      	cmp	r2, r3
 80078f2:	d117      	bne.n	8007924 <pubsub_delete_message_S+0x60>
            chMtxLockS(&listener->mtx);
 80078f4:	68fb      	ldr	r3, [r7, #12]
 80078f6:	3318      	adds	r3, #24
 80078f8:	4618      	mov	r0, r3
 80078fa:	f001 fda5 	bl	8009448 <chMtxLockS>
            if (listener->next_message == message_to_delete) {
 80078fe:	68fb      	ldr	r3, [r7, #12]
 8007900:	685a      	ldr	r2, [r3, #4]
 8007902:	687b      	ldr	r3, [r7, #4]
 8007904:	429a      	cmp	r2, r3
 8007906:	d108      	bne.n	800791a <pubsub_delete_message_S+0x56>
                listener->next_message = message_to_delete->next_in_topic;
 8007908:	687b      	ldr	r3, [r7, #4]
 800790a:	685a      	ldr	r2, [r3, #4]
 800790c:	68fb      	ldr	r3, [r7, #12]
 800790e:	605a      	str	r2, [r3, #4]
                listener->misses++;
 8007910:	68fb      	ldr	r3, [r7, #12]
 8007912:	695b      	ldr	r3, [r3, #20]
 8007914:	1c5a      	adds	r2, r3, #1
 8007916:	68fb      	ldr	r3, [r7, #12]
 8007918:	615a      	str	r2, [r3, #20]
            }
            chMtxUnlockS(&listener->mtx);
 800791a:	68fb      	ldr	r3, [r7, #12]
 800791c:	3318      	adds	r3, #24
 800791e:	4618      	mov	r0, r3
 8007920:	f001 feae 	bl	8009680 <chMtxUnlockS>
        }
        listener = listener->next;
 8007924:	68fb      	ldr	r3, [r7, #12]
 8007926:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007928:	60fb      	str	r3, [r7, #12]

    if (message_to_delete->topic->message_list_tail == message_to_delete) {
        message_to_delete->topic->message_list_tail = NULL;
    }

    while (listener) {
 800792a:	68fb      	ldr	r3, [r7, #12]
 800792c:	2b00      	cmp	r3, #0
 800792e:	d1dc      	bne.n	80078ea <pubsub_delete_message_S+0x26>
            }
            chMtxUnlockS(&listener->mtx);
        }
        listener = listener->next;
    }
}
 8007930:	3710      	adds	r7, #16
 8007932:	46bd      	mov	sp, r7
 8007934:	bd80      	pop	{r7, pc}
 8007936:	bf00      	nop

08007938 <pubsub_publish_message>:

void pubsub_publish_message(struct pubsub_topic_s* topic, size_t size, pubsub_message_writer_func_ptr writer_cb, void* ctx) {
 8007938:	b580      	push	{r7, lr}
 800793a:	b088      	sub	sp, #32
 800793c:	af00      	add	r7, sp, #0
 800793e:	60f8      	str	r0, [r7, #12]
 8007940:	60b9      	str	r1, [r7, #8]
 8007942:	607a      	str	r2, [r7, #4]
 8007944:	603b      	str	r3, [r7, #0]
    if (!topic || !topic->group || !topic->listener_list_head) {
 8007946:	68fb      	ldr	r3, [r7, #12]
 8007948:	2b00      	cmp	r3, #0
 800794a:	d07c      	beq.n	8007a46 <pubsub_publish_message+0x10e>
 800794c:	68fb      	ldr	r3, [r7, #12]
 800794e:	685b      	ldr	r3, [r3, #4]
 8007950:	2b00      	cmp	r3, #0
 8007952:	d078      	beq.n	8007a46 <pubsub_publish_message+0x10e>
 8007954:	68fb      	ldr	r3, [r7, #12]
 8007956:	689b      	ldr	r3, [r3, #8]
 8007958:	2b00      	cmp	r3, #0
 800795a:	d074      	beq.n	8007a46 <pubsub_publish_message+0x10e>
        return;
    }

    struct pubsub_message_s* message;
    while (true) {
        chSysLock();
 800795c:	f7ff fecc 	bl	80076f8 <chSysLock>
        message = fifoallocator_allocate(&topic->group->allocator, size+sizeof(struct pubsub_message_s));
 8007960:	68fb      	ldr	r3, [r7, #12]
 8007962:	685b      	ldr	r3, [r3, #4]
 8007964:	461a      	mov	r2, r3
 8007966:	68bb      	ldr	r3, [r7, #8]
 8007968:	3308      	adds	r3, #8
 800796a:	4610      	mov	r0, r2
 800796c:	4619      	mov	r1, r3
 800796e:	f7ff fdb5 	bl	80074dc <fifoallocator_allocate>
 8007972:	61b8      	str	r0, [r7, #24]

        if (message != NULL) {
 8007974:	69bb      	ldr	r3, [r7, #24]
 8007976:	2b00      	cmp	r3, #0
 8007978:	d119      	bne.n	80079ae <pubsub_publish_message+0x76>
            break;
        }

        // Delete the oldest message in the topic group
        struct pubsub_message_s* message_to_delete = fifoallocator_peek_oldest(&topic->group->allocator);
 800797a:	68fb      	ldr	r3, [r7, #12]
 800797c:	685b      	ldr	r3, [r3, #4]
 800797e:	4618      	mov	r0, r3
 8007980:	f7ff fe2c 	bl	80075dc <fifoallocator_peek_oldest>
 8007984:	6178      	str	r0, [r7, #20]
        pubsub_delete_message_S(message_to_delete);
 8007986:	6978      	ldr	r0, [r7, #20]
 8007988:	f7ff ff9c 	bl	80078c4 <pubsub_delete_message_S>

        if (fifoallocator_peek_oldest(&topic->group->allocator) == message_to_delete) {
 800798c:	68fb      	ldr	r3, [r7, #12]
 800798e:	685b      	ldr	r3, [r3, #4]
 8007990:	4618      	mov	r0, r3
 8007992:	f7ff fe23 	bl	80075dc <fifoallocator_peek_oldest>
 8007996:	4602      	mov	r2, r0
 8007998:	697b      	ldr	r3, [r7, #20]
 800799a:	429a      	cmp	r2, r3
 800799c:	d104      	bne.n	80079a8 <pubsub_publish_message+0x70>
            fifoallocator_pop_oldest(&topic->group->allocator);
 800799e:	68fb      	ldr	r3, [r7, #12]
 80079a0:	685b      	ldr	r3, [r3, #4]
 80079a2:	4618      	mov	r0, r3
 80079a4:	f7ff fe42 	bl	800762c <fifoallocator_pop_oldest>
        }

        chSysUnlock();
 80079a8:	f7ff feae 	bl	8007708 <chSysUnlock>
 80079ac:	e7d6      	b.n	800795c <pubsub_publish_message+0x24>
    }

    message->topic = topic;
 80079ae:	69bb      	ldr	r3, [r7, #24]
 80079b0:	68fa      	ldr	r2, [r7, #12]
 80079b2:	601a      	str	r2, [r3, #0]
    message->next_in_topic = NULL;
 80079b4:	69bb      	ldr	r3, [r7, #24]
 80079b6:	2200      	movs	r2, #0
 80079b8:	605a      	str	r2, [r3, #4]

    if (writer_cb) {
 80079ba:	687b      	ldr	r3, [r7, #4]
 80079bc:	2b00      	cmp	r3, #0
 80079be:	d007      	beq.n	80079d0 <pubsub_publish_message+0x98>
        writer_cb(size, message->data, ctx);
 80079c0:	69bb      	ldr	r3, [r7, #24]
 80079c2:	f103 0208 	add.w	r2, r3, #8
 80079c6:	687b      	ldr	r3, [r7, #4]
 80079c8:	68b8      	ldr	r0, [r7, #8]
 80079ca:	4611      	mov	r1, r2
 80079cc:	683a      	ldr	r2, [r7, #0]
 80079ce:	4798      	blx	r3
    }

    if (topic->message_list_tail) {
 80079d0:	68fb      	ldr	r3, [r7, #12]
 80079d2:	681b      	ldr	r3, [r3, #0]
 80079d4:	2b00      	cmp	r3, #0
 80079d6:	d00b      	beq.n	80079f0 <pubsub_publish_message+0xb8>
        chDbgCheck(topic->message_list_tail != message); // Circular reference
 80079d8:	68fb      	ldr	r3, [r7, #12]
 80079da:	681a      	ldr	r2, [r3, #0]
 80079dc:	69bb      	ldr	r3, [r7, #24]
 80079de:	429a      	cmp	r2, r3
 80079e0:	d102      	bne.n	80079e8 <pubsub_publish_message+0xb0>
 80079e2:	481a      	ldr	r0, [pc, #104]	; (8007a4c <pubsub_publish_message+0x114>)
 80079e4:	f002 f80a 	bl	80099fc <chSysHalt>
        topic->message_list_tail->next_in_topic = message;
 80079e8:	68fb      	ldr	r3, [r7, #12]
 80079ea:	681b      	ldr	r3, [r3, #0]
 80079ec:	69ba      	ldr	r2, [r7, #24]
 80079ee:	605a      	str	r2, [r3, #4]
    }
    topic->message_list_tail = message;
 80079f0:	68fb      	ldr	r3, [r7, #12]
 80079f2:	69ba      	ldr	r2, [r7, #24]
 80079f4:	601a      	str	r2, [r3, #0]

    // Set listeners' next messages
    struct pubsub_listener_s* listener = topic->listener_list_head;
 80079f6:	68fb      	ldr	r3, [r7, #12]
 80079f8:	689b      	ldr	r3, [r3, #8]
 80079fa:	61fb      	str	r3, [r7, #28]
 80079fc:	e009      	b.n	8007a12 <pubsub_publish_message+0xda>
    while (listener) {
        if (!listener->next_message) {
 80079fe:	69fb      	ldr	r3, [r7, #28]
 8007a00:	685b      	ldr	r3, [r3, #4]
 8007a02:	2b00      	cmp	r3, #0
 8007a04:	d102      	bne.n	8007a0c <pubsub_publish_message+0xd4>
            listener->next_message = message;
 8007a06:	69fb      	ldr	r3, [r7, #28]
 8007a08:	69ba      	ldr	r2, [r7, #24]
 8007a0a:	605a      	str	r2, [r3, #4]
        }

        listener = listener->next;
 8007a0c:	69fb      	ldr	r3, [r7, #28]
 8007a0e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007a10:	61fb      	str	r3, [r7, #28]
    }
    topic->message_list_tail = message;

    // Set listeners' next messages
    struct pubsub_listener_s* listener = topic->listener_list_head;
    while (listener) {
 8007a12:	69fb      	ldr	r3, [r7, #28]
 8007a14:	2b00      	cmp	r3, #0
 8007a16:	d1f2      	bne.n	80079fe <pubsub_publish_message+0xc6>

        listener = listener->next;
    }

    // Wake listener threads
    listener = topic->listener_list_head;
 8007a18:	68fb      	ldr	r3, [r7, #12]
 8007a1a:	689b      	ldr	r3, [r3, #8]
 8007a1c:	61fb      	str	r3, [r7, #28]
 8007a1e:	e00d      	b.n	8007a3c <pubsub_publish_message+0x104>
    while (listener) {
        if (listener->waiting_thread_reference_ptr) {
 8007a20:	69fb      	ldr	r3, [r7, #28]
 8007a22:	689b      	ldr	r3, [r3, #8]
 8007a24:	2b00      	cmp	r3, #0
 8007a26:	d006      	beq.n	8007a36 <pubsub_publish_message+0xfe>
            chThdResumeS(listener->waiting_thread_reference_ptr, (msg_t)listener);
 8007a28:	69fb      	ldr	r3, [r7, #28]
 8007a2a:	689a      	ldr	r2, [r3, #8]
 8007a2c:	69fb      	ldr	r3, [r7, #28]
 8007a2e:	4610      	mov	r0, r2
 8007a30:	4619      	mov	r1, r3
 8007a32:	f001 fb8b 	bl	800914c <chThdResumeS>
        }

        listener = listener->next;
 8007a36:	69fb      	ldr	r3, [r7, #28]
 8007a38:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007a3a:	61fb      	str	r3, [r7, #28]
        listener = listener->next;
    }

    // Wake listener threads
    listener = topic->listener_list_head;
    while (listener) {
 8007a3c:	69fb      	ldr	r3, [r7, #28]
 8007a3e:	2b00      	cmp	r3, #0
 8007a40:	d1ee      	bne.n	8007a20 <pubsub_publish_message+0xe8>
        }

        listener = listener->next;
    }

    chSysUnlock();
 8007a42:	f7ff fe61 	bl	8007708 <chSysUnlock>
}
 8007a46:	3720      	adds	r7, #32
 8007a48:	46bd      	mov	sp, r7
 8007a4a:	bd80      	pop	{r7, pc}
 8007a4c:	0800d094 	.word	0x0800d094

08007a50 <pubsub_listener_handle_one_timeout>:

void pubsub_listener_handle_until_timeout(struct pubsub_listener_s* listener, systime_t timeout) {
    pubsub_multiple_listener_handle_until_timeout(1, &listener, timeout);
}

bool pubsub_listener_handle_one_timeout(struct pubsub_listener_s* listener, systime_t timeout) {
 8007a50:	b580      	push	{r7, lr}
 8007a52:	b082      	sub	sp, #8
 8007a54:	af00      	add	r7, sp, #0
 8007a56:	6078      	str	r0, [r7, #4]
 8007a58:	460b      	mov	r3, r1
 8007a5a:	807b      	strh	r3, [r7, #2]
    return pubsub_multiple_listener_handle_one_timeout(1, &listener, timeout);
 8007a5c:	1d3a      	adds	r2, r7, #4
 8007a5e:	887b      	ldrh	r3, [r7, #2]
 8007a60:	2001      	movs	r0, #1
 8007a62:	4611      	mov	r1, r2
 8007a64:	461a      	mov	r2, r3
 8007a66:	f000 f805 	bl	8007a74 <pubsub_multiple_listener_handle_one_timeout>
 8007a6a:	4603      	mov	r3, r0
}
 8007a6c:	4618      	mov	r0, r3
 8007a6e:	3708      	adds	r7, #8
 8007a70:	46bd      	mov	sp, r7
 8007a72:	bd80      	pop	{r7, pc}

08007a74 <pubsub_multiple_listener_handle_one_timeout>:

static struct pubsub_listener_s* pubsub_multiple_listener_wait_timeout_S(size_t num_listeners, struct pubsub_listener_s** listeners, systime_t timeout);

bool pubsub_multiple_listener_handle_one_timeout(size_t num_listeners, struct pubsub_listener_s** listeners, systime_t timeout) {
 8007a74:	b580      	push	{r7, lr}
 8007a76:	b088      	sub	sp, #32
 8007a78:	af00      	add	r7, sp, #0
 8007a7a:	60f8      	str	r0, [r7, #12]
 8007a7c:	60b9      	str	r1, [r7, #8]
 8007a7e:	4613      	mov	r3, r2
 8007a80:	80fb      	strh	r3, [r7, #6]
    chSysLock();
 8007a82:	f7ff fe39 	bl	80076f8 <chSysLock>
    struct pubsub_listener_s* listener_with_message = pubsub_multiple_listener_wait_timeout_S(num_listeners, listeners, timeout);
 8007a86:	88fb      	ldrh	r3, [r7, #6]
 8007a88:	68f8      	ldr	r0, [r7, #12]
 8007a8a:	68b9      	ldr	r1, [r7, #8]
 8007a8c:	461a      	mov	r2, r3
 8007a8e:	f000 f843 	bl	8007b18 <pubsub_multiple_listener_wait_timeout_S>
 8007a92:	61f8      	str	r0, [r7, #28]

    if (listener_with_message) {
 8007a94:	69fb      	ldr	r3, [r7, #28]
 8007a96:	2b00      	cmp	r3, #0
 8007a98:	d027      	beq.n	8007aea <pubsub_multiple_listener_handle_one_timeout+0x76>
        chMtxLockS(&listener_with_message->mtx);
 8007a9a:	69fb      	ldr	r3, [r7, #28]
 8007a9c:	3318      	adds	r3, #24
 8007a9e:	4618      	mov	r0, r3
 8007aa0:	f001 fcd2 	bl	8009448 <chMtxLockS>
        chSysUnlock();
 8007aa4:	f7ff fe30 	bl	8007708 <chSysUnlock>

        struct pubsub_message_s* message = listener_with_message->next_message;
 8007aa8:	69fb      	ldr	r3, [r7, #28]
 8007aaa:	685b      	ldr	r3, [r3, #4]
 8007aac:	61bb      	str	r3, [r7, #24]
        listener_with_message->next_message = message->next_in_topic;
 8007aae:	69bb      	ldr	r3, [r7, #24]
 8007ab0:	685a      	ldr	r2, [r3, #4]
 8007ab2:	69fb      	ldr	r3, [r7, #28]
 8007ab4:	605a      	str	r2, [r3, #4]

        if (listener_with_message->handler_cb) {
 8007ab6:	69fb      	ldr	r3, [r7, #28]
 8007ab8:	68db      	ldr	r3, [r3, #12]
 8007aba:	2b00      	cmp	r3, #0
 8007abc:	d00e      	beq.n	8007adc <pubsub_multiple_listener_handle_one_timeout+0x68>
            size_t message_size = fifoallocator_get_block_size(message)-sizeof(struct pubsub_message_s);
 8007abe:	69b8      	ldr	r0, [r7, #24]
 8007ac0:	f7ff fda2 	bl	8007608 <fifoallocator_get_block_size>
 8007ac4:	4603      	mov	r3, r0
 8007ac6:	3b08      	subs	r3, #8
 8007ac8:	617b      	str	r3, [r7, #20]

            listener_with_message->handler_cb(message_size, message->data, listener_with_message->handler_cb_ctx);
 8007aca:	69fb      	ldr	r3, [r7, #28]
 8007acc:	68db      	ldr	r3, [r3, #12]
 8007ace:	69ba      	ldr	r2, [r7, #24]
 8007ad0:	f102 0108 	add.w	r1, r2, #8
 8007ad4:	69fa      	ldr	r2, [r7, #28]
 8007ad6:	6912      	ldr	r2, [r2, #16]
 8007ad8:	6978      	ldr	r0, [r7, #20]
 8007ada:	4798      	blx	r3
        }

        chMtxUnlock(&listener_with_message->mtx);
 8007adc:	69fb      	ldr	r3, [r7, #28]
 8007ade:	3318      	adds	r3, #24
 8007ae0:	4618      	mov	r0, r3
 8007ae2:	f001 fd47 	bl	8009574 <chMtxUnlock>
        return true;
 8007ae6:	2301      	movs	r3, #1
 8007ae8:	e002      	b.n	8007af0 <pubsub_multiple_listener_handle_one_timeout+0x7c>
    } else {
        chSysUnlock();
 8007aea:	f7ff fe0d 	bl	8007708 <chSysUnlock>
        return false;
 8007aee:	2300      	movs	r3, #0
    }
}
 8007af0:	4618      	mov	r0, r3
 8007af2:	3720      	adds	r7, #32
 8007af4:	46bd      	mov	sp, r7
 8007af6:	bd80      	pop	{r7, pc}

08007af8 <pubsub_listener_set_waiting_thread_reference>:
            elapsed = chVTTimeElapsedSinceX(start);
        }
    } while(elapsed < timeout);
}

void pubsub_listener_set_waiting_thread_reference(struct pubsub_listener_s* listener, thread_reference_t* trpp) {
 8007af8:	b480      	push	{r7}
 8007afa:	b083      	sub	sp, #12
 8007afc:	af00      	add	r7, sp, #0
 8007afe:	6078      	str	r0, [r7, #4]
 8007b00:	6039      	str	r1, [r7, #0]
    if (!listener) {
 8007b02:	687b      	ldr	r3, [r7, #4]
 8007b04:	2b00      	cmp	r3, #0
 8007b06:	d002      	beq.n	8007b0e <pubsub_listener_set_waiting_thread_reference+0x16>
        return;
    }

    listener->waiting_thread_reference_ptr = trpp;
 8007b08:	687b      	ldr	r3, [r7, #4]
 8007b0a:	683a      	ldr	r2, [r7, #0]
 8007b0c:	609a      	str	r2, [r3, #8]
}
 8007b0e:	370c      	adds	r7, #12
 8007b10:	46bd      	mov	sp, r7
 8007b12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007b16:	4770      	bx	lr

08007b18 <pubsub_multiple_listener_wait_timeout_S>:

static struct pubsub_listener_s* pubsub_multiple_listener_wait_timeout_S(size_t num_listeners, struct pubsub_listener_s** listeners, systime_t timeout) {
 8007b18:	b580      	push	{r7, lr}
 8007b1a:	b08c      	sub	sp, #48	; 0x30
 8007b1c:	af00      	add	r7, sp, #0
 8007b1e:	60f8      	str	r0, [r7, #12]
 8007b20:	60b9      	str	r1, [r7, #8]
 8007b22:	4613      	mov	r3, r2
 8007b24:	80fb      	strh	r3, [r7, #6]
    chDbgCheckClassS();
 8007b26:	f002 f859 	bl	8009bdc <chDbgCheckClassS>

    // Check for immediately available messages
    for (size_t i=0; i<num_listeners; i++) {
 8007b2a:	2300      	movs	r3, #0
 8007b2c:	62fb      	str	r3, [r7, #44]	; 0x2c
 8007b2e:	e01a      	b.n	8007b66 <pubsub_multiple_listener_wait_timeout_S+0x4e>
        if (listeners && listeners[i] && listeners[i]->next_message) {
 8007b30:	68bb      	ldr	r3, [r7, #8]
 8007b32:	2b00      	cmp	r3, #0
 8007b34:	d014      	beq.n	8007b60 <pubsub_multiple_listener_wait_timeout_S+0x48>
 8007b36:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007b38:	009b      	lsls	r3, r3, #2
 8007b3a:	68ba      	ldr	r2, [r7, #8]
 8007b3c:	4413      	add	r3, r2
 8007b3e:	681b      	ldr	r3, [r3, #0]
 8007b40:	2b00      	cmp	r3, #0
 8007b42:	d00d      	beq.n	8007b60 <pubsub_multiple_listener_wait_timeout_S+0x48>
 8007b44:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007b46:	009b      	lsls	r3, r3, #2
 8007b48:	68ba      	ldr	r2, [r7, #8]
 8007b4a:	4413      	add	r3, r2
 8007b4c:	681b      	ldr	r3, [r3, #0]
 8007b4e:	685b      	ldr	r3, [r3, #4]
 8007b50:	2b00      	cmp	r3, #0
 8007b52:	d005      	beq.n	8007b60 <pubsub_multiple_listener_wait_timeout_S+0x48>
            return listeners[i];
 8007b54:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007b56:	009b      	lsls	r3, r3, #2
 8007b58:	68ba      	ldr	r2, [r7, #8]
 8007b5a:	4413      	add	r3, r2
 8007b5c:	681b      	ldr	r3, [r3, #0]
 8007b5e:	e06b      	b.n	8007c38 <pubsub_multiple_listener_wait_timeout_S+0x120>

static struct pubsub_listener_s* pubsub_multiple_listener_wait_timeout_S(size_t num_listeners, struct pubsub_listener_s** listeners, systime_t timeout) {
    chDbgCheckClassS();

    // Check for immediately available messages
    for (size_t i=0; i<num_listeners; i++) {
 8007b60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007b62:	3301      	adds	r3, #1
 8007b64:	62fb      	str	r3, [r7, #44]	; 0x2c
 8007b66:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8007b68:	68fb      	ldr	r3, [r7, #12]
 8007b6a:	429a      	cmp	r2, r3
 8007b6c:	d3e0      	bcc.n	8007b30 <pubsub_multiple_listener_wait_timeout_S+0x18>
        if (listeners && listeners[i] && listeners[i]->next_message) {
            return listeners[i];
        }
    }

    if (timeout == TIME_IMMEDIATE) {
 8007b6e:	88fb      	ldrh	r3, [r7, #6]
 8007b70:	2b00      	cmp	r3, #0
 8007b72:	d101      	bne.n	8007b78 <pubsub_multiple_listener_wait_timeout_S+0x60>
        return NULL;
 8007b74:	2300      	movs	r3, #0
 8007b76:	e05f      	b.n	8007c38 <pubsub_multiple_listener_wait_timeout_S+0x120>
    }

    // Point listeners' waiting thread references to our thread
    thread_reference_t trp = NULL;
 8007b78:	2300      	movs	r3, #0
 8007b7a:	617b      	str	r3, [r7, #20]
    for (size_t i=0; i<num_listeners; i++) {
 8007b7c:	2300      	movs	r3, #0
 8007b7e:	62bb      	str	r3, [r7, #40]	; 0x28
 8007b80:	e014      	b.n	8007bac <pubsub_multiple_listener_wait_timeout_S+0x94>
        if (listeners && listeners[i]) {
 8007b82:	68bb      	ldr	r3, [r7, #8]
 8007b84:	2b00      	cmp	r3, #0
 8007b86:	d00e      	beq.n	8007ba6 <pubsub_multiple_listener_wait_timeout_S+0x8e>
 8007b88:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007b8a:	009b      	lsls	r3, r3, #2
 8007b8c:	68ba      	ldr	r2, [r7, #8]
 8007b8e:	4413      	add	r3, r2
 8007b90:	681b      	ldr	r3, [r3, #0]
 8007b92:	2b00      	cmp	r3, #0
 8007b94:	d007      	beq.n	8007ba6 <pubsub_multiple_listener_wait_timeout_S+0x8e>
            listeners[i]->waiting_thread_reference_ptr = &trp;
 8007b96:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007b98:	009b      	lsls	r3, r3, #2
 8007b9a:	68ba      	ldr	r2, [r7, #8]
 8007b9c:	4413      	add	r3, r2
 8007b9e:	681b      	ldr	r3, [r3, #0]
 8007ba0:	f107 0214 	add.w	r2, r7, #20
 8007ba4:	609a      	str	r2, [r3, #8]
        return NULL;
    }

    // Point listeners' waiting thread references to our thread
    thread_reference_t trp = NULL;
    for (size_t i=0; i<num_listeners; i++) {
 8007ba6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007ba8:	3301      	adds	r3, #1
 8007baa:	62bb      	str	r3, [r7, #40]	; 0x28
 8007bac:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007bae:	68fb      	ldr	r3, [r7, #12]
 8007bb0:	429a      	cmp	r2, r3
 8007bb2:	d3e6      	bcc.n	8007b82 <pubsub_multiple_listener_wait_timeout_S+0x6a>
            listeners[i]->waiting_thread_reference_ptr = &trp;
        }
    }

    // Wait for a listener to wake us up
    msg_t message = chThdSuspendTimeoutS(&trp, timeout);
 8007bb4:	f107 0214 	add.w	r2, r7, #20
 8007bb8:	88fb      	ldrh	r3, [r7, #6]
 8007bba:	4610      	mov	r0, r2
 8007bbc:	4619      	mov	r1, r3
 8007bbe:	f001 fa7b 	bl	80090b8 <chThdSuspendTimeoutS>
 8007bc2:	61b8      	str	r0, [r7, #24]

    struct pubsub_listener_s* ret = NULL;
 8007bc4:	2300      	movs	r3, #0
 8007bc6:	627b      	str	r3, [r7, #36]	; 0x24
    if (message != MSG_TIMEOUT) {
 8007bc8:	69bb      	ldr	r3, [r7, #24]
 8007bca:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007bce:	d017      	beq.n	8007c00 <pubsub_multiple_listener_wait_timeout_S+0xe8>
        for (size_t i=0; i<num_listeners; i++) {
 8007bd0:	2300      	movs	r3, #0
 8007bd2:	623b      	str	r3, [r7, #32]
 8007bd4:	e010      	b.n	8007bf8 <pubsub_multiple_listener_wait_timeout_S+0xe0>
            if (listeners[i] == (void*)message) {
 8007bd6:	6a3b      	ldr	r3, [r7, #32]
 8007bd8:	009b      	lsls	r3, r3, #2
 8007bda:	68ba      	ldr	r2, [r7, #8]
 8007bdc:	4413      	add	r3, r2
 8007bde:	681a      	ldr	r2, [r3, #0]
 8007be0:	69bb      	ldr	r3, [r7, #24]
 8007be2:	429a      	cmp	r2, r3
 8007be4:	d105      	bne.n	8007bf2 <pubsub_multiple_listener_wait_timeout_S+0xda>
                ret = listeners[i];
 8007be6:	6a3b      	ldr	r3, [r7, #32]
 8007be8:	009b      	lsls	r3, r3, #2
 8007bea:	68ba      	ldr	r2, [r7, #8]
 8007bec:	4413      	add	r3, r2
 8007bee:	681b      	ldr	r3, [r3, #0]
 8007bf0:	627b      	str	r3, [r7, #36]	; 0x24
    // Wait for a listener to wake us up
    msg_t message = chThdSuspendTimeoutS(&trp, timeout);

    struct pubsub_listener_s* ret = NULL;
    if (message != MSG_TIMEOUT) {
        for (size_t i=0; i<num_listeners; i++) {
 8007bf2:	6a3b      	ldr	r3, [r7, #32]
 8007bf4:	3301      	adds	r3, #1
 8007bf6:	623b      	str	r3, [r7, #32]
 8007bf8:	6a3a      	ldr	r2, [r7, #32]
 8007bfa:	68fb      	ldr	r3, [r7, #12]
 8007bfc:	429a      	cmp	r2, r3
 8007bfe:	d3ea      	bcc.n	8007bd6 <pubsub_multiple_listener_wait_timeout_S+0xbe>
            }
        }
    }

    // Set listeners' waiting thread references back to NULL
    for (size_t i=0; i<num_listeners; i++) {
 8007c00:	2300      	movs	r3, #0
 8007c02:	61fb      	str	r3, [r7, #28]
 8007c04:	e013      	b.n	8007c2e <pubsub_multiple_listener_wait_timeout_S+0x116>
        if (listeners && listeners[i]) {
 8007c06:	68bb      	ldr	r3, [r7, #8]
 8007c08:	2b00      	cmp	r3, #0
 8007c0a:	d00d      	beq.n	8007c28 <pubsub_multiple_listener_wait_timeout_S+0x110>
 8007c0c:	69fb      	ldr	r3, [r7, #28]
 8007c0e:	009b      	lsls	r3, r3, #2
 8007c10:	68ba      	ldr	r2, [r7, #8]
 8007c12:	4413      	add	r3, r2
 8007c14:	681b      	ldr	r3, [r3, #0]
 8007c16:	2b00      	cmp	r3, #0
 8007c18:	d006      	beq.n	8007c28 <pubsub_multiple_listener_wait_timeout_S+0x110>
            listeners[i]->waiting_thread_reference_ptr = NULL;
 8007c1a:	69fb      	ldr	r3, [r7, #28]
 8007c1c:	009b      	lsls	r3, r3, #2
 8007c1e:	68ba      	ldr	r2, [r7, #8]
 8007c20:	4413      	add	r3, r2
 8007c22:	681b      	ldr	r3, [r3, #0]
 8007c24:	2200      	movs	r2, #0
 8007c26:	609a      	str	r2, [r3, #8]
            }
        }
    }

    // Set listeners' waiting thread references back to NULL
    for (size_t i=0; i<num_listeners; i++) {
 8007c28:	69fb      	ldr	r3, [r7, #28]
 8007c2a:	3301      	adds	r3, #1
 8007c2c:	61fb      	str	r3, [r7, #28]
 8007c2e:	69fa      	ldr	r2, [r7, #28]
 8007c30:	68fb      	ldr	r3, [r7, #12]
 8007c32:	429a      	cmp	r2, r3
 8007c34:	d3e7      	bcc.n	8007c06 <pubsub_multiple_listener_wait_timeout_S+0xee>
        if (listeners && listeners[i]) {
            listeners[i]->waiting_thread_reference_ptr = NULL;
        }
    }

    return ret;
 8007c36:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8007c38:	4618      	mov	r0, r3
 8007c3a:	3730      	adds	r7, #48	; 0x30
 8007c3c:	46bd      	mov	sp, r7
 8007c3e:	bd80      	pop	{r7, pc}

08007c40 <port_lock.lto_priv.122>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8007c40:	b480      	push	{r7}
 8007c42:	b083      	sub	sp, #12
 8007c44:	af00      	add	r7, sp, #0
 8007c46:	2320      	movs	r3, #32
 8007c48:	607b      	str	r3, [r7, #4]
 8007c4a:	687b      	ldr	r3, [r7, #4]
 8007c4c:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8007c50:	370c      	adds	r7, #12
 8007c52:	46bd      	mov	sp, r7
 8007c54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007c58:	4770      	bx	lr
 8007c5a:	bf00      	nop

08007c5c <port_unlock.lto_priv.120>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8007c5c:	b480      	push	{r7}
 8007c5e:	b083      	sub	sp, #12
 8007c60:	af00      	add	r7, sp, #0
 8007c62:	2300      	movs	r3, #0
 8007c64:	607b      	str	r3, [r7, #4]
 8007c66:	687b      	ldr	r3, [r7, #4]
 8007c68:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8007c6c:	370c      	adds	r7, #12
 8007c6e:	46bd      	mov	sp, r7
 8007c70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007c74:	4770      	bx	lr
 8007c76:	bf00      	nop

08007c78 <st_lld_get_counter.lto_priv.118>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 8007c78:	b480      	push	{r7}
 8007c7a:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 8007c7c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8007c80:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007c82:	b29b      	uxth	r3, r3
}
 8007c84:	4618      	mov	r0, r3
 8007c86:	46bd      	mov	sp, r7
 8007c88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007c8c:	4770      	bx	lr
 8007c8e:	bf00      	nop

08007c90 <port_timer_get_time.lto_priv.115>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8007c90:	b580      	push	{r7, lr}
 8007c92:	af00      	add	r7, sp, #0

  return stGetCounter();
 8007c94:	f7ff fff0 	bl	8007c78 <st_lld_get_counter.lto_priv.118>
 8007c98:	4603      	mov	r3, r0
}
 8007c9a:	4618      	mov	r0, r3
 8007c9c:	bd80      	pop	{r7, pc}
 8007c9e:	bf00      	nop

08007ca0 <chSysLock.lto_priv.98>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8007ca0:	b580      	push	{r7, lr}
 8007ca2:	af00      	add	r7, sp, #0

  port_lock();
 8007ca4:	f7ff ffcc 	bl	8007c40 <port_lock.lto_priv.122>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007ca8:	f001 fef6 	bl	8009a98 <_dbg_check_lock>
}
 8007cac:	bd80      	pop	{r7, pc}
 8007cae:	bf00      	nop

08007cb0 <chSysUnlock.lto_priv.96>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8007cb0:	b580      	push	{r7, lr}
 8007cb2:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8007cb4:	f001 ff06 	bl	8009ac4 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007cb8:	4b09      	ldr	r3, [pc, #36]	; (8007ce0 <chSysUnlock.lto_priv.96+0x30>)
 8007cba:	681b      	ldr	r3, [r3, #0]
 8007cbc:	4a08      	ldr	r2, [pc, #32]	; (8007ce0 <chSysUnlock.lto_priv.96+0x30>)
 8007cbe:	4293      	cmp	r3, r2
 8007cc0:	d00a      	beq.n	8007cd8 <chSysUnlock.lto_priv.96+0x28>
 8007cc2:	4b07      	ldr	r3, [pc, #28]	; (8007ce0 <chSysUnlock.lto_priv.96+0x30>)
 8007cc4:	699b      	ldr	r3, [r3, #24]
 8007cc6:	689a      	ldr	r2, [r3, #8]
 8007cc8:	4b05      	ldr	r3, [pc, #20]	; (8007ce0 <chSysUnlock.lto_priv.96+0x30>)
 8007cca:	681b      	ldr	r3, [r3, #0]
 8007ccc:	689b      	ldr	r3, [r3, #8]
 8007cce:	429a      	cmp	r2, r3
 8007cd0:	d202      	bcs.n	8007cd8 <chSysUnlock.lto_priv.96+0x28>
 8007cd2:	4804      	ldr	r0, [pc, #16]	; (8007ce4 <chSysUnlock.lto_priv.96+0x34>)
 8007cd4:	f001 fe92 	bl	80099fc <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8007cd8:	f7ff ffc0 	bl	8007c5c <port_unlock.lto_priv.120>
}
 8007cdc:	bd80      	pop	{r7, pc}
 8007cde:	bf00      	nop
 8007ce0:	20001330 	.word	0x20001330
 8007ce4:	0800d0d4 	.word	0x0800d0d4

08007ce8 <chVTGetSystemTimeX.lto_priv.89>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8007ce8:	b580      	push	{r7, lr}
 8007cea:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8007cec:	f7ff ffd0 	bl	8007c90 <port_timer_get_time.lto_priv.115>
 8007cf0:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8007cf2:	4618      	mov	r0, r3
 8007cf4:	bd80      	pop	{r7, pc}
 8007cf6:	bf00      	nop

08007cf8 <chThdGetSelfX.lto_priv.106>:
  *
  * @return             A pointer to the current thread.
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {
 8007cf8:	b480      	push	{r7}
 8007cfa:	af00      	add	r7, sp, #0

  return ch.rlist.current;
 8007cfc:	4b03      	ldr	r3, [pc, #12]	; (8007d0c <chThdGetSelfX.lto_priv.106+0x14>)
 8007cfe:	699b      	ldr	r3, [r3, #24]
}
 8007d00:	4618      	mov	r0, r3
 8007d02:	46bd      	mov	sp, r7
 8007d04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007d08:	4770      	bx	lr
 8007d0a:	bf00      	nop
 8007d0c:	20001330 	.word	0x20001330

08007d10 <chRegSetThreadName.lto_priv.107>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8007d10:	b480      	push	{r7}
 8007d12:	b083      	sub	sp, #12
 8007d14:	af00      	add	r7, sp, #0
 8007d16:	6078      	str	r0, [r7, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8007d18:	4b04      	ldr	r3, [pc, #16]	; (8007d2c <chRegSetThreadName.lto_priv.107+0x1c>)
 8007d1a:	699b      	ldr	r3, [r3, #24]
 8007d1c:	687a      	ldr	r2, [r7, #4]
 8007d1e:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 8007d20:	370c      	adds	r7, #12
 8007d22:	46bd      	mov	sp, r7
 8007d24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007d28:	4770      	bx	lr
 8007d2a:	bf00      	nop
 8007d2c:	20001330 	.word	0x20001330

08007d30 <chMBGetUsedCountI.lto_priv.105>:
 * @return              The number of queued messages.
 * @retval QUEUE_RESET  if the queue is in reset state.
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(const mailbox_t *mbp) {
 8007d30:	b580      	push	{r7, lr}
 8007d32:	b082      	sub	sp, #8
 8007d34:	af00      	add	r7, sp, #0
 8007d36:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 8007d38:	f001 ff3e 	bl	8009bb8 <chDbgCheckClassI>

  return mbp->cnt;
 8007d3c:	687b      	ldr	r3, [r7, #4]
 8007d3e:	691b      	ldr	r3, [r3, #16]
}
 8007d40:	4618      	mov	r0, r3
 8007d42:	3708      	adds	r7, #8
 8007d44:	46bd      	mov	sp, r7
 8007d46:	bd80      	pop	{r7, pc}

08007d48 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
static inline void *chCoreAllocAligned(size_t size, unsigned align) {
 8007d48:	b580      	push	{r7, lr}
 8007d4a:	b084      	sub	sp, #16
 8007d4c:	af00      	add	r7, sp, #0
 8007d4e:	6078      	str	r0, [r7, #4]
 8007d50:	6039      	str	r1, [r7, #0]
  void *p;

  chSysLock();
 8007d52:	f7ff ffa5 	bl	8007ca0 <chSysLock.lto_priv.98>
  p = chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8007d56:	6878      	ldr	r0, [r7, #4]
 8007d58:	6839      	ldr	r1, [r7, #0]
 8007d5a:	2200      	movs	r2, #0
 8007d5c:	f000 fe7a 	bl	8008a54 <chCoreAllocAlignedWithOffsetI>
 8007d60:	60f8      	str	r0, [r7, #12]
  chSysUnlock();
 8007d62:	f7ff ffa5 	bl	8007cb0 <chSysUnlock.lto_priv.96>

  return p;
 8007d66:	68fb      	ldr	r3, [r7, #12]
}
 8007d68:	4618      	mov	r0, r3
 8007d6a:	3710      	adds	r7, #16
 8007d6c:	46bd      	mov	sp, r7
 8007d6e:	bd80      	pop	{r7, pc}

08007d70 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocI(size_t size) {
 8007d70:	b580      	push	{r7, lr}
 8007d72:	b082      	sub	sp, #8
 8007d74:	af00      	add	r7, sp, #0
 8007d76:	6078      	str	r0, [r7, #4]

  return chCoreAllocAlignedWithOffsetI(size, PORT_NATURAL_ALIGN, 0U);
 8007d78:	6878      	ldr	r0, [r7, #4]
 8007d7a:	2104      	movs	r1, #4
 8007d7c:	2200      	movs	r2, #0
 8007d7e:	f000 fe69 	bl	8008a54 <chCoreAllocAlignedWithOffsetI>
 8007d82:	4603      	mov	r3, r0
}
 8007d84:	4618      	mov	r0, r3
 8007d86:	3708      	adds	r7, #8
 8007d88:	46bd      	mov	sp, r7
 8007d8a:	bd80      	pop	{r7, pc}

08007d8c <chPoolAddI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be added
 *
 * @iclass
 */
static inline void chPoolAddI(memory_pool_t *mp, void *objp) {
 8007d8c:	b580      	push	{r7, lr}
 8007d8e:	b082      	sub	sp, #8
 8007d90:	af00      	add	r7, sp, #0
 8007d92:	6078      	str	r0, [r7, #4]
 8007d94:	6039      	str	r1, [r7, #0]

  chDbgCheckClassI();
 8007d96:	f001 ff0f 	bl	8009bb8 <chDbgCheckClassI>

  chPoolFreeI(mp, objp);
 8007d9a:	6878      	ldr	r0, [r7, #4]
 8007d9c:	6839      	ldr	r1, [r7, #0]
 8007d9e:	f000 ff8f 	bl	8008cc0 <chPoolFreeI>
}
 8007da2:	3708      	adds	r7, #8
 8007da4:	46bd      	mov	sp, r7
 8007da6:	bd80      	pop	{r7, pc}

08007da8 <worker_thread_init>:
static bool worker_thread_listener_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* check_task);
static bool worker_thread_listener_task_is_registered(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* check_task);
static bool worker_thread_get_any_listener_task_due_I(struct worker_thread_s* worker_thread);
#endif

void worker_thread_init(struct worker_thread_s* worker_thread, const char* name, tprio_t priority) {
 8007da8:	b580      	push	{r7, lr}
 8007daa:	b084      	sub	sp, #16
 8007dac:	af00      	add	r7, sp, #0
 8007dae:	60f8      	str	r0, [r7, #12]
 8007db0:	60b9      	str	r1, [r7, #8]
 8007db2:	607a      	str	r2, [r7, #4]
    chDbgCheck(worker_thread != NULL);
 8007db4:	68fb      	ldr	r3, [r7, #12]
 8007db6:	2b00      	cmp	r3, #0
 8007db8:	d102      	bne.n	8007dc0 <worker_thread_init+0x18>
 8007dba:	480d      	ldr	r0, [pc, #52]	; (8007df0 <worker_thread_init+0x48>)
 8007dbc:	f001 fe1e 	bl	80099fc <chSysHalt>

    worker_thread->name = name;
 8007dc0:	68fb      	ldr	r3, [r7, #12]
 8007dc2:	68ba      	ldr	r2, [r7, #8]
 8007dc4:	601a      	str	r2, [r3, #0]
    worker_thread->priority = priority;
 8007dc6:	68fb      	ldr	r3, [r7, #12]
 8007dc8:	687a      	ldr	r2, [r7, #4]
 8007dca:	605a      	str	r2, [r3, #4]

    worker_thread->timer_task_list_head = NULL;
 8007dcc:	68fb      	ldr	r3, [r7, #12]
 8007dce:	2200      	movs	r2, #0
 8007dd0:	611a      	str	r2, [r3, #16]
#ifdef MODULE_PUBSUB_ENABLED
    worker_thread->listener_task_list_head = NULL;
 8007dd2:	68fb      	ldr	r3, [r7, #12]
 8007dd4:	2200      	movs	r2, #0
 8007dd6:	615a      	str	r2, [r3, #20]
    worker_thread->publisher_task_list_head = NULL;
 8007dd8:	68fb      	ldr	r3, [r7, #12]
 8007dda:	2200      	movs	r2, #0
 8007ddc:	619a      	str	r2, [r3, #24]
#endif

    worker_thread->thread = NULL;
 8007dde:	68fb      	ldr	r3, [r7, #12]
 8007de0:	2200      	movs	r2, #0
 8007de2:	609a      	str	r2, [r3, #8]
    worker_thread->suspend_trp = NULL;
 8007de4:	68fb      	ldr	r3, [r7, #12]
 8007de6:	2200      	movs	r2, #0
 8007de8:	60da      	str	r2, [r3, #12]
}
 8007dea:	3710      	adds	r7, #16
 8007dec:	46bd      	mov	sp, r7
 8007dee:	bd80      	pop	{r7, pc}
 8007df0:	0800d0ac 	.word	0x0800d0ac

08007df4 <worker_thread_start>:

void worker_thread_start(struct worker_thread_s* worker_thread, size_t stack_size) {
 8007df4:	b580      	push	{r7, lr}
 8007df6:	b08a      	sub	sp, #40	; 0x28
 8007df8:	af00      	add	r7, sp, #0
 8007dfa:	6078      	str	r0, [r7, #4]
 8007dfc:	6039      	str	r1, [r7, #0]
    chDbgCheck(worker_thread != NULL);
 8007dfe:	687b      	ldr	r3, [r7, #4]
 8007e00:	2b00      	cmp	r3, #0
 8007e02:	d102      	bne.n	8007e0a <worker_thread_start+0x16>
 8007e04:	4818      	ldr	r0, [pc, #96]	; (8007e68 <worker_thread_start+0x74>)
 8007e06:	f001 fdf9 	bl	80099fc <chSysHalt>

    void* working_area = chCoreAllocAligned(THD_WORKING_AREA_SIZE(stack_size), PORT_WORKING_AREA_ALIGN);
 8007e0a:	683b      	ldr	r3, [r7, #0]
 8007e0c:	33bb      	adds	r3, #187	; 0xbb
 8007e0e:	f023 0307 	bic.w	r3, r3, #7
 8007e12:	4618      	mov	r0, r3
 8007e14:	2108      	movs	r1, #8
 8007e16:	f7ff ff97 	bl	8007d48 <chCoreAllocAligned>
 8007e1a:	6278      	str	r0, [r7, #36]	; 0x24
    chDbgCheck(working_area != NULL);
 8007e1c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007e1e:	2b00      	cmp	r3, #0
 8007e20:	d102      	bne.n	8007e28 <worker_thread_start+0x34>
 8007e22:	4811      	ldr	r0, [pc, #68]	; (8007e68 <worker_thread_start+0x74>)
 8007e24:	f001 fdea 	bl	80099fc <chSysHalt>
    
    const thread_descriptor_t thread_descriptor = {
        worker_thread->name,
 8007e28:	687b      	ldr	r3, [r7, #4]
 8007e2a:	681b      	ldr	r3, [r3, #0]
    chDbgCheck(worker_thread != NULL);

    void* working_area = chCoreAllocAligned(THD_WORKING_AREA_SIZE(stack_size), PORT_WORKING_AREA_ALIGN);
    chDbgCheck(working_area != NULL);
    
    const thread_descriptor_t thread_descriptor = {
 8007e2c:	60fb      	str	r3, [r7, #12]
 8007e2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007e30:	613b      	str	r3, [r7, #16]
        worker_thread->name,
        THD_WORKING_AREA_BASE(working_area),
        THD_WORKING_AREA_BASE(working_area) + THD_WORKING_AREA_SIZE(stack_size)/sizeof(stkalign_t),
 8007e32:	683b      	ldr	r3, [r7, #0]
 8007e34:	33bb      	adds	r3, #187	; 0xbb
 8007e36:	f023 0307 	bic.w	r3, r3, #7
 8007e3a:	08db      	lsrs	r3, r3, #3
 8007e3c:	00db      	lsls	r3, r3, #3
 8007e3e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007e40:	4413      	add	r3, r2
    chDbgCheck(worker_thread != NULL);

    void* working_area = chCoreAllocAligned(THD_WORKING_AREA_SIZE(stack_size), PORT_WORKING_AREA_ALIGN);
    chDbgCheck(working_area != NULL);
    
    const thread_descriptor_t thread_descriptor = {
 8007e42:	617b      	str	r3, [r7, #20]
        worker_thread->name,
        THD_WORKING_AREA_BASE(working_area),
        THD_WORKING_AREA_BASE(working_area) + THD_WORKING_AREA_SIZE(stack_size)/sizeof(stkalign_t),
        worker_thread->priority,
 8007e44:	687b      	ldr	r3, [r7, #4]
 8007e46:	685b      	ldr	r3, [r3, #4]
    chDbgCheck(worker_thread != NULL);

    void* working_area = chCoreAllocAligned(THD_WORKING_AREA_SIZE(stack_size), PORT_WORKING_AREA_ALIGN);
    chDbgCheck(working_area != NULL);
    
    const thread_descriptor_t thread_descriptor = {
 8007e48:	61bb      	str	r3, [r7, #24]
 8007e4a:	4b08      	ldr	r3, [pc, #32]	; (8007e6c <worker_thread_start+0x78>)
 8007e4c:	61fb      	str	r3, [r7, #28]
 8007e4e:	687b      	ldr	r3, [r7, #4]
 8007e50:	623b      	str	r3, [r7, #32]
        worker_thread->priority,
        worker_thread_func,
        worker_thread
    };
    
    worker_thread->thread = chThdCreate(&thread_descriptor);
 8007e52:	f107 030c 	add.w	r3, r7, #12
 8007e56:	4618      	mov	r0, r3
 8007e58:	f001 f8a6 	bl	8008fa8 <chThdCreate>
 8007e5c:	4602      	mov	r2, r0
 8007e5e:	687b      	ldr	r3, [r7, #4]
 8007e60:	609a      	str	r2, [r3, #8]
}
 8007e62:	3728      	adds	r7, #40	; 0x28
 8007e64:	46bd      	mov	sp, r7
 8007e66:	bd80      	pop	{r7, pc}
 8007e68:	0800d0c0 	.word	0x0800d0c0
 8007e6c:	08005fc1 	.word	0x08005fc1

08007e70 <_worker_thread_add_timer_task_no_wake_I>:

static void _worker_thread_add_timer_task_no_wake_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, timer_task_handler_func_ptr task_func, void* ctx, systime_t timer_expiration_ticks, bool auto_repeat) {
 8007e70:	b590      	push	{r4, r7, lr}
 8007e72:	b087      	sub	sp, #28
 8007e74:	af02      	add	r7, sp, #8
 8007e76:	60f8      	str	r0, [r7, #12]
 8007e78:	60b9      	str	r1, [r7, #8]
 8007e7a:	607a      	str	r2, [r7, #4]
 8007e7c:	603b      	str	r3, [r7, #0]
    chDbgCheckClassI();
 8007e7e:	f001 fe9b 	bl	8009bb8 <chDbgCheckClassI>

    worker_thread_init_timer_task(task, chVTGetSystemTimeX(), timer_expiration_ticks, auto_repeat, task_func, ctx);
 8007e82:	f7ff ff31 	bl	8007ce8 <chVTGetSystemTimeX.lto_priv.89>
 8007e86:	4603      	mov	r3, r0
 8007e88:	4619      	mov	r1, r3
 8007e8a:	8c3a      	ldrh	r2, [r7, #32]
 8007e8c:	f897 4024 	ldrb.w	r4, [r7, #36]	; 0x24
 8007e90:	687b      	ldr	r3, [r7, #4]
 8007e92:	9300      	str	r3, [sp, #0]
 8007e94:	683b      	ldr	r3, [r7, #0]
 8007e96:	9301      	str	r3, [sp, #4]
 8007e98:	68b8      	ldr	r0, [r7, #8]
 8007e9a:	4623      	mov	r3, r4
 8007e9c:	f7fe f8ba 	bl	8006014 <worker_thread_init_timer_task.lto_priv.138>
    worker_thread_insert_timer_task_I(worker_thread, task);
 8007ea0:	68f8      	ldr	r0, [r7, #12]
 8007ea2:	68b9      	ldr	r1, [r7, #8]
 8007ea4:	f7fe f8f4 	bl	8006090 <worker_thread_insert_timer_task_I.lto_priv.137>
}
 8007ea8:	3714      	adds	r7, #20
 8007eaa:	46bd      	mov	sp, r7
 8007eac:	bd90      	pop	{r4, r7, pc}
 8007eae:	bf00      	nop

08007eb0 <worker_thread_add_timer_task>:

    // Wake worker thread to process tasks
    worker_thread_wake_I(worker_thread);
}

void worker_thread_add_timer_task(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, timer_task_handler_func_ptr task_func, void* ctx, systime_t timer_expiration_ticks, bool auto_repeat) {
 8007eb0:	b580      	push	{r7, lr}
 8007eb2:	b086      	sub	sp, #24
 8007eb4:	af02      	add	r7, sp, #8
 8007eb6:	60f8      	str	r0, [r7, #12]
 8007eb8:	60b9      	str	r1, [r7, #8]
 8007eba:	607a      	str	r2, [r7, #4]
 8007ebc:	603b      	str	r3, [r7, #0]
    chSysLock();
 8007ebe:	f7ff feef 	bl	8007ca0 <chSysLock.lto_priv.98>
    _worker_thread_add_timer_task_no_wake_I(worker_thread, task, task_func, ctx, timer_expiration_ticks, auto_repeat);
 8007ec2:	8b3b      	ldrh	r3, [r7, #24]
 8007ec4:	9300      	str	r3, [sp, #0]
 8007ec6:	7f3b      	ldrb	r3, [r7, #28]
 8007ec8:	9301      	str	r3, [sp, #4]
 8007eca:	68f8      	ldr	r0, [r7, #12]
 8007ecc:	68b9      	ldr	r1, [r7, #8]
 8007ece:	687a      	ldr	r2, [r7, #4]
 8007ed0:	683b      	ldr	r3, [r7, #0]
 8007ed2:	f7ff ffcd 	bl	8007e70 <_worker_thread_add_timer_task_no_wake_I>
    chSysUnlock();
 8007ed6:	f7ff feeb 	bl	8007cb0 <chSysUnlock.lto_priv.96>

    // Wake worker thread to process tasks
    worker_thread_wake(worker_thread);
 8007eda:	68f8      	ldr	r0, [r7, #12]
 8007edc:	f7fe f88c 	bl	8005ff8 <worker_thread_wake.lto_priv.134>
}
 8007ee0:	3710      	adds	r7, #16
 8007ee2:	46bd      	mov	sp, r7
 8007ee4:	bd80      	pop	{r7, pc}
 8007ee6:	bf00      	nop

08007ee8 <_worker_thread_timer_task_reschedule_no_wake_I>:

static void _worker_thread_timer_task_reschedule_no_wake_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, systime_t timer_expiration_ticks) {
 8007ee8:	b580      	push	{r7, lr}
 8007eea:	b086      	sub	sp, #24
 8007eec:	af00      	add	r7, sp, #0
 8007eee:	60f8      	str	r0, [r7, #12]
 8007ef0:	60b9      	str	r1, [r7, #8]
 8007ef2:	4613      	mov	r3, r2
 8007ef4:	80fb      	strh	r3, [r7, #6]
    chDbgCheckClassI();
 8007ef6:	f001 fe5f 	bl	8009bb8 <chDbgCheckClassI>

    systime_t t_now = chVTGetSystemTimeX();
 8007efa:	f7ff fef5 	bl	8007ce8 <chVTGetSystemTimeX.lto_priv.89>
 8007efe:	4603      	mov	r3, r0
 8007f00:	82fb      	strh	r3, [r7, #22]

    worker_thread_remove_timer_task_I(worker_thread, task);
 8007f02:	68f8      	ldr	r0, [r7, #12]
 8007f04:	68b9      	ldr	r1, [r7, #8]
 8007f06:	f000 f83b 	bl	8007f80 <worker_thread_remove_timer_task_I>

    task->timer_expiration_ticks = timer_expiration_ticks;
 8007f0a:	68bb      	ldr	r3, [r7, #8]
 8007f0c:	88fa      	ldrh	r2, [r7, #6]
 8007f0e:	811a      	strh	r2, [r3, #8]
    task->timer_begin_systime = t_now;
 8007f10:	68bb      	ldr	r3, [r7, #8]
 8007f12:	8afa      	ldrh	r2, [r7, #22]
 8007f14:	815a      	strh	r2, [r3, #10]

    worker_thread_insert_timer_task_I(worker_thread, task);
 8007f16:	68f8      	ldr	r0, [r7, #12]
 8007f18:	68b9      	ldr	r1, [r7, #8]
 8007f1a:	f7fe f8b9 	bl	8006090 <worker_thread_insert_timer_task_I.lto_priv.137>
}
 8007f1e:	3718      	adds	r7, #24
 8007f20:	46bd      	mov	sp, r7
 8007f22:	bd80      	pop	{r7, pc}

08007f24 <worker_thread_timer_task_reschedule_I>:

void worker_thread_timer_task_reschedule_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, systime_t timer_expiration_ticks) {
 8007f24:	b580      	push	{r7, lr}
 8007f26:	b084      	sub	sp, #16
 8007f28:	af00      	add	r7, sp, #0
 8007f2a:	60f8      	str	r0, [r7, #12]
 8007f2c:	60b9      	str	r1, [r7, #8]
 8007f2e:	4613      	mov	r3, r2
 8007f30:	80fb      	strh	r3, [r7, #6]
    chDbgCheckClassI();
 8007f32:	f001 fe41 	bl	8009bb8 <chDbgCheckClassI>
    _worker_thread_timer_task_reschedule_no_wake_I(worker_thread, task, timer_expiration_ticks);
 8007f36:	88fb      	ldrh	r3, [r7, #6]
 8007f38:	68f8      	ldr	r0, [r7, #12]
 8007f3a:	68b9      	ldr	r1, [r7, #8]
 8007f3c:	461a      	mov	r2, r3
 8007f3e:	f7ff ffd3 	bl	8007ee8 <_worker_thread_timer_task_reschedule_no_wake_I>

    // Wake worker thread to process tasks
    worker_thread_wake_I(worker_thread);
 8007f42:	68f8      	ldr	r0, [r7, #12]
 8007f44:	f7fe f848 	bl	8005fd8 <worker_thread_wake_I.lto_priv.136>
}
 8007f48:	3710      	adds	r7, #16
 8007f4a:	46bd      	mov	sp, r7
 8007f4c:	bd80      	pop	{r7, pc}
 8007f4e:	bf00      	nop

08007f50 <worker_thread_timer_task_reschedule>:

void worker_thread_timer_task_reschedule(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, systime_t timer_expiration_ticks) {
 8007f50:	b580      	push	{r7, lr}
 8007f52:	b084      	sub	sp, #16
 8007f54:	af00      	add	r7, sp, #0
 8007f56:	60f8      	str	r0, [r7, #12]
 8007f58:	60b9      	str	r1, [r7, #8]
 8007f5a:	4613      	mov	r3, r2
 8007f5c:	80fb      	strh	r3, [r7, #6]
    chSysLock();
 8007f5e:	f7ff fe9f 	bl	8007ca0 <chSysLock.lto_priv.98>
    _worker_thread_timer_task_reschedule_no_wake_I(worker_thread, task, timer_expiration_ticks);
 8007f62:	88fb      	ldrh	r3, [r7, #6]
 8007f64:	68f8      	ldr	r0, [r7, #12]
 8007f66:	68b9      	ldr	r1, [r7, #8]
 8007f68:	461a      	mov	r2, r3
 8007f6a:	f7ff ffbd 	bl	8007ee8 <_worker_thread_timer_task_reschedule_no_wake_I>
    chSysUnlock();
 8007f6e:	f7ff fe9f 	bl	8007cb0 <chSysUnlock.lto_priv.96>

    // Wake worker thread to process tasks
    worker_thread_wake(worker_thread);
 8007f72:	68f8      	ldr	r0, [r7, #12]
 8007f74:	f7fe f840 	bl	8005ff8 <worker_thread_wake.lto_priv.134>
}
 8007f78:	3710      	adds	r7, #16
 8007f7a:	46bd      	mov	sp, r7
 8007f7c:	bd80      	pop	{r7, pc}
 8007f7e:	bf00      	nop

08007f80 <worker_thread_remove_timer_task_I>:

void worker_thread_remove_timer_task_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task) {
 8007f80:	b580      	push	{r7, lr}
 8007f82:	b084      	sub	sp, #16
 8007f84:	af00      	add	r7, sp, #0
 8007f86:	6078      	str	r0, [r7, #4]
 8007f88:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 8007f8a:	f001 fe15 	bl	8009bb8 <chDbgCheckClassI>
    LINKED_LIST_REMOVE(struct worker_thread_timer_task_s, worker_thread->timer_task_list_head, task);
 8007f8e:	687b      	ldr	r3, [r7, #4]
 8007f90:	3310      	adds	r3, #16
 8007f92:	60fb      	str	r3, [r7, #12]
 8007f94:	e003      	b.n	8007f9e <worker_thread_remove_timer_task_I+0x1e>
 8007f96:	68fb      	ldr	r3, [r7, #12]
 8007f98:	681b      	ldr	r3, [r3, #0]
 8007f9a:	3310      	adds	r3, #16
 8007f9c:	60fb      	str	r3, [r7, #12]
 8007f9e:	68fb      	ldr	r3, [r7, #12]
 8007fa0:	681b      	ldr	r3, [r3, #0]
 8007fa2:	2b00      	cmp	r3, #0
 8007fa4:	d004      	beq.n	8007fb0 <worker_thread_remove_timer_task_I+0x30>
 8007fa6:	68fb      	ldr	r3, [r7, #12]
 8007fa8:	681a      	ldr	r2, [r3, #0]
 8007faa:	683b      	ldr	r3, [r7, #0]
 8007fac:	429a      	cmp	r2, r3
 8007fae:	d1f2      	bne.n	8007f96 <worker_thread_remove_timer_task_I+0x16>
 8007fb0:	68fb      	ldr	r3, [r7, #12]
 8007fb2:	681b      	ldr	r3, [r3, #0]
 8007fb4:	2b00      	cmp	r3, #0
 8007fb6:	d004      	beq.n	8007fc2 <worker_thread_remove_timer_task_I+0x42>
 8007fb8:	68fb      	ldr	r3, [r7, #12]
 8007fba:	681b      	ldr	r3, [r3, #0]
 8007fbc:	691a      	ldr	r2, [r3, #16]
 8007fbe:	68fb      	ldr	r3, [r7, #12]
 8007fc0:	601a      	str	r2, [r3, #0]
}
 8007fc2:	3710      	adds	r7, #16
 8007fc4:	46bd      	mov	sp, r7
 8007fc6:	bd80      	pop	{r7, pc}

08007fc8 <worker_thread_remove_timer_task>:

void worker_thread_remove_timer_task(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task) {
 8007fc8:	b580      	push	{r7, lr}
 8007fca:	b082      	sub	sp, #8
 8007fcc:	af00      	add	r7, sp, #0
 8007fce:	6078      	str	r0, [r7, #4]
 8007fd0:	6039      	str	r1, [r7, #0]
    chSysLock();
 8007fd2:	f7ff fe65 	bl	8007ca0 <chSysLock.lto_priv.98>
    worker_thread_remove_timer_task_I(worker_thread, task);
 8007fd6:	6878      	ldr	r0, [r7, #4]
 8007fd8:	6839      	ldr	r1, [r7, #0]
 8007fda:	f7ff ffd1 	bl	8007f80 <worker_thread_remove_timer_task_I>
    chSysUnlock();
 8007fde:	f7ff fe67 	bl	8007cb0 <chSysUnlock.lto_priv.96>
}
 8007fe2:	3708      	adds	r7, #8
 8007fe4:	46bd      	mov	sp, r7
 8007fe6:	bd80      	pop	{r7, pc}

08007fe8 <worker_thread_task_get_user_context>:

void* worker_thread_task_get_user_context(struct worker_thread_timer_task_s* task) {
 8007fe8:	b480      	push	{r7}
 8007fea:	b083      	sub	sp, #12
 8007fec:	af00      	add	r7, sp, #0
 8007fee:	6078      	str	r0, [r7, #4]
    if (!task) {
 8007ff0:	687b      	ldr	r3, [r7, #4]
 8007ff2:	2b00      	cmp	r3, #0
 8007ff4:	d101      	bne.n	8007ffa <worker_thread_task_get_user_context+0x12>
        return NULL;
 8007ff6:	2300      	movs	r3, #0
 8007ff8:	e001      	b.n	8007ffe <worker_thread_task_get_user_context+0x16>
    }

    return task->ctx;
 8007ffa:	687b      	ldr	r3, [r7, #4]
 8007ffc:	685b      	ldr	r3, [r3, #4]
}
 8007ffe:	4618      	mov	r0, r3
 8008000:	370c      	adds	r7, #12
 8008002:	46bd      	mov	sp, r7
 8008004:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008008:	4770      	bx	lr
 800800a:	bf00      	nop

0800800c <worker_thread_add_listener_task>:

#ifdef MODULE_PUBSUB_ENABLED
void worker_thread_add_listener_task(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* task, struct pubsub_topic_s* topic, pubsub_message_handler_func_ptr handler_cb, void* handler_cb_ctx) {
 800800c:	b580      	push	{r7, lr}
 800800e:	b086      	sub	sp, #24
 8008010:	af00      	add	r7, sp, #0
 8008012:	60f8      	str	r0, [r7, #12]
 8008014:	60b9      	str	r1, [r7, #8]
 8008016:	607a      	str	r2, [r7, #4]
 8008018:	603b      	str	r3, [r7, #0]
    chDbgCheck(!worker_thread_listener_task_is_registered(worker_thread, task));
 800801a:	68f8      	ldr	r0, [r7, #12]
 800801c:	68b9      	ldr	r1, [r7, #8]
 800801e:	f7fe f8f9 	bl	8006214 <worker_thread_listener_task_is_registered.lto_priv.135>
 8008022:	4603      	mov	r3, r0
 8008024:	2b00      	cmp	r3, #0
 8008026:	d002      	beq.n	800802e <worker_thread_add_listener_task+0x22>
 8008028:	4816      	ldr	r0, [pc, #88]	; (8008084 <worker_thread_add_listener_task+0x78>)
 800802a:	f001 fce7 	bl	80099fc <chSysHalt>

    pubsub_listener_init_and_register(&task->listener, topic, handler_cb, handler_cb_ctx);
 800802e:	68bb      	ldr	r3, [r7, #8]
 8008030:	4618      	mov	r0, r3
 8008032:	6879      	ldr	r1, [r7, #4]
 8008034:	683a      	ldr	r2, [r7, #0]
 8008036:	6a3b      	ldr	r3, [r7, #32]
 8008038:	f7ff fbb6 	bl	80077a8 <pubsub_listener_init_and_register>
    pubsub_listener_set_waiting_thread_reference(&task->listener, &worker_thread->suspend_trp);
 800803c:	68ba      	ldr	r2, [r7, #8]
 800803e:	68fb      	ldr	r3, [r7, #12]
 8008040:	330c      	adds	r3, #12
 8008042:	4610      	mov	r0, r2
 8008044:	4619      	mov	r1, r3
 8008046:	f7ff fd57 	bl	8007af8 <pubsub_listener_set_waiting_thread_reference>

    chSysLock();
 800804a:	f7ff fe29 	bl	8007ca0 <chSysLock.lto_priv.98>
    LINKED_LIST_APPEND(struct worker_thread_listener_task_s, worker_thread->listener_task_list_head, task);
 800804e:	68bb      	ldr	r3, [r7, #8]
 8008050:	2200      	movs	r2, #0
 8008052:	631a      	str	r2, [r3, #48]	; 0x30
 8008054:	68fb      	ldr	r3, [r7, #12]
 8008056:	3314      	adds	r3, #20
 8008058:	617b      	str	r3, [r7, #20]
 800805a:	e003      	b.n	8008064 <worker_thread_add_listener_task+0x58>
 800805c:	697b      	ldr	r3, [r7, #20]
 800805e:	681b      	ldr	r3, [r3, #0]
 8008060:	3330      	adds	r3, #48	; 0x30
 8008062:	617b      	str	r3, [r7, #20]
 8008064:	697b      	ldr	r3, [r7, #20]
 8008066:	681b      	ldr	r3, [r3, #0]
 8008068:	2b00      	cmp	r3, #0
 800806a:	d1f7      	bne.n	800805c <worker_thread_add_listener_task+0x50>
 800806c:	697b      	ldr	r3, [r7, #20]
 800806e:	68ba      	ldr	r2, [r7, #8]
 8008070:	601a      	str	r2, [r3, #0]
    chSysUnlock();
 8008072:	f7ff fe1d 	bl	8007cb0 <chSysUnlock.lto_priv.96>

    // Wake worker thread to process tasks
    worker_thread_wake(worker_thread);
 8008076:	68f8      	ldr	r0, [r7, #12]
 8008078:	f7fd ffbe 	bl	8005ff8 <worker_thread_wake.lto_priv.134>
}
 800807c:	3718      	adds	r7, #24
 800807e:	46bd      	mov	sp, r7
 8008080:	bd80      	pop	{r7, pc}
 8008082:	bf00      	nop
 8008084:	0800d0e0 	.word	0x0800d0e0

08008088 <worker_thread_remove_listener_task>:

void worker_thread_remove_listener_task(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* task) {
 8008088:	b580      	push	{r7, lr}
 800808a:	b084      	sub	sp, #16
 800808c:	af00      	add	r7, sp, #0
 800808e:	6078      	str	r0, [r7, #4]
 8008090:	6039      	str	r1, [r7, #0]
    pubsub_listener_unregister(&task->listener);
 8008092:	683b      	ldr	r3, [r7, #0]
 8008094:	4618      	mov	r0, r3
 8008096:	f7ff fbcb 	bl	8007830 <pubsub_listener_unregister>

    chSysLock();
 800809a:	f7ff fe01 	bl	8007ca0 <chSysLock.lto_priv.98>
    LINKED_LIST_REMOVE(struct worker_thread_listener_task_s, worker_thread->listener_task_list_head, task);
 800809e:	687b      	ldr	r3, [r7, #4]
 80080a0:	3314      	adds	r3, #20
 80080a2:	60fb      	str	r3, [r7, #12]
 80080a4:	e003      	b.n	80080ae <worker_thread_remove_listener_task+0x26>
 80080a6:	68fb      	ldr	r3, [r7, #12]
 80080a8:	681b      	ldr	r3, [r3, #0]
 80080aa:	3330      	adds	r3, #48	; 0x30
 80080ac:	60fb      	str	r3, [r7, #12]
 80080ae:	68fb      	ldr	r3, [r7, #12]
 80080b0:	681b      	ldr	r3, [r3, #0]
 80080b2:	2b00      	cmp	r3, #0
 80080b4:	d004      	beq.n	80080c0 <worker_thread_remove_listener_task+0x38>
 80080b6:	68fb      	ldr	r3, [r7, #12]
 80080b8:	681a      	ldr	r2, [r3, #0]
 80080ba:	683b      	ldr	r3, [r7, #0]
 80080bc:	429a      	cmp	r2, r3
 80080be:	d1f2      	bne.n	80080a6 <worker_thread_remove_listener_task+0x1e>
 80080c0:	68fb      	ldr	r3, [r7, #12]
 80080c2:	681b      	ldr	r3, [r3, #0]
 80080c4:	2b00      	cmp	r3, #0
 80080c6:	d004      	beq.n	80080d2 <worker_thread_remove_listener_task+0x4a>
 80080c8:	68fb      	ldr	r3, [r7, #12]
 80080ca:	681b      	ldr	r3, [r3, #0]
 80080cc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80080ce:	68fb      	ldr	r3, [r7, #12]
 80080d0:	601a      	str	r2, [r3, #0]
    chSysUnlock();
 80080d2:	f7ff fded 	bl	8007cb0 <chSysUnlock.lto_priv.96>
}
 80080d6:	3710      	adds	r7, #16
 80080d8:	46bd      	mov	sp, r7
 80080da:	bd80      	pop	{r7, pc}

080080dc <worker_thread_add_publisher_task_I>:

void worker_thread_add_publisher_task_I(struct worker_thread_s* worker_thread, struct worker_thread_publisher_task_s* task, size_t msg_max_size, size_t msg_queue_depth) {
 80080dc:	b590      	push	{r4, r7, lr}
 80080de:	b089      	sub	sp, #36	; 0x24
 80080e0:	af00      	add	r7, sp, #0
 80080e2:	60f8      	str	r0, [r7, #12]
 80080e4:	60b9      	str	r1, [r7, #8]
 80080e6:	607a      	str	r2, [r7, #4]
 80080e8:	603b      	str	r3, [r7, #0]
    chDbgCheckClassI();
 80080ea:	f001 fd65 	bl	8009bb8 <chDbgCheckClassI>
    chDbgCheck(!worker_thread_publisher_task_is_registered_I(worker_thread, task));
 80080ee:	68f8      	ldr	r0, [r7, #12]
 80080f0:	68b9      	ldr	r1, [r7, #8]
 80080f2:	f7fe f837 	bl	8006164 <worker_thread_publisher_task_is_registered_I.lto_priv.133>
 80080f6:	4603      	mov	r3, r0
 80080f8:	2b00      	cmp	r3, #0
 80080fa:	d002      	beq.n	8008102 <worker_thread_add_publisher_task_I+0x26>
 80080fc:	4825      	ldr	r0, [pc, #148]	; (8008194 <worker_thread_add_publisher_task_I+0xb8>)
 80080fe:	f001 fc7d 	bl	80099fc <chSysHalt>

    size_t mem_block_size = sizeof(struct worker_thread_publisher_msg_s)+msg_max_size;
 8008102:	687b      	ldr	r3, [r7, #4]
 8008104:	3308      	adds	r3, #8
 8008106:	617b      	str	r3, [r7, #20]

    task->msg_max_size = msg_max_size;
 8008108:	68bb      	ldr	r3, [r7, #8]
 800810a:	687a      	ldr	r2, [r7, #4]
 800810c:	601a      	str	r2, [r3, #0]
    chPoolObjectInit(&task->pool, mem_block_size, NULL);
 800810e:	68bb      	ldr	r3, [r7, #8]
 8008110:	3304      	adds	r3, #4
 8008112:	4618      	mov	r0, r3
 8008114:	6979      	ldr	r1, [r7, #20]
 8008116:	2200      	movs	r2, #0
 8008118:	f000 fd52 	bl	8008bc0 <chPoolObjectInit>
    chMBObjectInit(&task->mailbox, chCoreAllocI(sizeof(msg_t)*msg_queue_depth), msg_queue_depth);
 800811c:	68bb      	ldr	r3, [r7, #8]
 800811e:	f103 0410 	add.w	r4, r3, #16
 8008122:	683b      	ldr	r3, [r7, #0]
 8008124:	009b      	lsls	r3, r3, #2
 8008126:	4618      	mov	r0, r3
 8008128:	f7ff fe22 	bl	8007d70 <chCoreAllocI>
 800812c:	4602      	mov	r2, r0
 800812e:	683b      	ldr	r3, [r7, #0]
 8008130:	4620      	mov	r0, r4
 8008132:	4611      	mov	r1, r2
 8008134:	461a      	mov	r2, r3
 8008136:	f001 fbb1 	bl	800989c <chMBObjectInit>
    task->worker_thread = worker_thread;
 800813a:	68bb      	ldr	r3, [r7, #8]
 800813c:	68fa      	ldr	r2, [r7, #12]
 800813e:	639a      	str	r2, [r3, #56]	; 0x38

    for (size_t i = 0; i < msg_queue_depth; i++) {
 8008140:	2300      	movs	r3, #0
 8008142:	61fb      	str	r3, [r7, #28]
 8008144:	e00c      	b.n	8008160 <worker_thread_add_publisher_task_I+0x84>
        chPoolAddI(&task->pool, chCoreAllocI(mem_block_size));
 8008146:	68bb      	ldr	r3, [r7, #8]
 8008148:	1d1c      	adds	r4, r3, #4
 800814a:	6978      	ldr	r0, [r7, #20]
 800814c:	f7ff fe10 	bl	8007d70 <chCoreAllocI>
 8008150:	4603      	mov	r3, r0
 8008152:	4620      	mov	r0, r4
 8008154:	4619      	mov	r1, r3
 8008156:	f7ff fe19 	bl	8007d8c <chPoolAddI>
    task->msg_max_size = msg_max_size;
    chPoolObjectInit(&task->pool, mem_block_size, NULL);
    chMBObjectInit(&task->mailbox, chCoreAllocI(sizeof(msg_t)*msg_queue_depth), msg_queue_depth);
    task->worker_thread = worker_thread;

    for (size_t i = 0; i < msg_queue_depth; i++) {
 800815a:	69fb      	ldr	r3, [r7, #28]
 800815c:	3301      	adds	r3, #1
 800815e:	61fb      	str	r3, [r7, #28]
 8008160:	69fa      	ldr	r2, [r7, #28]
 8008162:	683b      	ldr	r3, [r7, #0]
 8008164:	429a      	cmp	r2, r3
 8008166:	d3ee      	bcc.n	8008146 <worker_thread_add_publisher_task_I+0x6a>
        chPoolAddI(&task->pool, chCoreAllocI(mem_block_size));
    }

    LINKED_LIST_APPEND(struct worker_thread_publisher_task_s, worker_thread->publisher_task_list_head, task);
 8008168:	68bb      	ldr	r3, [r7, #8]
 800816a:	2200      	movs	r2, #0
 800816c:	63da      	str	r2, [r3, #60]	; 0x3c
 800816e:	68fb      	ldr	r3, [r7, #12]
 8008170:	3318      	adds	r3, #24
 8008172:	61bb      	str	r3, [r7, #24]
 8008174:	e003      	b.n	800817e <worker_thread_add_publisher_task_I+0xa2>
 8008176:	69bb      	ldr	r3, [r7, #24]
 8008178:	681b      	ldr	r3, [r3, #0]
 800817a:	333c      	adds	r3, #60	; 0x3c
 800817c:	61bb      	str	r3, [r7, #24]
 800817e:	69bb      	ldr	r3, [r7, #24]
 8008180:	681b      	ldr	r3, [r3, #0]
 8008182:	2b00      	cmp	r3, #0
 8008184:	d1f7      	bne.n	8008176 <worker_thread_add_publisher_task_I+0x9a>
 8008186:	69bb      	ldr	r3, [r7, #24]
 8008188:	68ba      	ldr	r2, [r7, #8]
 800818a:	601a      	str	r2, [r3, #0]
}
 800818c:	3724      	adds	r7, #36	; 0x24
 800818e:	46bd      	mov	sp, r7
 8008190:	bd90      	pop	{r4, r7, pc}
 8008192:	bf00      	nop
 8008194:	0800d100 	.word	0x0800d100

08008198 <worker_thread_add_publisher_task>:

void worker_thread_add_publisher_task(struct worker_thread_s* worker_thread, struct worker_thread_publisher_task_s* task, size_t msg_max_size, size_t msg_queue_depth) {
 8008198:	b580      	push	{r7, lr}
 800819a:	b084      	sub	sp, #16
 800819c:	af00      	add	r7, sp, #0
 800819e:	60f8      	str	r0, [r7, #12]
 80081a0:	60b9      	str	r1, [r7, #8]
 80081a2:	607a      	str	r2, [r7, #4]
 80081a4:	603b      	str	r3, [r7, #0]
    chSysLock();
 80081a6:	f7ff fd7b 	bl	8007ca0 <chSysLock.lto_priv.98>
    worker_thread_add_publisher_task_I(worker_thread, task, msg_max_size, msg_queue_depth);
 80081aa:	68f8      	ldr	r0, [r7, #12]
 80081ac:	68b9      	ldr	r1, [r7, #8]
 80081ae:	687a      	ldr	r2, [r7, #4]
 80081b0:	683b      	ldr	r3, [r7, #0]
 80081b2:	f7ff ff93 	bl	80080dc <worker_thread_add_publisher_task_I>
    chSysUnlock();
 80081b6:	f7ff fd7b 	bl	8007cb0 <chSysUnlock.lto_priv.96>
}
 80081ba:	3710      	adds	r7, #16
 80081bc:	46bd      	mov	sp, r7
 80081be:	bd80      	pop	{r7, pc}

080081c0 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 80081c0:	b480      	push	{r7}
 80081c2:	b083      	sub	sp, #12
 80081c4:	af00      	add	r7, sp, #0
 80081c6:	4603      	mov	r3, r0
 80081c8:	80fb      	strh	r3, [r7, #6]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80081ca:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80081ce:	88fb      	ldrh	r3, [r7, #6]
 80081d0:	6353      	str	r3, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80081d2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80081d6:	2200      	movs	r2, #0
 80081d8:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80081da:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80081de:	2202      	movs	r2, #2
 80081e0:	60da      	str	r2, [r3, #12]
}
 80081e2:	370c      	adds	r7, #12
 80081e4:	46bd      	mov	sp, r7
 80081e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80081ea:	4770      	bx	lr

080081ec <st_lld_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {
 80081ec:	b480      	push	{r7}
 80081ee:	af00      	add	r7, sp, #0

  STM32_ST_TIM->DIER = 0;
 80081f0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80081f4:	2200      	movs	r2, #0
 80081f6:	60da      	str	r2, [r3, #12]
}
 80081f8:	46bd      	mov	sp, r7
 80081fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80081fe:	4770      	bx	lr

08008200 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8008200:	b480      	push	{r7}
 8008202:	b083      	sub	sp, #12
 8008204:	af00      	add	r7, sp, #0
 8008206:	4603      	mov	r3, r0
 8008208:	80fb      	strh	r3, [r7, #6]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800820a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800820e:	88fb      	ldrh	r3, [r7, #6]
 8008210:	6353      	str	r3, [r2, #52]	; 0x34
}
 8008212:	370c      	adds	r7, #12
 8008214:	46bd      	mov	sp, r7
 8008216:	f85d 7b04 	ldr.w	r7, [sp], #4
 800821a:	4770      	bx	lr

0800821c <st_lld_is_alarm_active>:
 * @retval false        if the alarm is not active.
 * @retval true         is the alarm is active
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {
 800821c:	b480      	push	{r7}
 800821e:	af00      	add	r7, sp, #0

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8008220:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008224:	68db      	ldr	r3, [r3, #12]
 8008226:	f003 0302 	and.w	r3, r3, #2
 800822a:	2b00      	cmp	r3, #0
 800822c:	bf14      	ite	ne
 800822e:	2301      	movne	r3, #1
 8008230:	2300      	moveq	r3, #0
 8008232:	b2db      	uxtb	r3, r3
}
 8008234:	4618      	mov	r0, r3
 8008236:	46bd      	mov	sp, r7
 8008238:	f85d 7b04 	ldr.w	r7, [sp], #4
 800823c:	4770      	bx	lr
 800823e:	bf00      	nop

08008240 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8008240:	b580      	push	{r7, lr}
 8008242:	af00      	add	r7, sp, #0

  st_lld_init();
 8008244:	f000 fa2c 	bl	80086a0 <st_lld_init>
}
 8008248:	bd80      	pop	{r7, pc}
 800824a:	bf00      	nop

0800824c <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 800824c:	b580      	push	{r7, lr}
 800824e:	b082      	sub	sp, #8
 8008250:	af00      	add	r7, sp, #0
 8008252:	4603      	mov	r3, r0
 8008254:	80fb      	strh	r3, [r7, #6]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8008256:	f7ff ffe1 	bl	800821c <st_lld_is_alarm_active>
 800825a:	4603      	mov	r3, r0
 800825c:	2b00      	cmp	r3, #0
 800825e:	d002      	beq.n	8008266 <stStartAlarm+0x1a>
 8008260:	4804      	ldr	r0, [pc, #16]	; (8008274 <stStartAlarm+0x28>)
 8008262:	f001 fbcb 	bl	80099fc <chSysHalt>

  st_lld_start_alarm(abstime);
 8008266:	88fb      	ldrh	r3, [r7, #6]
 8008268:	4618      	mov	r0, r3
 800826a:	f7ff ffa9 	bl	80081c0 <st_lld_start_alarm>
}
 800826e:	3708      	adds	r7, #8
 8008270:	46bd      	mov	sp, r7
 8008272:	bd80      	pop	{r7, pc}
 8008274:	0800d048 	.word	0x0800d048

08008278 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8008278:	b580      	push	{r7, lr}
 800827a:	af00      	add	r7, sp, #0

  st_lld_stop_alarm();
 800827c:	f7ff ffb6 	bl	80081ec <st_lld_stop_alarm>
}
 8008280:	bd80      	pop	{r7, pc}
 8008282:	bf00      	nop

08008284 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8008284:	b580      	push	{r7, lr}
 8008286:	b082      	sub	sp, #8
 8008288:	af00      	add	r7, sp, #0
 800828a:	4603      	mov	r3, r0
 800828c:	80fb      	strh	r3, [r7, #6]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 800828e:	f7ff ffc5 	bl	800821c <st_lld_is_alarm_active>
 8008292:	4603      	mov	r3, r0
 8008294:	f083 0301 	eor.w	r3, r3, #1
 8008298:	b2db      	uxtb	r3, r3
 800829a:	2b00      	cmp	r3, #0
 800829c:	d002      	beq.n	80082a4 <stSetAlarm+0x20>
 800829e:	4805      	ldr	r0, [pc, #20]	; (80082b4 <stSetAlarm+0x30>)
 80082a0:	f001 fbac 	bl	80099fc <chSysHalt>

  st_lld_set_alarm(abstime);
 80082a4:	88fb      	ldrh	r3, [r7, #6]
 80082a6:	4618      	mov	r0, r3
 80082a8:	f7ff ffaa 	bl	8008200 <st_lld_set_alarm>
}
 80082ac:	3708      	adds	r7, #8
 80082ae:	46bd      	mov	sp, r7
 80082b0:	bd80      	pop	{r7, pc}
 80082b2:	bf00      	nop
 80082b4:	0800d058 	.word	0x0800d058

080082b8 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 80082b8:	b480      	push	{r7}
 80082ba:	b083      	sub	sp, #12
 80082bc:	af00      	add	r7, sp, #0
 80082be:	6078      	str	r0, [r7, #4]
 80082c0:	6039      	str	r1, [r7, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80082c2:	4a13      	ldr	r2, [pc, #76]	; (8008310 <nvicEnableVector+0x58>)
 80082c4:	683b      	ldr	r3, [r7, #0]
 80082c6:	b2db      	uxtb	r3, r3
 80082c8:	011b      	lsls	r3, r3, #4
 80082ca:	b2d9      	uxtb	r1, r3
 80082cc:	687b      	ldr	r3, [r7, #4]
 80082ce:	4413      	add	r3, r2
 80082d0:	f503 7340 	add.w	r3, r3, #768	; 0x300
 80082d4:	460a      	mov	r2, r1
 80082d6:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80082d8:	490d      	ldr	r1, [pc, #52]	; (8008310 <nvicEnableVector+0x58>)
 80082da:	687b      	ldr	r3, [r7, #4]
 80082dc:	095b      	lsrs	r3, r3, #5
 80082de:	687a      	ldr	r2, [r7, #4]
 80082e0:	f002 021f 	and.w	r2, r2, #31
 80082e4:	2001      	movs	r0, #1
 80082e6:	fa00 f202 	lsl.w	r2, r0, r2
 80082ea:	3360      	adds	r3, #96	; 0x60
 80082ec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80082f0:	4907      	ldr	r1, [pc, #28]	; (8008310 <nvicEnableVector+0x58>)
 80082f2:	687b      	ldr	r3, [r7, #4]
 80082f4:	095b      	lsrs	r3, r3, #5
 80082f6:	687a      	ldr	r2, [r7, #4]
 80082f8:	f002 021f 	and.w	r2, r2, #31
 80082fc:	2001      	movs	r0, #1
 80082fe:	fa00 f202 	lsl.w	r2, r0, r2
 8008302:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8008306:	370c      	adds	r7, #12
 8008308:	46bd      	mov	sp, r7
 800830a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800830e:	4770      	bx	lr
 8008310:	e000e100 	.word	0xe000e100

08008314 <nvicDisableVector>:
/**
 * @brief   Disables an interrupt handler.
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {
 8008314:	b480      	push	{r7}
 8008316:	b083      	sub	sp, #12
 8008318:	af00      	add	r7, sp, #0
 800831a:	6078      	str	r0, [r7, #4]

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 800831c:	490b      	ldr	r1, [pc, #44]	; (800834c <nvicDisableVector+0x38>)
 800831e:	687b      	ldr	r3, [r7, #4]
 8008320:	095b      	lsrs	r3, r3, #5
 8008322:	687a      	ldr	r2, [r7, #4]
 8008324:	f002 021f 	and.w	r2, r2, #31
 8008328:	2001      	movs	r0, #1
 800832a:	fa00 f202 	lsl.w	r2, r0, r2
 800832e:	3320      	adds	r3, #32
 8008330:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8008334:	4a05      	ldr	r2, [pc, #20]	; (800834c <nvicDisableVector+0x38>)
 8008336:	687b      	ldr	r3, [r7, #4]
 8008338:	4413      	add	r3, r2
 800833a:	f503 7340 	add.w	r3, r3, #768	; 0x300
 800833e:	2200      	movs	r2, #0
 8008340:	701a      	strb	r2, [r3, #0]
#endif
}
 8008342:	370c      	adds	r7, #12
 8008344:	46bd      	mov	sp, r7
 8008346:	f85d 7b04 	ldr.w	r7, [sp], #4
 800834a:	4770      	bx	lr
 800834c:	e000e100 	.word	0xe000e100

08008350 <hal_lld_backup_domain_init>:
/**
 * @brief   Initializes the backup domain.
 * @note    WARNING! Changing clock source impossible without resetting
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {
 8008350:	b480      	push	{r7}
 8008352:	af00      	add	r7, sp, #0

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8008354:	4a04      	ldr	r2, [pc, #16]	; (8008368 <hal_lld_backup_domain_init+0x18>)
 8008356:	4b04      	ldr	r3, [pc, #16]	; (8008368 <hal_lld_backup_domain_init+0x18>)
 8008358:	681b      	ldr	r3, [r3, #0]
 800835a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800835e:	6013      	str	r3, [r2, #0]
    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
  }
#endif /* STM32_RTCSEL != STM32_RTCSEL_NOCLOCK */
#endif /* HAL_USE_RTC */
}
 8008360:	46bd      	mov	sp, r7
 8008362:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008366:	4770      	bx	lr
 8008368:	40007000 	.word	0x40007000

0800836c <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 800836c:	b580      	push	{r7, lr}
 800836e:	af00      	add	r7, sp, #0

  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
 8008370:	4b10      	ldr	r3, [pc, #64]	; (80083b4 <hal_lld_init+0x48>)
 8008372:	691b      	ldr	r3, [r3, #16]
 8008374:	4b0f      	ldr	r3, [pc, #60]	; (80083b4 <hal_lld_init+0x48>)
 8008376:	f04f 32ff 	mov.w	r2, #4294967295
 800837a:	611a      	str	r2, [r3, #16]
 800837c:	4b0d      	ldr	r3, [pc, #52]	; (80083b4 <hal_lld_init+0x48>)
 800837e:	2200      	movs	r2, #0
 8008380:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 8008382:	4b0c      	ldr	r3, [pc, #48]	; (80083b4 <hal_lld_init+0x48>)
 8008384:	68db      	ldr	r3, [r3, #12]
 8008386:	4b0b      	ldr	r3, [pc, #44]	; (80083b4 <hal_lld_init+0x48>)
 8008388:	f04f 32ff 	mov.w	r2, #4294967295
 800838c:	60da      	str	r2, [r3, #12]
 800838e:	4b09      	ldr	r3, [pc, #36]	; (80083b4 <hal_lld_init+0x48>)
 8008390:	2200      	movs	r2, #0
 8008392:	60da      	str	r2, [r3, #12]

  /* PWR and BD clocks enabled.*/
  /*** these were false in framework ***/
  rccEnablePWRInterface(TRUE);
 8008394:	4a07      	ldr	r2, [pc, #28]	; (80083b4 <hal_lld_init+0x48>)
 8008396:	4b07      	ldr	r3, [pc, #28]	; (80083b4 <hal_lld_init+0x48>)
 8008398:	69db      	ldr	r3, [r3, #28]
 800839a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800839e:	61d3      	str	r3, [r2, #28]
  rccEnableBKPInterface(TRUE);
 80083a0:	4a04      	ldr	r2, [pc, #16]	; (80083b4 <hal_lld_init+0x48>)
 80083a2:	4b04      	ldr	r3, [pc, #16]	; (80083b4 <hal_lld_init+0x48>)
 80083a4:	69db      	ldr	r3, [r3, #28]
 80083a6:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 80083aa:	61d3      	str	r3, [r2, #28]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 80083ac:	f7ff ffd0 	bl	8008350 <hal_lld_backup_domain_init>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 80083b0:	bd80      	pop	{r7, pc}
 80083b2:	bf00      	nop
 80083b4:	40021000 	.word	0x40021000

080083b8 <stm32_clock_init>:
    defined(STM32F10X_HD) || defined(STM32F10X_XL) ||                       \
    defined(__DOXYGEN__)
/*
 * Clocks initialization for all sub-families except CL.
 */
void stm32_clock_init(void) {
 80083b8:	b480      	push	{r7}
 80083ba:	af00      	add	r7, sp, #0

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80083bc:	4a27      	ldr	r2, [pc, #156]	; (800845c <stm32_clock_init+0xa4>)
 80083be:	4b27      	ldr	r3, [pc, #156]	; (800845c <stm32_clock_init+0xa4>)
 80083c0:	681b      	ldr	r3, [r3, #0]
 80083c2:	f043 0301 	orr.w	r3, r3, #1
 80083c6:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80083c8:	4b24      	ldr	r3, [pc, #144]	; (800845c <stm32_clock_init+0xa4>)
 80083ca:	681b      	ldr	r3, [r3, #0]
 80083cc:	f003 0302 	and.w	r3, r3, #2
 80083d0:	2b00      	cmp	r3, #0
 80083d2:	d0f9      	beq.n	80083c8 <stm32_clock_init+0x10>
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80083d4:	4a21      	ldr	r2, [pc, #132]	; (800845c <stm32_clock_init+0xa4>)
 80083d6:	4b21      	ldr	r3, [pc, #132]	; (800845c <stm32_clock_init+0xa4>)
 80083d8:	681b      	ldr	r3, [r3, #0]
 80083da:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 80083de:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80083e0:	4b1e      	ldr	r3, [pc, #120]	; (800845c <stm32_clock_init+0xa4>)
 80083e2:	2200      	movs	r2, #0
 80083e4:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80083e6:	4b1d      	ldr	r3, [pc, #116]	; (800845c <stm32_clock_init+0xa4>)
 80083e8:	685b      	ldr	r3, [r3, #4]
 80083ea:	f003 030c 	and.w	r3, r3, #12
 80083ee:	2b00      	cmp	r3, #0
 80083f0:	d1f9      	bne.n	80083e6 <stm32_clock_init+0x2e>
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
 80083f2:	4a1a      	ldr	r2, [pc, #104]	; (800845c <stm32_clock_init+0xa4>)
 80083f4:	4b19      	ldr	r3, [pc, #100]	; (800845c <stm32_clock_init+0xa4>)
 80083f6:	681b      	ldr	r3, [r3, #0]
 80083f8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80083fc:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 80083fe:	4b17      	ldr	r3, [pc, #92]	; (800845c <stm32_clock_init+0xa4>)
 8008400:	681b      	ldr	r3, [r3, #0]
 8008402:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8008406:	2b00      	cmp	r3, #0
 8008408:	d0f9      	beq.n	80083fe <stm32_clock_init+0x46>
    ;                                       /* Waits until LSI is stable.   */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
 800840a:	4a14      	ldr	r2, [pc, #80]	; (800845c <stm32_clock_init+0xa4>)
 800840c:	4b13      	ldr	r3, [pc, #76]	; (800845c <stm32_clock_init+0xa4>)
 800840e:	685b      	ldr	r3, [r3, #4]
 8008410:	f443 13e8 	orr.w	r3, r3, #1900544	; 0x1d0000
 8008414:	6053      	str	r3, [r2, #4]
  RCC->CR   |= RCC_CR_PLLON;
 8008416:	4a11      	ldr	r2, [pc, #68]	; (800845c <stm32_clock_init+0xa4>)
 8008418:	4b10      	ldr	r3, [pc, #64]	; (800845c <stm32_clock_init+0xa4>)
 800841a:	681b      	ldr	r3, [r3, #0]
 800841c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8008420:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8008422:	4b0e      	ldr	r3, [pc, #56]	; (800845c <stm32_clock_init+0xa4>)
 8008424:	681b      	ldr	r3, [r3, #0]
 8008426:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800842a:	2b00      	cmp	r3, #0
 800842c:	d0f9      	beq.n	8008422 <stm32_clock_init+0x6a>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Clock settings.*/
#if STM32_HAS_USB
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
 800842e:	4b0b      	ldr	r3, [pc, #44]	; (800845c <stm32_clock_init+0xa4>)
 8008430:	4a0b      	ldr	r2, [pc, #44]	; (8008460 <stm32_clock_init+0xa8>)
 8008432:	605a      	str	r2, [r3, #4]
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8008434:	4b0b      	ldr	r3, [pc, #44]	; (8008464 <stm32_clock_init+0xac>)
 8008436:	2212      	movs	r2, #18
 8008438:	601a      	str	r2, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 800843a:	4a08      	ldr	r2, [pc, #32]	; (800845c <stm32_clock_init+0xa4>)
 800843c:	4b07      	ldr	r3, [pc, #28]	; (800845c <stm32_clock_init+0xa4>)
 800843e:	685b      	ldr	r3, [r3, #4]
 8008440:	f043 0302 	orr.w	r3, r3, #2
 8008444:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8008446:	4b05      	ldr	r3, [pc, #20]	; (800845c <stm32_clock_init+0xa4>)
 8008448:	685b      	ldr	r3, [r3, #4]
 800844a:	f003 030c 	and.w	r3, r3, #12
 800844e:	2b08      	cmp	r3, #8
 8008450:	d1f9      	bne.n	8008446 <stm32_clock_init+0x8e>

#if !STM32_HSI_ENABLED
  RCC->CR &= ~RCC_CR_HSION;
#endif
#endif /* !STM32_NO_INIT */
}
 8008452:	46bd      	mov	sp, r7
 8008454:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008458:	4770      	bx	lr
 800845a:	bf00      	nop
 800845c:	40021000 	.word	0x40021000
 8008460:	001d6400 	.word	0x001d6400
 8008464:	40022000 	.word	0x40022000

08008468 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init() {
 8008468:	b480      	push	{r7}
 800846a:	af00      	add	r7, sp, #0
#endif

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, true);
 800846c:	4a19      	ldr	r2, [pc, #100]	; (80084d4 <_pal_lld_init+0x6c>)
 800846e:	4b19      	ldr	r3, [pc, #100]	; (80084d4 <_pal_lld_init+0x6c>)
 8008470:	699b      	ldr	r3, [r3, #24]
 8008472:	f043 037d 	orr.w	r3, r3, #125	; 0x7d
 8008476:	6193      	str	r3, [r2, #24]

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = VAL_GPIOAODR;
 8008478:	4b17      	ldr	r3, [pc, #92]	; (80084d8 <_pal_lld_init+0x70>)
 800847a:	f04f 32ff 	mov.w	r2, #4294967295
 800847e:	60da      	str	r2, [r3, #12]
  GPIOA->CRH = VAL_GPIOACRH;
 8008480:	4b15      	ldr	r3, [pc, #84]	; (80084d8 <_pal_lld_init+0x70>)
 8008482:	4a16      	ldr	r2, [pc, #88]	; (80084dc <_pal_lld_init+0x74>)
 8008484:	605a      	str	r2, [r3, #4]
  GPIOA->CRL = VAL_GPIOACRL;
 8008486:	4b14      	ldr	r3, [pc, #80]	; (80084d8 <_pal_lld_init+0x70>)
 8008488:	4a15      	ldr	r2, [pc, #84]	; (80084e0 <_pal_lld_init+0x78>)
 800848a:	601a      	str	r2, [r3, #0]
  GPIOB->ODR = VAL_GPIOBODR;
 800848c:	4b15      	ldr	r3, [pc, #84]	; (80084e4 <_pal_lld_init+0x7c>)
 800848e:	f04f 32ff 	mov.w	r2, #4294967295
 8008492:	60da      	str	r2, [r3, #12]
  GPIOB->CRH = VAL_GPIOBCRH;
 8008494:	4b13      	ldr	r3, [pc, #76]	; (80084e4 <_pal_lld_init+0x7c>)
 8008496:	4a14      	ldr	r2, [pc, #80]	; (80084e8 <_pal_lld_init+0x80>)
 8008498:	605a      	str	r2, [r3, #4]
  GPIOB->CRL = VAL_GPIOBCRL;
 800849a:	4b12      	ldr	r3, [pc, #72]	; (80084e4 <_pal_lld_init+0x7c>)
 800849c:	f04f 3288 	mov.w	r2, #2290649224	; 0x88888888
 80084a0:	601a      	str	r2, [r3, #0]
  GPIOC->ODR = VAL_GPIOCODR;
 80084a2:	4b12      	ldr	r3, [pc, #72]	; (80084ec <_pal_lld_init+0x84>)
 80084a4:	f04f 32ff 	mov.w	r2, #4294967295
 80084a8:	60da      	str	r2, [r3, #12]
  GPIOC->CRH = VAL_GPIOCCRH;
 80084aa:	4b10      	ldr	r3, [pc, #64]	; (80084ec <_pal_lld_init+0x84>)
 80084ac:	4a10      	ldr	r2, [pc, #64]	; (80084f0 <_pal_lld_init+0x88>)
 80084ae:	605a      	str	r2, [r3, #4]
  GPIOC->CRL = VAL_GPIOCCRL;
 80084b0:	4b0e      	ldr	r3, [pc, #56]	; (80084ec <_pal_lld_init+0x84>)
 80084b2:	4a10      	ldr	r2, [pc, #64]	; (80084f4 <_pal_lld_init+0x8c>)
 80084b4:	601a      	str	r2, [r3, #0]
  GPIOD->ODR = VAL_GPIODODR;
 80084b6:	4b10      	ldr	r3, [pc, #64]	; (80084f8 <_pal_lld_init+0x90>)
 80084b8:	f04f 32ff 	mov.w	r2, #4294967295
 80084bc:	60da      	str	r2, [r3, #12]
  GPIOD->CRH = VAL_GPIODCRH;
 80084be:	4b0e      	ldr	r3, [pc, #56]	; (80084f8 <_pal_lld_init+0x90>)
 80084c0:	f04f 3288 	mov.w	r2, #2290649224	; 0x88888888
 80084c4:	605a      	str	r2, [r3, #4]
  GPIOD->CRL = VAL_GPIODCRL;
 80084c6:	4b0c      	ldr	r3, [pc, #48]	; (80084f8 <_pal_lld_init+0x90>)
 80084c8:	4a0c      	ldr	r2, [pc, #48]	; (80084fc <_pal_lld_init+0x94>)
 80084ca:	601a      	str	r2, [r3, #0]
}
 80084cc:	46bd      	mov	sp, r7
 80084ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80084d2:	4770      	bx	lr
 80084d4:	40021000 	.word	0x40021000
 80084d8:	40010800 	.word	0x40010800
 80084dc:	888b4888 	.word	0x888b4888
 80084e0:	88884b84 	.word	0x88884b84
 80084e4:	40010c00 	.word	0x40010c00
 80084e8:	b4b88888 	.word	0xb4b88888
 80084ec:	40011000 	.word	0x40011000
 80084f0:	88833388 	.word	0x88833388
 80084f4:	44848888 	.word	0x44848888
 80084f8:	40011400 	.word	0x40011400
 80084fc:	88888844 	.word	0x88888844

08008500 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8008500:	b480      	push	{r7}
 8008502:	b08b      	sub	sp, #44	; 0x2c
 8008504:	af00      	add	r7, sp, #0
 8008506:	60f8      	str	r0, [r7, #12]
 8008508:	60b9      	str	r1, [r7, #8]
 800850a:	607a      	str	r2, [r7, #4]
    0xF,        /* PAL_MODE_STM32_ALTERNATE_OPENDRAIN, 50MHz.*/
  };
  uint32_t mh, ml, crh, crl, cfg;
  unsigned i;

  if (mode == PAL_MODE_INPUT_PULLUP)
 800850c:	687b      	ldr	r3, [r7, #4]
 800850e:	2b03      	cmp	r3, #3
 8008510:	d103      	bne.n	800851a <_pal_lld_setgroupmode+0x1a>
    port->BSRR = mask;
 8008512:	68fb      	ldr	r3, [r7, #12]
 8008514:	68ba      	ldr	r2, [r7, #8]
 8008516:	611a      	str	r2, [r3, #16]
 8008518:	e005      	b.n	8008526 <_pal_lld_setgroupmode+0x26>
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
 800851a:	687b      	ldr	r3, [r7, #4]
 800851c:	2b04      	cmp	r3, #4
 800851e:	d102      	bne.n	8008526 <_pal_lld_setgroupmode+0x26>
    port->BRR = mask;
 8008520:	68fb      	ldr	r3, [r7, #12]
 8008522:	68ba      	ldr	r2, [r7, #8]
 8008524:	615a      	str	r2, [r3, #20]
  cfg = cfgtab[mode];
 8008526:	4a2b      	ldr	r2, [pc, #172]	; (80085d4 <_pal_lld_setgroupmode+0xd4>)
 8008528:	687b      	ldr	r3, [r7, #4]
 800852a:	4413      	add	r3, r2
 800852c:	781b      	ldrb	r3, [r3, #0]
 800852e:	613b      	str	r3, [r7, #16]
  mh = ml = crh = crl = 0;
 8008530:	2300      	movs	r3, #0
 8008532:	61bb      	str	r3, [r7, #24]
 8008534:	69bb      	ldr	r3, [r7, #24]
 8008536:	61fb      	str	r3, [r7, #28]
 8008538:	69fb      	ldr	r3, [r7, #28]
 800853a:	623b      	str	r3, [r7, #32]
 800853c:	6a3b      	ldr	r3, [r7, #32]
 800853e:	627b      	str	r3, [r7, #36]	; 0x24
  for (i = 0; i < 8; i++) {
 8008540:	2300      	movs	r3, #0
 8008542:	617b      	str	r3, [r7, #20]
 8008544:	e02d      	b.n	80085a2 <_pal_lld_setgroupmode+0xa2>
    ml <<= 4;
 8008546:	6a3b      	ldr	r3, [r7, #32]
 8008548:	011b      	lsls	r3, r3, #4
 800854a:	623b      	str	r3, [r7, #32]
    mh <<= 4;
 800854c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800854e:	011b      	lsls	r3, r3, #4
 8008550:	627b      	str	r3, [r7, #36]	; 0x24
    crl <<= 4;
 8008552:	69bb      	ldr	r3, [r7, #24]
 8008554:	011b      	lsls	r3, r3, #4
 8008556:	61bb      	str	r3, [r7, #24]
    crh <<= 4;
 8008558:	69fb      	ldr	r3, [r7, #28]
 800855a:	011b      	lsls	r3, r3, #4
 800855c:	61fb      	str	r3, [r7, #28]
    if ((mask & 0x0080) == 0)
 800855e:	68bb      	ldr	r3, [r7, #8]
 8008560:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8008564:	2b00      	cmp	r3, #0
 8008566:	d104      	bne.n	8008572 <_pal_lld_setgroupmode+0x72>
      ml |= 0xf;
 8008568:	6a3b      	ldr	r3, [r7, #32]
 800856a:	f043 030f 	orr.w	r3, r3, #15
 800856e:	623b      	str	r3, [r7, #32]
 8008570:	e003      	b.n	800857a <_pal_lld_setgroupmode+0x7a>
    else
      crl |= cfg;
 8008572:	69ba      	ldr	r2, [r7, #24]
 8008574:	693b      	ldr	r3, [r7, #16]
 8008576:	4313      	orrs	r3, r2
 8008578:	61bb      	str	r3, [r7, #24]
    if ((mask & 0x8000) == 0)
 800857a:	68bb      	ldr	r3, [r7, #8]
 800857c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8008580:	2b00      	cmp	r3, #0
 8008582:	d104      	bne.n	800858e <_pal_lld_setgroupmode+0x8e>
      mh |= 0xf;
 8008584:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008586:	f043 030f 	orr.w	r3, r3, #15
 800858a:	627b      	str	r3, [r7, #36]	; 0x24
 800858c:	e003      	b.n	8008596 <_pal_lld_setgroupmode+0x96>
    else
      crh |= cfg;
 800858e:	69fa      	ldr	r2, [r7, #28]
 8008590:	693b      	ldr	r3, [r7, #16]
 8008592:	4313      	orrs	r3, r2
 8008594:	61fb      	str	r3, [r7, #28]
    mask <<= 1;
 8008596:	68bb      	ldr	r3, [r7, #8]
 8008598:	005b      	lsls	r3, r3, #1
 800859a:	60bb      	str	r3, [r7, #8]
    port->BSRR = mask;
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
    port->BRR = mask;
  cfg = cfgtab[mode];
  mh = ml = crh = crl = 0;
  for (i = 0; i < 8; i++) {
 800859c:	697b      	ldr	r3, [r7, #20]
 800859e:	3301      	adds	r3, #1
 80085a0:	617b      	str	r3, [r7, #20]
 80085a2:	697b      	ldr	r3, [r7, #20]
 80085a4:	2b07      	cmp	r3, #7
 80085a6:	d9ce      	bls.n	8008546 <_pal_lld_setgroupmode+0x46>
      mh |= 0xf;
    else
      crh |= cfg;
    mask <<= 1;
  }
  port->CRH = (port->CRH & mh) | crh;
 80085a8:	68fb      	ldr	r3, [r7, #12]
 80085aa:	685a      	ldr	r2, [r3, #4]
 80085ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80085ae:	401a      	ands	r2, r3
 80085b0:	69fb      	ldr	r3, [r7, #28]
 80085b2:	431a      	orrs	r2, r3
 80085b4:	68fb      	ldr	r3, [r7, #12]
 80085b6:	605a      	str	r2, [r3, #4]
  port->CRL = (port->CRL & ml) | crl;
 80085b8:	68fb      	ldr	r3, [r7, #12]
 80085ba:	681a      	ldr	r2, [r3, #0]
 80085bc:	6a3b      	ldr	r3, [r7, #32]
 80085be:	401a      	ands	r2, r3
 80085c0:	69bb      	ldr	r3, [r7, #24]
 80085c2:	431a      	orrs	r2, r3
 80085c4:	68fb      	ldr	r3, [r7, #12]
 80085c6:	601a      	str	r2, [r3, #0]
}
 80085c8:	372c      	adds	r7, #44	; 0x2c
 80085ca:	46bd      	mov	sp, r7
 80085cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80085d0:	4770      	bx	lr
 80085d2:	bf00      	nop
 80085d4:	0800d064 	.word	0x0800d064

080085d8 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80085d8:	b480      	push	{r7}
 80085da:	b083      	sub	sp, #12
 80085dc:	af00      	add	r7, sp, #0
 80085de:	2320      	movs	r3, #32
 80085e0:	607b      	str	r3, [r7, #4]
 80085e2:	687b      	ldr	r3, [r7, #4]
 80085e4:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80085e8:	370c      	adds	r7, #12
 80085ea:	46bd      	mov	sp, r7
 80085ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80085f0:	4770      	bx	lr
 80085f2:	bf00      	nop

080085f4 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80085f4:	b480      	push	{r7}
 80085f6:	b083      	sub	sp, #12
 80085f8:	af00      	add	r7, sp, #0
 80085fa:	2300      	movs	r3, #0
 80085fc:	607b      	str	r3, [r7, #4]
 80085fe:	687b      	ldr	r3, [r7, #4]
 8008600:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008604:	370c      	adds	r7, #12
 8008606:	46bd      	mov	sp, r7
 8008608:	f85d 7b04 	ldr.w	r7, [sp], #4
 800860c:	4770      	bx	lr
 800860e:	bf00      	nop

08008610 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8008610:	b580      	push	{r7, lr}
 8008612:	af00      	add	r7, sp, #0

  port_lock();
 8008614:	f7ff ffe0 	bl	80085d8 <port_lock>
}
 8008618:	bd80      	pop	{r7, pc}
 800861a:	bf00      	nop

0800861c <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800861c:	b580      	push	{r7, lr}
 800861e:	af00      	add	r7, sp, #0

  port_unlock();
 8008620:	f7ff ffe8 	bl	80085f4 <port_unlock>
}
 8008624:	bd80      	pop	{r7, pc}
 8008626:	bf00      	nop

08008628 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8008628:	b580      	push	{r7, lr}
 800862a:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 800862c:	f7ff fff0 	bl	8008610 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8008630:	f001 fa5e 	bl	8009af0 <_dbg_check_lock_from_isr>
}
 8008634:	bd80      	pop	{r7, pc}
 8008636:	bf00      	nop

08008638 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8008638:	b580      	push	{r7, lr}
 800863a:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
 800863c:	f001 fa6e 	bl	8009b1c <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8008640:	f7ff ffec 	bl	800861c <port_unlock_from_isr>
}
 8008644:	bd80      	pop	{r7, pc}
 8008646:	bf00      	nop

08008648 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8008648:	b580      	push	{r7, lr}
 800864a:	af00      	add	r7, sp, #0

  chSysLockFromISR();
 800864c:	f7ff ffec 	bl	8008628 <chSysLockFromISR>
}
 8008650:	bd80      	pop	{r7, pc}
 8008652:	bf00      	nop

08008654 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8008654:	b580      	push	{r7, lr}
 8008656:	af00      	add	r7, sp, #0

  chSysUnlockFromISR();
 8008658:	f7ff ffee 	bl	8008638 <chSysUnlockFromISR>
}
 800865c:	bd80      	pop	{r7, pc}
 800865e:	bf00      	nop

08008660 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8008660:	b580      	push	{r7, lr}
 8008662:	af00      	add	r7, sp, #0

  chSysTimerHandlerI();
 8008664:	f001 f9d6 	bl	8009a14 <chSysTimerHandlerI>
}
 8008668:	bd80      	pop	{r7, pc}
 800866a:	bf00      	nop

0800866c <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 800866c:	b580      	push	{r7, lr}
 800866e:	af00      	add	r7, sp, #0

  OSAL_IRQ_PROLOGUE();
 8008670:	f001 fa6a 	bl	8009b48 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8008674:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008678:	691b      	ldr	r3, [r3, #16]
 800867a:	f003 0302 	and.w	r3, r3, #2
 800867e:	2b00      	cmp	r3, #0
 8008680:	d009      	beq.n	8008696 <VectorB0+0x2a>
    STM32_ST_TIM->SR = 0U;
 8008682:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008686:	2200      	movs	r2, #0
 8008688:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 800868a:	f7ff ffdd 	bl	8008648 <osalSysLockFromISR>
    osalOsTimerHandlerI();
 800868e:	f7ff ffe7 	bl	8008660 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 8008692:	f7ff ffdf 	bl	8008654 <osalSysUnlockFromISR>
  }

  OSAL_IRQ_EPILOGUE();
 8008696:	f001 fa73 	bl	8009b80 <_dbg_check_leave_isr>
 800869a:	f000 fb7d 	bl	8008d98 <_port_irq_epilogue>
}
 800869e:	bd80      	pop	{r7, pc}

080086a0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 80086a0:	b580      	push	{r7, lr}
 80086a2:	af00      	add	r7, sp, #0

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80086a4:	4a19      	ldr	r2, [pc, #100]	; (800870c <st_lld_init+0x6c>)
 80086a6:	4b19      	ldr	r3, [pc, #100]	; (800870c <st_lld_init+0x6c>)
 80086a8:	69db      	ldr	r3, [r3, #28]
 80086aa:	f043 0301 	orr.w	r3, r3, #1
 80086ae:	61d3      	str	r3, [r2, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80086b0:	4a17      	ldr	r2, [pc, #92]	; (8008710 <st_lld_init+0x70>)
 80086b2:	4b17      	ldr	r3, [pc, #92]	; (8008710 <st_lld_init+0x70>)
 80086b4:	685b      	ldr	r3, [r3, #4]
 80086b6:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80086ba:	6053      	str	r3, [r2, #4]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80086bc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80086c0:	f641 421f 	movw	r2, #7199	; 0x1c1f
 80086c4:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80086c6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80086ca:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80086ce:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 80086d0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80086d4:	2200      	movs	r2, #0
 80086d6:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 80086d8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80086dc:	2200      	movs	r2, #0
 80086de:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 80086e0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80086e4:	2200      	movs	r2, #0
 80086e6:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 80086e8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80086ec:	2200      	movs	r2, #0
 80086ee:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80086f0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80086f4:	2201      	movs	r2, #1
 80086f6:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80086f8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80086fc:	2201      	movs	r2, #1
 80086fe:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8008700:	201c      	movs	r0, #28
 8008702:	2108      	movs	r1, #8
 8008704:	f7ff fdd8 	bl	80082b8 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8008708:	bd80      	pop	{r7, pc}
 800870a:	bf00      	nop
 800870c:	40021000 	.word	0x40021000
 8008710:	e0042000 	.word	0xe0042000

08008714 <boardInit>:
#include <hal.h>

void boardInit(void) {
 8008714:	b480      	push	{r7}
 8008716:	af00      	add	r7, sp, #0
//    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
//    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
//    GPIO_Init(GPIO_CAN, &GPIO_InitStructure);

//    GPIO_PinRemapConfig(GPIO_Remapping_CAN , ENABLE);
}
 8008718:	46bd      	mov	sp, r7
 800871a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800871e:	4770      	bx	lr

08008720 <param_struct_valid>:
{
    return shared_find_marker(*((uint64_t*)SHARED_APP_DESCRIPTOR_SIGNATURE), buf, buf_len);
}

static bool param_struct_valid(const struct shared_app_parameters_s* parameters, bool ignore_crc64)
{
 8008720:	b5b0      	push	{r4, r5, r7, lr}
 8008722:	b082      	sub	sp, #8
 8008724:	af00      	add	r7, sp, #0
 8008726:	6078      	str	r0, [r7, #4]
 8008728:	460b      	mov	r3, r1
 800872a:	70fb      	strb	r3, [r7, #3]
    return parameters && (ignore_crc64 || crc64_we((uint8_t*)parameters, sizeof(struct shared_app_parameters_s)-sizeof(uint64_t), 0) == parameters->crc64);
 800872c:	687b      	ldr	r3, [r7, #4]
 800872e:	2b00      	cmp	r3, #0
 8008730:	d017      	beq.n	8008762 <param_struct_valid+0x42>
 8008732:	78fb      	ldrb	r3, [r7, #3]
 8008734:	2b00      	cmp	r3, #0
 8008736:	d112      	bne.n	800875e <param_struct_valid+0x3e>
 8008738:	6878      	ldr	r0, [r7, #4]
 800873a:	2107      	movs	r1, #7
 800873c:	f04f 0200 	mov.w	r2, #0
 8008740:	f04f 0300 	mov.w	r3, #0
 8008744:	f000 f868 	bl	8008818 <crc64_we>
 8008748:	4604      	mov	r4, r0
 800874a:	460d      	mov	r5, r1
 800874c:	6879      	ldr	r1, [r7, #4]
 800874e:	f8d1 2007 	ldr.w	r2, [r1, #7]
 8008752:	f8d1 300b 	ldr.w	r3, [r1, #11]
 8008756:	429d      	cmp	r5, r3
 8008758:	bf08      	it	eq
 800875a:	4294      	cmpeq	r4, r2
 800875c:	d101      	bne.n	8008762 <param_struct_valid+0x42>
 800875e:	2301      	movs	r3, #1
 8008760:	e000      	b.n	8008764 <param_struct_valid+0x44>
 8008762:	2300      	movs	r3, #0
 8008764:	f003 0301 	and.w	r3, r3, #1
 8008768:	b2db      	uxtb	r3, r3
}
 800876a:	4618      	mov	r0, r3
 800876c:	3708      	adds	r7, #8
 800876e:	46bd      	mov	sp, r7
 8008770:	bdb0      	pop	{r4, r5, r7, pc}
 8008772:	bf00      	nop

08008774 <shared_get_parameters>:

const struct shared_app_parameters_s* shared_get_parameters(const struct shared_app_descriptor_s* descriptor)
{
 8008774:	b580      	push	{r7, lr}
 8008776:	b084      	sub	sp, #16
 8008778:	af00      	add	r7, sp, #0
 800877a:	6078      	str	r0, [r7, #4]
    if (descriptor->parameters_fmt != SHARED_APP_PARAMETERS_FMT) {
 800877c:	687b      	ldr	r3, [r7, #4]
 800877e:	7e9b      	ldrb	r3, [r3, #26]
 8008780:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8008784:	b2db      	uxtb	r3, r3
 8008786:	2b01      	cmp	r3, #1
 8008788:	d001      	beq.n	800878e <shared_get_parameters+0x1a>
        return 0;
 800878a:	2300      	movs	r3, #0
 800878c:	e03e      	b.n	800880c <shared_get_parameters+0x98>
    }

    const struct shared_app_parameters_s* ret = 0;
 800878e:	2300      	movs	r3, #0
 8008790:	60fb      	str	r3, [r7, #12]

    for (uint8_t i=0; i<2; i++) {
 8008792:	2300      	movs	r3, #0
 8008794:	72fb      	strb	r3, [r7, #11]
 8008796:	e035      	b.n	8008804 <shared_get_parameters+0x90>
        if (param_struct_valid(descriptor->parameters[i], descriptor->parameters_ignore_crc64) &&
 8008798:	7afb      	ldrb	r3, [r7, #11]
 800879a:	687a      	ldr	r2, [r7, #4]
 800879c:	3306      	adds	r3, #6
 800879e:	009b      	lsls	r3, r3, #2
 80087a0:	4413      	add	r3, r2
 80087a2:	f8d3 2003 	ldr.w	r2, [r3, #3]
 80087a6:	687b      	ldr	r3, [r7, #4]
 80087a8:	7e9b      	ldrb	r3, [r3, #26]
 80087aa:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 80087ae:	b2db      	uxtb	r3, r3
 80087b0:	2b00      	cmp	r3, #0
 80087b2:	bf14      	ite	ne
 80087b4:	2301      	movne	r3, #1
 80087b6:	2300      	moveq	r3, #0
 80087b8:	b2db      	uxtb	r3, r3
 80087ba:	4610      	mov	r0, r2
 80087bc:	4619      	mov	r1, r3
 80087be:	f7ff ffaf 	bl	8008720 <param_struct_valid>
 80087c2:	4603      	mov	r3, r0
 80087c4:	2b00      	cmp	r3, #0
 80087c6:	d01a      	beq.n	80087fe <shared_get_parameters+0x8a>
 80087c8:	68fb      	ldr	r3, [r7, #12]
 80087ca:	2b00      	cmp	r3, #0
 80087cc:	d00f      	beq.n	80087ee <shared_get_parameters+0x7a>
            (!ret || (int8_t)(descriptor->parameters[i]->param_idx-ret->param_idx) > 0)) {
 80087ce:	7afb      	ldrb	r3, [r7, #11]
 80087d0:	687a      	ldr	r2, [r7, #4]
 80087d2:	3306      	adds	r3, #6
 80087d4:	009b      	lsls	r3, r3, #2
 80087d6:	4413      	add	r3, r2
 80087d8:	f8d3 3003 	ldr.w	r3, [r3, #3]
 80087dc:	781a      	ldrb	r2, [r3, #0]
 80087de:	68fb      	ldr	r3, [r7, #12]
 80087e0:	781b      	ldrb	r3, [r3, #0]
 80087e2:	1ad3      	subs	r3, r2, r3
 80087e4:	b2db      	uxtb	r3, r3
 80087e6:	b2db      	uxtb	r3, r3
 80087e8:	b25b      	sxtb	r3, r3
 80087ea:	2b00      	cmp	r3, #0
 80087ec:	dd07      	ble.n	80087fe <shared_get_parameters+0x8a>
            ret = descriptor->parameters[i];
 80087ee:	7afb      	ldrb	r3, [r7, #11]
 80087f0:	687a      	ldr	r2, [r7, #4]
 80087f2:	3306      	adds	r3, #6
 80087f4:	009b      	lsls	r3, r3, #2
 80087f6:	4413      	add	r3, r2
 80087f8:	f8d3 3003 	ldr.w	r3, [r3, #3]
 80087fc:	60fb      	str	r3, [r7, #12]
        return 0;
    }

    const struct shared_app_parameters_s* ret = 0;

    for (uint8_t i=0; i<2; i++) {
 80087fe:	7afb      	ldrb	r3, [r7, #11]
 8008800:	3301      	adds	r3, #1
 8008802:	72fb      	strb	r3, [r7, #11]
 8008804:	7afb      	ldrb	r3, [r7, #11]
 8008806:	2b01      	cmp	r3, #1
 8008808:	d9c6      	bls.n	8008798 <shared_get_parameters+0x24>
            (!ret || (int8_t)(descriptor->parameters[i]->param_idx-ret->param_idx) > 0)) {
            ret = descriptor->parameters[i];
        }
    }

    return ret;
 800880a:	68fb      	ldr	r3, [r7, #12]
}
 800880c:	4618      	mov	r0, r3
 800880e:	3710      	adds	r7, #16
 8008810:	46bd      	mov	sp, r7
 8008812:	bd80      	pop	{r7, pc}
 8008814:	0000      	movs	r0, r0
	...

08008818 <crc64_we>:
#include <common/crc64_we.h>

uint64_t crc64_we(const uint8_t *buf, uint32_t len, uint64_t crc)
{
 8008818:	b4b0      	push	{r4, r5, r7}
 800881a:	b087      	sub	sp, #28
 800881c:	af00      	add	r7, sp, #0
 800881e:	60f8      	str	r0, [r7, #12]
 8008820:	60b9      	str	r1, [r7, #8]
 8008822:	e9c7 2300 	strd	r2, r3, [r7]
    uint32_t i;
    uint8_t j;

    crc = ~crc;
 8008826:	e9d7 2300 	ldrd	r2, r3, [r7]
 800882a:	ea6f 0202 	mvn.w	r2, r2
 800882e:	ea6f 0303 	mvn.w	r3, r3
 8008832:	e9c7 2300 	strd	r2, r3, [r7]

    for (i = 0; i < len; i++) {
 8008836:	2300      	movs	r3, #0
 8008838:	617b      	str	r3, [r7, #20]
 800883a:	e036      	b.n	80088aa <crc64_we+0x92>
        crc ^= ((uint64_t)buf[i]) << 56;
 800883c:	68fa      	ldr	r2, [r7, #12]
 800883e:	697b      	ldr	r3, [r7, #20]
 8008840:	4413      	add	r3, r2
 8008842:	781b      	ldrb	r3, [r3, #0]
 8008844:	b2da      	uxtb	r2, r3
 8008846:	f04f 0300 	mov.w	r3, #0
 800884a:	0615      	lsls	r5, r2, #24
 800884c:	2400      	movs	r4, #0
 800884e:	e9d7 2300 	ldrd	r2, r3, [r7]
 8008852:	ea82 0204 	eor.w	r2, r2, r4
 8008856:	ea83 0305 	eor.w	r3, r3, r5
 800885a:	e9c7 2300 	strd	r2, r3, [r7]
        for (j = 0; j < 8; j++) {
 800885e:	2300      	movs	r3, #0
 8008860:	74fb      	strb	r3, [r7, #19]
 8008862:	e01c      	b.n	800889e <crc64_we+0x86>
            crc = (crc & (1ULL<<63)) ? (crc<<1)^0x42F0E1EBA9EA3693ULL : (crc<<1);
 8008864:	e9d7 2300 	ldrd	r2, r3, [r7]
 8008868:	2a00      	cmp	r2, #0
 800886a:	f173 0300 	sbcs.w	r3, r3, #0
 800886e:	da0c      	bge.n	800888a <crc64_we+0x72>
 8008870:	e9d7 2300 	ldrd	r2, r3, [r7]
 8008874:	1892      	adds	r2, r2, r2
 8008876:	eb43 0303 	adc.w	r3, r3, r3
 800887a:	a115      	add	r1, pc, #84	; (adr r1, 80088d0 <crc64_we+0xb8>)
 800887c:	e9d1 0100 	ldrd	r0, r1, [r1]
 8008880:	ea82 0200 	eor.w	r2, r2, r0
 8008884:	ea83 0301 	eor.w	r3, r3, r1
 8008888:	e004      	b.n	8008894 <crc64_we+0x7c>
 800888a:	e9d7 2300 	ldrd	r2, r3, [r7]
 800888e:	1892      	adds	r2, r2, r2
 8008890:	eb43 0303 	adc.w	r3, r3, r3
 8008894:	e9c7 2300 	strd	r2, r3, [r7]

    crc = ~crc;

    for (i = 0; i < len; i++) {
        crc ^= ((uint64_t)buf[i]) << 56;
        for (j = 0; j < 8; j++) {
 8008898:	7cfb      	ldrb	r3, [r7, #19]
 800889a:	3301      	adds	r3, #1
 800889c:	74fb      	strb	r3, [r7, #19]
 800889e:	7cfb      	ldrb	r3, [r7, #19]
 80088a0:	2b07      	cmp	r3, #7
 80088a2:	d9df      	bls.n	8008864 <crc64_we+0x4c>
    uint32_t i;
    uint8_t j;

    crc = ~crc;

    for (i = 0; i < len; i++) {
 80088a4:	697b      	ldr	r3, [r7, #20]
 80088a6:	3301      	adds	r3, #1
 80088a8:	617b      	str	r3, [r7, #20]
 80088aa:	697a      	ldr	r2, [r7, #20]
 80088ac:	68bb      	ldr	r3, [r7, #8]
 80088ae:	429a      	cmp	r2, r3
 80088b0:	d3c4      	bcc.n	800883c <crc64_we+0x24>
        for (j = 0; j < 8; j++) {
            crc = (crc & (1ULL<<63)) ? (crc<<1)^0x42F0E1EBA9EA3693ULL : (crc<<1);
        }
    }

    return ~crc;
 80088b2:	e9d7 2300 	ldrd	r2, r3, [r7]
 80088b6:	ea6f 0202 	mvn.w	r2, r2
 80088ba:	ea6f 0303 	mvn.w	r3, r3
}
 80088be:	4610      	mov	r0, r2
 80088c0:	4619      	mov	r1, r3
 80088c2:	371c      	adds	r7, #28
 80088c4:	46bd      	mov	sp, r7
 80088c6:	bcb0      	pop	{r4, r5, r7}
 80088c8:	4770      	bx	lr
 80088ca:	bf00      	nop
 80088cc:	f3af 8000 	nop.w
 80088d0:	a9ea3693 	.word	0xa9ea3693
 80088d4:	42f0e1eb 	.word	0x42f0e1eb

080088d8 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 80088d8:	b580      	push	{r7, lr}
 80088da:	b086      	sub	sp, #24
 80088dc:	af00      	add	r7, sp, #0
 80088de:	60f8      	str	r0, [r7, #12]
 80088e0:	60b9      	str	r1, [r7, #8]
 80088e2:	4613      	mov	r3, r2
 80088e4:	80fb      	strh	r3, [r7, #6]
  msg_t rdymsg;

  chSysLock();
 80088e6:	f000 ff79 	bl	80097dc <chSysLock.lto_priv.163>
  rdymsg = chMBFetchS(mbp, msgp, timeout);
 80088ea:	88fb      	ldrh	r3, [r7, #6]
 80088ec:	68f8      	ldr	r0, [r7, #12]
 80088ee:	68b9      	ldr	r1, [r7, #8]
 80088f0:	461a      	mov	r2, r3
 80088f2:	f000 f809 	bl	8008908 <chMBFetchS>
 80088f6:	6178      	str	r0, [r7, #20]
  chSysUnlock();
 80088f8:	f000 ff78 	bl	80097ec <chSysUnlock.lto_priv.158>

  return rdymsg;
 80088fc:	697b      	ldr	r3, [r7, #20]
}
 80088fe:	4618      	mov	r0, r3
 8008900:	3718      	adds	r7, #24
 8008902:	46bd      	mov	sp, r7
 8008904:	bd80      	pop	{r7, pc}
 8008906:	bf00      	nop

08008908 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8008908:	b580      	push	{r7, lr}
 800890a:	b086      	sub	sp, #24
 800890c:	af00      	add	r7, sp, #0
 800890e:	60f8      	str	r0, [r7, #12]
 8008910:	60b9      	str	r1, [r7, #8]
 8008912:	4613      	mov	r3, r2
 8008914:	80fb      	strh	r3, [r7, #6]
  msg_t rdymsg;

  chDbgCheckClassS();
 8008916:	f001 f961 	bl	8009bdc <chDbgCheckClassS>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 800891a:	68fb      	ldr	r3, [r7, #12]
 800891c:	2b00      	cmp	r3, #0
 800891e:	d002      	beq.n	8008926 <chMBFetchS+0x1e>
 8008920:	68bb      	ldr	r3, [r7, #8]
 8008922:	2b00      	cmp	r3, #0
 8008924:	d102      	bne.n	800892c <chMBFetchS+0x24>
 8008926:	4821      	ldr	r0, [pc, #132]	; (80089ac <chMBFetchS+0xa4>)
 8008928:	f001 f868 	bl	80099fc <chSysHalt>

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 800892c:	68fb      	ldr	r3, [r7, #12]
 800892e:	7d1b      	ldrb	r3, [r3, #20]
 8008930:	2b00      	cmp	r3, #0
 8008932:	d002      	beq.n	800893a <chMBFetchS+0x32>
      return MSG_RESET;
 8008934:	f06f 0301 	mvn.w	r3, #1
 8008938:	e033      	b.n	80089a2 <chMBFetchS+0x9a>
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
 800893a:	68f8      	ldr	r0, [r7, #12]
 800893c:	f000 ff8e 	bl	800985c <chMBGetUsedCountI.lto_priv.198>
 8008940:	4603      	mov	r3, r0
 8008942:	2b00      	cmp	r3, #0
 8008944:	dd20      	ble.n	8008988 <chMBFetchS+0x80>
      *msgp = *mbp->rdptr++;
 8008946:	68fb      	ldr	r3, [r7, #12]
 8008948:	68db      	ldr	r3, [r3, #12]
 800894a:	1d19      	adds	r1, r3, #4
 800894c:	68fa      	ldr	r2, [r7, #12]
 800894e:	60d1      	str	r1, [r2, #12]
 8008950:	681a      	ldr	r2, [r3, #0]
 8008952:	68bb      	ldr	r3, [r7, #8]
 8008954:	601a      	str	r2, [r3, #0]
      if (mbp->rdptr >= mbp->top) {
 8008956:	68fb      	ldr	r3, [r7, #12]
 8008958:	68da      	ldr	r2, [r3, #12]
 800895a:	68fb      	ldr	r3, [r7, #12]
 800895c:	685b      	ldr	r3, [r3, #4]
 800895e:	429a      	cmp	r2, r3
 8008960:	d303      	bcc.n	800896a <chMBFetchS+0x62>
        mbp->rdptr = mbp->buffer;
 8008962:	68fb      	ldr	r3, [r7, #12]
 8008964:	681a      	ldr	r2, [r3, #0]
 8008966:	68fb      	ldr	r3, [r7, #12]
 8008968:	60da      	str	r2, [r3, #12]
      }
      mbp->cnt--;
 800896a:	68fb      	ldr	r3, [r7, #12]
 800896c:	691b      	ldr	r3, [r3, #16]
 800896e:	1e5a      	subs	r2, r3, #1
 8008970:	68fb      	ldr	r3, [r7, #12]
 8008972:	611a      	str	r2, [r3, #16]

      /* If there is a writer waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 8008974:	68fb      	ldr	r3, [r7, #12]
 8008976:	3318      	adds	r3, #24
 8008978:	4618      	mov	r0, r3
 800897a:	2100      	movs	r1, #0
 800897c:	f000 fc34 	bl	80091e8 <chThdDequeueNextI>
      chSchRescheduleS();
 8008980:	f001 fd0a 	bl	800a398 <chSchRescheduleS>

      return MSG_OK;
 8008984:	2300      	movs	r3, #0
 8008986:	e00c      	b.n	80089a2 <chMBFetchS+0x9a>
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 8008988:	68fb      	ldr	r3, [r7, #12]
 800898a:	f103 0220 	add.w	r2, r3, #32
 800898e:	88fb      	ldrh	r3, [r7, #6]
 8008990:	4610      	mov	r0, r2
 8008992:	4619      	mov	r1, r3
 8008994:	f000 fc0a 	bl	80091ac <chThdEnqueueTimeoutS>
 8008998:	6178      	str	r0, [r7, #20]
  } while (rdymsg == MSG_OK);
 800899a:	697b      	ldr	r3, [r7, #20]
 800899c:	2b00      	cmp	r3, #0
 800899e:	d0c5      	beq.n	800892c <chMBFetchS+0x24>

  return rdymsg;
 80089a0:	697b      	ldr	r3, [r7, #20]
}
 80089a2:	4618      	mov	r0, r3
 80089a4:	3718      	adds	r7, #24
 80089a6:	46bd      	mov	sp, r7
 80089a8:	bd80      	pop	{r7, pc}
 80089aa:	bf00      	nop
 80089ac:	0800cfc4 	.word	0x0800cfc4

080089b0 <port_lock.lto_priv.179>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80089b0:	b480      	push	{r7}
 80089b2:	b083      	sub	sp, #12
 80089b4:	af00      	add	r7, sp, #0
 80089b6:	2320      	movs	r3, #32
 80089b8:	607b      	str	r3, [r7, #4]
 80089ba:	687b      	ldr	r3, [r7, #4]
 80089bc:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80089c0:	370c      	adds	r7, #12
 80089c2:	46bd      	mov	sp, r7
 80089c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80089c8:	4770      	bx	lr
 80089ca:	bf00      	nop

080089cc <port_unlock.lto_priv.174>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80089cc:	b480      	push	{r7}
 80089ce:	b083      	sub	sp, #12
 80089d0:	af00      	add	r7, sp, #0
 80089d2:	2300      	movs	r3, #0
 80089d4:	607b      	str	r3, [r7, #4]
 80089d6:	687b      	ldr	r3, [r7, #4]
 80089d8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80089dc:	370c      	adds	r7, #12
 80089de:	46bd      	mov	sp, r7
 80089e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80089e4:	4770      	bx	lr
 80089e6:	bf00      	nop

080089e8 <chSysLock.lto_priv.164>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80089e8:	b580      	push	{r7, lr}
 80089ea:	af00      	add	r7, sp, #0

  port_lock();
 80089ec:	f7ff ffe0 	bl	80089b0 <port_lock.lto_priv.179>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80089f0:	f001 f852 	bl	8009a98 <_dbg_check_lock>
}
 80089f4:	bd80      	pop	{r7, pc}
 80089f6:	bf00      	nop

080089f8 <chSysUnlock.lto_priv.159>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80089f8:	b580      	push	{r7, lr}
 80089fa:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 80089fc:	f001 f862 	bl	8009ac4 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008a00:	4b09      	ldr	r3, [pc, #36]	; (8008a28 <chSysUnlock.lto_priv.159+0x30>)
 8008a02:	681b      	ldr	r3, [r3, #0]
 8008a04:	4a08      	ldr	r2, [pc, #32]	; (8008a28 <chSysUnlock.lto_priv.159+0x30>)
 8008a06:	4293      	cmp	r3, r2
 8008a08:	d00a      	beq.n	8008a20 <chSysUnlock.lto_priv.159+0x28>
 8008a0a:	4b07      	ldr	r3, [pc, #28]	; (8008a28 <chSysUnlock.lto_priv.159+0x30>)
 8008a0c:	699b      	ldr	r3, [r3, #24]
 8008a0e:	689a      	ldr	r2, [r3, #8]
 8008a10:	4b05      	ldr	r3, [pc, #20]	; (8008a28 <chSysUnlock.lto_priv.159+0x30>)
 8008a12:	681b      	ldr	r3, [r3, #0]
 8008a14:	689b      	ldr	r3, [r3, #8]
 8008a16:	429a      	cmp	r2, r3
 8008a18:	d202      	bcs.n	8008a20 <chSysUnlock.lto_priv.159+0x28>
 8008a1a:	4804      	ldr	r0, [pc, #16]	; (8008a2c <chSysUnlock.lto_priv.159+0x34>)
 8008a1c:	f000 ffee 	bl	80099fc <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8008a20:	f7ff ffd4 	bl	80089cc <port_unlock.lto_priv.174>
}
 8008a24:	bd80      	pop	{r7, pc}
 8008a26:	bf00      	nop
 8008a28:	20001330 	.word	0x20001330
 8008a2c:	0800cff0 	.word	0x0800cff0

08008a30 <_core_init>:
/**
 * @brief   Low level memory manager initialization.
 *
 * @notapi
 */
void _core_init(void) {
 8008a30:	b480      	push	{r7}
 8008a32:	af00      	add	r7, sp, #0
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
 8008a34:	4b04      	ldr	r3, [pc, #16]	; (8008a48 <_core_init+0x18>)
 8008a36:	4a05      	ldr	r2, [pc, #20]	; (8008a4c <_core_init+0x1c>)
 8008a38:	601a      	str	r2, [r3, #0]
  ch_memcore.endmem  = __heap_end__;
 8008a3a:	4b03      	ldr	r3, [pc, #12]	; (8008a48 <_core_init+0x18>)
 8008a3c:	4a04      	ldr	r2, [pc, #16]	; (8008a50 <_core_init+0x20>)
 8008a3e:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.nextmem = &static_heap[0];
  ch_memcore.endmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 8008a40:	46bd      	mov	sp, r7
 8008a42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a46:	4770      	bx	lr
 8008a48:	20001394 	.word	0x20001394
 8008a4c:	200014b8 	.word	0x200014b8
 8008a50:	20003f00 	.word	0x20003f00

08008a54 <chCoreAllocAlignedWithOffsetI>:
 *
 * @iclass
 */
void *chCoreAllocAlignedWithOffsetI(size_t size,
                                    unsigned align,
                                    size_t offset) {
 8008a54:	b580      	push	{r7, lr}
 8008a56:	b086      	sub	sp, #24
 8008a58:	af00      	add	r7, sp, #0
 8008a5a:	60f8      	str	r0, [r7, #12]
 8008a5c:	60b9      	str	r1, [r7, #8]
 8008a5e:	607a      	str	r2, [r7, #4]
  uint8_t *p, *next;

  chDbgCheckClassI();
 8008a60:	f001 f8aa 	bl	8009bb8 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8008a64:	68bb      	ldr	r3, [r7, #8]
 8008a66:	2b00      	cmp	r3, #0
 8008a68:	d005      	beq.n	8008a76 <chCoreAllocAlignedWithOffsetI+0x22>
 8008a6a:	68bb      	ldr	r3, [r7, #8]
 8008a6c:	1e5a      	subs	r2, r3, #1
 8008a6e:	68bb      	ldr	r3, [r7, #8]
 8008a70:	4013      	ands	r3, r2
 8008a72:	2b00      	cmp	r3, #0
 8008a74:	d002      	beq.n	8008a7c <chCoreAllocAlignedWithOffsetI+0x28>
 8008a76:	4817      	ldr	r0, [pc, #92]	; (8008ad4 <chCoreAllocAlignedWithOffsetI+0x80>)
 8008a78:	f000 ffc0 	bl	80099fc <chSysHalt>

  size = MEM_ALIGN_NEXT(size, align);
 8008a7c:	68ba      	ldr	r2, [r7, #8]
 8008a7e:	68fb      	ldr	r3, [r7, #12]
 8008a80:	4413      	add	r3, r2
 8008a82:	1e5a      	subs	r2, r3, #1
 8008a84:	68bb      	ldr	r3, [r7, #8]
 8008a86:	425b      	negs	r3, r3
 8008a88:	4013      	ands	r3, r2
 8008a8a:	60fb      	str	r3, [r7, #12]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8008a8c:	4b12      	ldr	r3, [pc, #72]	; (8008ad8 <chCoreAllocAlignedWithOffsetI+0x84>)
 8008a8e:	681a      	ldr	r2, [r3, #0]
 8008a90:	687b      	ldr	r3, [r7, #4]
 8008a92:	4413      	add	r3, r2
 8008a94:	461a      	mov	r2, r3
 8008a96:	68bb      	ldr	r3, [r7, #8]
 8008a98:	4413      	add	r3, r2
 8008a9a:	1e5a      	subs	r2, r3, #1
 8008a9c:	68bb      	ldr	r3, [r7, #8]
 8008a9e:	425b      	negs	r3, r3
 8008aa0:	4013      	ands	r3, r2
 8008aa2:	617b      	str	r3, [r7, #20]
  next = p + size;
 8008aa4:	697a      	ldr	r2, [r7, #20]
 8008aa6:	68fb      	ldr	r3, [r7, #12]
 8008aa8:	4413      	add	r3, r2
 8008aaa:	613b      	str	r3, [r7, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8008aac:	4b0a      	ldr	r3, [pc, #40]	; (8008ad8 <chCoreAllocAlignedWithOffsetI+0x84>)
 8008aae:	685a      	ldr	r2, [r3, #4]
 8008ab0:	693b      	ldr	r3, [r7, #16]
 8008ab2:	429a      	cmp	r2, r3
 8008ab4:	d304      	bcc.n	8008ac0 <chCoreAllocAlignedWithOffsetI+0x6c>
 8008ab6:	4b08      	ldr	r3, [pc, #32]	; (8008ad8 <chCoreAllocAlignedWithOffsetI+0x84>)
 8008ab8:	681a      	ldr	r2, [r3, #0]
 8008aba:	693b      	ldr	r3, [r7, #16]
 8008abc:	429a      	cmp	r2, r3
 8008abe:	d901      	bls.n	8008ac4 <chCoreAllocAlignedWithOffsetI+0x70>
//    CH_CFG_CORE_ALLOCATOR_FAILURE_HOOK();
    return NULL;
 8008ac0:	2300      	movs	r3, #0
 8008ac2:	e003      	b.n	8008acc <chCoreAllocAlignedWithOffsetI+0x78>
  }

  ch_memcore.nextmem = next;
 8008ac4:	4a04      	ldr	r2, [pc, #16]	; (8008ad8 <chCoreAllocAlignedWithOffsetI+0x84>)
 8008ac6:	693b      	ldr	r3, [r7, #16]
 8008ac8:	6013      	str	r3, [r2, #0]

  return p;
 8008aca:	697b      	ldr	r3, [r7, #20]
}
 8008acc:	4618      	mov	r0, r3
 8008ace:	3718      	adds	r7, #24
 8008ad0:	46bd      	mov	sp, r7
 8008ad2:	bd80      	pop	{r7, pc}
 8008ad4:	0800cfd0 	.word	0x0800cfd0
 8008ad8:	20001394 	.word	0x20001394

08008adc <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 8008adc:	b580      	push	{r7, lr}
 8008ade:	b086      	sub	sp, #24
 8008ae0:	af00      	add	r7, sp, #0
 8008ae2:	60f8      	str	r0, [r7, #12]
 8008ae4:	60b9      	str	r1, [r7, #8]
 8008ae6:	607a      	str	r2, [r7, #4]
  void *p;

  chSysLock();
 8008ae8:	f7ff ff7e 	bl	80089e8 <chSysLock.lto_priv.164>
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
 8008aec:	68f8      	ldr	r0, [r7, #12]
 8008aee:	68b9      	ldr	r1, [r7, #8]
 8008af0:	687a      	ldr	r2, [r7, #4]
 8008af2:	f7ff ffaf 	bl	8008a54 <chCoreAllocAlignedWithOffsetI>
 8008af6:	6178      	str	r0, [r7, #20]
  chSysUnlock();
 8008af8:	f7ff ff7e 	bl	80089f8 <chSysUnlock.lto_priv.159>

  return p;
 8008afc:	697b      	ldr	r3, [r7, #20]
}
 8008afe:	4618      	mov	r0, r3
 8008b00:	3718      	adds	r7, #24
 8008b02:	46bd      	mov	sp, r7
 8008b04:	bd80      	pop	{r7, pc}
 8008b06:	bf00      	nop

08008b08 <chCoreGetStatusX>:
 *
 * @return              The size, in bytes, of the free core memory.
 *
 * @xclass
 */
size_t chCoreGetStatusX(void) {
 8008b08:	b480      	push	{r7}
 8008b0a:	af00      	add	r7, sp, #0

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(ch_memcore.endmem - ch_memcore.nextmem);
 8008b0c:	4b05      	ldr	r3, [pc, #20]	; (8008b24 <chCoreGetStatusX+0x1c>)
 8008b0e:	685b      	ldr	r3, [r3, #4]
 8008b10:	461a      	mov	r2, r3
 8008b12:	4b04      	ldr	r3, [pc, #16]	; (8008b24 <chCoreGetStatusX+0x1c>)
 8008b14:	681b      	ldr	r3, [r3, #0]
 8008b16:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 8008b18:	4618      	mov	r0, r3
 8008b1a:	46bd      	mov	sp, r7
 8008b1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b20:	4770      	bx	lr
 8008b22:	bf00      	nop
 8008b24:	20001394 	.word	0x20001394

08008b28 <port_lock.lto_priv.180>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8008b28:	b480      	push	{r7}
 8008b2a:	b083      	sub	sp, #12
 8008b2c:	af00      	add	r7, sp, #0
 8008b2e:	2320      	movs	r3, #32
 8008b30:	607b      	str	r3, [r7, #4]
 8008b32:	687b      	ldr	r3, [r7, #4]
 8008b34:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008b38:	370c      	adds	r7, #12
 8008b3a:	46bd      	mov	sp, r7
 8008b3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b40:	4770      	bx	lr
 8008b42:	bf00      	nop

08008b44 <port_unlock.lto_priv.175>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8008b44:	b480      	push	{r7}
 8008b46:	b083      	sub	sp, #12
 8008b48:	af00      	add	r7, sp, #0
 8008b4a:	2300      	movs	r3, #0
 8008b4c:	607b      	str	r3, [r7, #4]
 8008b4e:	687b      	ldr	r3, [r7, #4]
 8008b50:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008b54:	370c      	adds	r7, #12
 8008b56:	46bd      	mov	sp, r7
 8008b58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b5c:	4770      	bx	lr
 8008b5e:	bf00      	nop

08008b60 <chSysLock.lto_priv.165>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8008b60:	b580      	push	{r7, lr}
 8008b62:	af00      	add	r7, sp, #0

  port_lock();
 8008b64:	f7ff ffe0 	bl	8008b28 <port_lock.lto_priv.180>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8008b68:	f000 ff96 	bl	8009a98 <_dbg_check_lock>
}
 8008b6c:	bd80      	pop	{r7, pc}
 8008b6e:	bf00      	nop

08008b70 <chSysUnlock.lto_priv.160>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8008b70:	b580      	push	{r7, lr}
 8008b72:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8008b74:	f000 ffa6 	bl	8009ac4 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008b78:	4b09      	ldr	r3, [pc, #36]	; (8008ba0 <chSysUnlock.lto_priv.160+0x30>)
 8008b7a:	681b      	ldr	r3, [r3, #0]
 8008b7c:	4a08      	ldr	r2, [pc, #32]	; (8008ba0 <chSysUnlock.lto_priv.160+0x30>)
 8008b7e:	4293      	cmp	r3, r2
 8008b80:	d00a      	beq.n	8008b98 <chSysUnlock.lto_priv.160+0x28>
 8008b82:	4b07      	ldr	r3, [pc, #28]	; (8008ba0 <chSysUnlock.lto_priv.160+0x30>)
 8008b84:	699b      	ldr	r3, [r3, #24]
 8008b86:	689a      	ldr	r2, [r3, #8]
 8008b88:	4b05      	ldr	r3, [pc, #20]	; (8008ba0 <chSysUnlock.lto_priv.160+0x30>)
 8008b8a:	681b      	ldr	r3, [r3, #0]
 8008b8c:	689b      	ldr	r3, [r3, #8]
 8008b8e:	429a      	cmp	r2, r3
 8008b90:	d202      	bcs.n	8008b98 <chSysUnlock.lto_priv.160+0x28>
 8008b92:	4804      	ldr	r0, [pc, #16]	; (8008ba4 <chSysUnlock.lto_priv.160+0x34>)
 8008b94:	f000 ff32 	bl	80099fc <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8008b98:	f7ff ffd4 	bl	8008b44 <port_unlock.lto_priv.175>
}
 8008b9c:	bd80      	pop	{r7, pc}
 8008b9e:	bf00      	nop
 8008ba0:	20001330 	.word	0x20001330
 8008ba4:	0800d030 	.word	0x0800d030

08008ba8 <chPoolAdd>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be added
 *
 * @api
 */
static inline void chPoolAdd(memory_pool_t *mp, void *objp) {
 8008ba8:	b580      	push	{r7, lr}
 8008baa:	b082      	sub	sp, #8
 8008bac:	af00      	add	r7, sp, #0
 8008bae:	6078      	str	r0, [r7, #4]
 8008bb0:	6039      	str	r1, [r7, #0]

  chPoolFree(mp, objp);
 8008bb2:	6878      	ldr	r0, [r7, #4]
 8008bb4:	6839      	ldr	r1, [r7, #0]
 8008bb6:	f000 f8a1 	bl	8008cfc <chPoolFree>
}
 8008bba:	3708      	adds	r7, #8
 8008bbc:	46bd      	mov	sp, r7
 8008bbe:	bd80      	pop	{r7, pc}

08008bc0 <chPoolObjectInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {
 8008bc0:	b580      	push	{r7, lr}
 8008bc2:	b084      	sub	sp, #16
 8008bc4:	af00      	add	r7, sp, #0
 8008bc6:	60f8      	str	r0, [r7, #12]
 8008bc8:	60b9      	str	r1, [r7, #8]
 8008bca:	607a      	str	r2, [r7, #4]

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));
 8008bcc:	68fb      	ldr	r3, [r7, #12]
 8008bce:	2b00      	cmp	r3, #0
 8008bd0:	d002      	beq.n	8008bd8 <chPoolObjectInit+0x18>
 8008bd2:	68bb      	ldr	r3, [r7, #8]
 8008bd4:	2b03      	cmp	r3, #3
 8008bd6:	d802      	bhi.n	8008bde <chPoolObjectInit+0x1e>
 8008bd8:	4807      	ldr	r0, [pc, #28]	; (8008bf8 <chPoolObjectInit+0x38>)
 8008bda:	f000 ff0f 	bl	80099fc <chSysHalt>

  mp->next = NULL;
 8008bde:	68fb      	ldr	r3, [r7, #12]
 8008be0:	2200      	movs	r2, #0
 8008be2:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 8008be4:	68fb      	ldr	r3, [r7, #12]
 8008be6:	68ba      	ldr	r2, [r7, #8]
 8008be8:	605a      	str	r2, [r3, #4]
  mp->provider = provider;
 8008bea:	68fb      	ldr	r3, [r7, #12]
 8008bec:	687a      	ldr	r2, [r7, #4]
 8008bee:	609a      	str	r2, [r3, #8]
}
 8008bf0:	3710      	adds	r7, #16
 8008bf2:	46bd      	mov	sp, r7
 8008bf4:	bd80      	pop	{r7, pc}
 8008bf6:	bf00      	nop
 8008bf8:	0800cffc 	.word	0x0800cffc

08008bfc <chPoolLoadArray>:
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
 8008bfc:	b580      	push	{r7, lr}
 8008bfe:	b084      	sub	sp, #16
 8008c00:	af00      	add	r7, sp, #0
 8008c02:	60f8      	str	r0, [r7, #12]
 8008c04:	60b9      	str	r1, [r7, #8]
 8008c06:	607a      	str	r2, [r7, #4]

  chDbgCheck((mp != NULL) && (n != 0U));
 8008c08:	68fb      	ldr	r3, [r7, #12]
 8008c0a:	2b00      	cmp	r3, #0
 8008c0c:	d002      	beq.n	8008c14 <chPoolLoadArray+0x18>
 8008c0e:	687b      	ldr	r3, [r7, #4]
 8008c10:	2b00      	cmp	r3, #0
 8008c12:	d10f      	bne.n	8008c34 <chPoolLoadArray+0x38>
 8008c14:	480a      	ldr	r0, [pc, #40]	; (8008c40 <chPoolLoadArray+0x44>)
 8008c16:	f000 fef1 	bl	80099fc <chSysHalt>
 8008c1a:	e00b      	b.n	8008c34 <chPoolLoadArray+0x38>

  while (n != 0U) {
    chPoolAdd(mp, p);
 8008c1c:	68f8      	ldr	r0, [r7, #12]
 8008c1e:	68b9      	ldr	r1, [r7, #8]
 8008c20:	f7ff ffc2 	bl	8008ba8 <chPoolAdd>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
 8008c24:	68fb      	ldr	r3, [r7, #12]
 8008c26:	685b      	ldr	r3, [r3, #4]
 8008c28:	68ba      	ldr	r2, [r7, #8]
 8008c2a:	4413      	add	r3, r2
 8008c2c:	60bb      	str	r3, [r7, #8]
    /*lint -restore*/
    n--;
 8008c2e:	687b      	ldr	r3, [r7, #4]
 8008c30:	3b01      	subs	r3, #1
 8008c32:	607b      	str	r3, [r7, #4]
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8008c34:	687b      	ldr	r3, [r7, #4]
 8008c36:	2b00      	cmp	r3, #0
 8008c38:	d1f0      	bne.n	8008c1c <chPoolLoadArray+0x20>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
    /*lint -restore*/
    n--;
  }
}
 8008c3a:	3710      	adds	r7, #16
 8008c3c:	46bd      	mov	sp, r7
 8008c3e:	bd80      	pop	{r7, pc}
 8008c40:	0800d010 	.word	0x0800d010

08008c44 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
 8008c44:	b580      	push	{r7, lr}
 8008c46:	b084      	sub	sp, #16
 8008c48:	af00      	add	r7, sp, #0
 8008c4a:	6078      	str	r0, [r7, #4]
  void *objp;

  chDbgCheckClassI();
 8008c4c:	f000 ffb4 	bl	8009bb8 <chDbgCheckClassI>
  chDbgCheck(mp != NULL);
 8008c50:	687b      	ldr	r3, [r7, #4]
 8008c52:	2b00      	cmp	r3, #0
 8008c54:	d102      	bne.n	8008c5c <chPoolAllocI+0x18>
 8008c56:	4810      	ldr	r0, [pc, #64]	; (8008c98 <chPoolAllocI+0x54>)
 8008c58:	f000 fed0 	bl	80099fc <chSysHalt>

  objp = mp->next;
 8008c5c:	687b      	ldr	r3, [r7, #4]
 8008c5e:	681b      	ldr	r3, [r3, #0]
 8008c60:	60fb      	str	r3, [r7, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 8008c62:	68fb      	ldr	r3, [r7, #12]
 8008c64:	2b00      	cmp	r3, #0
 8008c66:	d005      	beq.n	8008c74 <chPoolAllocI+0x30>
    mp->next = mp->next->next;
 8008c68:	687b      	ldr	r3, [r7, #4]
 8008c6a:	681b      	ldr	r3, [r3, #0]
 8008c6c:	681a      	ldr	r2, [r3, #0]
 8008c6e:	687b      	ldr	r3, [r7, #4]
 8008c70:	601a      	str	r2, [r3, #0]
 8008c72:	e00b      	b.n	8008c8c <chPoolAllocI+0x48>
  }
  else if (mp->provider != NULL) {
 8008c74:	687b      	ldr	r3, [r7, #4]
 8008c76:	689b      	ldr	r3, [r3, #8]
 8008c78:	2b00      	cmp	r3, #0
 8008c7a:	d007      	beq.n	8008c8c <chPoolAllocI+0x48>
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
 8008c7c:	687b      	ldr	r3, [r7, #4]
 8008c7e:	689b      	ldr	r3, [r3, #8]
 8008c80:	687a      	ldr	r2, [r7, #4]
 8008c82:	6852      	ldr	r2, [r2, #4]
 8008c84:	4610      	mov	r0, r2
 8008c86:	2104      	movs	r1, #4
 8008c88:	4798      	blx	r3
 8008c8a:	60f8      	str	r0, [r7, #12]
  }
  /*lint -restore*/

  return objp;
 8008c8c:	68fb      	ldr	r3, [r7, #12]
}
 8008c8e:	4618      	mov	r0, r3
 8008c90:	3710      	adds	r7, #16
 8008c92:	46bd      	mov	sp, r7
 8008c94:	bd80      	pop	{r7, pc}
 8008c96:	bf00      	nop
 8008c98:	0800d020 	.word	0x0800d020

08008c9c <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 8008c9c:	b580      	push	{r7, lr}
 8008c9e:	b084      	sub	sp, #16
 8008ca0:	af00      	add	r7, sp, #0
 8008ca2:	6078      	str	r0, [r7, #4]
  void *objp;

  chSysLock();
 8008ca4:	f7ff ff5c 	bl	8008b60 <chSysLock.lto_priv.165>
  objp = chPoolAllocI(mp);
 8008ca8:	6878      	ldr	r0, [r7, #4]
 8008caa:	f7ff ffcb 	bl	8008c44 <chPoolAllocI>
 8008cae:	60f8      	str	r0, [r7, #12]
  chSysUnlock();
 8008cb0:	f7ff ff5e 	bl	8008b70 <chSysUnlock.lto_priv.160>

  return objp;
 8008cb4:	68fb      	ldr	r3, [r7, #12]
}
 8008cb6:	4618      	mov	r0, r3
 8008cb8:	3710      	adds	r7, #16
 8008cba:	46bd      	mov	sp, r7
 8008cbc:	bd80      	pop	{r7, pc}
 8008cbe:	bf00      	nop

08008cc0 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8008cc0:	b580      	push	{r7, lr}
 8008cc2:	b084      	sub	sp, #16
 8008cc4:	af00      	add	r7, sp, #0
 8008cc6:	6078      	str	r0, [r7, #4]
 8008cc8:	6039      	str	r1, [r7, #0]
  struct pool_header *php = objp;
 8008cca:	683b      	ldr	r3, [r7, #0]
 8008ccc:	60fb      	str	r3, [r7, #12]

  chDbgCheckClassI();
 8008cce:	f000 ff73 	bl	8009bb8 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 8008cd2:	687b      	ldr	r3, [r7, #4]
 8008cd4:	2b00      	cmp	r3, #0
 8008cd6:	d002      	beq.n	8008cde <chPoolFreeI+0x1e>
 8008cd8:	683b      	ldr	r3, [r7, #0]
 8008cda:	2b00      	cmp	r3, #0
 8008cdc:	d102      	bne.n	8008ce4 <chPoolFreeI+0x24>
 8008cde:	4806      	ldr	r0, [pc, #24]	; (8008cf8 <chPoolFreeI+0x38>)
 8008ce0:	f000 fe8c 	bl	80099fc <chSysHalt>

  php->next = mp->next;
 8008ce4:	687b      	ldr	r3, [r7, #4]
 8008ce6:	681a      	ldr	r2, [r3, #0]
 8008ce8:	68fb      	ldr	r3, [r7, #12]
 8008cea:	601a      	str	r2, [r3, #0]
  mp->next = php;
 8008cec:	687b      	ldr	r3, [r7, #4]
 8008cee:	68fa      	ldr	r2, [r7, #12]
 8008cf0:	601a      	str	r2, [r3, #0]
}
 8008cf2:	3710      	adds	r7, #16
 8008cf4:	46bd      	mov	sp, r7
 8008cf6:	bd80      	pop	{r7, pc}
 8008cf8:	0800d03c 	.word	0x0800d03c

08008cfc <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 8008cfc:	b580      	push	{r7, lr}
 8008cfe:	b082      	sub	sp, #8
 8008d00:	af00      	add	r7, sp, #0
 8008d02:	6078      	str	r0, [r7, #4]
 8008d04:	6039      	str	r1, [r7, #0]

  chSysLock();
 8008d06:	f7ff ff2b 	bl	8008b60 <chSysLock.lto_priv.165>
  chPoolFreeI(mp, objp);
 8008d0a:	6878      	ldr	r0, [r7, #4]
 8008d0c:	6839      	ldr	r1, [r7, #0]
 8008d0e:	f7ff ffd7 	bl	8008cc0 <chPoolFreeI>
  chSysUnlock();
 8008d12:	f7ff ff2d 	bl	8008b70 <chSysUnlock.lto_priv.160>
}
 8008d16:	3708      	adds	r7, #8
 8008d18:	46bd      	mov	sp, r7
 8008d1a:	bd80      	pop	{r7, pc}

08008d1c <port_lock.lto_priv.181>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8008d1c:	b480      	push	{r7}
 8008d1e:	b083      	sub	sp, #12
 8008d20:	af00      	add	r7, sp, #0
 8008d22:	2320      	movs	r3, #32
 8008d24:	607b      	str	r3, [r7, #4]
 8008d26:	687b      	ldr	r3, [r7, #4]
 8008d28:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008d2c:	370c      	adds	r7, #12
 8008d2e:	46bd      	mov	sp, r7
 8008d30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d34:	4770      	bx	lr
 8008d36:	bf00      	nop

08008d38 <port_unlock.lto_priv.176>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8008d38:	b480      	push	{r7}
 8008d3a:	b083      	sub	sp, #12
 8008d3c:	af00      	add	r7, sp, #0
 8008d3e:	2300      	movs	r3, #0
 8008d40:	607b      	str	r3, [r7, #4]
 8008d42:	687b      	ldr	r3, [r7, #4]
 8008d44:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008d48:	370c      	adds	r7, #12
 8008d4a:	46bd      	mov	sp, r7
 8008d4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d50:	4770      	bx	lr
 8008d52:	bf00      	nop

08008d54 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8008d54:	b580      	push	{r7, lr}
 8008d56:	af00      	add	r7, sp, #0

  port_lock();
 8008d58:	f7ff ffe0 	bl	8008d1c <port_lock.lto_priv.181>
}
 8008d5c:	bd80      	pop	{r7, pc}
 8008d5e:	bf00      	nop

08008d60 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8008d60:	b580      	push	{r7, lr}
 8008d62:	af00      	add	r7, sp, #0

  port_unlock();
 8008d64:	f7ff ffe8 	bl	8008d38 <port_unlock.lto_priv.176>
}
 8008d68:	bd80      	pop	{r7, pc}
 8008d6a:	bf00      	nop

08008d6c <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8008d6c:	b590      	push	{r4, r7, lr}
 8008d6e:	b083      	sub	sp, #12
 8008d70:	af00      	add	r7, sp, #0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8008d72:	f3ef 8309 	mrs	r3, PSP
 8008d76:	461c      	mov	r4, r3
  return(result);
 8008d78:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 8008d7a:	607b      	str	r3, [r7, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8008d7c:	687b      	ldr	r3, [r7, #4]
 8008d7e:	3320      	adds	r3, #32
 8008d80:	607b      	str	r3, [r7, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 8008d82:	687b      	ldr	r3, [r7, #4]
 8008d84:	603b      	str	r3, [r7, #0]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8008d86:	683b      	ldr	r3, [r7, #0]
 8008d88:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8008d8c:	f7ff ffe8 	bl	8008d60 <port_unlock_from_isr>
}
 8008d90:	370c      	adds	r7, #12
 8008d92:	46bd      	mov	sp, r7
 8008d94:	bd90      	pop	{r4, r7, pc}
 8008d96:	bf00      	nop

08008d98 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8008d98:	b590      	push	{r4, r7, lr}
 8008d9a:	b083      	sub	sp, #12
 8008d9c:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 8008d9e:	f7ff ffd9 	bl	8008d54 <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8008da2:	4b14      	ldr	r3, [pc, #80]	; (8008df4 <_port_irq_epilogue+0x5c>)
 8008da4:	685b      	ldr	r3, [r3, #4]
 8008da6:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8008daa:	2b00      	cmp	r3, #0
 8008dac:	d01d      	beq.n	8008dea <_port_irq_epilogue+0x52>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8008dae:	f3ef 8309 	mrs	r3, PSP
 8008db2:	461c      	mov	r4, r3
  return(result);
 8008db4:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 8008db6:	607b      	str	r3, [r7, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8008db8:	687b      	ldr	r3, [r7, #4]
 8008dba:	3b20      	subs	r3, #32
 8008dbc:	607b      	str	r3, [r7, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8008dbe:	687b      	ldr	r3, [r7, #4]
 8008dc0:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8008dc4:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 8008dc6:	687b      	ldr	r3, [r7, #4]
 8008dc8:	603b      	str	r3, [r7, #0]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8008dca:	683b      	ldr	r3, [r7, #0]
 8008dcc:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8008dd0:	f001 faee 	bl	800a3b0 <chSchIsPreemptionRequired>
 8008dd4:	4603      	mov	r3, r0
 8008dd6:	2b00      	cmp	r3, #0
 8008dd8:	d003      	beq.n	8008de2 <_port_irq_epilogue+0x4a>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8008dda:	687b      	ldr	r3, [r7, #4]
 8008ddc:	4a06      	ldr	r2, [pc, #24]	; (8008df8 <_port_irq_epilogue+0x60>)
 8008dde:	619a      	str	r2, [r3, #24]
 8008de0:	e005      	b.n	8008dee <_port_irq_epilogue+0x56>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8008de2:	687b      	ldr	r3, [r7, #4]
 8008de4:	4a05      	ldr	r2, [pc, #20]	; (8008dfc <_port_irq_epilogue+0x64>)
 8008de6:	619a      	str	r2, [r3, #24]
 8008de8:	e001      	b.n	8008dee <_port_irq_epilogue+0x56>

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
 8008dea:	f7ff ffb9 	bl	8008d60 <port_unlock_from_isr>
}
 8008dee:	370c      	adds	r7, #12
 8008df0:	46bd      	mov	sp, r7
 8008df2:	bd90      	pop	{r4, r7, pc}
 8008df4:	e000ed00 	.word	0xe000ed00
 8008df8:	080032b9 	.word	0x080032b9
 8008dfc:	080032c4 	.word	0x080032c4

08008e00 <osalInit>:
/**
 * @brief   OSAL module initialization.
 *
 * @api
 */
static inline void osalInit(void) {
 8008e00:	b480      	push	{r7}
 8008e02:	af00      	add	r7, sp, #0

}
 8008e04:	46bd      	mov	sp, r7
 8008e06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008e0a:	4770      	bx	lr

08008e0c <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8008e0c:	b580      	push	{r7, lr}
 8008e0e:	af00      	add	r7, sp, #0

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8008e10:	f7ff fff6 	bl	8008e00 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8008e14:	f7ff faaa 	bl	800836c <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit();
 8008e18:	f7ff fb26 	bl	8008468 <_pal_lld_init>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8008e1c:	f7ff fc7a 	bl	8008714 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8008e20:	f7ff fa0e 	bl	8008240 <stInit>
#endif
}
 8008e24:	bd80      	pop	{r7, pc}
 8008e26:	bf00      	nop

08008e28 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8008e28:	b580      	push	{r7, lr}
 8008e2a:	b084      	sub	sp, #16
 8008e2c:	af00      	add	r7, sp, #0
 8008e2e:	6078      	str	r0, [r7, #4]
 8008e30:	6039      	str	r1, [r7, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
 8008e32:	6878      	ldr	r0, [r7, #4]
 8008e34:	f001 fb56 	bl	800a4e4 <queue_notempty.lto_priv.221>
 8008e38:	4603      	mov	r3, r0
 8008e3a:	f083 0301 	eor.w	r3, r3, #1
 8008e3e:	b2db      	uxtb	r3, r3
 8008e40:	2b00      	cmp	r3, #0
 8008e42:	d002      	beq.n	8008e4a <chThdDoDequeueNextI+0x22>
 8008e44:	480b      	ldr	r0, [pc, #44]	; (8008e74 <chThdDoDequeueNextI+0x4c>)
 8008e46:	f000 fdd9 	bl	80099fc <chSysHalt>

  tp = queue_fifo_remove(tqp);
 8008e4a:	6878      	ldr	r0, [r7, #4]
 8008e4c:	f001 f912 	bl	800a074 <queue_fifo_remove>
 8008e50:	60f8      	str	r0, [r7, #12]

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8008e52:	68fb      	ldr	r3, [r7, #12]
 8008e54:	f893 3020 	ldrb.w	r3, [r3, #32]
 8008e58:	2b04      	cmp	r3, #4
 8008e5a:	d002      	beq.n	8008e62 <chThdDoDequeueNextI+0x3a>
 8008e5c:	4805      	ldr	r0, [pc, #20]	; (8008e74 <chThdDoDequeueNextI+0x4c>)
 8008e5e:	f000 fdcd 	bl	80099fc <chSysHalt>

  tp->u.rdymsg = msg;
 8008e62:	68fb      	ldr	r3, [r7, #12]
 8008e64:	683a      	ldr	r2, [r7, #0]
 8008e66:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8008e68:	68f8      	ldr	r0, [r7, #12]
 8008e6a:	f001 f92f 	bl	800a0cc <chSchReadyI>
}
 8008e6e:	3710      	adds	r7, #16
 8008e70:	46bd      	mov	sp, r7
 8008e72:	bd80      	pop	{r7, pc}
 8008e74:	0800cf20 	.word	0x0800cf20

08008e78 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
 8008e78:	b480      	push	{r7}
 8008e7a:	b085      	sub	sp, #20
 8008e7c:	af00      	add	r7, sp, #0
 8008e7e:	60f8      	str	r0, [r7, #12]
 8008e80:	60b9      	str	r1, [r7, #8]
 8008e82:	607a      	str	r2, [r7, #4]

  tp->prio      = prio;
 8008e84:	68fb      	ldr	r3, [r7, #12]
 8008e86:	687a      	ldr	r2, [r7, #4]
 8008e88:	609a      	str	r2, [r3, #8]
  tp->state     = CH_STATE_WTSTART;
 8008e8a:	68fb      	ldr	r3, [r7, #12]
 8008e8c:	2202      	movs	r2, #2
 8008e8e:	f883 2020 	strb.w	r2, [r3, #32]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8008e92:	68fb      	ldr	r3, [r7, #12]
 8008e94:	2200      	movs	r2, #0
 8008e96:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8008e9a:	68fb      	ldr	r3, [r7, #12]
 8008e9c:	687a      	ldr	r2, [r7, #4]
 8008e9e:	62da      	str	r2, [r3, #44]	; 0x2c
  tp->mtxlist   = NULL;
 8008ea0:	68fb      	ldr	r3, [r7, #12]
 8008ea2:	2200      	movs	r2, #0
 8008ea4:	629a      	str	r2, [r3, #40]	; 0x28
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8008ea6:	68fb      	ldr	r3, [r7, #12]
 8008ea8:	2201      	movs	r2, #1
 8008eaa:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  tp->name      = name;
 8008eae:	68fb      	ldr	r3, [r7, #12]
 8008eb0:	68ba      	ldr	r2, [r7, #8]
 8008eb2:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 8008eb4:	68fb      	ldr	r3, [r7, #12]
 8008eb6:	4a0a      	ldr	r2, [pc, #40]	; (8008ee0 <_thread_init+0x68>)
 8008eb8:	611a      	str	r2, [r3, #16]
 8008eba:	4b09      	ldr	r3, [pc, #36]	; (8008ee0 <_thread_init+0x68>)
 8008ebc:	695a      	ldr	r2, [r3, #20]
 8008ebe:	68fb      	ldr	r3, [r7, #12]
 8008ec0:	615a      	str	r2, [r3, #20]
 8008ec2:	68fb      	ldr	r3, [r7, #12]
 8008ec4:	695b      	ldr	r3, [r3, #20]
 8008ec6:	68fa      	ldr	r2, [r7, #12]
 8008ec8:	611a      	str	r2, [r3, #16]
 8008eca:	4a05      	ldr	r2, [pc, #20]	; (8008ee0 <_thread_init+0x68>)
 8008ecc:	68fb      	ldr	r3, [r7, #12]
 8008ece:	6153      	str	r3, [r2, #20]
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 8008ed0:	68fb      	ldr	r3, [r7, #12]
}
 8008ed2:	4618      	mov	r0, r3
 8008ed4:	3714      	adds	r7, #20
 8008ed6:	46bd      	mov	sp, r7
 8008ed8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008edc:	4770      	bx	lr
 8008ede:	bf00      	nop
 8008ee0:	20001330 	.word	0x20001330

08008ee4 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8008ee4:	b580      	push	{r7, lr}
 8008ee6:	b084      	sub	sp, #16
 8008ee8:	af00      	add	r7, sp, #0
 8008eea:	6078      	str	r0, [r7, #4]
  thread_t *tp;

  chDbgCheckClassI();
 8008eec:	f000 fe64 	bl	8009bb8 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 8008ef0:	687b      	ldr	r3, [r7, #4]
 8008ef2:	2b00      	cmp	r3, #0
 8008ef4:	d102      	bne.n	8008efc <chThdCreateSuspendedI+0x18>
 8008ef6:	482a      	ldr	r0, [pc, #168]	; (8008fa0 <chThdCreateSuspendedI+0xbc>)
 8008ef8:	f000 fd80 	bl	80099fc <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 8008efc:	687b      	ldr	r3, [r7, #4]
 8008efe:	685b      	ldr	r3, [r3, #4]
 8008f00:	f003 0307 	and.w	r3, r3, #7
 8008f04:	2b00      	cmp	r3, #0
 8008f06:	d113      	bne.n	8008f30 <chThdCreateSuspendedI+0x4c>
 8008f08:	687b      	ldr	r3, [r7, #4]
 8008f0a:	689b      	ldr	r3, [r3, #8]
 8008f0c:	f003 0307 	and.w	r3, r3, #7
 8008f10:	2b00      	cmp	r3, #0
 8008f12:	d10d      	bne.n	8008f30 <chThdCreateSuspendedI+0x4c>
 8008f14:	687b      	ldr	r3, [r7, #4]
 8008f16:	689a      	ldr	r2, [r3, #8]
 8008f18:	687b      	ldr	r3, [r7, #4]
 8008f1a:	685b      	ldr	r3, [r3, #4]
 8008f1c:	429a      	cmp	r2, r3
 8008f1e:	d907      	bls.n	8008f30 <chThdCreateSuspendedI+0x4c>
 8008f20:	687b      	ldr	r3, [r7, #4]
 8008f22:	689b      	ldr	r3, [r3, #8]
 8008f24:	461a      	mov	r2, r3
 8008f26:	687b      	ldr	r3, [r7, #4]
 8008f28:	685b      	ldr	r3, [r3, #4]
 8008f2a:	1ad3      	subs	r3, r2, r3
 8008f2c:	2bb7      	cmp	r3, #183	; 0xb7
 8008f2e:	d802      	bhi.n	8008f36 <chThdCreateSuspendedI+0x52>
 8008f30:	481b      	ldr	r0, [pc, #108]	; (8008fa0 <chThdCreateSuspendedI+0xbc>)
 8008f32:	f000 fd63 	bl	80099fc <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 8008f36:	687b      	ldr	r3, [r7, #4]
 8008f38:	68db      	ldr	r3, [r3, #12]
 8008f3a:	2bff      	cmp	r3, #255	; 0xff
 8008f3c:	d803      	bhi.n	8008f46 <chThdCreateSuspendedI+0x62>
 8008f3e:	687b      	ldr	r3, [r7, #4]
 8008f40:	691b      	ldr	r3, [r3, #16]
 8008f42:	2b00      	cmp	r3, #0
 8008f44:	d102      	bne.n	8008f4c <chThdCreateSuspendedI+0x68>
 8008f46:	4816      	ldr	r0, [pc, #88]	; (8008fa0 <chThdCreateSuspendedI+0xbc>)
 8008f48:	f000 fd58 	bl	80099fc <chSysHalt>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8008f4c:	687b      	ldr	r3, [r7, #4]
 8008f4e:	689b      	ldr	r3, [r3, #8]
 8008f50:	3b30      	subs	r3, #48	; 0x30
 8008f52:	60fb      	str	r3, [r7, #12]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8008f54:	687b      	ldr	r3, [r7, #4]
 8008f56:	685a      	ldr	r2, [r3, #4]
 8008f58:	68fb      	ldr	r3, [r7, #12]
 8008f5a:	61da      	str	r2, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8008f5c:	68fb      	ldr	r3, [r7, #12]
 8008f5e:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8008f62:	68fb      	ldr	r3, [r7, #12]
 8008f64:	60da      	str	r2, [r3, #12]
 8008f66:	68fb      	ldr	r3, [r7, #12]
 8008f68:	68db      	ldr	r3, [r3, #12]
 8008f6a:	687a      	ldr	r2, [r7, #4]
 8008f6c:	6912      	ldr	r2, [r2, #16]
 8008f6e:	601a      	str	r2, [r3, #0]
 8008f70:	68fb      	ldr	r3, [r7, #12]
 8008f72:	68db      	ldr	r3, [r3, #12]
 8008f74:	687a      	ldr	r2, [r7, #4]
 8008f76:	6952      	ldr	r2, [r2, #20]
 8008f78:	605a      	str	r2, [r3, #4]
 8008f7a:	68fb      	ldr	r3, [r7, #12]
 8008f7c:	68db      	ldr	r3, [r3, #12]
 8008f7e:	4a09      	ldr	r2, [pc, #36]	; (8008fa4 <chThdCreateSuspendedI+0xc0>)
 8008f80:	621a      	str	r2, [r3, #32]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8008f82:	687b      	ldr	r3, [r7, #4]
 8008f84:	681a      	ldr	r2, [r3, #0]
 8008f86:	687b      	ldr	r3, [r7, #4]
 8008f88:	68db      	ldr	r3, [r3, #12]
 8008f8a:	68f8      	ldr	r0, [r7, #12]
 8008f8c:	4611      	mov	r1, r2
 8008f8e:	461a      	mov	r2, r3
 8008f90:	f7ff ff72 	bl	8008e78 <_thread_init>
 8008f94:	4603      	mov	r3, r0
}
 8008f96:	4618      	mov	r0, r3
 8008f98:	3710      	adds	r7, #16
 8008f9a:	46bd      	mov	sp, r7
 8008f9c:	bd80      	pop	{r7, pc}
 8008f9e:	bf00      	nop
 8008fa0:	0800ce98 	.word	0x0800ce98
 8008fa4:	080032a5 	.word	0x080032a5

08008fa8 <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 8008fa8:	b580      	push	{r7, lr}
 8008faa:	b084      	sub	sp, #16
 8008fac:	af00      	add	r7, sp, #0
 8008fae:	6078      	str	r0, [r7, #4]
  thread_t *tp;

#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 8008fb0:	687b      	ldr	r3, [r7, #4]
 8008fb2:	685b      	ldr	r3, [r3, #4]
 8008fb4:	4618      	mov	r0, r3
 8008fb6:	f000 f99f 	bl	80092f8 <chRegFindThreadByWorkingArea>
 8008fba:	4603      	mov	r3, r0
 8008fbc:	2b00      	cmp	r3, #0
 8008fbe:	d002      	beq.n	8008fc6 <chThdCreate+0x1e>
 8008fc0:	4809      	ldr	r0, [pc, #36]	; (8008fe8 <chThdCreate+0x40>)
 8008fc2:	f000 fd1b 	bl	80099fc <chSysHalt>
  _thread_memfill((uint8_t *)tdp->wbase,
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 8008fc6:	f001 fa9f 	bl	800a508 <chSysLock.lto_priv.218>
  tp = chThdCreateSuspendedI(tdp);
 8008fca:	6878      	ldr	r0, [r7, #4]
 8008fcc:	f7ff ff8a 	bl	8008ee4 <chThdCreateSuspendedI>
 8008fd0:	60f8      	str	r0, [r7, #12]
  chSchWakeupS(tp, MSG_OK);
 8008fd2:	68f8      	ldr	r0, [r7, #12]
 8008fd4:	2100      	movs	r1, #0
 8008fd6:	f001 f991 	bl	800a2fc <chSchWakeupS>
  chSysUnlock();
 8008fda:	f001 fa9d 	bl	800a518 <chSysUnlock.lto_priv.215>

  return tp;
 8008fde:	68fb      	ldr	r3, [r7, #12]
}
 8008fe0:	4618      	mov	r0, r3
 8008fe2:	3710      	adds	r7, #16
 8008fe4:	46bd      	mov	sp, r7
 8008fe6:	bd80      	pop	{r7, pc}
 8008fe8:	0800cebc 	.word	0x0800cebc

08008fec <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8008fec:	b580      	push	{r7, lr}
 8008fee:	b082      	sub	sp, #8
 8008ff0:	af00      	add	r7, sp, #0
 8008ff2:	6078      	str	r0, [r7, #4]

  chSysLock();
 8008ff4:	f001 fa88 	bl	800a508 <chSysLock.lto_priv.218>
  chThdExitS(msg);
 8008ff8:	6878      	ldr	r0, [r7, #4]
 8008ffa:	f000 f803 	bl	8009004 <chThdExitS>
  /* The thread never returns here.*/
}
 8008ffe:	3708      	adds	r7, #8
 8009000:	46bd      	mov	sp, r7
 8009002:	bd80      	pop	{r7, pc}

08009004 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8009004:	b580      	push	{r7, lr}
 8009006:	b084      	sub	sp, #16
 8009008:	af00      	add	r7, sp, #0
 800900a:	6078      	str	r0, [r7, #4]
  thread_t *tp = currp;
 800900c:	4b0e      	ldr	r3, [pc, #56]	; (8009048 <chThdExitS+0x44>)
 800900e:	699b      	ldr	r3, [r3, #24]
 8009010:	60fb      	str	r3, [r7, #12]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 8009012:	68fb      	ldr	r3, [r7, #12]
 8009014:	687a      	ldr	r2, [r7, #4]
 8009016:	625a      	str	r2, [r3, #36]	; 0x24
  if ((tp->refs == (trefs_t)0) &&
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
  }
#else
  if (tp->refs == (trefs_t)0) {
 8009018:	68fb      	ldr	r3, [r7, #12]
 800901a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800901e:	2b00      	cmp	r3, #0
 8009020:	d109      	bne.n	8009036 <chThdExitS+0x32>
    REG_REMOVE(tp);
 8009022:	68fb      	ldr	r3, [r7, #12]
 8009024:	695b      	ldr	r3, [r3, #20]
 8009026:	68fa      	ldr	r2, [r7, #12]
 8009028:	6912      	ldr	r2, [r2, #16]
 800902a:	611a      	str	r2, [r3, #16]
 800902c:	68fb      	ldr	r3, [r7, #12]
 800902e:	691b      	ldr	r3, [r3, #16]
 8009030:	68fa      	ldr	r2, [r7, #12]
 8009032:	6952      	ldr	r2, [r2, #20]
 8009034:	615a      	str	r2, [r3, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8009036:	200f      	movs	r0, #15
 8009038:	f001 f8c8 	bl	800a1cc <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 800903c:	4803      	ldr	r0, [pc, #12]	; (800904c <chThdExitS+0x48>)
 800903e:	f000 fcdd 	bl	80099fc <chSysHalt>
}
 8009042:	3710      	adds	r7, #16
 8009044:	46bd      	mov	sp, r7
 8009046:	bd80      	pop	{r7, pc}
 8009048:	20001330 	.word	0x20001330
 800904c:	0800cec8 	.word	0x0800cec8

08009050 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8009050:	b580      	push	{r7, lr}
 8009052:	b084      	sub	sp, #16
 8009054:	af00      	add	r7, sp, #0
 8009056:	6078      	str	r0, [r7, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);
 8009058:	687b      	ldr	r3, [r7, #4]
 800905a:	2bff      	cmp	r3, #255	; 0xff
 800905c:	d902      	bls.n	8009064 <chThdSetPriority+0x14>
 800905e:	4814      	ldr	r0, [pc, #80]	; (80090b0 <chThdSetPriority+0x60>)
 8009060:	f000 fccc 	bl	80099fc <chSysHalt>

  chSysLock();
 8009064:	f001 fa50 	bl	800a508 <chSysLock.lto_priv.218>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->realprio;
 8009068:	4b12      	ldr	r3, [pc, #72]	; (80090b4 <chThdSetPriority+0x64>)
 800906a:	699b      	ldr	r3, [r3, #24]
 800906c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800906e:	60fb      	str	r3, [r7, #12]
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
 8009070:	4b10      	ldr	r3, [pc, #64]	; (80090b4 <chThdSetPriority+0x64>)
 8009072:	699b      	ldr	r3, [r3, #24]
 8009074:	689a      	ldr	r2, [r3, #8]
 8009076:	4b0f      	ldr	r3, [pc, #60]	; (80090b4 <chThdSetPriority+0x64>)
 8009078:	699b      	ldr	r3, [r3, #24]
 800907a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800907c:	429a      	cmp	r2, r3
 800907e:	d005      	beq.n	800908c <chThdSetPriority+0x3c>
 8009080:	4b0c      	ldr	r3, [pc, #48]	; (80090b4 <chThdSetPriority+0x64>)
 8009082:	699b      	ldr	r3, [r3, #24]
 8009084:	689a      	ldr	r2, [r3, #8]
 8009086:	687b      	ldr	r3, [r7, #4]
 8009088:	429a      	cmp	r2, r3
 800908a:	d203      	bcs.n	8009094 <chThdSetPriority+0x44>
    currp->prio = newprio;
 800908c:	4b09      	ldr	r3, [pc, #36]	; (80090b4 <chThdSetPriority+0x64>)
 800908e:	699b      	ldr	r3, [r3, #24]
 8009090:	687a      	ldr	r2, [r7, #4]
 8009092:	609a      	str	r2, [r3, #8]
  }
  currp->realprio = newprio;
 8009094:	4b07      	ldr	r3, [pc, #28]	; (80090b4 <chThdSetPriority+0x64>)
 8009096:	699b      	ldr	r3, [r3, #24]
 8009098:	687a      	ldr	r2, [r7, #4]
 800909a:	62da      	str	r2, [r3, #44]	; 0x2c
#else
  oldprio = currp->prio;
  currp->prio = newprio;
#endif
  chSchRescheduleS();
 800909c:	f001 f97c 	bl	800a398 <chSchRescheduleS>
  chSysUnlock();
 80090a0:	f001 fa3a 	bl	800a518 <chSysUnlock.lto_priv.215>

  return oldprio;
 80090a4:	68fb      	ldr	r3, [r7, #12]
}
 80090a6:	4618      	mov	r0, r3
 80090a8:	3710      	adds	r7, #16
 80090aa:	46bd      	mov	sp, r7
 80090ac:	bd80      	pop	{r7, pc}
 80090ae:	bf00      	nop
 80090b0:	0800ced4 	.word	0x0800ced4
 80090b4:	20001330 	.word	0x20001330

080090b8 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
 80090b8:	b580      	push	{r7, lr}
 80090ba:	b084      	sub	sp, #16
 80090bc:	af00      	add	r7, sp, #0
 80090be:	6078      	str	r0, [r7, #4]
 80090c0:	460b      	mov	r3, r1
 80090c2:	807b      	strh	r3, [r7, #2]
  thread_t *tp = chThdGetSelfX();
 80090c4:	f001 fa44 	bl	800a550 <chThdGetSelfX.lto_priv.237>
 80090c8:	60f8      	str	r0, [r7, #12]

  chDbgAssert(*trp == NULL, "not NULL");
 80090ca:	687b      	ldr	r3, [r7, #4]
 80090cc:	681b      	ldr	r3, [r3, #0]
 80090ce:	2b00      	cmp	r3, #0
 80090d0:	d002      	beq.n	80090d8 <chThdSuspendTimeoutS+0x20>
 80090d2:	480c      	ldr	r0, [pc, #48]	; (8009104 <chThdSuspendTimeoutS+0x4c>)
 80090d4:	f000 fc92 	bl	80099fc <chSysHalt>

  if (TIME_IMMEDIATE == timeout) {
 80090d8:	887b      	ldrh	r3, [r7, #2]
 80090da:	2b00      	cmp	r3, #0
 80090dc:	d102      	bne.n	80090e4 <chThdSuspendTimeoutS+0x2c>
    return MSG_TIMEOUT;
 80090de:	f04f 33ff 	mov.w	r3, #4294967295
 80090e2:	e00b      	b.n	80090fc <chThdSuspendTimeoutS+0x44>
  }

  *trp = tp;
 80090e4:	687b      	ldr	r3, [r7, #4]
 80090e6:	68fa      	ldr	r2, [r7, #12]
 80090e8:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 80090ea:	68fb      	ldr	r3, [r7, #12]
 80090ec:	687a      	ldr	r2, [r7, #4]
 80090ee:	625a      	str	r2, [r3, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 80090f0:	887b      	ldrh	r3, [r7, #2]
 80090f2:	2003      	movs	r0, #3
 80090f4:	4619      	mov	r1, r3
 80090f6:	f001 f8c7 	bl	800a288 <chSchGoSleepTimeoutS>
 80090fa:	4603      	mov	r3, r0
}
 80090fc:	4618      	mov	r0, r3
 80090fe:	3710      	adds	r7, #16
 8009100:	46bd      	mov	sp, r7
 8009102:	bd80      	pop	{r7, pc}
 8009104:	0800cee8 	.word	0x0800cee8

08009108 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8009108:	b580      	push	{r7, lr}
 800910a:	b084      	sub	sp, #16
 800910c:	af00      	add	r7, sp, #0
 800910e:	6078      	str	r0, [r7, #4]
 8009110:	6039      	str	r1, [r7, #0]

  if (*trp != NULL) {
 8009112:	687b      	ldr	r3, [r7, #4]
 8009114:	681b      	ldr	r3, [r3, #0]
 8009116:	2b00      	cmp	r3, #0
 8009118:	d013      	beq.n	8009142 <chThdResumeI+0x3a>
    thread_t *tp = *trp;
 800911a:	687b      	ldr	r3, [r7, #4]
 800911c:	681b      	ldr	r3, [r3, #0]
 800911e:	60fb      	str	r3, [r7, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8009120:	68fb      	ldr	r3, [r7, #12]
 8009122:	f893 3020 	ldrb.w	r3, [r3, #32]
 8009126:	2b03      	cmp	r3, #3
 8009128:	d002      	beq.n	8009130 <chThdResumeI+0x28>
 800912a:	4807      	ldr	r0, [pc, #28]	; (8009148 <chThdResumeI+0x40>)
 800912c:	f000 fc66 	bl	80099fc <chSysHalt>

    *trp = NULL;
 8009130:	687b      	ldr	r3, [r7, #4]
 8009132:	2200      	movs	r2, #0
 8009134:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 8009136:	68fb      	ldr	r3, [r7, #12]
 8009138:	683a      	ldr	r2, [r7, #0]
 800913a:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800913c:	68f8      	ldr	r0, [r7, #12]
 800913e:	f000 ffc5 	bl	800a0cc <chSchReadyI>
  }
}
 8009142:	3710      	adds	r7, #16
 8009144:	46bd      	mov	sp, r7
 8009146:	bd80      	pop	{r7, pc}
 8009148:	0800cf00 	.word	0x0800cf00

0800914c <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 800914c:	b580      	push	{r7, lr}
 800914e:	b084      	sub	sp, #16
 8009150:	af00      	add	r7, sp, #0
 8009152:	6078      	str	r0, [r7, #4]
 8009154:	6039      	str	r1, [r7, #0]

  if (*trp != NULL) {
 8009156:	687b      	ldr	r3, [r7, #4]
 8009158:	681b      	ldr	r3, [r3, #0]
 800915a:	2b00      	cmp	r3, #0
 800915c:	d011      	beq.n	8009182 <chThdResumeS+0x36>
    thread_t *tp = *trp;
 800915e:	687b      	ldr	r3, [r7, #4]
 8009160:	681b      	ldr	r3, [r3, #0]
 8009162:	60fb      	str	r3, [r7, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8009164:	68fb      	ldr	r3, [r7, #12]
 8009166:	f893 3020 	ldrb.w	r3, [r3, #32]
 800916a:	2b03      	cmp	r3, #3
 800916c:	d002      	beq.n	8009174 <chThdResumeS+0x28>
 800916e:	4806      	ldr	r0, [pc, #24]	; (8009188 <chThdResumeS+0x3c>)
 8009170:	f000 fc44 	bl	80099fc <chSysHalt>

    *trp = NULL;
 8009174:	687b      	ldr	r3, [r7, #4]
 8009176:	2200      	movs	r2, #0
 8009178:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 800917a:	68f8      	ldr	r0, [r7, #12]
 800917c:	6839      	ldr	r1, [r7, #0]
 800917e:	f001 f8bd 	bl	800a2fc <chSchWakeupS>
  }
}
 8009182:	3710      	adds	r7, #16
 8009184:	46bd      	mov	sp, r7
 8009186:	bd80      	pop	{r7, pc}
 8009188:	0800cf10 	.word	0x0800cf10

0800918c <chThdResume>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @api
 */
void chThdResume(thread_reference_t *trp, msg_t msg) {
 800918c:	b580      	push	{r7, lr}
 800918e:	b082      	sub	sp, #8
 8009190:	af00      	add	r7, sp, #0
 8009192:	6078      	str	r0, [r7, #4]
 8009194:	6039      	str	r1, [r7, #0]

  chSysLock();
 8009196:	f001 f9b7 	bl	800a508 <chSysLock.lto_priv.218>
  chThdResumeS(trp, msg);
 800919a:	6878      	ldr	r0, [r7, #4]
 800919c:	6839      	ldr	r1, [r7, #0]
 800919e:	f7ff ffd5 	bl	800914c <chThdResumeS>
  chSysUnlock();
 80091a2:	f001 f9b9 	bl	800a518 <chSysUnlock.lto_priv.215>
}
 80091a6:	3708      	adds	r7, #8
 80091a8:	46bd      	mov	sp, r7
 80091aa:	bd80      	pop	{r7, pc}

080091ac <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 80091ac:	b580      	push	{r7, lr}
 80091ae:	b082      	sub	sp, #8
 80091b0:	af00      	add	r7, sp, #0
 80091b2:	6078      	str	r0, [r7, #4]
 80091b4:	460b      	mov	r3, r1
 80091b6:	807b      	strh	r3, [r7, #2]

  if (TIME_IMMEDIATE == timeout) {
 80091b8:	887b      	ldrh	r3, [r7, #2]
 80091ba:	2b00      	cmp	r3, #0
 80091bc:	d102      	bne.n	80091c4 <chThdEnqueueTimeoutS+0x18>
    return MSG_TIMEOUT;
 80091be:	f04f 33ff 	mov.w	r3, #4294967295
 80091c2:	e00b      	b.n	80091dc <chThdEnqueueTimeoutS+0x30>
  }

  queue_insert(currp, tqp);
 80091c4:	4b07      	ldr	r3, [pc, #28]	; (80091e4 <chThdEnqueueTimeoutS+0x38>)
 80091c6:	699b      	ldr	r3, [r3, #24]
 80091c8:	4618      	mov	r0, r3
 80091ca:	6879      	ldr	r1, [r7, #4]
 80091cc:	f000 ff3a 	bl	800a044 <queue_insert>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80091d0:	887b      	ldrh	r3, [r7, #2]
 80091d2:	2004      	movs	r0, #4
 80091d4:	4619      	mov	r1, r3
 80091d6:	f001 f857 	bl	800a288 <chSchGoSleepTimeoutS>
 80091da:	4603      	mov	r3, r0
}
 80091dc:	4618      	mov	r0, r3
 80091de:	3708      	adds	r7, #8
 80091e0:	46bd      	mov	sp, r7
 80091e2:	bd80      	pop	{r7, pc}
 80091e4:	20001330 	.word	0x20001330

080091e8 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80091e8:	b580      	push	{r7, lr}
 80091ea:	b082      	sub	sp, #8
 80091ec:	af00      	add	r7, sp, #0
 80091ee:	6078      	str	r0, [r7, #4]
 80091f0:	6039      	str	r1, [r7, #0]

  if (queue_notempty(tqp)) {
 80091f2:	6878      	ldr	r0, [r7, #4]
 80091f4:	f001 f976 	bl	800a4e4 <queue_notempty.lto_priv.221>
 80091f8:	4603      	mov	r3, r0
 80091fa:	2b00      	cmp	r3, #0
 80091fc:	d003      	beq.n	8009206 <chThdDequeueNextI+0x1e>
    chThdDoDequeueNextI(tqp, msg);
 80091fe:	6878      	ldr	r0, [r7, #4]
 8009200:	6839      	ldr	r1, [r7, #0]
 8009202:	f7ff fe11 	bl	8008e28 <chThdDoDequeueNextI>
  }
}
 8009206:	3708      	adds	r7, #8
 8009208:	46bd      	mov	sp, r7
 800920a:	bd80      	pop	{r7, pc}

0800920c <port_lock.lto_priv.208>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800920c:	b480      	push	{r7}
 800920e:	b083      	sub	sp, #12
 8009210:	af00      	add	r7, sp, #0
 8009212:	2320      	movs	r3, #32
 8009214:	607b      	str	r3, [r7, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8009216:	687b      	ldr	r3, [r7, #4]
 8009218:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800921c:	370c      	adds	r7, #12
 800921e:	46bd      	mov	sp, r7
 8009220:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009224:	4770      	bx	lr
 8009226:	bf00      	nop

08009228 <port_unlock.lto_priv.205>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8009228:	b480      	push	{r7}
 800922a:	b083      	sub	sp, #12
 800922c:	af00      	add	r7, sp, #0
 800922e:	2300      	movs	r3, #0
 8009230:	607b      	str	r3, [r7, #4]
 8009232:	687b      	ldr	r3, [r7, #4]
 8009234:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8009238:	370c      	adds	r7, #12
 800923a:	46bd      	mov	sp, r7
 800923c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009240:	4770      	bx	lr
 8009242:	bf00      	nop

08009244 <chSysLock.lto_priv.219>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8009244:	b580      	push	{r7, lr}
 8009246:	af00      	add	r7, sp, #0

  port_lock();
 8009248:	f7ff ffe0 	bl	800920c <port_lock.lto_priv.208>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800924c:	f000 fc24 	bl	8009a98 <_dbg_check_lock>
}
 8009250:	bd80      	pop	{r7, pc}
 8009252:	bf00      	nop

08009254 <chSysUnlock.lto_priv.216>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8009254:	b580      	push	{r7, lr}
 8009256:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8009258:	f000 fc34 	bl	8009ac4 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800925c:	4b09      	ldr	r3, [pc, #36]	; (8009284 <chSysUnlock.lto_priv.216+0x30>)
 800925e:	681b      	ldr	r3, [r3, #0]
 8009260:	4a08      	ldr	r2, [pc, #32]	; (8009284 <chSysUnlock.lto_priv.216+0x30>)
 8009262:	4293      	cmp	r3, r2
 8009264:	d00a      	beq.n	800927c <chSysUnlock.lto_priv.216+0x28>
 8009266:	4b07      	ldr	r3, [pc, #28]	; (8009284 <chSysUnlock.lto_priv.216+0x30>)
 8009268:	699b      	ldr	r3, [r3, #24]
 800926a:	689a      	ldr	r2, [r3, #8]
 800926c:	4b05      	ldr	r3, [pc, #20]	; (8009284 <chSysUnlock.lto_priv.216+0x30>)
 800926e:	681b      	ldr	r3, [r3, #0]
 8009270:	689b      	ldr	r3, [r3, #8]
 8009272:	429a      	cmp	r2, r3
 8009274:	d202      	bcs.n	800927c <chSysUnlock.lto_priv.216+0x28>
 8009276:	4804      	ldr	r0, [pc, #16]	; (8009288 <chSysUnlock.lto_priv.216+0x34>)
 8009278:	f000 fbc0 	bl	80099fc <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 800927c:	f7ff ffd4 	bl	8009228 <port_unlock.lto_priv.205>
}
 8009280:	bd80      	pop	{r7, pc}
 8009282:	bf00      	nop
 8009284:	20001330 	.word	0x20001330
 8009288:	0800cf4c 	.word	0x0800cf4c

0800928c <chThdGetWorkingAreaX>:
 * @param[in] tp        pointer to the thread
 * @return              The working area base pointer.
 *
 * @xclass
 */
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 800928c:	b480      	push	{r7}
 800928e:	b083      	sub	sp, #12
 8009290:	af00      	add	r7, sp, #0
 8009292:	6078      	str	r0, [r7, #4]

  return tp->wabase;
 8009294:	687b      	ldr	r3, [r7, #4]
 8009296:	69db      	ldr	r3, [r3, #28]
}
 8009298:	4618      	mov	r0, r3
 800929a:	370c      	adds	r7, #12
 800929c:	46bd      	mov	sp, r7
 800929e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80092a2:	4770      	bx	lr

080092a4 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 80092a4:	b580      	push	{r7, lr}
 80092a6:	b082      	sub	sp, #8
 80092a8:	af00      	add	r7, sp, #0
  thread_t *tp;

  chSysLock();
 80092aa:	f7ff ffcb 	bl	8009244 <chSysLock.lto_priv.219>
  tp = ch.rlist.newer;
 80092ae:	4b05      	ldr	r3, [pc, #20]	; (80092c4 <chRegFirstThread+0x20>)
 80092b0:	691b      	ldr	r3, [r3, #16]
 80092b2:	607b      	str	r3, [r7, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
#endif
  chSysUnlock();
 80092b4:	f7ff ffce 	bl	8009254 <chSysUnlock.lto_priv.216>

  return tp;
 80092b8:	687b      	ldr	r3, [r7, #4]
}
 80092ba:	4618      	mov	r0, r3
 80092bc:	3708      	adds	r7, #8
 80092be:	46bd      	mov	sp, r7
 80092c0:	bd80      	pop	{r7, pc}
 80092c2:	bf00      	nop
 80092c4:	20001330 	.word	0x20001330

080092c8 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 80092c8:	b580      	push	{r7, lr}
 80092ca:	b084      	sub	sp, #16
 80092cc:	af00      	add	r7, sp, #0
 80092ce:	6078      	str	r0, [r7, #4]
  thread_t *ntp;

  chSysLock();
 80092d0:	f7ff ffb8 	bl	8009244 <chSysLock.lto_priv.219>
  ntp = tp->newer;
 80092d4:	687b      	ldr	r3, [r7, #4]
 80092d6:	691b      	ldr	r3, [r3, #16]
 80092d8:	60fb      	str	r3, [r7, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 80092da:	68fb      	ldr	r3, [r7, #12]
 80092dc:	4a05      	ldr	r2, [pc, #20]	; (80092f4 <chRegNextThread+0x2c>)
 80092de:	4293      	cmp	r3, r2
 80092e0:	d101      	bne.n	80092e6 <chRegNextThread+0x1e>
  /*lint -restore*/
    ntp = NULL;
 80092e2:	2300      	movs	r3, #0
 80092e4:	60fb      	str	r3, [r7, #12]
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
    ntp->refs++;
  }
#endif
  chSysUnlock();
 80092e6:	f7ff ffb5 	bl	8009254 <chSysUnlock.lto_priv.216>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
#endif

  return ntp;
 80092ea:	68fb      	ldr	r3, [r7, #12]
}
 80092ec:	4618      	mov	r0, r3
 80092ee:	3710      	adds	r7, #16
 80092f0:	46bd      	mov	sp, r7
 80092f2:	bd80      	pop	{r7, pc}
 80092f4:	20001330 	.word	0x20001330

080092f8 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 80092f8:	b580      	push	{r7, lr}
 80092fa:	b084      	sub	sp, #16
 80092fc:	af00      	add	r7, sp, #0
 80092fe:	6078      	str	r0, [r7, #4]
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
 8009300:	f7ff ffd0 	bl	80092a4 <chRegFirstThread>
 8009304:	60f8      	str	r0, [r7, #12]
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8009306:	68f8      	ldr	r0, [r7, #12]
 8009308:	f7ff ffc0 	bl	800928c <chThdGetWorkingAreaX>
 800930c:	4602      	mov	r2, r0
 800930e:	687b      	ldr	r3, [r7, #4]
 8009310:	429a      	cmp	r2, r3
 8009312:	d101      	bne.n	8009318 <chRegFindThreadByWorkingArea+0x20>
      return ctp;
 8009314:	68fb      	ldr	r3, [r7, #12]
 8009316:	e007      	b.n	8009328 <chRegFindThreadByWorkingArea+0x30>
    }
    ctp = chRegNextThread(ctp);
 8009318:	68f8      	ldr	r0, [r7, #12]
 800931a:	f7ff ffd5 	bl	80092c8 <chRegNextThread>
 800931e:	60f8      	str	r0, [r7, #12]
  } while (ctp != NULL);
 8009320:	68fb      	ldr	r3, [r7, #12]
 8009322:	2b00      	cmp	r3, #0
 8009324:	d1ef      	bne.n	8009306 <chRegFindThreadByWorkingArea+0xe>

  return NULL;
 8009326:	2300      	movs	r3, #0
}
 8009328:	4618      	mov	r0, r3
 800932a:	3710      	adds	r7, #16
 800932c:	46bd      	mov	sp, r7
 800932e:	bd80      	pop	{r7, pc}

08009330 <port_lock.lto_priv.209>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8009330:	b480      	push	{r7}
 8009332:	b083      	sub	sp, #12
 8009334:	af00      	add	r7, sp, #0
 8009336:	2320      	movs	r3, #32
 8009338:	607b      	str	r3, [r7, #4]
 800933a:	687b      	ldr	r3, [r7, #4]
 800933c:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8009340:	370c      	adds	r7, #12
 8009342:	46bd      	mov	sp, r7
 8009344:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009348:	4770      	bx	lr
 800934a:	bf00      	nop

0800934c <port_unlock.lto_priv.206>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800934c:	b480      	push	{r7}
 800934e:	b083      	sub	sp, #12
 8009350:	af00      	add	r7, sp, #0
 8009352:	2300      	movs	r3, #0
 8009354:	607b      	str	r3, [r7, #4]
 8009356:	687b      	ldr	r3, [r7, #4]
 8009358:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800935c:	370c      	adds	r7, #12
 800935e:	46bd      	mov	sp, r7
 8009360:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009364:	4770      	bx	lr
 8009366:	bf00      	nop

08009368 <queue_init.lto_priv.203>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8009368:	b480      	push	{r7}
 800936a:	b083      	sub	sp, #12
 800936c:	af00      	add	r7, sp, #0
 800936e:	6078      	str	r0, [r7, #4]

  tqp->next = (thread_t *)tqp;
 8009370:	687b      	ldr	r3, [r7, #4]
 8009372:	687a      	ldr	r2, [r7, #4]
 8009374:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8009376:	687b      	ldr	r3, [r7, #4]
 8009378:	687a      	ldr	r2, [r7, #4]
 800937a:	605a      	str	r2, [r3, #4]
}
 800937c:	370c      	adds	r7, #12
 800937e:	46bd      	mov	sp, r7
 8009380:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009384:	4770      	bx	lr
 8009386:	bf00      	nop

08009388 <queue_notempty.lto_priv.222>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8009388:	b480      	push	{r7}
 800938a:	b083      	sub	sp, #12
 800938c:	af00      	add	r7, sp, #0
 800938e:	6078      	str	r0, [r7, #4]

  return (bool)(tqp->next != (const thread_t *)tqp);
 8009390:	687b      	ldr	r3, [r7, #4]
 8009392:	681a      	ldr	r2, [r3, #0]
 8009394:	687b      	ldr	r3, [r7, #4]
 8009396:	429a      	cmp	r2, r3
 8009398:	bf14      	ite	ne
 800939a:	2301      	movne	r3, #1
 800939c:	2300      	moveq	r3, #0
 800939e:	b2db      	uxtb	r3, r3
}
 80093a0:	4618      	mov	r0, r3
 80093a2:	370c      	adds	r7, #12
 80093a4:	46bd      	mov	sp, r7
 80093a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80093aa:	4770      	bx	lr

080093ac <chSysLock.lto_priv.220>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80093ac:	b580      	push	{r7, lr}
 80093ae:	af00      	add	r7, sp, #0

  port_lock();
 80093b0:	f7ff ffbe 	bl	8009330 <port_lock.lto_priv.209>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80093b4:	f000 fb70 	bl	8009a98 <_dbg_check_lock>
}
 80093b8:	bd80      	pop	{r7, pc}
 80093ba:	bf00      	nop

080093bc <chSysUnlock.lto_priv.217>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80093bc:	b580      	push	{r7, lr}
 80093be:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 80093c0:	f000 fb80 	bl	8009ac4 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80093c4:	4b09      	ldr	r3, [pc, #36]	; (80093ec <chSysUnlock.lto_priv.217+0x30>)
 80093c6:	681b      	ldr	r3, [r3, #0]
 80093c8:	4a08      	ldr	r2, [pc, #32]	; (80093ec <chSysUnlock.lto_priv.217+0x30>)
 80093ca:	4293      	cmp	r3, r2
 80093cc:	d00a      	beq.n	80093e4 <chSysUnlock.lto_priv.217+0x28>
 80093ce:	4b07      	ldr	r3, [pc, #28]	; (80093ec <chSysUnlock.lto_priv.217+0x30>)
 80093d0:	699b      	ldr	r3, [r3, #24]
 80093d2:	689a      	ldr	r2, [r3, #8]
 80093d4:	4b05      	ldr	r3, [pc, #20]	; (80093ec <chSysUnlock.lto_priv.217+0x30>)
 80093d6:	681b      	ldr	r3, [r3, #0]
 80093d8:	689b      	ldr	r3, [r3, #8]
 80093da:	429a      	cmp	r2, r3
 80093dc:	d202      	bcs.n	80093e4 <chSysUnlock.lto_priv.217+0x28>
 80093de:	4804      	ldr	r0, [pc, #16]	; (80093f0 <chSysUnlock.lto_priv.217+0x34>)
 80093e0:	f000 fb0c 	bl	80099fc <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 80093e4:	f7ff ffb2 	bl	800934c <port_unlock.lto_priv.206>
}
 80093e8:	bd80      	pop	{r7, pc}
 80093ea:	bf00      	nop
 80093ec:	20001330 	.word	0x20001330
 80093f0:	0800cf68 	.word	0x0800cf68

080093f4 <chMtxQueueNotEmptyS>:
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 80093f4:	b580      	push	{r7, lr}
 80093f6:	b082      	sub	sp, #8
 80093f8:	af00      	add	r7, sp, #0
 80093fa:	6078      	str	r0, [r7, #4]

  chDbgCheckClassS();
 80093fc:	f000 fbee 	bl	8009bdc <chDbgCheckClassS>

  return queue_notempty(&mp->queue);
 8009400:	687b      	ldr	r3, [r7, #4]
 8009402:	4618      	mov	r0, r3
 8009404:	f7ff ffc0 	bl	8009388 <queue_notempty.lto_priv.222>
 8009408:	4603      	mov	r3, r0
}
 800940a:	4618      	mov	r0, r3
 800940c:	3708      	adds	r7, #8
 800940e:	46bd      	mov	sp, r7
 8009410:	bd80      	pop	{r7, pc}
 8009412:	bf00      	nop

08009414 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8009414:	b580      	push	{r7, lr}
 8009416:	b082      	sub	sp, #8
 8009418:	af00      	add	r7, sp, #0
 800941a:	6078      	str	r0, [r7, #4]

  chDbgCheck(mp != NULL);
 800941c:	687b      	ldr	r3, [r7, #4]
 800941e:	2b00      	cmp	r3, #0
 8009420:	d102      	bne.n	8009428 <chMtxObjectInit+0x14>
 8009422:	4808      	ldr	r0, [pc, #32]	; (8009444 <chMtxObjectInit+0x30>)
 8009424:	f000 faea 	bl	80099fc <chSysHalt>

  queue_init(&mp->queue);
 8009428:	687b      	ldr	r3, [r7, #4]
 800942a:	4618      	mov	r0, r3
 800942c:	f7ff ff9c 	bl	8009368 <queue_init.lto_priv.203>
  mp->owner = NULL;
 8009430:	687b      	ldr	r3, [r7, #4]
 8009432:	2200      	movs	r2, #0
 8009434:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
 8009436:	687b      	ldr	r3, [r7, #4]
 8009438:	2200      	movs	r2, #0
 800943a:	611a      	str	r2, [r3, #16]
#endif
}
 800943c:	3708      	adds	r7, #8
 800943e:	46bd      	mov	sp, r7
 8009440:	bd80      	pop	{r7, pc}
 8009442:	bf00      	nop
 8009444:	0800cf58 	.word	0x0800cf58

08009448 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8009448:	b580      	push	{r7, lr}
 800944a:	b084      	sub	sp, #16
 800944c:	af00      	add	r7, sp, #0
 800944e:	6078      	str	r0, [r7, #4]
  thread_t *ctp = currp;
 8009450:	4b46      	ldr	r3, [pc, #280]	; (800956c <chMtxLockS+0x124>)
 8009452:	699b      	ldr	r3, [r3, #24]
 8009454:	60bb      	str	r3, [r7, #8]

  chDbgCheckClassS();
 8009456:	f000 fbc1 	bl	8009bdc <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 800945a:	687b      	ldr	r3, [r7, #4]
 800945c:	2b00      	cmp	r3, #0
 800945e:	d102      	bne.n	8009466 <chMtxLockS+0x1e>
 8009460:	4843      	ldr	r0, [pc, #268]	; (8009570 <chMtxLockS+0x128>)
 8009462:	f000 facb 	bl	80099fc <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8009466:	687b      	ldr	r3, [r7, #4]
 8009468:	689b      	ldr	r3, [r3, #8]
 800946a:	2b00      	cmp	r3, #0
 800946c:	d065      	beq.n	800953a <chMtxLockS+0xf2>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE

    chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");
 800946e:	687b      	ldr	r3, [r7, #4]
 8009470:	691b      	ldr	r3, [r3, #16]
 8009472:	2b00      	cmp	r3, #0
 8009474:	dc02      	bgt.n	800947c <chMtxLockS+0x34>
 8009476:	483e      	ldr	r0, [pc, #248]	; (8009570 <chMtxLockS+0x128>)
 8009478:	f000 fac0 	bl	80099fc <chSysHalt>

    /* If the mutex is already owned by this thread, the counter is increased
       and there is no need of more actions.*/
    if (mp->owner == ctp) {
 800947c:	687b      	ldr	r3, [r7, #4]
 800947e:	689a      	ldr	r2, [r3, #8]
 8009480:	68bb      	ldr	r3, [r7, #8]
 8009482:	429a      	cmp	r2, r3
 8009484:	d105      	bne.n	8009492 <chMtxLockS+0x4a>
      mp->cnt++;
 8009486:	687b      	ldr	r3, [r7, #4]
 8009488:	691b      	ldr	r3, [r3, #16]
 800948a:	1c5a      	adds	r2, r3, #1
 800948c:	687b      	ldr	r3, [r7, #4]
 800948e:	611a      	str	r2, [r3, #16]
 8009490:	e069      	b.n	8009566 <chMtxLockS+0x11e>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
 8009492:	687b      	ldr	r3, [r7, #4]
 8009494:	689b      	ldr	r3, [r3, #8]
 8009496:	60fb      	str	r3, [r7, #12]
 8009498:	e026      	b.n	80094e8 <chMtxLockS+0xa0>

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 800949a:	68bb      	ldr	r3, [r7, #8]
 800949c:	689a      	ldr	r2, [r3, #8]
 800949e:	68fb      	ldr	r3, [r7, #12]
 80094a0:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 80094a2:	68fb      	ldr	r3, [r7, #12]
 80094a4:	f893 3020 	ldrb.w	r3, [r3, #32]
 80094a8:	2b00      	cmp	r3, #0
 80094aa:	d011      	beq.n	80094d0 <chMtxLockS+0x88>
 80094ac:	2b06      	cmp	r3, #6
 80094ae:	d000      	beq.n	80094b2 <chMtxLockS+0x6a>
 80094b0:	e020      	b.n	80094f4 <chMtxLockS+0xac>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 80094b2:	68f8      	ldr	r0, [r7, #12]
 80094b4:	f000 fdf4 	bl	800a0a0 <queue_dequeue>
 80094b8:	4602      	mov	r2, r0
 80094ba:	68fb      	ldr	r3, [r7, #12]
 80094bc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80094be:	4610      	mov	r0, r2
 80094c0:	4619      	mov	r1, r3
 80094c2:	f000 fd97 	bl	8009ff4 <queue_prio_insert>
          tp = tp->u.wtmtxp->owner;
 80094c6:	68fb      	ldr	r3, [r7, #12]
 80094c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80094ca:	689b      	ldr	r3, [r3, #8]
 80094cc:	60fb      	str	r3, [r7, #12]
 80094ce:	e00b      	b.n	80094e8 <chMtxLockS+0xa0>
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 80094d0:	68fb      	ldr	r3, [r7, #12]
 80094d2:	2201      	movs	r2, #1
 80094d4:	f883 2020 	strb.w	r2, [r3, #32]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 80094d8:	68f8      	ldr	r0, [r7, #12]
 80094da:	f000 fde1 	bl	800a0a0 <queue_dequeue>
 80094de:	4603      	mov	r3, r0
 80094e0:	4618      	mov	r0, r3
 80094e2:	f000 fdf3 	bl	800a0cc <chSchReadyI>
 80094e6:	e005      	b.n	80094f4 <chMtxLockS+0xac>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 80094e8:	68fb      	ldr	r3, [r7, #12]
 80094ea:	689a      	ldr	r2, [r3, #8]
 80094ec:	68bb      	ldr	r3, [r7, #8]
 80094ee:	689b      	ldr	r3, [r3, #8]
 80094f0:	429a      	cmp	r2, r3
 80094f2:	d3d2      	bcc.n	800949a <chMtxLockS+0x52>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
 80094f4:	687b      	ldr	r3, [r7, #4]
 80094f6:	68b8      	ldr	r0, [r7, #8]
 80094f8:	4619      	mov	r1, r3
 80094fa:	f000 fd7b 	bl	8009ff4 <queue_prio_insert>
      ctp->u.wtmtxp = mp;
 80094fe:	68bb      	ldr	r3, [r7, #8]
 8009500:	687a      	ldr	r2, [r7, #4]
 8009502:	625a      	str	r2, [r3, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8009504:	2006      	movs	r0, #6
 8009506:	f000 fe61 	bl	800a1cc <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 800950a:	687b      	ldr	r3, [r7, #4]
 800950c:	689a      	ldr	r2, [r3, #8]
 800950e:	68bb      	ldr	r3, [r7, #8]
 8009510:	429a      	cmp	r2, r3
 8009512:	d002      	beq.n	800951a <chMtxLockS+0xd2>
 8009514:	4816      	ldr	r0, [pc, #88]	; (8009570 <chMtxLockS+0x128>)
 8009516:	f000 fa71 	bl	80099fc <chSysHalt>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 800951a:	68bb      	ldr	r3, [r7, #8]
 800951c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800951e:	687b      	ldr	r3, [r7, #4]
 8009520:	429a      	cmp	r2, r3
 8009522:	d002      	beq.n	800952a <chMtxLockS+0xe2>
 8009524:	4812      	ldr	r0, [pc, #72]	; (8009570 <chMtxLockS+0x128>)
 8009526:	f000 fa69 	bl	80099fc <chSysHalt>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      chDbgAssert(mp->cnt == (cnt_t)1, "counter is not one");
 800952a:	687b      	ldr	r3, [r7, #4]
 800952c:	691b      	ldr	r3, [r3, #16]
 800952e:	2b01      	cmp	r3, #1
 8009530:	d019      	beq.n	8009566 <chMtxLockS+0x11e>
 8009532:	480f      	ldr	r0, [pc, #60]	; (8009570 <chMtxLockS+0x128>)
 8009534:	f000 fa62 	bl	80099fc <chSysHalt>
 8009538:	e015      	b.n	8009566 <chMtxLockS+0x11e>
    }
#endif
  }
  else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");
 800953a:	687b      	ldr	r3, [r7, #4]
 800953c:	691b      	ldr	r3, [r3, #16]
 800953e:	2b00      	cmp	r3, #0
 8009540:	d002      	beq.n	8009548 <chMtxLockS+0x100>
 8009542:	480b      	ldr	r0, [pc, #44]	; (8009570 <chMtxLockS+0x128>)
 8009544:	f000 fa5a 	bl	80099fc <chSysHalt>

    mp->cnt++;
 8009548:	687b      	ldr	r3, [r7, #4]
 800954a:	691b      	ldr	r3, [r3, #16]
 800954c:	1c5a      	adds	r2, r3, #1
 800954e:	687b      	ldr	r3, [r7, #4]
 8009550:	611a      	str	r2, [r3, #16]
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 8009552:	687b      	ldr	r3, [r7, #4]
 8009554:	68ba      	ldr	r2, [r7, #8]
 8009556:	609a      	str	r2, [r3, #8]
    mp->next = ctp->mtxlist;
 8009558:	68bb      	ldr	r3, [r7, #8]
 800955a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800955c:	687b      	ldr	r3, [r7, #4]
 800955e:	60da      	str	r2, [r3, #12]
    ctp->mtxlist = mp;
 8009560:	68bb      	ldr	r3, [r7, #8]
 8009562:	687a      	ldr	r2, [r7, #4]
 8009564:	629a      	str	r2, [r3, #40]	; 0x28
  }
}
 8009566:	3710      	adds	r7, #16
 8009568:	46bd      	mov	sp, r7
 800956a:	bd80      	pop	{r7, pc}
 800956c:	20001330 	.word	0x20001330
 8009570:	0800cf74 	.word	0x0800cf74

08009574 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8009574:	b580      	push	{r7, lr}
 8009576:	b086      	sub	sp, #24
 8009578:	af00      	add	r7, sp, #0
 800957a:	6078      	str	r0, [r7, #4]
  thread_t *ctp = currp;
 800957c:	4b3e      	ldr	r3, [pc, #248]	; (8009678 <chMtxUnlock+0x104>)
 800957e:	699b      	ldr	r3, [r3, #24]
 8009580:	60fb      	str	r3, [r7, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 8009582:	687b      	ldr	r3, [r7, #4]
 8009584:	2b00      	cmp	r3, #0
 8009586:	d102      	bne.n	800958e <chMtxUnlock+0x1a>
 8009588:	483c      	ldr	r0, [pc, #240]	; (800967c <chMtxUnlock+0x108>)
 800958a:	f000 fa37 	bl	80099fc <chSysHalt>

  chSysLock();
 800958e:	f7ff ff0d 	bl	80093ac <chSysLock.lto_priv.220>

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8009592:	68fb      	ldr	r3, [r7, #12]
 8009594:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009596:	2b00      	cmp	r3, #0
 8009598:	d102      	bne.n	80095a0 <chMtxUnlock+0x2c>
 800959a:	4838      	ldr	r0, [pc, #224]	; (800967c <chMtxUnlock+0x108>)
 800959c:	f000 fa2e 	bl	80099fc <chSysHalt>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 80095a0:	68fb      	ldr	r3, [r7, #12]
 80095a2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80095a4:	689a      	ldr	r2, [r3, #8]
 80095a6:	68fb      	ldr	r3, [r7, #12]
 80095a8:	429a      	cmp	r2, r3
 80095aa:	d002      	beq.n	80095b2 <chMtxUnlock+0x3e>
 80095ac:	4833      	ldr	r0, [pc, #204]	; (800967c <chMtxUnlock+0x108>)
 80095ae:	f000 fa25 	bl	80099fc <chSysHalt>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");
 80095b2:	687b      	ldr	r3, [r7, #4]
 80095b4:	691b      	ldr	r3, [r3, #16]
 80095b6:	2b00      	cmp	r3, #0
 80095b8:	dc02      	bgt.n	80095c0 <chMtxUnlock+0x4c>
 80095ba:	4830      	ldr	r0, [pc, #192]	; (800967c <chMtxUnlock+0x108>)
 80095bc:	f000 fa1e 	bl	80099fc <chSysHalt>

  if (--mp->cnt == (cnt_t)0) {
 80095c0:	687b      	ldr	r3, [r7, #4]
 80095c2:	691b      	ldr	r3, [r3, #16]
 80095c4:	1e5a      	subs	r2, r3, #1
 80095c6:	687b      	ldr	r3, [r7, #4]
 80095c8:	611a      	str	r2, [r3, #16]
 80095ca:	687b      	ldr	r3, [r7, #4]
 80095cc:	691b      	ldr	r3, [r3, #16]
 80095ce:	2b00      	cmp	r3, #0
 80095d0:	d14c      	bne.n	800966c <chMtxUnlock+0xf8>
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 80095d2:	68fb      	ldr	r3, [r7, #12]
 80095d4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80095d6:	687b      	ldr	r3, [r7, #4]
 80095d8:	429a      	cmp	r2, r3
 80095da:	d002      	beq.n	80095e2 <chMtxUnlock+0x6e>
 80095dc:	4827      	ldr	r0, [pc, #156]	; (800967c <chMtxUnlock+0x108>)
 80095de:	f000 fa0d 	bl	80099fc <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 80095e2:	687b      	ldr	r3, [r7, #4]
 80095e4:	68da      	ldr	r2, [r3, #12]
 80095e6:	68fb      	ldr	r3, [r7, #12]
 80095e8:	629a      	str	r2, [r3, #40]	; 0x28

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80095ea:	6878      	ldr	r0, [r7, #4]
 80095ec:	f7ff ff02 	bl	80093f4 <chMtxQueueNotEmptyS>
 80095f0:	4603      	mov	r3, r0
 80095f2:	2b00      	cmp	r3, #0
 80095f4:	d037      	beq.n	8009666 <chMtxUnlock+0xf2>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 80095f6:	68fb      	ldr	r3, [r7, #12]
 80095f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80095fa:	613b      	str	r3, [r7, #16]
      lmp = ctp->mtxlist;
 80095fc:	68fb      	ldr	r3, [r7, #12]
 80095fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009600:	617b      	str	r3, [r7, #20]
 8009602:	e012      	b.n	800962a <chMtxUnlock+0xb6>
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8009604:	6978      	ldr	r0, [r7, #20]
 8009606:	f7ff fef5 	bl	80093f4 <chMtxQueueNotEmptyS>
 800960a:	4603      	mov	r3, r0
 800960c:	2b00      	cmp	r3, #0
 800960e:	d009      	beq.n	8009624 <chMtxUnlock+0xb0>
            (lmp->queue.next->prio > newprio)) {
 8009610:	697b      	ldr	r3, [r7, #20]
 8009612:	681b      	ldr	r3, [r3, #0]
 8009614:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8009616:	693b      	ldr	r3, [r7, #16]
 8009618:	429a      	cmp	r2, r3
 800961a:	d903      	bls.n	8009624 <chMtxUnlock+0xb0>
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
 800961c:	697b      	ldr	r3, [r7, #20]
 800961e:	681b      	ldr	r3, [r3, #0]
 8009620:	689b      	ldr	r3, [r3, #8]
 8009622:	613b      	str	r3, [r7, #16]
        }
        lmp = lmp->next;
 8009624:	697b      	ldr	r3, [r7, #20]
 8009626:	68db      	ldr	r3, [r3, #12]
 8009628:	617b      	str	r3, [r7, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 800962a:	697b      	ldr	r3, [r7, #20]
 800962c:	2b00      	cmp	r3, #0
 800962e:	d1e9      	bne.n	8009604 <chMtxUnlock+0x90>
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 8009630:	68fb      	ldr	r3, [r7, #12]
 8009632:	693a      	ldr	r2, [r7, #16]
 8009634:	609a      	str	r2, [r3, #8]

      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
 8009636:	687b      	ldr	r3, [r7, #4]
 8009638:	2201      	movs	r2, #1
 800963a:	611a      	str	r2, [r3, #16]
#endif
      tp = queue_fifo_remove(&mp->queue);
 800963c:	687b      	ldr	r3, [r7, #4]
 800963e:	4618      	mov	r0, r3
 8009640:	f000 fd18 	bl	800a074 <queue_fifo_remove>
 8009644:	60b8      	str	r0, [r7, #8]
      mp->owner = tp;
 8009646:	687b      	ldr	r3, [r7, #4]
 8009648:	68ba      	ldr	r2, [r7, #8]
 800964a:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 800964c:	68bb      	ldr	r3, [r7, #8]
 800964e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8009650:	687b      	ldr	r3, [r7, #4]
 8009652:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 8009654:	68bb      	ldr	r3, [r7, #8]
 8009656:	687a      	ldr	r2, [r7, #4]
 8009658:	629a      	str	r2, [r3, #40]	; 0x28

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 800965a:	68b8      	ldr	r0, [r7, #8]
 800965c:	f000 fd36 	bl	800a0cc <chSchReadyI>
      chSchRescheduleS();
 8009660:	f000 fe9a 	bl	800a398 <chSchRescheduleS>
 8009664:	e002      	b.n	800966c <chMtxUnlock+0xf8>
    }
    else {
      mp->owner = NULL;
 8009666:	687b      	ldr	r3, [r7, #4]
 8009668:	2200      	movs	r2, #0
 800966a:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 800966c:	f7ff fea6 	bl	80093bc <chSysUnlock.lto_priv.217>
}
 8009670:	3718      	adds	r7, #24
 8009672:	46bd      	mov	sp, r7
 8009674:	bd80      	pop	{r7, pc}
 8009676:	bf00      	nop
 8009678:	20001330 	.word	0x20001330
 800967c:	0800cf80 	.word	0x0800cf80

08009680 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8009680:	b580      	push	{r7, lr}
 8009682:	b086      	sub	sp, #24
 8009684:	af00      	add	r7, sp, #0
 8009686:	6078      	str	r0, [r7, #4]
  thread_t *ctp = currp;
 8009688:	4b3c      	ldr	r3, [pc, #240]	; (800977c <chMtxUnlockS+0xfc>)
 800968a:	699b      	ldr	r3, [r3, #24]
 800968c:	60fb      	str	r3, [r7, #12]
  mutex_t *lmp;

  chDbgCheckClassS();
 800968e:	f000 faa5 	bl	8009bdc <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8009692:	687b      	ldr	r3, [r7, #4]
 8009694:	2b00      	cmp	r3, #0
 8009696:	d102      	bne.n	800969e <chMtxUnlockS+0x1e>
 8009698:	4839      	ldr	r0, [pc, #228]	; (8009780 <chMtxUnlockS+0x100>)
 800969a:	f000 f9af 	bl	80099fc <chSysHalt>

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 800969e:	68fb      	ldr	r3, [r7, #12]
 80096a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80096a2:	2b00      	cmp	r3, #0
 80096a4:	d102      	bne.n	80096ac <chMtxUnlockS+0x2c>
 80096a6:	4836      	ldr	r0, [pc, #216]	; (8009780 <chMtxUnlockS+0x100>)
 80096a8:	f000 f9a8 	bl	80099fc <chSysHalt>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 80096ac:	68fb      	ldr	r3, [r7, #12]
 80096ae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80096b0:	689a      	ldr	r2, [r3, #8]
 80096b2:	68fb      	ldr	r3, [r7, #12]
 80096b4:	429a      	cmp	r2, r3
 80096b6:	d002      	beq.n	80096be <chMtxUnlockS+0x3e>
 80096b8:	4831      	ldr	r0, [pc, #196]	; (8009780 <chMtxUnlockS+0x100>)
 80096ba:	f000 f99f 	bl	80099fc <chSysHalt>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");
 80096be:	687b      	ldr	r3, [r7, #4]
 80096c0:	691b      	ldr	r3, [r3, #16]
 80096c2:	2b00      	cmp	r3, #0
 80096c4:	dc02      	bgt.n	80096cc <chMtxUnlockS+0x4c>
 80096c6:	482e      	ldr	r0, [pc, #184]	; (8009780 <chMtxUnlockS+0x100>)
 80096c8:	f000 f998 	bl	80099fc <chSysHalt>

  if (--mp->cnt == (cnt_t)0) {
 80096cc:	687b      	ldr	r3, [r7, #4]
 80096ce:	691b      	ldr	r3, [r3, #16]
 80096d0:	1e5a      	subs	r2, r3, #1
 80096d2:	687b      	ldr	r3, [r7, #4]
 80096d4:	611a      	str	r2, [r3, #16]
 80096d6:	687b      	ldr	r3, [r7, #4]
 80096d8:	691b      	ldr	r3, [r3, #16]
 80096da:	2b00      	cmp	r3, #0
 80096dc:	d14a      	bne.n	8009774 <chMtxUnlockS+0xf4>
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 80096de:	68fb      	ldr	r3, [r7, #12]
 80096e0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80096e2:	687b      	ldr	r3, [r7, #4]
 80096e4:	429a      	cmp	r2, r3
 80096e6:	d002      	beq.n	80096ee <chMtxUnlockS+0x6e>
 80096e8:	4825      	ldr	r0, [pc, #148]	; (8009780 <chMtxUnlockS+0x100>)
 80096ea:	f000 f987 	bl	80099fc <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 80096ee:	687b      	ldr	r3, [r7, #4]
 80096f0:	68da      	ldr	r2, [r3, #12]
 80096f2:	68fb      	ldr	r3, [r7, #12]
 80096f4:	629a      	str	r2, [r3, #40]	; 0x28

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80096f6:	6878      	ldr	r0, [r7, #4]
 80096f8:	f7ff fe7c 	bl	80093f4 <chMtxQueueNotEmptyS>
 80096fc:	4603      	mov	r3, r0
 80096fe:	2b00      	cmp	r3, #0
 8009700:	d035      	beq.n	800976e <chMtxUnlockS+0xee>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8009702:	68fb      	ldr	r3, [r7, #12]
 8009704:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009706:	613b      	str	r3, [r7, #16]
      lmp = ctp->mtxlist;
 8009708:	68fb      	ldr	r3, [r7, #12]
 800970a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800970c:	617b      	str	r3, [r7, #20]
 800970e:	e012      	b.n	8009736 <chMtxUnlockS+0xb6>
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8009710:	6978      	ldr	r0, [r7, #20]
 8009712:	f7ff fe6f 	bl	80093f4 <chMtxQueueNotEmptyS>
 8009716:	4603      	mov	r3, r0
 8009718:	2b00      	cmp	r3, #0
 800971a:	d009      	beq.n	8009730 <chMtxUnlockS+0xb0>
            (lmp->queue.next->prio > newprio)) {
 800971c:	697b      	ldr	r3, [r7, #20]
 800971e:	681b      	ldr	r3, [r3, #0]
 8009720:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8009722:	693b      	ldr	r3, [r7, #16]
 8009724:	429a      	cmp	r2, r3
 8009726:	d903      	bls.n	8009730 <chMtxUnlockS+0xb0>
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
 8009728:	697b      	ldr	r3, [r7, #20]
 800972a:	681b      	ldr	r3, [r3, #0]
 800972c:	689b      	ldr	r3, [r3, #8]
 800972e:	613b      	str	r3, [r7, #16]
        }
        lmp = lmp->next;
 8009730:	697b      	ldr	r3, [r7, #20]
 8009732:	68db      	ldr	r3, [r3, #12]
 8009734:	617b      	str	r3, [r7, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8009736:	697b      	ldr	r3, [r7, #20]
 8009738:	2b00      	cmp	r3, #0
 800973a:	d1e9      	bne.n	8009710 <chMtxUnlockS+0x90>
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 800973c:	68fb      	ldr	r3, [r7, #12]
 800973e:	693a      	ldr	r2, [r7, #16]
 8009740:	609a      	str	r2, [r3, #8]

      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
 8009742:	687b      	ldr	r3, [r7, #4]
 8009744:	2201      	movs	r2, #1
 8009746:	611a      	str	r2, [r3, #16]
#endif
      tp = queue_fifo_remove(&mp->queue);
 8009748:	687b      	ldr	r3, [r7, #4]
 800974a:	4618      	mov	r0, r3
 800974c:	f000 fc92 	bl	800a074 <queue_fifo_remove>
 8009750:	60b8      	str	r0, [r7, #8]
      mp->owner = tp;
 8009752:	687b      	ldr	r3, [r7, #4]
 8009754:	68ba      	ldr	r2, [r7, #8]
 8009756:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 8009758:	68bb      	ldr	r3, [r7, #8]
 800975a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800975c:	687b      	ldr	r3, [r7, #4]
 800975e:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 8009760:	68bb      	ldr	r3, [r7, #8]
 8009762:	687a      	ldr	r2, [r7, #4]
 8009764:	629a      	str	r2, [r3, #40]	; 0x28
      (void) chSchReadyI(tp);
 8009766:	68b8      	ldr	r0, [r7, #8]
 8009768:	f000 fcb0 	bl	800a0cc <chSchReadyI>
 800976c:	e002      	b.n	8009774 <chMtxUnlockS+0xf4>
    }
    else {
      mp->owner = NULL;
 800976e:	687b      	ldr	r3, [r7, #4]
 8009770:	2200      	movs	r2, #0
 8009772:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 8009774:	3718      	adds	r7, #24
 8009776:	46bd      	mov	sp, r7
 8009778:	bd80      	pop	{r7, pc}
 800977a:	bf00      	nop
 800977c:	20001330 	.word	0x20001330
 8009780:	0800cf8c 	.word	0x0800cf8c

08009784 <port_lock.lto_priv.210>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8009784:	b480      	push	{r7}
 8009786:	b083      	sub	sp, #12
 8009788:	af00      	add	r7, sp, #0
 800978a:	2320      	movs	r3, #32
 800978c:	607b      	str	r3, [r7, #4]
 800978e:	687b      	ldr	r3, [r7, #4]
 8009790:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8009794:	370c      	adds	r7, #12
 8009796:	46bd      	mov	sp, r7
 8009798:	f85d 7b04 	ldr.w	r7, [sp], #4
 800979c:	4770      	bx	lr
 800979e:	bf00      	nop

080097a0 <port_unlock.lto_priv.207>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80097a0:	b480      	push	{r7}
 80097a2:	b083      	sub	sp, #12
 80097a4:	af00      	add	r7, sp, #0
 80097a6:	2300      	movs	r3, #0
 80097a8:	607b      	str	r3, [r7, #4]
 80097aa:	687b      	ldr	r3, [r7, #4]
 80097ac:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80097b0:	370c      	adds	r7, #12
 80097b2:	46bd      	mov	sp, r7
 80097b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80097b8:	4770      	bx	lr
 80097ba:	bf00      	nop

080097bc <queue_init.lto_priv.204>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80097bc:	b480      	push	{r7}
 80097be:	b083      	sub	sp, #12
 80097c0:	af00      	add	r7, sp, #0
 80097c2:	6078      	str	r0, [r7, #4]

  tqp->next = (thread_t *)tqp;
 80097c4:	687b      	ldr	r3, [r7, #4]
 80097c6:	687a      	ldr	r2, [r7, #4]
 80097c8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80097ca:	687b      	ldr	r3, [r7, #4]
 80097cc:	687a      	ldr	r2, [r7, #4]
 80097ce:	605a      	str	r2, [r3, #4]
}
 80097d0:	370c      	adds	r7, #12
 80097d2:	46bd      	mov	sp, r7
 80097d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80097d8:	4770      	bx	lr
 80097da:	bf00      	nop

080097dc <chSysLock.lto_priv.163>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80097dc:	b580      	push	{r7, lr}
 80097de:	af00      	add	r7, sp, #0

  port_lock();
 80097e0:	f7ff ffd0 	bl	8009784 <port_lock.lto_priv.210>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80097e4:	f000 f958 	bl	8009a98 <_dbg_check_lock>
}
 80097e8:	bd80      	pop	{r7, pc}
 80097ea:	bf00      	nop

080097ec <chSysUnlock.lto_priv.158>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80097ec:	b580      	push	{r7, lr}
 80097ee:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 80097f0:	f000 f968 	bl	8009ac4 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80097f4:	4b09      	ldr	r3, [pc, #36]	; (800981c <chSysUnlock.lto_priv.158+0x30>)
 80097f6:	681b      	ldr	r3, [r3, #0]
 80097f8:	4a08      	ldr	r2, [pc, #32]	; (800981c <chSysUnlock.lto_priv.158+0x30>)
 80097fa:	4293      	cmp	r3, r2
 80097fc:	d00a      	beq.n	8009814 <chSysUnlock.lto_priv.158+0x28>
 80097fe:	4b07      	ldr	r3, [pc, #28]	; (800981c <chSysUnlock.lto_priv.158+0x30>)
 8009800:	699b      	ldr	r3, [r3, #24]
 8009802:	689a      	ldr	r2, [r3, #8]
 8009804:	4b05      	ldr	r3, [pc, #20]	; (800981c <chSysUnlock.lto_priv.158+0x30>)
 8009806:	681b      	ldr	r3, [r3, #0]
 8009808:	689b      	ldr	r3, [r3, #8]
 800980a:	429a      	cmp	r2, r3
 800980c:	d202      	bcs.n	8009814 <chSysUnlock.lto_priv.158+0x28>
 800980e:	4804      	ldr	r0, [pc, #16]	; (8009820 <chSysUnlock.lto_priv.158+0x34>)
 8009810:	f000 f8f4 	bl	80099fc <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8009814:	f7ff ffc4 	bl	80097a0 <port_unlock.lto_priv.207>
}
 8009818:	bd80      	pop	{r7, pc}
 800981a:	bf00      	nop
 800981c:	20001330 	.word	0x20001330
 8009820:	0800cfac 	.word	0x0800cfac

08009824 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8009824:	b580      	push	{r7, lr}
 8009826:	b082      	sub	sp, #8
 8009828:	af00      	add	r7, sp, #0
 800982a:	6078      	str	r0, [r7, #4]

  queue_init(tqp);
 800982c:	6878      	ldr	r0, [r7, #4]
 800982e:	f7ff ffc5 	bl	80097bc <queue_init.lto_priv.204>
}
 8009832:	3708      	adds	r7, #8
 8009834:	46bd      	mov	sp, r7
 8009836:	bd80      	pop	{r7, pc}

08009838 <chMBGetSizeI>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The size of the mailbox.
 *
 * @iclass
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {
 8009838:	b480      	push	{r7}
 800983a:	b083      	sub	sp, #12
 800983c:	af00      	add	r7, sp, #0
 800983e:	6078      	str	r0, [r7, #4]

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 8009840:	687b      	ldr	r3, [r7, #4]
 8009842:	685b      	ldr	r3, [r3, #4]
 8009844:	461a      	mov	r2, r3
 8009846:	687b      	ldr	r3, [r7, #4]
 8009848:	681b      	ldr	r3, [r3, #0]
 800984a:	1ad3      	subs	r3, r2, r3
 800984c:	109b      	asrs	r3, r3, #2
  /*lint -restore*/
}
 800984e:	4618      	mov	r0, r3
 8009850:	370c      	adds	r7, #12
 8009852:	46bd      	mov	sp, r7
 8009854:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009858:	4770      	bx	lr
 800985a:	bf00      	nop

0800985c <chMBGetUsedCountI.lto_priv.198>:
 * @return              The number of queued messages.
 * @retval QUEUE_RESET  if the queue is in reset state.
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(const mailbox_t *mbp) {
 800985c:	b580      	push	{r7, lr}
 800985e:	b082      	sub	sp, #8
 8009860:	af00      	add	r7, sp, #0
 8009862:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 8009864:	f000 f9a8 	bl	8009bb8 <chDbgCheckClassI>

  return mbp->cnt;
 8009868:	687b      	ldr	r3, [r7, #4]
 800986a:	691b      	ldr	r3, [r3, #16]
}
 800986c:	4618      	mov	r0, r3
 800986e:	3708      	adds	r7, #8
 8009870:	46bd      	mov	sp, r7
 8009872:	bd80      	pop	{r7, pc}

08009874 <chMBGetFreeCountI.lto_priv.199>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {
 8009874:	b590      	push	{r4, r7, lr}
 8009876:	b083      	sub	sp, #12
 8009878:	af00      	add	r7, sp, #0
 800987a:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 800987c:	f000 f99c 	bl	8009bb8 <chDbgCheckClassI>

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8009880:	6878      	ldr	r0, [r7, #4]
 8009882:	f7ff ffd9 	bl	8009838 <chMBGetSizeI>
 8009886:	4604      	mov	r4, r0
 8009888:	6878      	ldr	r0, [r7, #4]
 800988a:	f7ff ffe7 	bl	800985c <chMBGetUsedCountI.lto_priv.198>
 800988e:	4603      	mov	r3, r0
 8009890:	1ae3      	subs	r3, r4, r3
}
 8009892:	4618      	mov	r0, r3
 8009894:	370c      	adds	r7, #12
 8009896:	46bd      	mov	sp, r7
 8009898:	bd90      	pop	{r4, r7, pc}
 800989a:	bf00      	nop

0800989c <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
 800989c:	b580      	push	{r7, lr}
 800989e:	b084      	sub	sp, #16
 80098a0:	af00      	add	r7, sp, #0
 80098a2:	60f8      	str	r0, [r7, #12]
 80098a4:	60b9      	str	r1, [r7, #8]
 80098a6:	607a      	str	r2, [r7, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));
 80098a8:	68fb      	ldr	r3, [r7, #12]
 80098aa:	2b00      	cmp	r3, #0
 80098ac:	d005      	beq.n	80098ba <chMBObjectInit+0x1e>
 80098ae:	68bb      	ldr	r3, [r7, #8]
 80098b0:	2b00      	cmp	r3, #0
 80098b2:	d002      	beq.n	80098ba <chMBObjectInit+0x1e>
 80098b4:	687b      	ldr	r3, [r7, #4]
 80098b6:	2b00      	cmp	r3, #0
 80098b8:	dc02      	bgt.n	80098c0 <chMBObjectInit+0x24>
 80098ba:	4812      	ldr	r0, [pc, #72]	; (8009904 <chMBObjectInit+0x68>)
 80098bc:	f000 f89e 	bl	80099fc <chSysHalt>

  mbp->buffer = buf;
 80098c0:	68fb      	ldr	r3, [r7, #12]
 80098c2:	68ba      	ldr	r2, [r7, #8]
 80098c4:	601a      	str	r2, [r3, #0]
  mbp->rdptr  = buf;
 80098c6:	68fb      	ldr	r3, [r7, #12]
 80098c8:	68ba      	ldr	r2, [r7, #8]
 80098ca:	60da      	str	r2, [r3, #12]
  mbp->wrptr  = buf;
 80098cc:	68fb      	ldr	r3, [r7, #12]
 80098ce:	68ba      	ldr	r2, [r7, #8]
 80098d0:	609a      	str	r2, [r3, #8]
  mbp->top    = &buf[n];
 80098d2:	687b      	ldr	r3, [r7, #4]
 80098d4:	009b      	lsls	r3, r3, #2
 80098d6:	68ba      	ldr	r2, [r7, #8]
 80098d8:	441a      	add	r2, r3
 80098da:	68fb      	ldr	r3, [r7, #12]
 80098dc:	605a      	str	r2, [r3, #4]
  mbp->cnt    = (cnt_t)0;
 80098de:	68fb      	ldr	r3, [r7, #12]
 80098e0:	2200      	movs	r2, #0
 80098e2:	611a      	str	r2, [r3, #16]
  mbp->reset  = false;
 80098e4:	68fb      	ldr	r3, [r7, #12]
 80098e6:	2200      	movs	r2, #0
 80098e8:	751a      	strb	r2, [r3, #20]
  chThdQueueObjectInit(&mbp->qw);
 80098ea:	68fb      	ldr	r3, [r7, #12]
 80098ec:	3318      	adds	r3, #24
 80098ee:	4618      	mov	r0, r3
 80098f0:	f7ff ff98 	bl	8009824 <chThdQueueObjectInit>
  chThdQueueObjectInit(&mbp->qr);
 80098f4:	68fb      	ldr	r3, [r7, #12]
 80098f6:	3320      	adds	r3, #32
 80098f8:	4618      	mov	r0, r3
 80098fa:	f7ff ff93 	bl	8009824 <chThdQueueObjectInit>
}
 80098fe:	3710      	adds	r7, #16
 8009900:	46bd      	mov	sp, r7
 8009902:	bd80      	pop	{r7, pc}
 8009904:	0800cf9c 	.word	0x0800cf9c

08009908 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8009908:	b580      	push	{r7, lr}
 800990a:	b082      	sub	sp, #8
 800990c:	af00      	add	r7, sp, #0
 800990e:	6078      	str	r0, [r7, #4]
 8009910:	6039      	str	r1, [r7, #0]

  chDbgCheckClassI();
 8009912:	f000 f951 	bl	8009bb8 <chDbgCheckClassI>
  chDbgCheck(mbp != NULL);
 8009916:	687b      	ldr	r3, [r7, #4]
 8009918:	2b00      	cmp	r3, #0
 800991a:	d102      	bne.n	8009922 <chMBPostI+0x1a>
 800991c:	4819      	ldr	r0, [pc, #100]	; (8009984 <chMBPostI+0x7c>)
 800991e:	f000 f86d 	bl	80099fc <chSysHalt>

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8009922:	687b      	ldr	r3, [r7, #4]
 8009924:	7d1b      	ldrb	r3, [r3, #20]
 8009926:	2b00      	cmp	r3, #0
 8009928:	d002      	beq.n	8009930 <chMBPostI+0x28>
    return MSG_RESET;
 800992a:	f06f 0301 	mvn.w	r3, #1
 800992e:	e025      	b.n	800997c <chMBPostI+0x74>
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
 8009930:	6878      	ldr	r0, [r7, #4]
 8009932:	f7ff ff9f 	bl	8009874 <chMBGetFreeCountI.lto_priv.199>
 8009936:	4603      	mov	r3, r0
 8009938:	2b00      	cmp	r3, #0
 800993a:	dd1d      	ble.n	8009978 <chMBPostI+0x70>
    *mbp->wrptr++ = msg;
 800993c:	687b      	ldr	r3, [r7, #4]
 800993e:	689b      	ldr	r3, [r3, #8]
 8009940:	1d19      	adds	r1, r3, #4
 8009942:	687a      	ldr	r2, [r7, #4]
 8009944:	6091      	str	r1, [r2, #8]
 8009946:	683a      	ldr	r2, [r7, #0]
 8009948:	601a      	str	r2, [r3, #0]
    if (mbp->wrptr >= mbp->top) {
 800994a:	687b      	ldr	r3, [r7, #4]
 800994c:	689a      	ldr	r2, [r3, #8]
 800994e:	687b      	ldr	r3, [r7, #4]
 8009950:	685b      	ldr	r3, [r3, #4]
 8009952:	429a      	cmp	r2, r3
 8009954:	d303      	bcc.n	800995e <chMBPostI+0x56>
      mbp->wrptr = mbp->buffer;
 8009956:	687b      	ldr	r3, [r7, #4]
 8009958:	681a      	ldr	r2, [r3, #0]
 800995a:	687b      	ldr	r3, [r7, #4]
 800995c:	609a      	str	r2, [r3, #8]
    }
    mbp->cnt++;
 800995e:	687b      	ldr	r3, [r7, #4]
 8009960:	691b      	ldr	r3, [r3, #16]
 8009962:	1c5a      	adds	r2, r3, #1
 8009964:	687b      	ldr	r3, [r7, #4]
 8009966:	611a      	str	r2, [r3, #16]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8009968:	687b      	ldr	r3, [r7, #4]
 800996a:	3320      	adds	r3, #32
 800996c:	4618      	mov	r0, r3
 800996e:	2100      	movs	r1, #0
 8009970:	f7ff fc3a 	bl	80091e8 <chThdDequeueNextI>

    return MSG_OK;
 8009974:	2300      	movs	r3, #0
 8009976:	e001      	b.n	800997c <chMBPostI+0x74>
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
 8009978:	f04f 33ff 	mov.w	r3, #4294967295
}
 800997c:	4618      	mov	r0, r3
 800997e:	3708      	adds	r7, #8
 8009980:	46bd      	mov	sp, r7
 8009982:	bd80      	pop	{r7, pc}
 8009984:	0800cfb8 	.word	0x0800cfb8

08009988 <_idle_thread.lto_priv.31>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8009988:	b580      	push	{r7, lr}
 800998a:	b082      	sub	sp, #8
 800998c:	af00      	add	r7, sp, #0
 800998e:	6078      	str	r0, [r7, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8009990:	f001 fbd4 	bl	800b13c <port_wait_for_interrupt.lto_priv.273>
 8009994:	e7fc      	b.n	8009990 <_idle_thread.lto_priv.31+0x8>
 8009996:	bf00      	nop

08009998 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8009998:	b580      	push	{r7, lr}
 800999a:	af00      	add	r7, sp, #0

  _scheduler_init();
 800999c:	f000 fb18 	bl	8009fd0 <_scheduler_init>
  _vt_init();
 80099a0:	f000 f968 	bl	8009c74 <_vt_init>
  _trace_init();

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
 80099a4:	4b10      	ldr	r3, [pc, #64]	; (80099e8 <chSysInit+0x50>)
 80099a6:	2200      	movs	r2, #0
 80099a8:	62da      	str	r2, [r3, #44]	; 0x2c
  ch.dbg.lock_cnt = (cnt_t)0;
 80099aa:	4b0f      	ldr	r3, [pc, #60]	; (80099e8 <chSysInit+0x50>)
 80099ac:	2200      	movs	r2, #0
 80099ae:	631a      	str	r2, [r3, #48]	; 0x30
#endif
#if CH_CFG_USE_TM == TRUE
  _tm_init();
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 80099b0:	f7ff f83e 	bl	8008a30 <_core_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 80099b4:	480d      	ldr	r0, [pc, #52]	; (80099ec <chSysInit+0x54>)
 80099b6:	490e      	ldr	r1, [pc, #56]	; (80099f0 <chSysInit+0x58>)
 80099b8:	2280      	movs	r2, #128	; 0x80
 80099ba:	f7ff fa5d 	bl	8008e78 <_thread_init>
 80099be:	4602      	mov	r2, r0
 80099c0:	4b09      	ldr	r3, [pc, #36]	; (80099e8 <chSysInit+0x50>)
 80099c2:	619a      	str	r2, [r3, #24]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 80099c4:	4b08      	ldr	r3, [pc, #32]	; (80099e8 <chSysInit+0x50>)
 80099c6:	699b      	ldr	r3, [r3, #24]
 80099c8:	4a0a      	ldr	r2, [pc, #40]	; (80099f4 <chSysInit+0x5c>)
 80099ca:	61da      	str	r2, [r3, #28]
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 80099cc:	4b06      	ldr	r3, [pc, #24]	; (80099e8 <chSysInit+0x50>)
 80099ce:	699b      	ldr	r3, [r3, #24]
 80099d0:	2201      	movs	r2, #1
 80099d2:	f883 2020 	strb.w	r2, [r3, #32]

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
 80099d6:	f001 fb53 	bl	800b080 <port_init.lto_priv.272>
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->stats);
#endif

  /* It is alive now.*/
  chSysEnable();
 80099da:	f001 fbdb 	bl	800b194 <chSysEnable.lto_priv.271>
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
 80099de:	4806      	ldr	r0, [pc, #24]	; (80099f8 <chSysInit+0x60>)
 80099e0:	f7ff fae2 	bl	8008fa8 <chThdCreate>
  }
#endif
}
 80099e4:	bd80      	pop	{r7, pc}
 80099e6:	bf00      	nop
 80099e8:	20001330 	.word	0x20001330
 80099ec:	20001364 	.word	0x20001364
 80099f0:	0800cf34 	.word	0x0800cf34
 80099f4:	20000500 	.word	0x20000500
 80099f8:	0800ce28 	.word	0x0800ce28

080099fc <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 80099fc:	b580      	push	{r7, lr}
 80099fe:	b082      	sub	sp, #8
 8009a00:	af00      	add	r7, sp, #0
 8009a02:	6078      	str	r0, [r7, #4]

  port_disable();
 8009a04:	f001 fb84 	bl	800b110 <port_disable.lto_priv.270>

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8009a08:	4a01      	ldr	r2, [pc, #4]	; (8009a10 <chSysHalt+0x14>)
 8009a0a:	687b      	ldr	r3, [r7, #4]
 8009a0c:	6293      	str	r3, [r2, #40]	; 0x28
 8009a0e:	e7fe      	b.n	8009a0e <chSysHalt+0x12>
 8009a10:	20001330 	.word	0x20001330

08009a14 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8009a14:	b580      	push	{r7, lr}
 8009a16:	af00      	add	r7, sp, #0

  chDbgCheckClassI();
 8009a18:	f000 f8ce 	bl	8009bb8 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
 8009a1c:	f001 fbda 	bl	800b1d4 <chVTDoTickI.lto_priv.269>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 8009a20:	bd80      	pop	{r7, pc}
 8009a22:	bf00      	nop

08009a24 <port_lock.lto_priv.250>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8009a24:	b480      	push	{r7}
 8009a26:	b083      	sub	sp, #12
 8009a28:	af00      	add	r7, sp, #0
 8009a2a:	2320      	movs	r3, #32
 8009a2c:	607b      	str	r3, [r7, #4]
 8009a2e:	687b      	ldr	r3, [r7, #4]
 8009a30:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8009a34:	370c      	adds	r7, #12
 8009a36:	46bd      	mov	sp, r7
 8009a38:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a3c:	4770      	bx	lr
 8009a3e:	bf00      	nop

08009a40 <port_unlock.lto_priv.247>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8009a40:	b480      	push	{r7}
 8009a42:	b083      	sub	sp, #12
 8009a44:	af00      	add	r7, sp, #0
 8009a46:	2300      	movs	r3, #0
 8009a48:	607b      	str	r3, [r7, #4]
 8009a4a:	687b      	ldr	r3, [r7, #4]
 8009a4c:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8009a50:	370c      	adds	r7, #12
 8009a52:	46bd      	mov	sp, r7
 8009a54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a58:	4770      	bx	lr
 8009a5a:	bf00      	nop

08009a5c <port_lock_from_isr.lto_priv.260>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8009a5c:	b580      	push	{r7, lr}
 8009a5e:	af00      	add	r7, sp, #0

  port_lock();
 8009a60:	f7ff ffe0 	bl	8009a24 <port_lock.lto_priv.250>
}
 8009a64:	bd80      	pop	{r7, pc}
 8009a66:	bf00      	nop

08009a68 <port_unlock_from_isr.lto_priv.258>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8009a68:	b580      	push	{r7, lr}
 8009a6a:	af00      	add	r7, sp, #0

  port_unlock();
 8009a6c:	f7ff ffe8 	bl	8009a40 <port_unlock.lto_priv.247>
}
 8009a70:	bd80      	pop	{r7, pc}
 8009a72:	bf00      	nop

08009a74 <_dbg_check_enable>:
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
 8009a74:	b580      	push	{r7, lr}
 8009a76:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8009a78:	4b05      	ldr	r3, [pc, #20]	; (8009a90 <_dbg_check_enable+0x1c>)
 8009a7a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009a7c:	2b00      	cmp	r3, #0
 8009a7e:	d103      	bne.n	8009a88 <_dbg_check_enable+0x14>
 8009a80:	4b03      	ldr	r3, [pc, #12]	; (8009a90 <_dbg_check_enable+0x1c>)
 8009a82:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009a84:	2b00      	cmp	r3, #0
 8009a86:	d002      	beq.n	8009a8e <_dbg_check_enable+0x1a>
    chSysHalt("SV#3");
 8009a88:	4802      	ldr	r0, [pc, #8]	; (8009a94 <_dbg_check_enable+0x20>)
 8009a8a:	f7ff ffb7 	bl	80099fc <chSysHalt>
  }
}
 8009a8e:	bd80      	pop	{r7, pc}
 8009a90:	20001330 	.word	0x20001330
 8009a94:	0800cc70 	.word	0x0800cc70

08009a98 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 8009a98:	b580      	push	{r7, lr}
 8009a9a:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8009a9c:	4b07      	ldr	r3, [pc, #28]	; (8009abc <_dbg_check_lock+0x24>)
 8009a9e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009aa0:	2b00      	cmp	r3, #0
 8009aa2:	d103      	bne.n	8009aac <_dbg_check_lock+0x14>
 8009aa4:	4b05      	ldr	r3, [pc, #20]	; (8009abc <_dbg_check_lock+0x24>)
 8009aa6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009aa8:	2b00      	cmp	r3, #0
 8009aaa:	d002      	beq.n	8009ab2 <_dbg_check_lock+0x1a>
    chSysHalt("SV#4");
 8009aac:	4804      	ldr	r0, [pc, #16]	; (8009ac0 <_dbg_check_lock+0x28>)
 8009aae:	f7ff ffa5 	bl	80099fc <chSysHalt>
  }
  _dbg_enter_lock();
 8009ab2:	4b02      	ldr	r3, [pc, #8]	; (8009abc <_dbg_check_lock+0x24>)
 8009ab4:	2201      	movs	r2, #1
 8009ab6:	631a      	str	r2, [r3, #48]	; 0x30
}
 8009ab8:	bd80      	pop	{r7, pc}
 8009aba:	bf00      	nop
 8009abc:	20001330 	.word	0x20001330
 8009ac0:	0800cc78 	.word	0x0800cc78

08009ac4 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 8009ac4:	b580      	push	{r7, lr}
 8009ac6:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8009ac8:	4b07      	ldr	r3, [pc, #28]	; (8009ae8 <_dbg_check_unlock+0x24>)
 8009aca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009acc:	2b00      	cmp	r3, #0
 8009ace:	d103      	bne.n	8009ad8 <_dbg_check_unlock+0x14>
 8009ad0:	4b05      	ldr	r3, [pc, #20]	; (8009ae8 <_dbg_check_unlock+0x24>)
 8009ad2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009ad4:	2b00      	cmp	r3, #0
 8009ad6:	dc02      	bgt.n	8009ade <_dbg_check_unlock+0x1a>
    chSysHalt("SV#5");
 8009ad8:	4804      	ldr	r0, [pc, #16]	; (8009aec <_dbg_check_unlock+0x28>)
 8009ada:	f7ff ff8f 	bl	80099fc <chSysHalt>
  }
  _dbg_leave_lock();
 8009ade:	4b02      	ldr	r3, [pc, #8]	; (8009ae8 <_dbg_check_unlock+0x24>)
 8009ae0:	2200      	movs	r2, #0
 8009ae2:	631a      	str	r2, [r3, #48]	; 0x30
}
 8009ae4:	bd80      	pop	{r7, pc}
 8009ae6:	bf00      	nop
 8009ae8:	20001330 	.word	0x20001330
 8009aec:	0800cc80 	.word	0x0800cc80

08009af0 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
 8009af0:	b580      	push	{r7, lr}
 8009af2:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8009af4:	4b07      	ldr	r3, [pc, #28]	; (8009b14 <_dbg_check_lock_from_isr+0x24>)
 8009af6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009af8:	2b00      	cmp	r3, #0
 8009afa:	dd03      	ble.n	8009b04 <_dbg_check_lock_from_isr+0x14>
 8009afc:	4b05      	ldr	r3, [pc, #20]	; (8009b14 <_dbg_check_lock_from_isr+0x24>)
 8009afe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009b00:	2b00      	cmp	r3, #0
 8009b02:	d002      	beq.n	8009b0a <_dbg_check_lock_from_isr+0x1a>
    chSysHalt("SV#6");
 8009b04:	4804      	ldr	r0, [pc, #16]	; (8009b18 <_dbg_check_lock_from_isr+0x28>)
 8009b06:	f7ff ff79 	bl	80099fc <chSysHalt>
  }
  _dbg_enter_lock();
 8009b0a:	4b02      	ldr	r3, [pc, #8]	; (8009b14 <_dbg_check_lock_from_isr+0x24>)
 8009b0c:	2201      	movs	r2, #1
 8009b0e:	631a      	str	r2, [r3, #48]	; 0x30
}
 8009b10:	bd80      	pop	{r7, pc}
 8009b12:	bf00      	nop
 8009b14:	20001330 	.word	0x20001330
 8009b18:	0800cc88 	.word	0x0800cc88

08009b1c <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
 8009b1c:	b580      	push	{r7, lr}
 8009b1e:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8009b20:	4b07      	ldr	r3, [pc, #28]	; (8009b40 <_dbg_check_unlock_from_isr+0x24>)
 8009b22:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009b24:	2b00      	cmp	r3, #0
 8009b26:	dd03      	ble.n	8009b30 <_dbg_check_unlock_from_isr+0x14>
 8009b28:	4b05      	ldr	r3, [pc, #20]	; (8009b40 <_dbg_check_unlock_from_isr+0x24>)
 8009b2a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009b2c:	2b00      	cmp	r3, #0
 8009b2e:	dc02      	bgt.n	8009b36 <_dbg_check_unlock_from_isr+0x1a>
    chSysHalt("SV#7");
 8009b30:	4804      	ldr	r0, [pc, #16]	; (8009b44 <_dbg_check_unlock_from_isr+0x28>)
 8009b32:	f7ff ff63 	bl	80099fc <chSysHalt>
  }
  _dbg_leave_lock();
 8009b36:	4b02      	ldr	r3, [pc, #8]	; (8009b40 <_dbg_check_unlock_from_isr+0x24>)
 8009b38:	2200      	movs	r2, #0
 8009b3a:	631a      	str	r2, [r3, #48]	; 0x30
}
 8009b3c:	bd80      	pop	{r7, pc}
 8009b3e:	bf00      	nop
 8009b40:	20001330 	.word	0x20001330
 8009b44:	0800cc90 	.word	0x0800cc90

08009b48 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
 8009b48:	b580      	push	{r7, lr}
 8009b4a:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 8009b4c:	f7ff ff86 	bl	8009a5c <port_lock_from_isr.lto_priv.260>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8009b50:	4b09      	ldr	r3, [pc, #36]	; (8009b78 <_dbg_check_enter_isr+0x30>)
 8009b52:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009b54:	2b00      	cmp	r3, #0
 8009b56:	db03      	blt.n	8009b60 <_dbg_check_enter_isr+0x18>
 8009b58:	4b07      	ldr	r3, [pc, #28]	; (8009b78 <_dbg_check_enter_isr+0x30>)
 8009b5a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009b5c:	2b00      	cmp	r3, #0
 8009b5e:	d002      	beq.n	8009b66 <_dbg_check_enter_isr+0x1e>
    chSysHalt("SV#8");
 8009b60:	4806      	ldr	r0, [pc, #24]	; (8009b7c <_dbg_check_enter_isr+0x34>)
 8009b62:	f7ff ff4b 	bl	80099fc <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 8009b66:	4b04      	ldr	r3, [pc, #16]	; (8009b78 <_dbg_check_enter_isr+0x30>)
 8009b68:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009b6a:	3301      	adds	r3, #1
 8009b6c:	4a02      	ldr	r2, [pc, #8]	; (8009b78 <_dbg_check_enter_isr+0x30>)
 8009b6e:	62d3      	str	r3, [r2, #44]	; 0x2c
  port_unlock_from_isr();
 8009b70:	f7ff ff7a 	bl	8009a68 <port_unlock_from_isr.lto_priv.258>
}
 8009b74:	bd80      	pop	{r7, pc}
 8009b76:	bf00      	nop
 8009b78:	20001330 	.word	0x20001330
 8009b7c:	0800cc98 	.word	0x0800cc98

08009b80 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
 8009b80:	b580      	push	{r7, lr}
 8009b82:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 8009b84:	f7ff ff6a 	bl	8009a5c <port_lock_from_isr.lto_priv.260>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8009b88:	4b09      	ldr	r3, [pc, #36]	; (8009bb0 <_dbg_check_leave_isr+0x30>)
 8009b8a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009b8c:	2b00      	cmp	r3, #0
 8009b8e:	dd03      	ble.n	8009b98 <_dbg_check_leave_isr+0x18>
 8009b90:	4b07      	ldr	r3, [pc, #28]	; (8009bb0 <_dbg_check_leave_isr+0x30>)
 8009b92:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009b94:	2b00      	cmp	r3, #0
 8009b96:	d002      	beq.n	8009b9e <_dbg_check_leave_isr+0x1e>
    chSysHalt("SV#9");
 8009b98:	4806      	ldr	r0, [pc, #24]	; (8009bb4 <_dbg_check_leave_isr+0x34>)
 8009b9a:	f7ff ff2f 	bl	80099fc <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 8009b9e:	4b04      	ldr	r3, [pc, #16]	; (8009bb0 <_dbg_check_leave_isr+0x30>)
 8009ba0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009ba2:	3b01      	subs	r3, #1
 8009ba4:	4a02      	ldr	r2, [pc, #8]	; (8009bb0 <_dbg_check_leave_isr+0x30>)
 8009ba6:	62d3      	str	r3, [r2, #44]	; 0x2c
  port_unlock_from_isr();
 8009ba8:	f7ff ff5e 	bl	8009a68 <port_unlock_from_isr.lto_priv.258>
}
 8009bac:	bd80      	pop	{r7, pc}
 8009bae:	bf00      	nop
 8009bb0:	20001330 	.word	0x20001330
 8009bb4:	0800cca0 	.word	0x0800cca0

08009bb8 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8009bb8:	b580      	push	{r7, lr}
 8009bba:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8009bbc:	4b05      	ldr	r3, [pc, #20]	; (8009bd4 <chDbgCheckClassI+0x1c>)
 8009bbe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009bc0:	2b00      	cmp	r3, #0
 8009bc2:	db03      	blt.n	8009bcc <chDbgCheckClassI+0x14>
 8009bc4:	4b03      	ldr	r3, [pc, #12]	; (8009bd4 <chDbgCheckClassI+0x1c>)
 8009bc6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009bc8:	2b00      	cmp	r3, #0
 8009bca:	dc02      	bgt.n	8009bd2 <chDbgCheckClassI+0x1a>
    chSysHalt("SV#10");
 8009bcc:	4802      	ldr	r0, [pc, #8]	; (8009bd8 <chDbgCheckClassI+0x20>)
 8009bce:	f7ff ff15 	bl	80099fc <chSysHalt>
  }
}
 8009bd2:	bd80      	pop	{r7, pc}
 8009bd4:	20001330 	.word	0x20001330
 8009bd8:	0800cca8 	.word	0x0800cca8

08009bdc <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8009bdc:	b580      	push	{r7, lr}
 8009bde:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8009be0:	4b05      	ldr	r3, [pc, #20]	; (8009bf8 <chDbgCheckClassS+0x1c>)
 8009be2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009be4:	2b00      	cmp	r3, #0
 8009be6:	d103      	bne.n	8009bf0 <chDbgCheckClassS+0x14>
 8009be8:	4b03      	ldr	r3, [pc, #12]	; (8009bf8 <chDbgCheckClassS+0x1c>)
 8009bea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009bec:	2b00      	cmp	r3, #0
 8009bee:	dc02      	bgt.n	8009bf6 <chDbgCheckClassS+0x1a>
    chSysHalt("SV#11");
 8009bf0:	4802      	ldr	r0, [pc, #8]	; (8009bfc <chDbgCheckClassS+0x20>)
 8009bf2:	f7ff ff03 	bl	80099fc <chSysHalt>
  }
}
 8009bf6:	bd80      	pop	{r7, pc}
 8009bf8:	20001330 	.word	0x20001330
 8009bfc:	0800ccb0 	.word	0x0800ccb0

08009c00 <st_lld_get_counter.lto_priv.245>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 8009c00:	b480      	push	{r7}
 8009c02:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 8009c04:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009c08:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009c0a:	b29b      	uxth	r3, r3
}
 8009c0c:	4618      	mov	r0, r3
 8009c0e:	46bd      	mov	sp, r7
 8009c10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009c14:	4770      	bx	lr
 8009c16:	bf00      	nop

08009c18 <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 8009c18:	b580      	push	{r7, lr}
 8009c1a:	b082      	sub	sp, #8
 8009c1c:	af00      	add	r7, sp, #0
 8009c1e:	4603      	mov	r3, r0
 8009c20:	80fb      	strh	r3, [r7, #6]

  stStartAlarm(time);
 8009c22:	88fb      	ldrh	r3, [r7, #6]
 8009c24:	4618      	mov	r0, r3
 8009c26:	f7fe fb11 	bl	800824c <stStartAlarm>
}
 8009c2a:	3708      	adds	r7, #8
 8009c2c:	46bd      	mov	sp, r7
 8009c2e:	bd80      	pop	{r7, pc}

08009c30 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8009c30:	b580      	push	{r7, lr}
 8009c32:	af00      	add	r7, sp, #0

  stStopAlarm();
 8009c34:	f7fe fb20 	bl	8008278 <stStopAlarm>
}
 8009c38:	bd80      	pop	{r7, pc}
 8009c3a:	bf00      	nop

08009c3c <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8009c3c:	b580      	push	{r7, lr}
 8009c3e:	b082      	sub	sp, #8
 8009c40:	af00      	add	r7, sp, #0
 8009c42:	4603      	mov	r3, r0
 8009c44:	80fb      	strh	r3, [r7, #6]

  stSetAlarm(time);
 8009c46:	88fb      	ldrh	r3, [r7, #6]
 8009c48:	4618      	mov	r0, r3
 8009c4a:	f7fe fb1b 	bl	8008284 <stSetAlarm>
}
 8009c4e:	3708      	adds	r7, #8
 8009c50:	46bd      	mov	sp, r7
 8009c52:	bd80      	pop	{r7, pc}

08009c54 <port_timer_get_time.lto_priv.243>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8009c54:	b580      	push	{r7, lr}
 8009c56:	af00      	add	r7, sp, #0

  return stGetCounter();
 8009c58:	f7ff ffd2 	bl	8009c00 <st_lld_get_counter.lto_priv.245>
 8009c5c:	4603      	mov	r3, r0
}
 8009c5e:	4618      	mov	r0, r3
 8009c60:	bd80      	pop	{r7, pc}
 8009c62:	bf00      	nop

08009c64 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8009c64:	b580      	push	{r7, lr}
 8009c66:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8009c68:	f7ff fff4 	bl	8009c54 <port_timer_get_time.lto_priv.243>
 8009c6c:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8009c6e:	4618      	mov	r0, r3
 8009c70:	bd80      	pop	{r7, pc}
 8009c72:	bf00      	nop

08009c74 <_vt_init>:
 * @brief   Virtual Timers initialization.
 * @note    Internal use only.
 *
 * @notapi
 */
void _vt_init(void) {
 8009c74:	b480      	push	{r7}
 8009c76:	af00      	add	r7, sp, #0

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8009c78:	4b08      	ldr	r3, [pc, #32]	; (8009c9c <_vt_init+0x28>)
 8009c7a:	4a09      	ldr	r2, [pc, #36]	; (8009ca0 <_vt_init+0x2c>)
 8009c7c:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8009c7e:	4b07      	ldr	r3, [pc, #28]	; (8009c9c <_vt_init+0x28>)
 8009c80:	4a07      	ldr	r2, [pc, #28]	; (8009ca0 <_vt_init+0x2c>)
 8009c82:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (systime_t)-1;
 8009c84:	4b05      	ldr	r3, [pc, #20]	; (8009c9c <_vt_init+0x28>)
 8009c86:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8009c8a:	849a      	strh	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8009c8c:	4b03      	ldr	r3, [pc, #12]	; (8009c9c <_vt_init+0x28>)
 8009c8e:	2200      	movs	r2, #0
 8009c90:	84da      	strh	r2, [r3, #38]	; 0x26
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8009c92:	46bd      	mov	sp, r7
 8009c94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009c98:	4770      	bx	lr
 8009c9a:	bf00      	nop
 8009c9c:	20001330 	.word	0x20001330
 8009ca0:	2000134c 	.word	0x2000134c

08009ca4 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8009ca4:	b580      	push	{r7, lr}
 8009ca6:	b086      	sub	sp, #24
 8009ca8:	af00      	add	r7, sp, #0
 8009caa:	60f8      	str	r0, [r7, #12]
 8009cac:	607a      	str	r2, [r7, #4]
 8009cae:	603b      	str	r3, [r7, #0]
 8009cb0:	460b      	mov	r3, r1
 8009cb2:	817b      	strh	r3, [r7, #10]
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 8009cb4:	f7ff ff80 	bl	8009bb8 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8009cb8:	68fb      	ldr	r3, [r7, #12]
 8009cba:	2b00      	cmp	r3, #0
 8009cbc:	d005      	beq.n	8009cca <chVTDoSetI+0x26>
 8009cbe:	687b      	ldr	r3, [r7, #4]
 8009cc0:	2b00      	cmp	r3, #0
 8009cc2:	d002      	beq.n	8009cca <chVTDoSetI+0x26>
 8009cc4:	897b      	ldrh	r3, [r7, #10]
 8009cc6:	2b00      	cmp	r3, #0
 8009cc8:	d102      	bne.n	8009cd0 <chVTDoSetI+0x2c>
 8009cca:	4847      	ldr	r0, [pc, #284]	; (8009de8 <chVTDoSetI+0x144>)
 8009ccc:	f7ff fe96 	bl	80099fc <chSysHalt>

  vtp->par = par;
 8009cd0:	68fb      	ldr	r3, [r7, #12]
 8009cd2:	683a      	ldr	r2, [r7, #0]
 8009cd4:	611a      	str	r2, [r3, #16]
  vtp->func = vtfunc;
 8009cd6:	68fb      	ldr	r3, [r7, #12]
 8009cd8:	687a      	ldr	r2, [r7, #4]
 8009cda:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 8009cdc:	f7ff ffc2 	bl	8009c64 <chVTGetSystemTimeX>
 8009ce0:	4603      	mov	r3, r0
 8009ce2:	823b      	strh	r3, [r7, #16]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8009ce4:	897b      	ldrh	r3, [r7, #10]
 8009ce6:	2b01      	cmp	r3, #1
 8009ce8:	d801      	bhi.n	8009cee <chVTDoSetI+0x4a>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8009cea:	2302      	movs	r3, #2
 8009cec:	817b      	strh	r3, [r7, #10]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8009cee:	4b3f      	ldr	r3, [pc, #252]	; (8009dec <chVTDoSetI+0x148>)
 8009cf0:	69db      	ldr	r3, [r3, #28]
 8009cf2:	4a3f      	ldr	r2, [pc, #252]	; (8009df0 <chVTDoSetI+0x14c>)
 8009cf4:	4293      	cmp	r3, r2
 8009cf6:	d11a      	bne.n	8009d2e <chVTDoSetI+0x8a>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 8009cf8:	4a3c      	ldr	r2, [pc, #240]	; (8009dec <chVTDoSetI+0x148>)
 8009cfa:	8a3b      	ldrh	r3, [r7, #16]
 8009cfc:	84d3      	strh	r3, [r2, #38]	; 0x26
      ch.vtlist.next = vtp;
 8009cfe:	4a3b      	ldr	r2, [pc, #236]	; (8009dec <chVTDoSetI+0x148>)
 8009d00:	68fb      	ldr	r3, [r7, #12]
 8009d02:	61d3      	str	r3, [r2, #28]
      ch.vtlist.prev = vtp;
 8009d04:	4a39      	ldr	r2, [pc, #228]	; (8009dec <chVTDoSetI+0x148>)
 8009d06:	68fb      	ldr	r3, [r7, #12]
 8009d08:	6213      	str	r3, [r2, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8009d0a:	68fb      	ldr	r3, [r7, #12]
 8009d0c:	4a38      	ldr	r2, [pc, #224]	; (8009df0 <chVTDoSetI+0x14c>)
 8009d0e:	601a      	str	r2, [r3, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8009d10:	68fb      	ldr	r3, [r7, #12]
 8009d12:	4a37      	ldr	r2, [pc, #220]	; (8009df0 <chVTDoSetI+0x14c>)
 8009d14:	605a      	str	r2, [r3, #4]
      vtp->delta = delay;
 8009d16:	68fb      	ldr	r3, [r7, #12]
 8009d18:	897a      	ldrh	r2, [r7, #10]
 8009d1a:	811a      	strh	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 8009d1c:	4b33      	ldr	r3, [pc, #204]	; (8009dec <chVTDoSetI+0x148>)
 8009d1e:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8009d20:	897b      	ldrh	r3, [r7, #10]
 8009d22:	4413      	add	r3, r2
 8009d24:	b29b      	uxth	r3, r3
 8009d26:	4618      	mov	r0, r3
 8009d28:	f7ff ff76 	bl	8009c18 <port_timer_start_alarm>
 8009d2c:	e059      	b.n	8009de2 <chVTDoSetI+0x13e>

      return;
    }

    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;
 8009d2e:	4b2f      	ldr	r3, [pc, #188]	; (8009dec <chVTDoSetI+0x148>)
 8009d30:	69db      	ldr	r3, [r3, #28]
 8009d32:	617b      	str	r3, [r7, #20]

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;
 8009d34:	4b2d      	ldr	r3, [pc, #180]	; (8009dec <chVTDoSetI+0x148>)
 8009d36:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 8009d38:	8a3a      	ldrh	r2, [r7, #16]
 8009d3a:	1ad3      	subs	r3, r2, r3
 8009d3c:	b29a      	uxth	r2, r3
 8009d3e:	897b      	ldrh	r3, [r7, #10]
 8009d40:	4413      	add	r3, r2
 8009d42:	827b      	strh	r3, [r7, #18]

    if (delta < now - ch.vtlist.lasttime) {
 8009d44:	8a7a      	ldrh	r2, [r7, #18]
 8009d46:	8a3b      	ldrh	r3, [r7, #16]
 8009d48:	4928      	ldr	r1, [pc, #160]	; (8009dec <chVTDoSetI+0x148>)
 8009d4a:	8cc9      	ldrh	r1, [r1, #38]	; 0x26
 8009d4c:	1a5b      	subs	r3, r3, r1
 8009d4e:	429a      	cmp	r2, r3
 8009d50:	da08      	bge.n	8009d64 <chVTDoSetI+0xc0>
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8009d52:	697b      	ldr	r3, [r7, #20]
 8009d54:	891b      	ldrh	r3, [r3, #8]
 8009d56:	8a7a      	ldrh	r2, [r7, #18]
 8009d58:	1ad3      	subs	r3, r2, r3
 8009d5a:	827b      	strh	r3, [r7, #18]
      p = p->next;
 8009d5c:	697b      	ldr	r3, [r7, #20]
 8009d5e:	681b      	ldr	r3, [r3, #0]
 8009d60:	617b      	str	r3, [r7, #20]
 8009d62:	e01c      	b.n	8009d9e <chVTDoSetI+0xfa>
    }
    else if (delta < p->delta) {
 8009d64:	697b      	ldr	r3, [r7, #20]
 8009d66:	891b      	ldrh	r3, [r3, #8]
 8009d68:	8a7a      	ldrh	r2, [r7, #18]
 8009d6a:	429a      	cmp	r2, r3
 8009d6c:	d217      	bcs.n	8009d9e <chVTDoSetI+0xfa>
     /* A small delay that will become the first element in the delta list
        and next deadline.*/
      port_timer_set_alarm(ch.vtlist.lasttime + delta);
 8009d6e:	4b1f      	ldr	r3, [pc, #124]	; (8009dec <chVTDoSetI+0x148>)
 8009d70:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8009d72:	8a7b      	ldrh	r3, [r7, #18]
 8009d74:	4413      	add	r3, r2
 8009d76:	b29b      	uxth	r3, r3
 8009d78:	4618      	mov	r0, r3
 8009d7a:	f7ff ff5f 	bl	8009c3c <port_timer_set_alarm>
 8009d7e:	e00e      	b.n	8009d9e <chVTDoSetI+0xfa>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");
 8009d80:	697a      	ldr	r2, [r7, #20]
 8009d82:	68fb      	ldr	r3, [r7, #12]
 8009d84:	429a      	cmp	r2, r3
 8009d86:	d102      	bne.n	8009d8e <chVTDoSetI+0xea>
 8009d88:	4817      	ldr	r0, [pc, #92]	; (8009de8 <chVTDoSetI+0x144>)
 8009d8a:	f7ff fe37 	bl	80099fc <chSysHalt>

    delta -= p->delta;
 8009d8e:	697b      	ldr	r3, [r7, #20]
 8009d90:	891b      	ldrh	r3, [r3, #8]
 8009d92:	8a7a      	ldrh	r2, [r7, #18]
 8009d94:	1ad3      	subs	r3, r2, r3
 8009d96:	827b      	strh	r3, [r7, #18]
    p = p->next;
 8009d98:	697b      	ldr	r3, [r7, #20]
 8009d9a:	681b      	ldr	r3, [r3, #0]
 8009d9c:	617b      	str	r3, [r7, #20]
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8009d9e:	697b      	ldr	r3, [r7, #20]
 8009da0:	891b      	ldrh	r3, [r3, #8]
 8009da2:	8a7a      	ldrh	r2, [r7, #18]
 8009da4:	429a      	cmp	r2, r3
 8009da6:	d8eb      	bhi.n	8009d80 <chVTDoSetI+0xdc>
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 8009da8:	68fb      	ldr	r3, [r7, #12]
 8009daa:	697a      	ldr	r2, [r7, #20]
 8009dac:	601a      	str	r2, [r3, #0]
  vtp->prev = vtp->next->prev;
 8009dae:	68fb      	ldr	r3, [r7, #12]
 8009db0:	681b      	ldr	r3, [r3, #0]
 8009db2:	685a      	ldr	r2, [r3, #4]
 8009db4:	68fb      	ldr	r3, [r7, #12]
 8009db6:	605a      	str	r2, [r3, #4]
  vtp->prev->next = vtp;
 8009db8:	68fb      	ldr	r3, [r7, #12]
 8009dba:	685b      	ldr	r3, [r3, #4]
 8009dbc:	68fa      	ldr	r2, [r7, #12]
 8009dbe:	601a      	str	r2, [r3, #0]
  p->prev = vtp;
 8009dc0:	697b      	ldr	r3, [r7, #20]
 8009dc2:	68fa      	ldr	r2, [r7, #12]
 8009dc4:	605a      	str	r2, [r3, #4]
  vtp->delta = delta;
 8009dc6:	68fb      	ldr	r3, [r7, #12]
 8009dc8:	8a7a      	ldrh	r2, [r7, #18]
 8009dca:	811a      	strh	r2, [r3, #8]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 8009dcc:	697b      	ldr	r3, [r7, #20]
 8009dce:	891a      	ldrh	r2, [r3, #8]
 8009dd0:	8a7b      	ldrh	r3, [r7, #18]
 8009dd2:	1ad3      	subs	r3, r2, r3
 8009dd4:	b29a      	uxth	r2, r3
 8009dd6:	697b      	ldr	r3, [r7, #20]
 8009dd8:	811a      	strh	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (systime_t)-1;
 8009dda:	4b04      	ldr	r3, [pc, #16]	; (8009dec <chVTDoSetI+0x148>)
 8009ddc:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8009de0:	849a      	strh	r2, [r3, #36]	; 0x24
}
 8009de2:	3718      	adds	r7, #24
 8009de4:	46bd      	mov	sp, r7
 8009de6:	bd80      	pop	{r7, pc}
 8009de8:	0800ce4c 	.word	0x0800ce4c
 8009dec:	20001330 	.word	0x20001330
 8009df0:	2000134c 	.word	0x2000134c

08009df4 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8009df4:	b580      	push	{r7, lr}
 8009df6:	b084      	sub	sp, #16
 8009df8:	af00      	add	r7, sp, #0
 8009dfa:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 8009dfc:	f7ff fedc 	bl	8009bb8 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 8009e00:	687b      	ldr	r3, [r7, #4]
 8009e02:	2b00      	cmp	r3, #0
 8009e04:	d102      	bne.n	8009e0c <chVTDoResetI+0x18>
 8009e06:	4838      	ldr	r0, [pc, #224]	; (8009ee8 <chVTDoResetI+0xf4>)
 8009e08:	f7ff fdf8 	bl	80099fc <chSysHalt>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
 8009e0c:	687b      	ldr	r3, [r7, #4]
 8009e0e:	68db      	ldr	r3, [r3, #12]
 8009e10:	2b00      	cmp	r3, #0
 8009e12:	d102      	bne.n	8009e1a <chVTDoResetI+0x26>
 8009e14:	4834      	ldr	r0, [pc, #208]	; (8009ee8 <chVTDoResetI+0xf4>)
 8009e16:	f7ff fdf1 	bl	80099fc <chSysHalt>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8009e1a:	4b34      	ldr	r3, [pc, #208]	; (8009eec <chVTDoResetI+0xf8>)
 8009e1c:	69da      	ldr	r2, [r3, #28]
 8009e1e:	687b      	ldr	r3, [r7, #4]
 8009e20:	429a      	cmp	r2, r3
 8009e22:	d01c      	beq.n	8009e5e <chVTDoResetI+0x6a>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8009e24:	687b      	ldr	r3, [r7, #4]
 8009e26:	685b      	ldr	r3, [r3, #4]
 8009e28:	687a      	ldr	r2, [r7, #4]
 8009e2a:	6812      	ldr	r2, [r2, #0]
 8009e2c:	601a      	str	r2, [r3, #0]
    vtp->next->prev = vtp->prev;
 8009e2e:	687b      	ldr	r3, [r7, #4]
 8009e30:	681b      	ldr	r3, [r3, #0]
 8009e32:	687a      	ldr	r2, [r7, #4]
 8009e34:	6852      	ldr	r2, [r2, #4]
 8009e36:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8009e38:	687b      	ldr	r3, [r7, #4]
 8009e3a:	2200      	movs	r2, #0
 8009e3c:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8009e3e:	687b      	ldr	r3, [r7, #4]
 8009e40:	681b      	ldr	r3, [r3, #0]
 8009e42:	4a2b      	ldr	r2, [pc, #172]	; (8009ef0 <chVTDoResetI+0xfc>)
 8009e44:	4293      	cmp	r3, r2
 8009e46:	d04b      	beq.n	8009ee0 <chVTDoResetI+0xec>
      vtp->next->delta += vtp->delta;
 8009e48:	687b      	ldr	r3, [r7, #4]
 8009e4a:	681b      	ldr	r3, [r3, #0]
 8009e4c:	687a      	ldr	r2, [r7, #4]
 8009e4e:	6812      	ldr	r2, [r2, #0]
 8009e50:	8911      	ldrh	r1, [r2, #8]
 8009e52:	687a      	ldr	r2, [r7, #4]
 8009e54:	8912      	ldrh	r2, [r2, #8]
 8009e56:	440a      	add	r2, r1
 8009e58:	b292      	uxth	r2, r2
 8009e5a:	811a      	strh	r2, [r3, #8]
 8009e5c:	e040      	b.n	8009ee0 <chVTDoResetI+0xec>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8009e5e:	687b      	ldr	r3, [r7, #4]
 8009e60:	681b      	ldr	r3, [r3, #0]
 8009e62:	4a22      	ldr	r2, [pc, #136]	; (8009eec <chVTDoResetI+0xf8>)
 8009e64:	61d3      	str	r3, [r2, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8009e66:	4b21      	ldr	r3, [pc, #132]	; (8009eec <chVTDoResetI+0xf8>)
 8009e68:	69db      	ldr	r3, [r3, #28]
 8009e6a:	4a21      	ldr	r2, [pc, #132]	; (8009ef0 <chVTDoResetI+0xfc>)
 8009e6c:	605a      	str	r2, [r3, #4]
  vtp->func = NULL;
 8009e6e:	687b      	ldr	r3, [r7, #4]
 8009e70:	2200      	movs	r2, #0
 8009e72:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8009e74:	4b1d      	ldr	r3, [pc, #116]	; (8009eec <chVTDoResetI+0xf8>)
 8009e76:	69db      	ldr	r3, [r3, #28]
 8009e78:	4a1d      	ldr	r2, [pc, #116]	; (8009ef0 <chVTDoResetI+0xfc>)
 8009e7a:	4293      	cmp	r3, r2
 8009e7c:	d102      	bne.n	8009e84 <chVTDoResetI+0x90>
    port_timer_stop_alarm();
 8009e7e:	f7ff fed7 	bl	8009c30 <port_timer_stop_alarm>
 8009e82:	e02d      	b.n	8009ee0 <chVTDoResetI+0xec>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8009e84:	4b19      	ldr	r3, [pc, #100]	; (8009eec <chVTDoResetI+0xf8>)
 8009e86:	69db      	ldr	r3, [r3, #28]
 8009e88:	4a18      	ldr	r2, [pc, #96]	; (8009eec <chVTDoResetI+0xf8>)
 8009e8a:	69d2      	ldr	r2, [r2, #28]
 8009e8c:	8911      	ldrh	r1, [r2, #8]
 8009e8e:	687a      	ldr	r2, [r7, #4]
 8009e90:	8912      	ldrh	r2, [r2, #8]
 8009e92:	440a      	add	r2, r1
 8009e94:	b292      	uxth	r2, r2
 8009e96:	811a      	strh	r2, [r3, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8009e98:	f7ff fee4 	bl	8009c64 <chVTGetSystemTimeX>
 8009e9c:	4603      	mov	r3, r0
 8009e9e:	461a      	mov	r2, r3
 8009ea0:	4b12      	ldr	r3, [pc, #72]	; (8009eec <chVTDoResetI+0xf8>)
 8009ea2:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 8009ea4:	1ad3      	subs	r3, r2, r3
 8009ea6:	81bb      	strh	r3, [r7, #12]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8009ea8:	4b10      	ldr	r3, [pc, #64]	; (8009eec <chVTDoResetI+0xf8>)
 8009eaa:	69db      	ldr	r3, [r3, #28]
 8009eac:	891b      	ldrh	r3, [r3, #8]
 8009eae:	89ba      	ldrh	r2, [r7, #12]
 8009eb0:	429a      	cmp	r2, r3
 8009eb2:	d215      	bcs.n	8009ee0 <chVTDoResetI+0xec>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8009eb4:	4b0d      	ldr	r3, [pc, #52]	; (8009eec <chVTDoResetI+0xf8>)
 8009eb6:	69db      	ldr	r3, [r3, #28]
 8009eb8:	891a      	ldrh	r2, [r3, #8]
 8009eba:	89bb      	ldrh	r3, [r7, #12]
 8009ebc:	1ad3      	subs	r3, r2, r3
 8009ebe:	81fb      	strh	r3, [r7, #14]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8009ec0:	89fb      	ldrh	r3, [r7, #14]
 8009ec2:	2b01      	cmp	r3, #1
 8009ec4:	d801      	bhi.n	8009eca <chVTDoResetI+0xd6>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8009ec6:	2302      	movs	r3, #2
 8009ec8:	81fb      	strh	r3, [r7, #14]
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
 8009eca:	4b08      	ldr	r3, [pc, #32]	; (8009eec <chVTDoResetI+0xf8>)
 8009ecc:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8009ece:	89bb      	ldrh	r3, [r7, #12]
 8009ed0:	4413      	add	r3, r2
 8009ed2:	b29a      	uxth	r2, r3
 8009ed4:	89fb      	ldrh	r3, [r7, #14]
 8009ed6:	4413      	add	r3, r2
 8009ed8:	b29b      	uxth	r3, r3
 8009eda:	4618      	mov	r0, r3
 8009edc:	f7ff feae 	bl	8009c3c <port_timer_set_alarm>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8009ee0:	3710      	adds	r7, #16
 8009ee2:	46bd      	mov	sp, r7
 8009ee4:	bd80      	pop	{r7, pc}
 8009ee6:	bf00      	nop
 8009ee8:	0800ce58 	.word	0x0800ce58
 8009eec:	20001330 	.word	0x20001330
 8009ef0:	2000134c 	.word	0x2000134c

08009ef4 <port_lock.lto_priv.251>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8009ef4:	b480      	push	{r7}
 8009ef6:	b083      	sub	sp, #12
 8009ef8:	af00      	add	r7, sp, #0
 8009efa:	2320      	movs	r3, #32
 8009efc:	607b      	str	r3, [r7, #4]
 8009efe:	687b      	ldr	r3, [r7, #4]
 8009f00:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8009f04:	370c      	adds	r7, #12
 8009f06:	46bd      	mov	sp, r7
 8009f08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f0c:	4770      	bx	lr
 8009f0e:	bf00      	nop

08009f10 <port_unlock.lto_priv.248>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8009f10:	b480      	push	{r7}
 8009f12:	b083      	sub	sp, #12
 8009f14:	af00      	add	r7, sp, #0
 8009f16:	2300      	movs	r3, #0
 8009f18:	607b      	str	r3, [r7, #4]
 8009f1a:	687b      	ldr	r3, [r7, #4]
 8009f1c:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8009f20:	370c      	adds	r7, #12
 8009f22:	46bd      	mov	sp, r7
 8009f24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f28:	4770      	bx	lr
 8009f2a:	bf00      	nop

08009f2c <port_lock_from_isr.lto_priv.261>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8009f2c:	b580      	push	{r7, lr}
 8009f2e:	af00      	add	r7, sp, #0

  port_lock();
 8009f30:	f7ff ffe0 	bl	8009ef4 <port_lock.lto_priv.251>
}
 8009f34:	bd80      	pop	{r7, pc}
 8009f36:	bf00      	nop

08009f38 <port_unlock_from_isr.lto_priv.259>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8009f38:	b580      	push	{r7, lr}
 8009f3a:	af00      	add	r7, sp, #0

  port_unlock();
 8009f3c:	f7ff ffe8 	bl	8009f10 <port_unlock.lto_priv.248>
}
 8009f40:	bd80      	pop	{r7, pc}
 8009f42:	bf00      	nop

08009f44 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8009f44:	b480      	push	{r7}
 8009f46:	b083      	sub	sp, #12
 8009f48:	af00      	add	r7, sp, #0
 8009f4a:	6078      	str	r0, [r7, #4]

  tqp->next = (thread_t *)tqp;
 8009f4c:	687b      	ldr	r3, [r7, #4]
 8009f4e:	687a      	ldr	r2, [r7, #4]
 8009f50:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8009f52:	687b      	ldr	r3, [r7, #4]
 8009f54:	687a      	ldr	r2, [r7, #4]
 8009f56:	605a      	str	r2, [r3, #4]
}
 8009f58:	370c      	adds	r7, #12
 8009f5a:	46bd      	mov	sp, r7
 8009f5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f60:	4770      	bx	lr
 8009f62:	bf00      	nop

08009f64 <chSchIsRescRequiredI>:
 * @retval false        if rescheduling is not necessary.
 * @retval true         if there is a ready thread at higher priority.
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {
 8009f64:	b580      	push	{r7, lr}
 8009f66:	af00      	add	r7, sp, #0

  chDbgCheckClassI();
 8009f68:	f7ff fe26 	bl	8009bb8 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 8009f6c:	4b06      	ldr	r3, [pc, #24]	; (8009f88 <chSchIsRescRequiredI+0x24>)
 8009f6e:	681b      	ldr	r3, [r3, #0]
 8009f70:	689a      	ldr	r2, [r3, #8]
 8009f72:	4b05      	ldr	r3, [pc, #20]	; (8009f88 <chSchIsRescRequiredI+0x24>)
 8009f74:	699b      	ldr	r3, [r3, #24]
 8009f76:	689b      	ldr	r3, [r3, #8]
 8009f78:	429a      	cmp	r2, r3
 8009f7a:	bf8c      	ite	hi
 8009f7c:	2301      	movhi	r3, #1
 8009f7e:	2300      	movls	r3, #0
 8009f80:	b2db      	uxtb	r3, r3
}
 8009f82:	4618      	mov	r0, r3
 8009f84:	bd80      	pop	{r7, pc}
 8009f86:	bf00      	nop
 8009f88:	20001330 	.word	0x20001330

08009f8c <chSysLockFromISR.lto_priv.257>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8009f8c:	b580      	push	{r7, lr}
 8009f8e:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 8009f90:	f7ff ffcc 	bl	8009f2c <port_lock_from_isr.lto_priv.261>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8009f94:	f7ff fdac 	bl	8009af0 <_dbg_check_lock_from_isr>
}
 8009f98:	bd80      	pop	{r7, pc}
 8009f9a:	bf00      	nop

08009f9c <chSysUnlockFromISR.lto_priv.255>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8009f9c:	b580      	push	{r7, lr}
 8009f9e:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
 8009fa0:	f7ff fdbc 	bl	8009b1c <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8009fa4:	f7ff ffc8 	bl	8009f38 <port_unlock_from_isr.lto_priv.259>
}
 8009fa8:	bd80      	pop	{r7, pc}
 8009faa:	bf00      	nop

08009fac <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8009fac:	b580      	push	{r7, lr}
 8009fae:	b082      	sub	sp, #8
 8009fb0:	af00      	add	r7, sp, #0
 8009fb2:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 8009fb4:	f7ff fe00 	bl	8009bb8 <chDbgCheckClassI>

  return (bool)(vtp->func != NULL);
 8009fb8:	687b      	ldr	r3, [r7, #4]
 8009fba:	68db      	ldr	r3, [r3, #12]
 8009fbc:	2b00      	cmp	r3, #0
 8009fbe:	bf14      	ite	ne
 8009fc0:	2301      	movne	r3, #1
 8009fc2:	2300      	moveq	r3, #0
 8009fc4:	b2db      	uxtb	r3, r3
}
 8009fc6:	4618      	mov	r0, r3
 8009fc8:	3708      	adds	r7, #8
 8009fca:	46bd      	mov	sp, r7
 8009fcc:	bd80      	pop	{r7, pc}
 8009fce:	bf00      	nop

08009fd0 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8009fd0:	b580      	push	{r7, lr}
 8009fd2:	af00      	add	r7, sp, #0

  queue_init(&ch.rlist.queue);
 8009fd4:	4806      	ldr	r0, [pc, #24]	; (8009ff0 <_scheduler_init+0x20>)
 8009fd6:	f7ff ffb5 	bl	8009f44 <queue_init>
  ch.rlist.prio = NOPRIO;
 8009fda:	4b05      	ldr	r3, [pc, #20]	; (8009ff0 <_scheduler_init+0x20>)
 8009fdc:	2200      	movs	r2, #0
 8009fde:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8009fe0:	4b03      	ldr	r3, [pc, #12]	; (8009ff0 <_scheduler_init+0x20>)
 8009fe2:	4a03      	ldr	r2, [pc, #12]	; (8009ff0 <_scheduler_init+0x20>)
 8009fe4:	611a      	str	r2, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8009fe6:	4b02      	ldr	r3, [pc, #8]	; (8009ff0 <_scheduler_init+0x20>)
 8009fe8:	4a01      	ldr	r2, [pc, #4]	; (8009ff0 <_scheduler_init+0x20>)
 8009fea:	615a      	str	r2, [r3, #20]
#endif
}
 8009fec:	bd80      	pop	{r7, pc}
 8009fee:	bf00      	nop
 8009ff0:	20001330 	.word	0x20001330

08009ff4 <queue_prio_insert>:
 * @param[in] tp        the pointer to the thread to be inserted in the list
 * @param[in] tqp       the pointer to the threads list header
 *
 * @notapi
 */
void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 8009ff4:	b480      	push	{r7}
 8009ff6:	b085      	sub	sp, #20
 8009ff8:	af00      	add	r7, sp, #0
 8009ffa:	6078      	str	r0, [r7, #4]
 8009ffc:	6039      	str	r1, [r7, #0]

  thread_t *cp = (thread_t *)tqp;
 8009ffe:	683b      	ldr	r3, [r7, #0]
 800a000:	60fb      	str	r3, [r7, #12]
  do {
    cp = cp->queue.next;
 800a002:	68fb      	ldr	r3, [r7, #12]
 800a004:	681b      	ldr	r3, [r3, #0]
 800a006:	60fb      	str	r3, [r7, #12]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800a008:	68fa      	ldr	r2, [r7, #12]
 800a00a:	683b      	ldr	r3, [r7, #0]
 800a00c:	429a      	cmp	r2, r3
 800a00e:	d005      	beq.n	800a01c <queue_prio_insert+0x28>
 800a010:	68fb      	ldr	r3, [r7, #12]
 800a012:	689a      	ldr	r2, [r3, #8]
 800a014:	687b      	ldr	r3, [r7, #4]
 800a016:	689b      	ldr	r3, [r3, #8]
 800a018:	429a      	cmp	r2, r3
 800a01a:	d2f2      	bcs.n	800a002 <queue_prio_insert+0xe>
  tp->queue.next             = cp;
 800a01c:	687b      	ldr	r3, [r7, #4]
 800a01e:	68fa      	ldr	r2, [r7, #12]
 800a020:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 800a022:	68fb      	ldr	r3, [r7, #12]
 800a024:	685a      	ldr	r2, [r3, #4]
 800a026:	687b      	ldr	r3, [r7, #4]
 800a028:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800a02a:	687b      	ldr	r3, [r7, #4]
 800a02c:	685b      	ldr	r3, [r3, #4]
 800a02e:	687a      	ldr	r2, [r7, #4]
 800a030:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 800a032:	68fb      	ldr	r3, [r7, #12]
 800a034:	687a      	ldr	r2, [r7, #4]
 800a036:	605a      	str	r2, [r3, #4]
}
 800a038:	3714      	adds	r7, #20
 800a03a:	46bd      	mov	sp, r7
 800a03c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a040:	4770      	bx	lr
 800a042:	bf00      	nop

0800a044 <queue_insert>:
 * @param[in] tp        the pointer to the thread to be inserted in the list
 * @param[in] tqp       the pointer to the threads list header
 *
 * @notapi
 */
void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 800a044:	b480      	push	{r7}
 800a046:	b083      	sub	sp, #12
 800a048:	af00      	add	r7, sp, #0
 800a04a:	6078      	str	r0, [r7, #4]
 800a04c:	6039      	str	r1, [r7, #0]

  tp->queue.next             = (thread_t *)tqp;
 800a04e:	687b      	ldr	r3, [r7, #4]
 800a050:	683a      	ldr	r2, [r7, #0]
 800a052:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = tqp->prev;
 800a054:	683b      	ldr	r3, [r7, #0]
 800a056:	685a      	ldr	r2, [r3, #4]
 800a058:	687b      	ldr	r3, [r7, #4]
 800a05a:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800a05c:	687b      	ldr	r3, [r7, #4]
 800a05e:	685b      	ldr	r3, [r3, #4]
 800a060:	687a      	ldr	r2, [r7, #4]
 800a062:	601a      	str	r2, [r3, #0]
  tqp->prev                  = tp;
 800a064:	683b      	ldr	r3, [r7, #0]
 800a066:	687a      	ldr	r2, [r7, #4]
 800a068:	605a      	str	r2, [r3, #4]
}
 800a06a:	370c      	adds	r7, #12
 800a06c:	46bd      	mov	sp, r7
 800a06e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a072:	4770      	bx	lr

0800a074 <queue_fifo_remove>:
 * @param[in] tqp       the pointer to the threads list header
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 800a074:	b480      	push	{r7}
 800a076:	b085      	sub	sp, #20
 800a078:	af00      	add	r7, sp, #0
 800a07a:	6078      	str	r0, [r7, #4]
  thread_t *tp = tqp->next;
 800a07c:	687b      	ldr	r3, [r7, #4]
 800a07e:	681b      	ldr	r3, [r3, #0]
 800a080:	60fb      	str	r3, [r7, #12]

  tqp->next             = tp->queue.next;
 800a082:	68fb      	ldr	r3, [r7, #12]
 800a084:	681a      	ldr	r2, [r3, #0]
 800a086:	687b      	ldr	r3, [r7, #4]
 800a088:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800a08a:	687b      	ldr	r3, [r7, #4]
 800a08c:	681b      	ldr	r3, [r3, #0]
 800a08e:	687a      	ldr	r2, [r7, #4]
 800a090:	605a      	str	r2, [r3, #4]

  return tp;
 800a092:	68fb      	ldr	r3, [r7, #12]
}
 800a094:	4618      	mov	r0, r3
 800a096:	3714      	adds	r7, #20
 800a098:	46bd      	mov	sp, r7
 800a09a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a09e:	4770      	bx	lr

0800a0a0 <queue_dequeue>:
 * @param[in] tp        the pointer to the thread to be removed from the queue
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *queue_dequeue(thread_t *tp) {
 800a0a0:	b480      	push	{r7}
 800a0a2:	b083      	sub	sp, #12
 800a0a4:	af00      	add	r7, sp, #0
 800a0a6:	6078      	str	r0, [r7, #4]

  tp->queue.prev->queue.next = tp->queue.next;
 800a0a8:	687b      	ldr	r3, [r7, #4]
 800a0aa:	685b      	ldr	r3, [r3, #4]
 800a0ac:	687a      	ldr	r2, [r7, #4]
 800a0ae:	6812      	ldr	r2, [r2, #0]
 800a0b0:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800a0b2:	687b      	ldr	r3, [r7, #4]
 800a0b4:	681b      	ldr	r3, [r3, #0]
 800a0b6:	687a      	ldr	r2, [r7, #4]
 800a0b8:	6852      	ldr	r2, [r2, #4]
 800a0ba:	605a      	str	r2, [r3, #4]

  return tp;
 800a0bc:	687b      	ldr	r3, [r7, #4]
}
 800a0be:	4618      	mov	r0, r3
 800a0c0:	370c      	adds	r7, #12
 800a0c2:	46bd      	mov	sp, r7
 800a0c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a0c8:	4770      	bx	lr
 800a0ca:	bf00      	nop

0800a0cc <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 800a0cc:	b580      	push	{r7, lr}
 800a0ce:	b084      	sub	sp, #16
 800a0d0:	af00      	add	r7, sp, #0
 800a0d2:	6078      	str	r0, [r7, #4]
  thread_t *cp;

  chDbgCheckClassI();
 800a0d4:	f7ff fd70 	bl	8009bb8 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800a0d8:	687b      	ldr	r3, [r7, #4]
 800a0da:	2b00      	cmp	r3, #0
 800a0dc:	d102      	bne.n	800a0e4 <chSchReadyI+0x18>
 800a0de:	4819      	ldr	r0, [pc, #100]	; (800a144 <chSchReadyI+0x78>)
 800a0e0:	f7ff fc8c 	bl	80099fc <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800a0e4:	687b      	ldr	r3, [r7, #4]
 800a0e6:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a0ea:	2b00      	cmp	r3, #0
 800a0ec:	d004      	beq.n	800a0f8 <chSchReadyI+0x2c>
 800a0ee:	687b      	ldr	r3, [r7, #4]
 800a0f0:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a0f4:	2b0f      	cmp	r3, #15
 800a0f6:	d102      	bne.n	800a0fe <chSchReadyI+0x32>
 800a0f8:	4812      	ldr	r0, [pc, #72]	; (800a144 <chSchReadyI+0x78>)
 800a0fa:	f7ff fc7f 	bl	80099fc <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800a0fe:	687b      	ldr	r3, [r7, #4]
 800a100:	2200      	movs	r2, #0
 800a102:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
 800a106:	4b10      	ldr	r3, [pc, #64]	; (800a148 <chSchReadyI+0x7c>)
 800a108:	60fb      	str	r3, [r7, #12]
  do {
    cp = cp->queue.next;
 800a10a:	68fb      	ldr	r3, [r7, #12]
 800a10c:	681b      	ldr	r3, [r3, #0]
 800a10e:	60fb      	str	r3, [r7, #12]
  } while (cp->prio >= tp->prio);
 800a110:	68fb      	ldr	r3, [r7, #12]
 800a112:	689a      	ldr	r2, [r3, #8]
 800a114:	687b      	ldr	r3, [r7, #4]
 800a116:	689b      	ldr	r3, [r3, #8]
 800a118:	429a      	cmp	r2, r3
 800a11a:	d2f6      	bcs.n	800a10a <chSchReadyI+0x3e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800a11c:	687b      	ldr	r3, [r7, #4]
 800a11e:	68fa      	ldr	r2, [r7, #12]
 800a120:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 800a122:	68fb      	ldr	r3, [r7, #12]
 800a124:	685a      	ldr	r2, [r3, #4]
 800a126:	687b      	ldr	r3, [r7, #4]
 800a128:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800a12a:	687b      	ldr	r3, [r7, #4]
 800a12c:	685b      	ldr	r3, [r3, #4]
 800a12e:	687a      	ldr	r2, [r7, #4]
 800a130:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 800a132:	68fb      	ldr	r3, [r7, #12]
 800a134:	687a      	ldr	r2, [r7, #4]
 800a136:	605a      	str	r2, [r3, #4]

  return tp;
 800a138:	687b      	ldr	r3, [r7, #4]
}
 800a13a:	4618      	mov	r0, r3
 800a13c:	3710      	adds	r7, #16
 800a13e:	46bd      	mov	sp, r7
 800a140:	bd80      	pop	{r7, pc}
 800a142:	bf00      	nop
 800a144:	0800ce68 	.word	0x0800ce68
 800a148:	20001330 	.word	0x20001330

0800a14c <chSchReadyAheadI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
 800a14c:	b580      	push	{r7, lr}
 800a14e:	b084      	sub	sp, #16
 800a150:	af00      	add	r7, sp, #0
 800a152:	6078      	str	r0, [r7, #4]
  thread_t *cp;

  chDbgCheckClassI();
 800a154:	f7ff fd30 	bl	8009bb8 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800a158:	687b      	ldr	r3, [r7, #4]
 800a15a:	2b00      	cmp	r3, #0
 800a15c:	d102      	bne.n	800a164 <chSchReadyAheadI+0x18>
 800a15e:	4819      	ldr	r0, [pc, #100]	; (800a1c4 <chSchReadyAheadI+0x78>)
 800a160:	f7ff fc4c 	bl	80099fc <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800a164:	687b      	ldr	r3, [r7, #4]
 800a166:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a16a:	2b00      	cmp	r3, #0
 800a16c:	d004      	beq.n	800a178 <chSchReadyAheadI+0x2c>
 800a16e:	687b      	ldr	r3, [r7, #4]
 800a170:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a174:	2b0f      	cmp	r3, #15
 800a176:	d102      	bne.n	800a17e <chSchReadyAheadI+0x32>
 800a178:	4812      	ldr	r0, [pc, #72]	; (800a1c4 <chSchReadyAheadI+0x78>)
 800a17a:	f7ff fc3f 	bl	80099fc <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800a17e:	687b      	ldr	r3, [r7, #4]
 800a180:	2200      	movs	r2, #0
 800a182:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
 800a186:	4b10      	ldr	r3, [pc, #64]	; (800a1c8 <chSchReadyAheadI+0x7c>)
 800a188:	60fb      	str	r3, [r7, #12]
  do {
    cp = cp->queue.next;
 800a18a:	68fb      	ldr	r3, [r7, #12]
 800a18c:	681b      	ldr	r3, [r3, #0]
 800a18e:	60fb      	str	r3, [r7, #12]
  } while (cp->prio > tp->prio);
 800a190:	68fb      	ldr	r3, [r7, #12]
 800a192:	689a      	ldr	r2, [r3, #8]
 800a194:	687b      	ldr	r3, [r7, #4]
 800a196:	689b      	ldr	r3, [r3, #8]
 800a198:	429a      	cmp	r2, r3
 800a19a:	d8f6      	bhi.n	800a18a <chSchReadyAheadI+0x3e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800a19c:	687b      	ldr	r3, [r7, #4]
 800a19e:	68fa      	ldr	r2, [r7, #12]
 800a1a0:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 800a1a2:	68fb      	ldr	r3, [r7, #12]
 800a1a4:	685a      	ldr	r2, [r3, #4]
 800a1a6:	687b      	ldr	r3, [r7, #4]
 800a1a8:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800a1aa:	687b      	ldr	r3, [r7, #4]
 800a1ac:	685b      	ldr	r3, [r3, #4]
 800a1ae:	687a      	ldr	r2, [r7, #4]
 800a1b0:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 800a1b2:	68fb      	ldr	r3, [r7, #12]
 800a1b4:	687a      	ldr	r2, [r7, #4]
 800a1b6:	605a      	str	r2, [r3, #4]

  return tp;
 800a1b8:	687b      	ldr	r3, [r7, #4]
}
 800a1ba:	4618      	mov	r0, r3
 800a1bc:	3710      	adds	r7, #16
 800a1be:	46bd      	mov	sp, r7
 800a1c0:	bd80      	pop	{r7, pc}
 800a1c2:	bf00      	nop
 800a1c4:	0800ce74 	.word	0x0800ce74
 800a1c8:	20001330 	.word	0x20001330

0800a1cc <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 800a1cc:	b590      	push	{r4, r7, lr}
 800a1ce:	b085      	sub	sp, #20
 800a1d0:	af00      	add	r7, sp, #0
 800a1d2:	4603      	mov	r3, r0
 800a1d4:	71fb      	strb	r3, [r7, #7]
  thread_t *otp = currp;
 800a1d6:	4b16      	ldr	r3, [pc, #88]	; (800a230 <chSchGoSleepS+0x64>)
 800a1d8:	699b      	ldr	r3, [r3, #24]
 800a1da:	60fb      	str	r3, [r7, #12]

  chDbgCheckClassS();
 800a1dc:	f7ff fcfe 	bl	8009bdc <chDbgCheckClassS>

  /* New state.*/
  otp->state = newstate;
 800a1e0:	68fb      	ldr	r3, [r7, #12]
 800a1e2:	79fa      	ldrb	r2, [r7, #7]
 800a1e4:	f883 2020 	strb.w	r2, [r3, #32]
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800a1e8:	4811      	ldr	r0, [pc, #68]	; (800a230 <chSchGoSleepS+0x64>)
 800a1ea:	f7ff ff43 	bl	800a074 <queue_fifo_remove>
 800a1ee:	4602      	mov	r2, r0
 800a1f0:	4b0f      	ldr	r3, [pc, #60]	; (800a230 <chSchGoSleepS+0x64>)
 800a1f2:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800a1f4:	4b0e      	ldr	r3, [pc, #56]	; (800a230 <chSchGoSleepS+0x64>)
 800a1f6:	699b      	ldr	r3, [r3, #24]
 800a1f8:	2201      	movs	r2, #1
 800a1fa:	f883 2020 	strb.w	r2, [r3, #32]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800a1fe:	f3ef 8309 	mrs	r3, PSP
 800a202:	461c      	mov	r4, r3
  return(result);
 800a204:	4623      	mov	r3, r4
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800a206:	60bb      	str	r3, [r7, #8]
 800a208:	68bb      	ldr	r3, [r7, #8]
 800a20a:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800a20e:	68fb      	ldr	r3, [r7, #12]
 800a210:	69db      	ldr	r3, [r3, #28]
 800a212:	429a      	cmp	r2, r3
 800a214:	d202      	bcs.n	800a21c <chSchGoSleepS+0x50>
 800a216:	4807      	ldr	r0, [pc, #28]	; (800a234 <chSchGoSleepS+0x68>)
 800a218:	f7ff fbf0 	bl	80099fc <chSysHalt>
 800a21c:	4b04      	ldr	r3, [pc, #16]	; (800a230 <chSchGoSleepS+0x64>)
 800a21e:	699b      	ldr	r3, [r3, #24]
 800a220:	4618      	mov	r0, r3
 800a222:	68f9      	ldr	r1, [r7, #12]
 800a224:	f7f9 f836 	bl	8003294 <_port_switch>
}
 800a228:	3714      	adds	r7, #20
 800a22a:	46bd      	mov	sp, r7
 800a22c:	bd90      	pop	{r4, r7, pc}
 800a22e:	bf00      	nop
 800a230:	20001330 	.word	0x20001330
 800a234:	0800ccb8 	.word	0x0800ccb8

0800a238 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 800a238:	b580      	push	{r7, lr}
 800a23a:	b084      	sub	sp, #16
 800a23c:	af00      	add	r7, sp, #0
 800a23e:	6078      	str	r0, [r7, #4]
  thread_t *tp = (thread_t *)p;
 800a240:	687b      	ldr	r3, [r7, #4]
 800a242:	60fb      	str	r3, [r7, #12]

  chSysLockFromISR();
 800a244:	f7ff fea2 	bl	8009f8c <chSysLockFromISR.lto_priv.257>
  switch (tp->state) {
 800a248:	68fb      	ldr	r3, [r7, #12]
 800a24a:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a24e:	2b03      	cmp	r3, #3
 800a250:	d006      	beq.n	800a260 <wakeup+0x28>
 800a252:	2b04      	cmp	r3, #4
 800a254:	d009      	beq.n	800a26a <wakeup+0x32>
 800a256:	2b00      	cmp	r3, #0
 800a258:	d10a      	bne.n	800a270 <wakeup+0x38>
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 800a25a:	f7ff fe9f 	bl	8009f9c <chSysUnlockFromISR.lto_priv.255>
 800a25e:	e010      	b.n	800a282 <wakeup+0x4a>
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 800a260:	68fb      	ldr	r3, [r7, #12]
 800a262:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a264:	2200      	movs	r2, #0
 800a266:	601a      	str	r2, [r3, #0]
 800a268:	e002      	b.n	800a270 <wakeup+0x38>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 800a26a:	68f8      	ldr	r0, [r7, #12]
 800a26c:	f7ff ff18 	bl	800a0a0 <queue_dequeue>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 800a270:	68fb      	ldr	r3, [r7, #12]
 800a272:	f04f 32ff 	mov.w	r2, #4294967295
 800a276:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800a278:	68f8      	ldr	r0, [r7, #12]
 800a27a:	f7ff ff27 	bl	800a0cc <chSchReadyI>
  chSysUnlockFromISR();
 800a27e:	f7ff fe8d 	bl	8009f9c <chSysUnlockFromISR.lto_priv.255>
}
 800a282:	3710      	adds	r7, #16
 800a284:	46bd      	mov	sp, r7
 800a286:	bd80      	pop	{r7, pc}

0800a288 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 800a288:	b580      	push	{r7, lr}
 800a28a:	b088      	sub	sp, #32
 800a28c:	af00      	add	r7, sp, #0
 800a28e:	4603      	mov	r3, r0
 800a290:	460a      	mov	r2, r1
 800a292:	71fb      	strb	r3, [r7, #7]
 800a294:	4613      	mov	r3, r2
 800a296:	80bb      	strh	r3, [r7, #4]

  chDbgCheckClassS();
 800a298:	f7ff fca0 	bl	8009bdc <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 800a29c:	88bb      	ldrh	r3, [r7, #4]
 800a29e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800a2a2:	4293      	cmp	r3, r2
 800a2a4:	d01b      	beq.n	800a2de <chSchGoSleepTimeoutS+0x56>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 800a2a6:	4b13      	ldr	r3, [pc, #76]	; (800a2f4 <chSchGoSleepTimeoutS+0x6c>)
 800a2a8:	699b      	ldr	r3, [r3, #24]
 800a2aa:	f107 010c 	add.w	r1, r7, #12
 800a2ae:	88ba      	ldrh	r2, [r7, #4]
 800a2b0:	4608      	mov	r0, r1
 800a2b2:	4611      	mov	r1, r2
 800a2b4:	4a10      	ldr	r2, [pc, #64]	; (800a2f8 <chSchGoSleepTimeoutS+0x70>)
 800a2b6:	f7ff fcf5 	bl	8009ca4 <chVTDoSetI>
    chSchGoSleepS(newstate);
 800a2ba:	79fb      	ldrb	r3, [r7, #7]
 800a2bc:	4618      	mov	r0, r3
 800a2be:	f7ff ff85 	bl	800a1cc <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800a2c2:	f107 030c 	add.w	r3, r7, #12
 800a2c6:	4618      	mov	r0, r3
 800a2c8:	f7ff fe70 	bl	8009fac <chVTIsArmedI>
 800a2cc:	4603      	mov	r3, r0
 800a2ce:	2b00      	cmp	r3, #0
 800a2d0:	d009      	beq.n	800a2e6 <chSchGoSleepTimeoutS+0x5e>
      chVTDoResetI(&vt);
 800a2d2:	f107 030c 	add.w	r3, r7, #12
 800a2d6:	4618      	mov	r0, r3
 800a2d8:	f7ff fd8c 	bl	8009df4 <chVTDoResetI>
 800a2dc:	e003      	b.n	800a2e6 <chSchGoSleepTimeoutS+0x5e>
    }
  }
  else {
    chSchGoSleepS(newstate);
 800a2de:	79fb      	ldrb	r3, [r7, #7]
 800a2e0:	4618      	mov	r0, r3
 800a2e2:	f7ff ff73 	bl	800a1cc <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 800a2e6:	4b03      	ldr	r3, [pc, #12]	; (800a2f4 <chSchGoSleepTimeoutS+0x6c>)
 800a2e8:	699b      	ldr	r3, [r3, #24]
 800a2ea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800a2ec:	4618      	mov	r0, r3
 800a2ee:	3720      	adds	r7, #32
 800a2f0:	46bd      	mov	sp, r7
 800a2f2:	bd80      	pop	{r7, pc}
 800a2f4:	20001330 	.word	0x20001330
 800a2f8:	0800a239 	.word	0x0800a239

0800a2fc <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 800a2fc:	b590      	push	{r4, r7, lr}
 800a2fe:	b085      	sub	sp, #20
 800a300:	af00      	add	r7, sp, #0
 800a302:	6078      	str	r0, [r7, #4]
 800a304:	6039      	str	r1, [r7, #0]
  thread_t *otp = currp;
 800a306:	4b21      	ldr	r3, [pc, #132]	; (800a38c <chSchWakeupS+0x90>)
 800a308:	699b      	ldr	r3, [r3, #24]
 800a30a:	60fb      	str	r3, [r7, #12]

  chDbgCheckClassS();
 800a30c:	f7ff fc66 	bl	8009bdc <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a310:	4b1e      	ldr	r3, [pc, #120]	; (800a38c <chSchWakeupS+0x90>)
 800a312:	681b      	ldr	r3, [r3, #0]
 800a314:	4a1d      	ldr	r2, [pc, #116]	; (800a38c <chSchWakeupS+0x90>)
 800a316:	4293      	cmp	r3, r2
 800a318:	d00a      	beq.n	800a330 <chSchWakeupS+0x34>
 800a31a:	4b1c      	ldr	r3, [pc, #112]	; (800a38c <chSchWakeupS+0x90>)
 800a31c:	699b      	ldr	r3, [r3, #24]
 800a31e:	689a      	ldr	r2, [r3, #8]
 800a320:	4b1a      	ldr	r3, [pc, #104]	; (800a38c <chSchWakeupS+0x90>)
 800a322:	681b      	ldr	r3, [r3, #0]
 800a324:	689b      	ldr	r3, [r3, #8]
 800a326:	429a      	cmp	r2, r3
 800a328:	d202      	bcs.n	800a330 <chSchWakeupS+0x34>
 800a32a:	4819      	ldr	r0, [pc, #100]	; (800a390 <chSchWakeupS+0x94>)
 800a32c:	f7ff fb66 	bl	80099fc <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 800a330:	687b      	ldr	r3, [r7, #4]
 800a332:	683a      	ldr	r2, [r7, #0]
 800a334:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 800a336:	687b      	ldr	r3, [r7, #4]
 800a338:	689a      	ldr	r2, [r3, #8]
 800a33a:	68fb      	ldr	r3, [r7, #12]
 800a33c:	689b      	ldr	r3, [r3, #8]
 800a33e:	429a      	cmp	r2, r3
 800a340:	d803      	bhi.n	800a34a <chSchWakeupS+0x4e>
    (void) chSchReadyI(ntp);
 800a342:	6878      	ldr	r0, [r7, #4]
 800a344:	f7ff fec2 	bl	800a0cc <chSchReadyI>
 800a348:	e01d      	b.n	800a386 <chSchWakeupS+0x8a>
  }
  else {
    otp = chSchReadyI(otp);
 800a34a:	68f8      	ldr	r0, [r7, #12]
 800a34c:	f7ff febe 	bl	800a0cc <chSchReadyI>
 800a350:	60f8      	str	r0, [r7, #12]
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 800a352:	4a0e      	ldr	r2, [pc, #56]	; (800a38c <chSchWakeupS+0x90>)
 800a354:	687b      	ldr	r3, [r7, #4]
 800a356:	6193      	str	r3, [r2, #24]
    ntp->state = CH_STATE_CURRENT;
 800a358:	687b      	ldr	r3, [r7, #4]
 800a35a:	2201      	movs	r2, #1
 800a35c:	f883 2020 	strb.w	r2, [r3, #32]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800a360:	f3ef 8309 	mrs	r3, PSP
 800a364:	461c      	mov	r4, r3
  return(result);
 800a366:	4623      	mov	r3, r4

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 800a368:	60bb      	str	r3, [r7, #8]
 800a36a:	68bb      	ldr	r3, [r7, #8]
 800a36c:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800a370:	68fb      	ldr	r3, [r7, #12]
 800a372:	69db      	ldr	r3, [r3, #28]
 800a374:	429a      	cmp	r2, r3
 800a376:	d202      	bcs.n	800a37e <chSchWakeupS+0x82>
 800a378:	4806      	ldr	r0, [pc, #24]	; (800a394 <chSchWakeupS+0x98>)
 800a37a:	f7ff fb3f 	bl	80099fc <chSysHalt>
 800a37e:	6878      	ldr	r0, [r7, #4]
 800a380:	68f9      	ldr	r1, [r7, #12]
 800a382:	f7f8 ff87 	bl	8003294 <_port_switch>
  }
}
 800a386:	3714      	adds	r7, #20
 800a388:	46bd      	mov	sp, r7
 800a38a:	bd90      	pop	{r4, r7, pc}
 800a38c:	20001330 	.word	0x20001330
 800a390:	0800ce88 	.word	0x0800ce88
 800a394:	0800ccb8 	.word	0x0800ccb8

0800a398 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 800a398:	b580      	push	{r7, lr}
 800a39a:	af00      	add	r7, sp, #0

  chDbgCheckClassS();
 800a39c:	f7ff fc1e 	bl	8009bdc <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
 800a3a0:	f7ff fde0 	bl	8009f64 <chSchIsRescRequiredI>
 800a3a4:	4603      	mov	r3, r0
 800a3a6:	2b00      	cmp	r3, #0
 800a3a8:	d001      	beq.n	800a3ae <chSchRescheduleS+0x16>
    chSchDoRescheduleAhead();
 800a3aa:	f000 f81b 	bl	800a3e4 <chSchDoRescheduleAhead>
  }
}
 800a3ae:	bd80      	pop	{r7, pc}

0800a3b0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 800a3b0:	b480      	push	{r7}
 800a3b2:	b083      	sub	sp, #12
 800a3b4:	af00      	add	r7, sp, #0
  tprio_t p1 = firstprio(&ch.rlist.queue);
 800a3b6:	4b0a      	ldr	r3, [pc, #40]	; (800a3e0 <chSchIsPreemptionRequired+0x30>)
 800a3b8:	681b      	ldr	r3, [r3, #0]
 800a3ba:	689b      	ldr	r3, [r3, #8]
 800a3bc:	607b      	str	r3, [r7, #4]
  tprio_t p2 = currp->prio;
 800a3be:	4b08      	ldr	r3, [pc, #32]	; (800a3e0 <chSchIsPreemptionRequired+0x30>)
 800a3c0:	699b      	ldr	r3, [r3, #24]
 800a3c2:	689b      	ldr	r3, [r3, #8]
 800a3c4:	603b      	str	r3, [r7, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 800a3c6:	687a      	ldr	r2, [r7, #4]
 800a3c8:	683b      	ldr	r3, [r7, #0]
 800a3ca:	429a      	cmp	r2, r3
 800a3cc:	bf8c      	ite	hi
 800a3ce:	2301      	movhi	r3, #1
 800a3d0:	2300      	movls	r3, #0
 800a3d2:	b2db      	uxtb	r3, r3
#endif
}
 800a3d4:	4618      	mov	r0, r3
 800a3d6:	370c      	adds	r7, #12
 800a3d8:	46bd      	mov	sp, r7
 800a3da:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a3de:	4770      	bx	lr
 800a3e0:	20001330 	.word	0x20001330

0800a3e4 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 800a3e4:	b590      	push	{r4, r7, lr}
 800a3e6:	b083      	sub	sp, #12
 800a3e8:	af00      	add	r7, sp, #0
  thread_t *otp = currp;
 800a3ea:	4b15      	ldr	r3, [pc, #84]	; (800a440 <chSchDoRescheduleAhead+0x5c>)
 800a3ec:	699b      	ldr	r3, [r3, #24]
 800a3ee:	607b      	str	r3, [r7, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800a3f0:	4813      	ldr	r0, [pc, #76]	; (800a440 <chSchDoRescheduleAhead+0x5c>)
 800a3f2:	f7ff fe3f 	bl	800a074 <queue_fifo_remove>
 800a3f6:	4602      	mov	r2, r0
 800a3f8:	4b11      	ldr	r3, [pc, #68]	; (800a440 <chSchDoRescheduleAhead+0x5c>)
 800a3fa:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800a3fc:	4b10      	ldr	r3, [pc, #64]	; (800a440 <chSchDoRescheduleAhead+0x5c>)
 800a3fe:	699b      	ldr	r3, [r3, #24]
 800a400:	2201      	movs	r2, #1
 800a402:	f883 2020 	strb.w	r2, [r3, #32]
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
 800a406:	6878      	ldr	r0, [r7, #4]
 800a408:	f7ff fea0 	bl	800a14c <chSchReadyAheadI>
 800a40c:	6078      	str	r0, [r7, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800a40e:	f3ef 8309 	mrs	r3, PSP
 800a412:	461c      	mov	r4, r3
  return(result);
 800a414:	4623      	mov	r3, r4

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800a416:	603b      	str	r3, [r7, #0]
 800a418:	683b      	ldr	r3, [r7, #0]
 800a41a:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800a41e:	687b      	ldr	r3, [r7, #4]
 800a420:	69db      	ldr	r3, [r3, #28]
 800a422:	429a      	cmp	r2, r3
 800a424:	d202      	bcs.n	800a42c <chSchDoRescheduleAhead+0x48>
 800a426:	4807      	ldr	r0, [pc, #28]	; (800a444 <chSchDoRescheduleAhead+0x60>)
 800a428:	f7ff fae8 	bl	80099fc <chSysHalt>
 800a42c:	4b04      	ldr	r3, [pc, #16]	; (800a440 <chSchDoRescheduleAhead+0x5c>)
 800a42e:	699b      	ldr	r3, [r3, #24]
 800a430:	4618      	mov	r0, r3
 800a432:	6879      	ldr	r1, [r7, #4]
 800a434:	f7f8 ff2e 	bl	8003294 <_port_switch>
}
 800a438:	370c      	adds	r7, #12
 800a43a:	46bd      	mov	sp, r7
 800a43c:	bd90      	pop	{r4, r7, pc}
 800a43e:	bf00      	nop
 800a440:	20001330 	.word	0x20001330
 800a444:	0800ccb8 	.word	0x0800ccb8

0800a448 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 800a448:	b590      	push	{r4, r7, lr}
 800a44a:	b083      	sub	sp, #12
 800a44c:	af00      	add	r7, sp, #0
  thread_t *otp = currp;
 800a44e:	4b15      	ldr	r3, [pc, #84]	; (800a4a4 <chSchDoReschedule+0x5c>)
 800a450:	699b      	ldr	r3, [r3, #24]
 800a452:	607b      	str	r3, [r7, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800a454:	4813      	ldr	r0, [pc, #76]	; (800a4a4 <chSchDoReschedule+0x5c>)
 800a456:	f7ff fe0d 	bl	800a074 <queue_fifo_remove>
 800a45a:	4602      	mov	r2, r0
 800a45c:	4b11      	ldr	r3, [pc, #68]	; (800a4a4 <chSchDoReschedule+0x5c>)
 800a45e:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800a460:	4b10      	ldr	r3, [pc, #64]	; (800a4a4 <chSchDoReschedule+0x5c>)
 800a462:	699b      	ldr	r3, [r3, #24]
 800a464:	2201      	movs	r2, #1
 800a466:	f883 2020 	strb.w	r2, [r3, #32]
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
 800a46a:	6878      	ldr	r0, [r7, #4]
 800a46c:	f7ff fe6e 	bl	800a14c <chSchReadyAheadI>
 800a470:	6078      	str	r0, [r7, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800a472:	f3ef 8309 	mrs	r3, PSP
 800a476:	461c      	mov	r4, r3
  return(result);
 800a478:	4623      	mov	r3, r4
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800a47a:	603b      	str	r3, [r7, #0]
 800a47c:	683b      	ldr	r3, [r7, #0]
 800a47e:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800a482:	687b      	ldr	r3, [r7, #4]
 800a484:	69db      	ldr	r3, [r3, #28]
 800a486:	429a      	cmp	r2, r3
 800a488:	d202      	bcs.n	800a490 <chSchDoReschedule+0x48>
 800a48a:	4807      	ldr	r0, [pc, #28]	; (800a4a8 <chSchDoReschedule+0x60>)
 800a48c:	f7ff fab6 	bl	80099fc <chSysHalt>
 800a490:	4b04      	ldr	r3, [pc, #16]	; (800a4a4 <chSchDoReschedule+0x5c>)
 800a492:	699b      	ldr	r3, [r3, #24]
 800a494:	4618      	mov	r0, r3
 800a496:	6879      	ldr	r1, [r7, #4]
 800a498:	f7f8 fefc 	bl	8003294 <_port_switch>
}
 800a49c:	370c      	adds	r7, #12
 800a49e:	46bd      	mov	sp, r7
 800a4a0:	bd90      	pop	{r4, r7, pc}
 800a4a2:	bf00      	nop
 800a4a4:	20001330 	.word	0x20001330
 800a4a8:	0800ccb8 	.word	0x0800ccb8

0800a4ac <port_lock.lto_priv.252>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800a4ac:	b480      	push	{r7}
 800a4ae:	b083      	sub	sp, #12
 800a4b0:	af00      	add	r7, sp, #0
 800a4b2:	2320      	movs	r3, #32
 800a4b4:	607b      	str	r3, [r7, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800a4b6:	687b      	ldr	r3, [r7, #4]
 800a4b8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a4bc:	370c      	adds	r7, #12
 800a4be:	46bd      	mov	sp, r7
 800a4c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a4c4:	4770      	bx	lr
 800a4c6:	bf00      	nop

0800a4c8 <port_unlock.lto_priv.249>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800a4c8:	b480      	push	{r7}
 800a4ca:	b083      	sub	sp, #12
 800a4cc:	af00      	add	r7, sp, #0
 800a4ce:	2300      	movs	r3, #0
 800a4d0:	607b      	str	r3, [r7, #4]
 800a4d2:	687b      	ldr	r3, [r7, #4]
 800a4d4:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a4d8:	370c      	adds	r7, #12
 800a4da:	46bd      	mov	sp, r7
 800a4dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a4e0:	4770      	bx	lr
 800a4e2:	bf00      	nop

0800a4e4 <queue_notempty.lto_priv.221>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 800a4e4:	b480      	push	{r7}
 800a4e6:	b083      	sub	sp, #12
 800a4e8:	af00      	add	r7, sp, #0
 800a4ea:	6078      	str	r0, [r7, #4]

  return (bool)(tqp->next != (const thread_t *)tqp);
 800a4ec:	687b      	ldr	r3, [r7, #4]
 800a4ee:	681a      	ldr	r2, [r3, #0]
 800a4f0:	687b      	ldr	r3, [r7, #4]
 800a4f2:	429a      	cmp	r2, r3
 800a4f4:	bf14      	ite	ne
 800a4f6:	2301      	movne	r3, #1
 800a4f8:	2300      	moveq	r3, #0
 800a4fa:	b2db      	uxtb	r3, r3
}
 800a4fc:	4618      	mov	r0, r3
 800a4fe:	370c      	adds	r7, #12
 800a500:	46bd      	mov	sp, r7
 800a502:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a506:	4770      	bx	lr

0800a508 <chSysLock.lto_priv.218>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800a508:	b580      	push	{r7, lr}
 800a50a:	af00      	add	r7, sp, #0

  port_lock();
 800a50c:	f7ff ffce 	bl	800a4ac <port_lock.lto_priv.252>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800a510:	f7ff fac2 	bl	8009a98 <_dbg_check_lock>
}
 800a514:	bd80      	pop	{r7, pc}
 800a516:	bf00      	nop

0800a518 <chSysUnlock.lto_priv.215>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800a518:	b580      	push	{r7, lr}
 800a51a:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 800a51c:	f7ff fad2 	bl	8009ac4 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a520:	4b09      	ldr	r3, [pc, #36]	; (800a548 <chSysUnlock.lto_priv.215+0x30>)
 800a522:	681b      	ldr	r3, [r3, #0]
 800a524:	4a08      	ldr	r2, [pc, #32]	; (800a548 <chSysUnlock.lto_priv.215+0x30>)
 800a526:	4293      	cmp	r3, r2
 800a528:	d00a      	beq.n	800a540 <chSysUnlock.lto_priv.215+0x28>
 800a52a:	4b07      	ldr	r3, [pc, #28]	; (800a548 <chSysUnlock.lto_priv.215+0x30>)
 800a52c:	699b      	ldr	r3, [r3, #24]
 800a52e:	689a      	ldr	r2, [r3, #8]
 800a530:	4b05      	ldr	r3, [pc, #20]	; (800a548 <chSysUnlock.lto_priv.215+0x30>)
 800a532:	681b      	ldr	r3, [r3, #0]
 800a534:	689b      	ldr	r3, [r3, #8]
 800a536:	429a      	cmp	r2, r3
 800a538:	d202      	bcs.n	800a540 <chSysUnlock.lto_priv.215+0x28>
 800a53a:	4804      	ldr	r0, [pc, #16]	; (800a54c <chSysUnlock.lto_priv.215+0x34>)
 800a53c:	f7ff fa5e 	bl	80099fc <chSysHalt>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 800a540:	f7ff ffc2 	bl	800a4c8 <port_unlock.lto_priv.249>
}
 800a544:	bd80      	pop	{r7, pc}
 800a546:	bf00      	nop
 800a548:	20001330 	.word	0x20001330
 800a54c:	0800ceb0 	.word	0x0800ceb0

0800a550 <chThdGetSelfX.lto_priv.237>:
  *
  * @return             A pointer to the current thread.
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {
 800a550:	b480      	push	{r7}
 800a552:	af00      	add	r7, sp, #0

  return ch.rlist.current;
 800a554:	4b03      	ldr	r3, [pc, #12]	; (800a564 <chThdGetSelfX.lto_priv.237+0x14>)
 800a556:	699b      	ldr	r3, [r3, #24]
}
 800a558:	4618      	mov	r0, r3
 800a55a:	46bd      	mov	sp, r7
 800a55c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a560:	4770      	bx	lr
 800a562:	bf00      	nop
 800a564:	20001330 	.word	0x20001330

0800a568 <_encode_uavcan_protocol_RestartNode_res>:
    uint32_t bit_ofs = 0;
    _decode_uavcan_protocol_RestartNode_res(transfer, &bit_ofs, msg, true);
    return (bit_ofs+7)/8;
}

void _encode_uavcan_protocol_RestartNode_res(uint8_t* buffer, struct uavcan_protocol_RestartNode_res_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800a568:	b580      	push	{r7, lr}
 800a56a:	b084      	sub	sp, #16
 800a56c:	af00      	add	r7, sp, #0
 800a56e:	60f8      	str	r0, [r7, #12]
 800a570:	60b9      	str	r1, [r7, #8]
 800a572:	607a      	str	r2, [r7, #4]
 800a574:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
 800a576:	68f8      	ldr	r0, [r7, #12]
 800a578:	2100      	movs	r1, #0
 800a57a:	2208      	movs	r2, #8
 800a57c:	f002 fb5e 	bl	800cc3c <memset>
    canardEncodeScalar(buffer, 0, 1, &msg->ok);
 800a580:	68bb      	ldr	r3, [r7, #8]
 800a582:	68f8      	ldr	r0, [r7, #12]
 800a584:	2100      	movs	r1, #0
 800a586:	2201      	movs	r2, #1
 800a588:	f001 fc36 	bl	800bdf8 <canardEncodeScalar>
    chunk_cb(buffer, 1, ctx);
 800a58c:	687b      	ldr	r3, [r7, #4]
 800a58e:	68f8      	ldr	r0, [r7, #12]
 800a590:	2101      	movs	r1, #1
 800a592:	683a      	ldr	r2, [r7, #0]
 800a594:	4798      	blx	r3
}
 800a596:	3710      	adds	r7, #16
 800a598:	46bd      	mov	sp, r7
 800a59a:	bd80      	pop	{r7, pc}

0800a59c <_decode_uavcan_protocol_RestartNode_res>:

void _decode_uavcan_protocol_RestartNode_res(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_RestartNode_res_s* msg, bool tao) {
 800a59c:	b580      	push	{r7, lr}
 800a59e:	b086      	sub	sp, #24
 800a5a0:	af02      	add	r7, sp, #8
 800a5a2:	60f8      	str	r0, [r7, #12]
 800a5a4:	60b9      	str	r1, [r7, #8]
 800a5a6:	607a      	str	r2, [r7, #4]
 800a5a8:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 1, false, &msg->ok);
 800a5aa:	68bb      	ldr	r3, [r7, #8]
 800a5ac:	681a      	ldr	r2, [r3, #0]
 800a5ae:	687b      	ldr	r3, [r7, #4]
 800a5b0:	9300      	str	r3, [sp, #0]
 800a5b2:	68f8      	ldr	r0, [r7, #12]
 800a5b4:	4611      	mov	r1, r2
 800a5b6:	2201      	movs	r2, #1
 800a5b8:	2300      	movs	r3, #0
 800a5ba:	f001 faa5 	bl	800bb08 <canardDecodeScalar>
    *bit_ofs += 1;
 800a5be:	68bb      	ldr	r3, [r7, #8]
 800a5c0:	681b      	ldr	r3, [r3, #0]
 800a5c2:	1c5a      	adds	r2, r3, #1
 800a5c4:	68bb      	ldr	r3, [r7, #8]
 800a5c6:	601a      	str	r2, [r3, #0]

}
 800a5c8:	3710      	adds	r7, #16
 800a5ca:	46bd      	mov	sp, r7
 800a5cc:	bd80      	pop	{r7, pc}
 800a5ce:	bf00      	nop

0800a5d0 <encode_func.lto_priv.34>:
#include <uavcan.protocol.RestartNode_req.h>
#include <uavcan.protocol.RestartNode_res.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800a5d0:	b580      	push	{r7, lr}
 800a5d2:	b084      	sub	sp, #16
 800a5d4:	af00      	add	r7, sp, #0
 800a5d6:	60f8      	str	r0, [r7, #12]
 800a5d8:	60b9      	str	r1, [r7, #8]
 800a5da:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_RestartNode_req(msg, chunk_cb, ctx);
 800a5dc:	68f8      	ldr	r0, [r7, #12]
 800a5de:	68b9      	ldr	r1, [r7, #8]
 800a5e0:	687a      	ldr	r2, [r7, #4]
 800a5e2:	f000 f811 	bl	800a608 <encode_uavcan_protocol_RestartNode_req>
}
 800a5e6:	3710      	adds	r7, #16
 800a5e8:	46bd      	mov	sp, r7
 800a5ea:	bd80      	pop	{r7, pc}

0800a5ec <decode_func.lto_priv.41>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800a5ec:	b580      	push	{r7, lr}
 800a5ee:	b082      	sub	sp, #8
 800a5f0:	af00      	add	r7, sp, #0
 800a5f2:	6078      	str	r0, [r7, #4]
 800a5f4:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_RestartNode_req(transfer, msg);
 800a5f6:	6878      	ldr	r0, [r7, #4]
 800a5f8:	6839      	ldr	r1, [r7, #0]
 800a5fa:	f000 f819 	bl	800a630 <decode_uavcan_protocol_RestartNode_req>
 800a5fe:	4603      	mov	r3, r0
}
 800a600:	4618      	mov	r0, r3
 800a602:	3708      	adds	r7, #8
 800a604:	46bd      	mov	sp, r7
 800a606:	bd80      	pop	{r7, pc}

0800a608 <encode_uavcan_protocol_RestartNode_req>:
    encode_func,
    decode_func,
    &uavcan_protocol_RestartNode_res_descriptor
};

void encode_uavcan_protocol_RestartNode_req(struct uavcan_protocol_RestartNode_req_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800a608:	b580      	push	{r7, lr}
 800a60a:	b088      	sub	sp, #32
 800a60c:	af02      	add	r7, sp, #8
 800a60e:	60f8      	str	r0, [r7, #12]
 800a610:	60b9      	str	r1, [r7, #8]
 800a612:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_RestartNode_req(buffer, msg, chunk_cb, ctx, true);
 800a614:	f107 0210 	add.w	r2, r7, #16
 800a618:	2301      	movs	r3, #1
 800a61a:	9300      	str	r3, [sp, #0]
 800a61c:	4610      	mov	r0, r2
 800a61e:	68f9      	ldr	r1, [r7, #12]
 800a620:	68ba      	ldr	r2, [r7, #8]
 800a622:	687b      	ldr	r3, [r7, #4]
 800a624:	f000 f81a 	bl	800a65c <_encode_uavcan_protocol_RestartNode_req>
}
 800a628:	3718      	adds	r7, #24
 800a62a:	46bd      	mov	sp, r7
 800a62c:	bd80      	pop	{r7, pc}
 800a62e:	bf00      	nop

0800a630 <decode_uavcan_protocol_RestartNode_req>:

uint32_t decode_uavcan_protocol_RestartNode_req(const CanardRxTransfer* transfer, struct uavcan_protocol_RestartNode_req_s* msg) {
 800a630:	b580      	push	{r7, lr}
 800a632:	b084      	sub	sp, #16
 800a634:	af00      	add	r7, sp, #0
 800a636:	6078      	str	r0, [r7, #4]
 800a638:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800a63a:	2300      	movs	r3, #0
 800a63c:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_RestartNode_req(transfer, &bit_ofs, msg, true);
 800a63e:	f107 030c 	add.w	r3, r7, #12
 800a642:	6878      	ldr	r0, [r7, #4]
 800a644:	4619      	mov	r1, r3
 800a646:	683a      	ldr	r2, [r7, #0]
 800a648:	2301      	movs	r3, #1
 800a64a:	f000 f821 	bl	800a690 <_decode_uavcan_protocol_RestartNode_req>
    return (bit_ofs+7)/8;
 800a64e:	68fb      	ldr	r3, [r7, #12]
 800a650:	3307      	adds	r3, #7
 800a652:	08db      	lsrs	r3, r3, #3
}
 800a654:	4618      	mov	r0, r3
 800a656:	3710      	adds	r7, #16
 800a658:	46bd      	mov	sp, r7
 800a65a:	bd80      	pop	{r7, pc}

0800a65c <_encode_uavcan_protocol_RestartNode_req>:

void _encode_uavcan_protocol_RestartNode_req(uint8_t* buffer, struct uavcan_protocol_RestartNode_req_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800a65c:	b580      	push	{r7, lr}
 800a65e:	b084      	sub	sp, #16
 800a660:	af00      	add	r7, sp, #0
 800a662:	60f8      	str	r0, [r7, #12]
 800a664:	60b9      	str	r1, [r7, #8]
 800a666:	607a      	str	r2, [r7, #4]
 800a668:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
 800a66a:	68f8      	ldr	r0, [r7, #12]
 800a66c:	2100      	movs	r1, #0
 800a66e:	2208      	movs	r2, #8
 800a670:	f002 fae4 	bl	800cc3c <memset>
    canardEncodeScalar(buffer, 0, 40, &msg->magic_number);
 800a674:	68bb      	ldr	r3, [r7, #8]
 800a676:	68f8      	ldr	r0, [r7, #12]
 800a678:	2100      	movs	r1, #0
 800a67a:	2228      	movs	r2, #40	; 0x28
 800a67c:	f001 fbbc 	bl	800bdf8 <canardEncodeScalar>
    chunk_cb(buffer, 40, ctx);
 800a680:	687b      	ldr	r3, [r7, #4]
 800a682:	68f8      	ldr	r0, [r7, #12]
 800a684:	2128      	movs	r1, #40	; 0x28
 800a686:	683a      	ldr	r2, [r7, #0]
 800a688:	4798      	blx	r3
}
 800a68a:	3710      	adds	r7, #16
 800a68c:	46bd      	mov	sp, r7
 800a68e:	bd80      	pop	{r7, pc}

0800a690 <_decode_uavcan_protocol_RestartNode_req>:

void _decode_uavcan_protocol_RestartNode_req(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_RestartNode_req_s* msg, bool tao) {
 800a690:	b580      	push	{r7, lr}
 800a692:	b086      	sub	sp, #24
 800a694:	af02      	add	r7, sp, #8
 800a696:	60f8      	str	r0, [r7, #12]
 800a698:	60b9      	str	r1, [r7, #8]
 800a69a:	607a      	str	r2, [r7, #4]
 800a69c:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 40, false, &msg->magic_number);
 800a69e:	68bb      	ldr	r3, [r7, #8]
 800a6a0:	681a      	ldr	r2, [r3, #0]
 800a6a2:	687b      	ldr	r3, [r7, #4]
 800a6a4:	9300      	str	r3, [sp, #0]
 800a6a6:	68f8      	ldr	r0, [r7, #12]
 800a6a8:	4611      	mov	r1, r2
 800a6aa:	2228      	movs	r2, #40	; 0x28
 800a6ac:	2300      	movs	r3, #0
 800a6ae:	f001 fa2b 	bl	800bb08 <canardDecodeScalar>
    *bit_ofs += 40;
 800a6b2:	68bb      	ldr	r3, [r7, #8]
 800a6b4:	681b      	ldr	r3, [r3, #0]
 800a6b6:	f103 0228 	add.w	r2, r3, #40	; 0x28
 800a6ba:	68bb      	ldr	r3, [r7, #8]
 800a6bc:	601a      	str	r2, [r3, #0]

}
 800a6be:	3710      	adds	r7, #16
 800a6c0:	46bd      	mov	sp, r7
 800a6c2:	bd80      	pop	{r7, pc}

0800a6c4 <encode_func.lto_priv.35>:
#include <uavcan.protocol.dynamic_node_id.Allocation.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800a6c4:	b580      	push	{r7, lr}
 800a6c6:	b084      	sub	sp, #16
 800a6c8:	af00      	add	r7, sp, #0
 800a6ca:	60f8      	str	r0, [r7, #12]
 800a6cc:	60b9      	str	r1, [r7, #8]
 800a6ce:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_dynamic_node_id_Allocation(msg, chunk_cb, ctx);
 800a6d0:	68f8      	ldr	r0, [r7, #12]
 800a6d2:	68b9      	ldr	r1, [r7, #8]
 800a6d4:	687a      	ldr	r2, [r7, #4]
 800a6d6:	f000 f811 	bl	800a6fc <encode_uavcan_protocol_dynamic_node_id_Allocation>
}
 800a6da:	3710      	adds	r7, #16
 800a6dc:	46bd      	mov	sp, r7
 800a6de:	bd80      	pop	{r7, pc}

0800a6e0 <decode_func.lto_priv.42>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800a6e0:	b580      	push	{r7, lr}
 800a6e2:	b082      	sub	sp, #8
 800a6e4:	af00      	add	r7, sp, #0
 800a6e6:	6078      	str	r0, [r7, #4]
 800a6e8:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_dynamic_node_id_Allocation(transfer, msg);
 800a6ea:	6878      	ldr	r0, [r7, #4]
 800a6ec:	6839      	ldr	r1, [r7, #0]
 800a6ee:	f000 f819 	bl	800a724 <decode_uavcan_protocol_dynamic_node_id_Allocation>
 800a6f2:	4603      	mov	r3, r0
}
 800a6f4:	4618      	mov	r0, r3
 800a6f6:	3708      	adds	r7, #8
 800a6f8:	46bd      	mov	sp, r7
 800a6fa:	bd80      	pop	{r7, pc}

0800a6fc <encode_uavcan_protocol_dynamic_node_id_Allocation>:
    encode_func,
    decode_func,
    NULL
};

void encode_uavcan_protocol_dynamic_node_id_Allocation(struct uavcan_protocol_dynamic_node_id_Allocation_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800a6fc:	b580      	push	{r7, lr}
 800a6fe:	b088      	sub	sp, #32
 800a700:	af02      	add	r7, sp, #8
 800a702:	60f8      	str	r0, [r7, #12]
 800a704:	60b9      	str	r1, [r7, #8]
 800a706:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_dynamic_node_id_Allocation(buffer, msg, chunk_cb, ctx, true);
 800a708:	f107 0210 	add.w	r2, r7, #16
 800a70c:	2301      	movs	r3, #1
 800a70e:	9300      	str	r3, [sp, #0]
 800a710:	4610      	mov	r0, r2
 800a712:	68f9      	ldr	r1, [r7, #12]
 800a714:	68ba      	ldr	r2, [r7, #8]
 800a716:	687b      	ldr	r3, [r7, #4]
 800a718:	f000 f81a 	bl	800a750 <_encode_uavcan_protocol_dynamic_node_id_Allocation>
}
 800a71c:	3718      	adds	r7, #24
 800a71e:	46bd      	mov	sp, r7
 800a720:	bd80      	pop	{r7, pc}
 800a722:	bf00      	nop

0800a724 <decode_uavcan_protocol_dynamic_node_id_Allocation>:

uint32_t decode_uavcan_protocol_dynamic_node_id_Allocation(const CanardRxTransfer* transfer, struct uavcan_protocol_dynamic_node_id_Allocation_s* msg) {
 800a724:	b580      	push	{r7, lr}
 800a726:	b084      	sub	sp, #16
 800a728:	af00      	add	r7, sp, #0
 800a72a:	6078      	str	r0, [r7, #4]
 800a72c:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800a72e:	2300      	movs	r3, #0
 800a730:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_dynamic_node_id_Allocation(transfer, &bit_ofs, msg, true);
 800a732:	f107 030c 	add.w	r3, r7, #12
 800a736:	6878      	ldr	r0, [r7, #4]
 800a738:	4619      	mov	r1, r3
 800a73a:	683a      	ldr	r2, [r7, #0]
 800a73c:	2301      	movs	r3, #1
 800a73e:	f000 f869 	bl	800a814 <_decode_uavcan_protocol_dynamic_node_id_Allocation>
    return (bit_ofs+7)/8;
 800a742:	68fb      	ldr	r3, [r7, #12]
 800a744:	3307      	adds	r3, #7
 800a746:	08db      	lsrs	r3, r3, #3
}
 800a748:	4618      	mov	r0, r3
 800a74a:	3710      	adds	r7, #16
 800a74c:	46bd      	mov	sp, r7
 800a74e:	bd80      	pop	{r7, pc}

0800a750 <_encode_uavcan_protocol_dynamic_node_id_Allocation>:

void _encode_uavcan_protocol_dynamic_node_id_Allocation(uint8_t* buffer, struct uavcan_protocol_dynamic_node_id_Allocation_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800a750:	b580      	push	{r7, lr}
 800a752:	b086      	sub	sp, #24
 800a754:	af00      	add	r7, sp, #0
 800a756:	60f8      	str	r0, [r7, #12]
 800a758:	60b9      	str	r1, [r7, #8]
 800a75a:	607a      	str	r2, [r7, #4]
 800a75c:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
 800a75e:	68f8      	ldr	r0, [r7, #12]
 800a760:	2100      	movs	r1, #0
 800a762:	2208      	movs	r2, #8
 800a764:	f002 fa6a 	bl	800cc3c <memset>
    canardEncodeScalar(buffer, 0, 7, &msg->node_id);
 800a768:	68bb      	ldr	r3, [r7, #8]
 800a76a:	68f8      	ldr	r0, [r7, #12]
 800a76c:	2100      	movs	r1, #0
 800a76e:	2207      	movs	r2, #7
 800a770:	f001 fb42 	bl	800bdf8 <canardEncodeScalar>
    chunk_cb(buffer, 7, ctx);
 800a774:	687b      	ldr	r3, [r7, #4]
 800a776:	68f8      	ldr	r0, [r7, #12]
 800a778:	2107      	movs	r1, #7
 800a77a:	683a      	ldr	r2, [r7, #0]
 800a77c:	4798      	blx	r3
    memset(buffer,0,8);
 800a77e:	68f8      	ldr	r0, [r7, #12]
 800a780:	2100      	movs	r1, #0
 800a782:	2208      	movs	r2, #8
 800a784:	f002 fa5a 	bl	800cc3c <memset>
    canardEncodeScalar(buffer, 0, 1, &msg->first_part_of_unique_id);
 800a788:	68bb      	ldr	r3, [r7, #8]
 800a78a:	3301      	adds	r3, #1
 800a78c:	68f8      	ldr	r0, [r7, #12]
 800a78e:	2100      	movs	r1, #0
 800a790:	2201      	movs	r2, #1
 800a792:	f001 fb31 	bl	800bdf8 <canardEncodeScalar>
    chunk_cb(buffer, 1, ctx);
 800a796:	687b      	ldr	r3, [r7, #4]
 800a798:	68f8      	ldr	r0, [r7, #12]
 800a79a:	2101      	movs	r1, #1
 800a79c:	683a      	ldr	r2, [r7, #0]
 800a79e:	4798      	blx	r3
    if (!tao) {
 800a7a0:	f897 3020 	ldrb.w	r3, [r7, #32]
 800a7a4:	f083 0301 	eor.w	r3, r3, #1
 800a7a8:	b2db      	uxtb	r3, r3
 800a7aa:	2b00      	cmp	r3, #0
 800a7ac:	d010      	beq.n	800a7d0 <_encode_uavcan_protocol_dynamic_node_id_Allocation+0x80>
        memset(buffer,0,8);
 800a7ae:	68f8      	ldr	r0, [r7, #12]
 800a7b0:	2100      	movs	r1, #0
 800a7b2:	2208      	movs	r2, #8
 800a7b4:	f002 fa42 	bl	800cc3c <memset>
        canardEncodeScalar(buffer, 0, 5, &msg->unique_id_len);
 800a7b8:	68bb      	ldr	r3, [r7, #8]
 800a7ba:	3302      	adds	r3, #2
 800a7bc:	68f8      	ldr	r0, [r7, #12]
 800a7be:	2100      	movs	r1, #0
 800a7c0:	2205      	movs	r2, #5
 800a7c2:	f001 fb19 	bl	800bdf8 <canardEncodeScalar>
        chunk_cb(buffer, 5, ctx);
 800a7c6:	687b      	ldr	r3, [r7, #4]
 800a7c8:	68f8      	ldr	r0, [r7, #12]
 800a7ca:	2105      	movs	r1, #5
 800a7cc:	683a      	ldr	r2, [r7, #0]
 800a7ce:	4798      	blx	r3
    }
    for (size_t i=0; i < msg->unique_id_len; i++) {
 800a7d0:	2300      	movs	r3, #0
 800a7d2:	617b      	str	r3, [r7, #20]
 800a7d4:	e015      	b.n	800a802 <_encode_uavcan_protocol_dynamic_node_id_Allocation+0xb2>
            memset(buffer,0,8);
 800a7d6:	68f8      	ldr	r0, [r7, #12]
 800a7d8:	2100      	movs	r1, #0
 800a7da:	2208      	movs	r2, #8
 800a7dc:	f002 fa2e 	bl	800cc3c <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->unique_id[i]);
 800a7e0:	68ba      	ldr	r2, [r7, #8]
 800a7e2:	697b      	ldr	r3, [r7, #20]
 800a7e4:	4413      	add	r3, r2
 800a7e6:	3303      	adds	r3, #3
 800a7e8:	68f8      	ldr	r0, [r7, #12]
 800a7ea:	2100      	movs	r1, #0
 800a7ec:	2208      	movs	r2, #8
 800a7ee:	f001 fb03 	bl	800bdf8 <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800a7f2:	687b      	ldr	r3, [r7, #4]
 800a7f4:	68f8      	ldr	r0, [r7, #12]
 800a7f6:	2108      	movs	r1, #8
 800a7f8:	683a      	ldr	r2, [r7, #0]
 800a7fa:	4798      	blx	r3
    if (!tao) {
        memset(buffer,0,8);
        canardEncodeScalar(buffer, 0, 5, &msg->unique_id_len);
        chunk_cb(buffer, 5, ctx);
    }
    for (size_t i=0; i < msg->unique_id_len; i++) {
 800a7fc:	697b      	ldr	r3, [r7, #20]
 800a7fe:	3301      	adds	r3, #1
 800a800:	617b      	str	r3, [r7, #20]
 800a802:	68bb      	ldr	r3, [r7, #8]
 800a804:	789b      	ldrb	r3, [r3, #2]
 800a806:	461a      	mov	r2, r3
 800a808:	697b      	ldr	r3, [r7, #20]
 800a80a:	429a      	cmp	r2, r3
 800a80c:	d8e3      	bhi.n	800a7d6 <_encode_uavcan_protocol_dynamic_node_id_Allocation+0x86>
            memset(buffer,0,8);
            canardEncodeScalar(buffer, 0, 8, &msg->unique_id[i]);
            chunk_cb(buffer, 8, ctx);
    }
}
 800a80e:	3718      	adds	r7, #24
 800a810:	46bd      	mov	sp, r7
 800a812:	bd80      	pop	{r7, pc}

0800a814 <_decode_uavcan_protocol_dynamic_node_id_Allocation>:

void _decode_uavcan_protocol_dynamic_node_id_Allocation(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_dynamic_node_id_Allocation_s* msg, bool tao) {
 800a814:	b580      	push	{r7, lr}
 800a816:	b088      	sub	sp, #32
 800a818:	af02      	add	r7, sp, #8
 800a81a:	60f8      	str	r0, [r7, #12]
 800a81c:	60b9      	str	r1, [r7, #8]
 800a81e:	607a      	str	r2, [r7, #4]
 800a820:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 7, false, &msg->node_id);
 800a822:	68bb      	ldr	r3, [r7, #8]
 800a824:	681a      	ldr	r2, [r3, #0]
 800a826:	687b      	ldr	r3, [r7, #4]
 800a828:	9300      	str	r3, [sp, #0]
 800a82a:	68f8      	ldr	r0, [r7, #12]
 800a82c:	4611      	mov	r1, r2
 800a82e:	2207      	movs	r2, #7
 800a830:	2300      	movs	r3, #0
 800a832:	f001 f969 	bl	800bb08 <canardDecodeScalar>
    *bit_ofs += 7;
 800a836:	68bb      	ldr	r3, [r7, #8]
 800a838:	681b      	ldr	r3, [r3, #0]
 800a83a:	1dda      	adds	r2, r3, #7
 800a83c:	68bb      	ldr	r3, [r7, #8]
 800a83e:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 1, false, &msg->first_part_of_unique_id);
 800a840:	68bb      	ldr	r3, [r7, #8]
 800a842:	681a      	ldr	r2, [r3, #0]
 800a844:	687b      	ldr	r3, [r7, #4]
 800a846:	3301      	adds	r3, #1
 800a848:	9300      	str	r3, [sp, #0]
 800a84a:	68f8      	ldr	r0, [r7, #12]
 800a84c:	4611      	mov	r1, r2
 800a84e:	2201      	movs	r2, #1
 800a850:	2300      	movs	r3, #0
 800a852:	f001 f959 	bl	800bb08 <canardDecodeScalar>
    *bit_ofs += 1;
 800a856:	68bb      	ldr	r3, [r7, #8]
 800a858:	681b      	ldr	r3, [r3, #0]
 800a85a:	1c5a      	adds	r2, r3, #1
 800a85c:	68bb      	ldr	r3, [r7, #8]
 800a85e:	601a      	str	r2, [r3, #0]

    if (!tao) {
 800a860:	78fb      	ldrb	r3, [r7, #3]
 800a862:	f083 0301 	eor.w	r3, r3, #1
 800a866:	b2db      	uxtb	r3, r3
 800a868:	2b00      	cmp	r3, #0
 800a86a:	d010      	beq.n	800a88e <_decode_uavcan_protocol_dynamic_node_id_Allocation+0x7a>
        canardDecodeScalar(transfer, *bit_ofs, 5, false, &msg->unique_id_len);
 800a86c:	68bb      	ldr	r3, [r7, #8]
 800a86e:	681a      	ldr	r2, [r3, #0]
 800a870:	687b      	ldr	r3, [r7, #4]
 800a872:	3302      	adds	r3, #2
 800a874:	9300      	str	r3, [sp, #0]
 800a876:	68f8      	ldr	r0, [r7, #12]
 800a878:	4611      	mov	r1, r2
 800a87a:	2205      	movs	r2, #5
 800a87c:	2300      	movs	r3, #0
 800a87e:	f001 f943 	bl	800bb08 <canardDecodeScalar>
        *bit_ofs += 5;
 800a882:	68bb      	ldr	r3, [r7, #8]
 800a884:	681b      	ldr	r3, [r3, #0]
 800a886:	1d5a      	adds	r2, r3, #5
 800a888:	68bb      	ldr	r3, [r7, #8]
 800a88a:	601a      	str	r2, [r3, #0]
 800a88c:	e00a      	b.n	800a8a4 <_decode_uavcan_protocol_dynamic_node_id_Allocation+0x90>
    } else {
        msg->unique_id_len = ((transfer->payload_len*8)-*bit_ofs)/8;
 800a88e:	68fb      	ldr	r3, [r7, #12]
 800a890:	8a9b      	ldrh	r3, [r3, #20]
 800a892:	00db      	lsls	r3, r3, #3
 800a894:	461a      	mov	r2, r3
 800a896:	68bb      	ldr	r3, [r7, #8]
 800a898:	681b      	ldr	r3, [r3, #0]
 800a89a:	1ad3      	subs	r3, r2, r3
 800a89c:	08db      	lsrs	r3, r3, #3
 800a89e:	b2da      	uxtb	r2, r3
 800a8a0:	687b      	ldr	r3, [r7, #4]
 800a8a2:	709a      	strb	r2, [r3, #2]
    }

    for (size_t i=0; i < msg->unique_id_len; i++) {
 800a8a4:	2300      	movs	r3, #0
 800a8a6:	617b      	str	r3, [r7, #20]
 800a8a8:	e014      	b.n	800a8d4 <_decode_uavcan_protocol_dynamic_node_id_Allocation+0xc0>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->unique_id[i]);
 800a8aa:	68bb      	ldr	r3, [r7, #8]
 800a8ac:	6819      	ldr	r1, [r3, #0]
 800a8ae:	687a      	ldr	r2, [r7, #4]
 800a8b0:	697b      	ldr	r3, [r7, #20]
 800a8b2:	4413      	add	r3, r2
 800a8b4:	3303      	adds	r3, #3
 800a8b6:	9300      	str	r3, [sp, #0]
 800a8b8:	68f8      	ldr	r0, [r7, #12]
 800a8ba:	2208      	movs	r2, #8
 800a8bc:	2300      	movs	r3, #0
 800a8be:	f001 f923 	bl	800bb08 <canardDecodeScalar>
        *bit_ofs += 8;
 800a8c2:	68bb      	ldr	r3, [r7, #8]
 800a8c4:	681b      	ldr	r3, [r3, #0]
 800a8c6:	f103 0208 	add.w	r2, r3, #8
 800a8ca:	68bb      	ldr	r3, [r7, #8]
 800a8cc:	601a      	str	r2, [r3, #0]
        *bit_ofs += 5;
    } else {
        msg->unique_id_len = ((transfer->payload_len*8)-*bit_ofs)/8;
    }

    for (size_t i=0; i < msg->unique_id_len; i++) {
 800a8ce:	697b      	ldr	r3, [r7, #20]
 800a8d0:	3301      	adds	r3, #1
 800a8d2:	617b      	str	r3, [r7, #20]
 800a8d4:	687b      	ldr	r3, [r7, #4]
 800a8d6:	789b      	ldrb	r3, [r3, #2]
 800a8d8:	461a      	mov	r2, r3
 800a8da:	697b      	ldr	r3, [r7, #20]
 800a8dc:	429a      	cmp	r2, r3
 800a8de:	d8e4      	bhi.n	800a8aa <_decode_uavcan_protocol_dynamic_node_id_Allocation+0x96>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->unique_id[i]);
        *bit_ofs += 8;
    }

}
 800a8e0:	3718      	adds	r7, #24
 800a8e2:	46bd      	mov	sp, r7
 800a8e4:	bd80      	pop	{r7, pc}
 800a8e6:	bf00      	nop

0800a8e8 <encode_func.lto_priv.37>:
#include <uavcan.protocol.GetNodeInfo_res.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800a8e8:	b580      	push	{r7, lr}
 800a8ea:	b084      	sub	sp, #16
 800a8ec:	af00      	add	r7, sp, #0
 800a8ee:	60f8      	str	r0, [r7, #12]
 800a8f0:	60b9      	str	r1, [r7, #8]
 800a8f2:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_GetNodeInfo_res(msg, chunk_cb, ctx);
 800a8f4:	68f8      	ldr	r0, [r7, #12]
 800a8f6:	68b9      	ldr	r1, [r7, #8]
 800a8f8:	687a      	ldr	r2, [r7, #4]
 800a8fa:	f000 f811 	bl	800a920 <encode_uavcan_protocol_GetNodeInfo_res>
}
 800a8fe:	3710      	adds	r7, #16
 800a900:	46bd      	mov	sp, r7
 800a902:	bd80      	pop	{r7, pc}

0800a904 <decode_func.lto_priv.44>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800a904:	b580      	push	{r7, lr}
 800a906:	b082      	sub	sp, #8
 800a908:	af00      	add	r7, sp, #0
 800a90a:	6078      	str	r0, [r7, #4]
 800a90c:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_GetNodeInfo_res(transfer, msg);
 800a90e:	6878      	ldr	r0, [r7, #4]
 800a910:	6839      	ldr	r1, [r7, #0]
 800a912:	f000 f819 	bl	800a948 <decode_uavcan_protocol_GetNodeInfo_res>
 800a916:	4603      	mov	r3, r0
}
 800a918:	4618      	mov	r0, r3
 800a91a:	3708      	adds	r7, #8
 800a91c:	46bd      	mov	sp, r7
 800a91e:	bd80      	pop	{r7, pc}

0800a920 <encode_uavcan_protocol_GetNodeInfo_res>:
    encode_func,
    decode_func,
    NULL
};

void encode_uavcan_protocol_GetNodeInfo_res(struct uavcan_protocol_GetNodeInfo_res_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800a920:	b580      	push	{r7, lr}
 800a922:	b088      	sub	sp, #32
 800a924:	af02      	add	r7, sp, #8
 800a926:	60f8      	str	r0, [r7, #12]
 800a928:	60b9      	str	r1, [r7, #8]
 800a92a:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_GetNodeInfo_res(buffer, msg, chunk_cb, ctx, true);
 800a92c:	f107 0210 	add.w	r2, r7, #16
 800a930:	2301      	movs	r3, #1
 800a932:	9300      	str	r3, [sp, #0]
 800a934:	4610      	mov	r0, r2
 800a936:	68f9      	ldr	r1, [r7, #12]
 800a938:	68ba      	ldr	r2, [r7, #8]
 800a93a:	687b      	ldr	r3, [r7, #4]
 800a93c:	f000 f81a 	bl	800a974 <_encode_uavcan_protocol_GetNodeInfo_res>
}
 800a940:	3718      	adds	r7, #24
 800a942:	46bd      	mov	sp, r7
 800a944:	bd80      	pop	{r7, pc}
 800a946:	bf00      	nop

0800a948 <decode_uavcan_protocol_GetNodeInfo_res>:

uint32_t decode_uavcan_protocol_GetNodeInfo_res(const CanardRxTransfer* transfer, struct uavcan_protocol_GetNodeInfo_res_s* msg) {
 800a948:	b580      	push	{r7, lr}
 800a94a:	b084      	sub	sp, #16
 800a94c:	af00      	add	r7, sp, #0
 800a94e:	6078      	str	r0, [r7, #4]
 800a950:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800a952:	2300      	movs	r3, #0
 800a954:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_GetNodeInfo_res(transfer, &bit_ofs, msg, true);
 800a956:	f107 030c 	add.w	r3, r7, #12
 800a95a:	6878      	ldr	r0, [r7, #4]
 800a95c:	4619      	mov	r1, r3
 800a95e:	683a      	ldr	r2, [r7, #0]
 800a960:	2301      	movs	r3, #1
 800a962:	f000 f86b 	bl	800aa3c <_decode_uavcan_protocol_GetNodeInfo_res>
    return (bit_ofs+7)/8;
 800a966:	68fb      	ldr	r3, [r7, #12]
 800a968:	3307      	adds	r3, #7
 800a96a:	08db      	lsrs	r3, r3, #3
}
 800a96c:	4618      	mov	r0, r3
 800a96e:	3710      	adds	r7, #16
 800a970:	46bd      	mov	sp, r7
 800a972:	bd80      	pop	{r7, pc}

0800a974 <_encode_uavcan_protocol_GetNodeInfo_res>:

void _encode_uavcan_protocol_GetNodeInfo_res(uint8_t* buffer, struct uavcan_protocol_GetNodeInfo_res_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800a974:	b580      	push	{r7, lr}
 800a976:	b088      	sub	sp, #32
 800a978:	af02      	add	r7, sp, #8
 800a97a:	60f8      	str	r0, [r7, #12]
 800a97c:	60b9      	str	r1, [r7, #8]
 800a97e:	607a      	str	r2, [r7, #4]
 800a980:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    _encode_uavcan_protocol_NodeStatus(buffer, &msg->status, chunk_cb, ctx, false);
 800a982:	68ba      	ldr	r2, [r7, #8]
 800a984:	2300      	movs	r3, #0
 800a986:	9300      	str	r3, [sp, #0]
 800a988:	68f8      	ldr	r0, [r7, #12]
 800a98a:	4611      	mov	r1, r2
 800a98c:	687a      	ldr	r2, [r7, #4]
 800a98e:	683b      	ldr	r3, [r7, #0]
 800a990:	f002 f81e 	bl	800c9d0 <_encode_uavcan_protocol_NodeStatus>
    _encode_uavcan_protocol_SoftwareVersion(buffer, &msg->software_version, chunk_cb, ctx, false);
 800a994:	68bb      	ldr	r3, [r7, #8]
 800a996:	f103 0210 	add.w	r2, r3, #16
 800a99a:	2300      	movs	r3, #0
 800a99c:	9300      	str	r3, [sp, #0]
 800a99e:	68f8      	ldr	r0, [r7, #12]
 800a9a0:	4611      	mov	r1, r2
 800a9a2:	687a      	ldr	r2, [r7, #4]
 800a9a4:	683b      	ldr	r3, [r7, #0]
 800a9a6:	f000 f9b7 	bl	800ad18 <_encode_uavcan_protocol_SoftwareVersion>
    _encode_uavcan_protocol_HardwareVersion(buffer, &msg->hardware_version, chunk_cb, ctx, false);
 800a9aa:	68bb      	ldr	r3, [r7, #8]
 800a9ac:	f103 0220 	add.w	r2, r3, #32
 800a9b0:	2300      	movs	r3, #0
 800a9b2:	9300      	str	r3, [sp, #0]
 800a9b4:	68f8      	ldr	r0, [r7, #12]
 800a9b6:	4611      	mov	r1, r2
 800a9b8:	687a      	ldr	r2, [r7, #4]
 800a9ba:	683b      	ldr	r3, [r7, #0]
 800a9bc:	f000 f8a4 	bl	800ab08 <_encode_uavcan_protocol_HardwareVersion>
    if (!tao) {
 800a9c0:	f897 3020 	ldrb.w	r3, [r7, #32]
 800a9c4:	f083 0301 	eor.w	r3, r3, #1
 800a9c8:	b2db      	uxtb	r3, r3
 800a9ca:	2b00      	cmp	r3, #0
 800a9cc:	d011      	beq.n	800a9f2 <_encode_uavcan_protocol_GetNodeInfo_res+0x7e>
        memset(buffer,0,8);
 800a9ce:	68f8      	ldr	r0, [r7, #12]
 800a9d0:	2100      	movs	r1, #0
 800a9d2:	2208      	movs	r2, #8
 800a9d4:	f002 f932 	bl	800cc3c <memset>
        canardEncodeScalar(buffer, 0, 7, &msg->name_len);
 800a9d8:	68bb      	ldr	r3, [r7, #8]
 800a9da:	f503 7399 	add.w	r3, r3, #306	; 0x132
 800a9de:	68f8      	ldr	r0, [r7, #12]
 800a9e0:	2100      	movs	r1, #0
 800a9e2:	2207      	movs	r2, #7
 800a9e4:	f001 fa08 	bl	800bdf8 <canardEncodeScalar>
        chunk_cb(buffer, 7, ctx);
 800a9e8:	687b      	ldr	r3, [r7, #4]
 800a9ea:	68f8      	ldr	r0, [r7, #12]
 800a9ec:	2107      	movs	r1, #7
 800a9ee:	683a      	ldr	r2, [r7, #0]
 800a9f0:	4798      	blx	r3
    }
    for (size_t i=0; i < msg->name_len; i++) {
 800a9f2:	2300      	movs	r3, #0
 800a9f4:	617b      	str	r3, [r7, #20]
 800a9f6:	e017      	b.n	800aa28 <_encode_uavcan_protocol_GetNodeInfo_res+0xb4>
            memset(buffer,0,8);
 800a9f8:	68f8      	ldr	r0, [r7, #12]
 800a9fa:	2100      	movs	r1, #0
 800a9fc:	2208      	movs	r2, #8
 800a9fe:	f002 f91d 	bl	800cc3c <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->name[i]);
 800aa02:	697b      	ldr	r3, [r7, #20]
 800aa04:	f503 7398 	add.w	r3, r3, #304	; 0x130
 800aa08:	68ba      	ldr	r2, [r7, #8]
 800aa0a:	4413      	add	r3, r2
 800aa0c:	3303      	adds	r3, #3
 800aa0e:	68f8      	ldr	r0, [r7, #12]
 800aa10:	2100      	movs	r1, #0
 800aa12:	2208      	movs	r2, #8
 800aa14:	f001 f9f0 	bl	800bdf8 <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800aa18:	687b      	ldr	r3, [r7, #4]
 800aa1a:	68f8      	ldr	r0, [r7, #12]
 800aa1c:	2108      	movs	r1, #8
 800aa1e:	683a      	ldr	r2, [r7, #0]
 800aa20:	4798      	blx	r3
    if (!tao) {
        memset(buffer,0,8);
        canardEncodeScalar(buffer, 0, 7, &msg->name_len);
        chunk_cb(buffer, 7, ctx);
    }
    for (size_t i=0; i < msg->name_len; i++) {
 800aa22:	697b      	ldr	r3, [r7, #20]
 800aa24:	3301      	adds	r3, #1
 800aa26:	617b      	str	r3, [r7, #20]
 800aa28:	68bb      	ldr	r3, [r7, #8]
 800aa2a:	f893 3132 	ldrb.w	r3, [r3, #306]	; 0x132
 800aa2e:	461a      	mov	r2, r3
 800aa30:	697b      	ldr	r3, [r7, #20]
 800aa32:	429a      	cmp	r2, r3
 800aa34:	d8e0      	bhi.n	800a9f8 <_encode_uavcan_protocol_GetNodeInfo_res+0x84>
            memset(buffer,0,8);
            canardEncodeScalar(buffer, 0, 8, &msg->name[i]);
            chunk_cb(buffer, 8, ctx);
    }
}
 800aa36:	3718      	adds	r7, #24
 800aa38:	46bd      	mov	sp, r7
 800aa3a:	bd80      	pop	{r7, pc}

0800aa3c <_decode_uavcan_protocol_GetNodeInfo_res>:

void _decode_uavcan_protocol_GetNodeInfo_res(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_GetNodeInfo_res_s* msg, bool tao) {
 800aa3c:	b580      	push	{r7, lr}
 800aa3e:	b088      	sub	sp, #32
 800aa40:	af02      	add	r7, sp, #8
 800aa42:	60f8      	str	r0, [r7, #12]
 800aa44:	60b9      	str	r1, [r7, #8]
 800aa46:	607a      	str	r2, [r7, #4]
 800aa48:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    _decode_uavcan_protocol_NodeStatus(transfer, bit_ofs, &msg->status, false);
 800aa4a:	687b      	ldr	r3, [r7, #4]
 800aa4c:	68f8      	ldr	r0, [r7, #12]
 800aa4e:	68b9      	ldr	r1, [r7, #8]
 800aa50:	461a      	mov	r2, r3
 800aa52:	2300      	movs	r3, #0
 800aa54:	f002 f81a 	bl	800ca8c <_decode_uavcan_protocol_NodeStatus>

    _decode_uavcan_protocol_SoftwareVersion(transfer, bit_ofs, &msg->software_version, false);
 800aa58:	687b      	ldr	r3, [r7, #4]
 800aa5a:	3310      	adds	r3, #16
 800aa5c:	68f8      	ldr	r0, [r7, #12]
 800aa5e:	68b9      	ldr	r1, [r7, #8]
 800aa60:	461a      	mov	r2, r3
 800aa62:	2300      	movs	r3, #0
 800aa64:	f000 f9b6 	bl	800add4 <_decode_uavcan_protocol_SoftwareVersion>

    _decode_uavcan_protocol_HardwareVersion(transfer, bit_ofs, &msg->hardware_version, false);
 800aa68:	687b      	ldr	r3, [r7, #4]
 800aa6a:	3320      	adds	r3, #32
 800aa6c:	68f8      	ldr	r0, [r7, #12]
 800aa6e:	68b9      	ldr	r1, [r7, #8]
 800aa70:	461a      	mov	r2, r3
 800aa72:	2300      	movs	r3, #0
 800aa74:	f000 f8c8 	bl	800ac08 <_decode_uavcan_protocol_HardwareVersion>

    if (!tao) {
 800aa78:	78fb      	ldrb	r3, [r7, #3]
 800aa7a:	f083 0301 	eor.w	r3, r3, #1
 800aa7e:	b2db      	uxtb	r3, r3
 800aa80:	2b00      	cmp	r3, #0
 800aa82:	d011      	beq.n	800aaa8 <_decode_uavcan_protocol_GetNodeInfo_res+0x6c>
        canardDecodeScalar(transfer, *bit_ofs, 7, false, &msg->name_len);
 800aa84:	68bb      	ldr	r3, [r7, #8]
 800aa86:	681a      	ldr	r2, [r3, #0]
 800aa88:	687b      	ldr	r3, [r7, #4]
 800aa8a:	f503 7399 	add.w	r3, r3, #306	; 0x132
 800aa8e:	9300      	str	r3, [sp, #0]
 800aa90:	68f8      	ldr	r0, [r7, #12]
 800aa92:	4611      	mov	r1, r2
 800aa94:	2207      	movs	r2, #7
 800aa96:	2300      	movs	r3, #0
 800aa98:	f001 f836 	bl	800bb08 <canardDecodeScalar>
        *bit_ofs += 7;
 800aa9c:	68bb      	ldr	r3, [r7, #8]
 800aa9e:	681b      	ldr	r3, [r3, #0]
 800aaa0:	1dda      	adds	r2, r3, #7
 800aaa2:	68bb      	ldr	r3, [r7, #8]
 800aaa4:	601a      	str	r2, [r3, #0]
 800aaa6:	e00b      	b.n	800aac0 <_decode_uavcan_protocol_GetNodeInfo_res+0x84>
    } else {
        msg->name_len = ((transfer->payload_len*8)-*bit_ofs)/8;
 800aaa8:	68fb      	ldr	r3, [r7, #12]
 800aaaa:	8a9b      	ldrh	r3, [r3, #20]
 800aaac:	00db      	lsls	r3, r3, #3
 800aaae:	461a      	mov	r2, r3
 800aab0:	68bb      	ldr	r3, [r7, #8]
 800aab2:	681b      	ldr	r3, [r3, #0]
 800aab4:	1ad3      	subs	r3, r2, r3
 800aab6:	08db      	lsrs	r3, r3, #3
 800aab8:	b2da      	uxtb	r2, r3
 800aaba:	687b      	ldr	r3, [r7, #4]
 800aabc:	f883 2132 	strb.w	r2, [r3, #306]	; 0x132
    }

    for (size_t i=0; i < msg->name_len; i++) {
 800aac0:	2300      	movs	r3, #0
 800aac2:	617b      	str	r3, [r7, #20]
 800aac4:	e016      	b.n	800aaf4 <_decode_uavcan_protocol_GetNodeInfo_res+0xb8>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->name[i]);
 800aac6:	68bb      	ldr	r3, [r7, #8]
 800aac8:	6819      	ldr	r1, [r3, #0]
 800aaca:	697b      	ldr	r3, [r7, #20]
 800aacc:	f503 7398 	add.w	r3, r3, #304	; 0x130
 800aad0:	687a      	ldr	r2, [r7, #4]
 800aad2:	4413      	add	r3, r2
 800aad4:	3303      	adds	r3, #3
 800aad6:	9300      	str	r3, [sp, #0]
 800aad8:	68f8      	ldr	r0, [r7, #12]
 800aada:	2208      	movs	r2, #8
 800aadc:	2300      	movs	r3, #0
 800aade:	f001 f813 	bl	800bb08 <canardDecodeScalar>
        *bit_ofs += 8;
 800aae2:	68bb      	ldr	r3, [r7, #8]
 800aae4:	681b      	ldr	r3, [r3, #0]
 800aae6:	f103 0208 	add.w	r2, r3, #8
 800aaea:	68bb      	ldr	r3, [r7, #8]
 800aaec:	601a      	str	r2, [r3, #0]
        *bit_ofs += 7;
    } else {
        msg->name_len = ((transfer->payload_len*8)-*bit_ofs)/8;
    }

    for (size_t i=0; i < msg->name_len; i++) {
 800aaee:	697b      	ldr	r3, [r7, #20]
 800aaf0:	3301      	adds	r3, #1
 800aaf2:	617b      	str	r3, [r7, #20]
 800aaf4:	687b      	ldr	r3, [r7, #4]
 800aaf6:	f893 3132 	ldrb.w	r3, [r3, #306]	; 0x132
 800aafa:	461a      	mov	r2, r3
 800aafc:	697b      	ldr	r3, [r7, #20]
 800aafe:	429a      	cmp	r2, r3
 800ab00:	d8e1      	bhi.n	800aac6 <_decode_uavcan_protocol_GetNodeInfo_res+0x8a>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->name[i]);
        *bit_ofs += 8;
    }

}
 800ab02:	3718      	adds	r7, #24
 800ab04:	46bd      	mov	sp, r7
 800ab06:	bd80      	pop	{r7, pc}

0800ab08 <_encode_uavcan_protocol_HardwareVersion>:
    uint32_t bit_ofs = 0;
    _decode_uavcan_protocol_HardwareVersion(transfer, &bit_ofs, msg, true);
    return (bit_ofs+7)/8;
}

void _encode_uavcan_protocol_HardwareVersion(uint8_t* buffer, struct uavcan_protocol_HardwareVersion_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800ab08:	b580      	push	{r7, lr}
 800ab0a:	b086      	sub	sp, #24
 800ab0c:	af00      	add	r7, sp, #0
 800ab0e:	60f8      	str	r0, [r7, #12]
 800ab10:	60b9      	str	r1, [r7, #8]
 800ab12:	607a      	str	r2, [r7, #4]
 800ab14:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
 800ab16:	68f8      	ldr	r0, [r7, #12]
 800ab18:	2100      	movs	r1, #0
 800ab1a:	2208      	movs	r2, #8
 800ab1c:	f002 f88e 	bl	800cc3c <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->major);
 800ab20:	68bb      	ldr	r3, [r7, #8]
 800ab22:	68f8      	ldr	r0, [r7, #12]
 800ab24:	2100      	movs	r1, #0
 800ab26:	2208      	movs	r2, #8
 800ab28:	f001 f966 	bl	800bdf8 <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800ab2c:	687b      	ldr	r3, [r7, #4]
 800ab2e:	68f8      	ldr	r0, [r7, #12]
 800ab30:	2108      	movs	r1, #8
 800ab32:	683a      	ldr	r2, [r7, #0]
 800ab34:	4798      	blx	r3
    memset(buffer,0,8);
 800ab36:	68f8      	ldr	r0, [r7, #12]
 800ab38:	2100      	movs	r1, #0
 800ab3a:	2208      	movs	r2, #8
 800ab3c:	f002 f87e 	bl	800cc3c <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->minor);
 800ab40:	68bb      	ldr	r3, [r7, #8]
 800ab42:	3301      	adds	r3, #1
 800ab44:	68f8      	ldr	r0, [r7, #12]
 800ab46:	2100      	movs	r1, #0
 800ab48:	2208      	movs	r2, #8
 800ab4a:	f001 f955 	bl	800bdf8 <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800ab4e:	687b      	ldr	r3, [r7, #4]
 800ab50:	68f8      	ldr	r0, [r7, #12]
 800ab52:	2108      	movs	r1, #8
 800ab54:	683a      	ldr	r2, [r7, #0]
 800ab56:	4798      	blx	r3
    for (size_t i=0; i < 16; i++) {
 800ab58:	2300      	movs	r3, #0
 800ab5a:	617b      	str	r3, [r7, #20]
 800ab5c:	e015      	b.n	800ab8a <_encode_uavcan_protocol_HardwareVersion+0x82>
            memset(buffer,0,8);
 800ab5e:	68f8      	ldr	r0, [r7, #12]
 800ab60:	2100      	movs	r1, #0
 800ab62:	2208      	movs	r2, #8
 800ab64:	f002 f86a 	bl	800cc3c <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->unique_id[i]);
 800ab68:	68ba      	ldr	r2, [r7, #8]
 800ab6a:	697b      	ldr	r3, [r7, #20]
 800ab6c:	4413      	add	r3, r2
 800ab6e:	3302      	adds	r3, #2
 800ab70:	68f8      	ldr	r0, [r7, #12]
 800ab72:	2100      	movs	r1, #0
 800ab74:	2208      	movs	r2, #8
 800ab76:	f001 f93f 	bl	800bdf8 <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800ab7a:	687b      	ldr	r3, [r7, #4]
 800ab7c:	68f8      	ldr	r0, [r7, #12]
 800ab7e:	2108      	movs	r1, #8
 800ab80:	683a      	ldr	r2, [r7, #0]
 800ab82:	4798      	blx	r3
    canardEncodeScalar(buffer, 0, 8, &msg->major);
    chunk_cb(buffer, 8, ctx);
    memset(buffer,0,8);
    canardEncodeScalar(buffer, 0, 8, &msg->minor);
    chunk_cb(buffer, 8, ctx);
    for (size_t i=0; i < 16; i++) {
 800ab84:	697b      	ldr	r3, [r7, #20]
 800ab86:	3301      	adds	r3, #1
 800ab88:	617b      	str	r3, [r7, #20]
 800ab8a:	697b      	ldr	r3, [r7, #20]
 800ab8c:	2b0f      	cmp	r3, #15
 800ab8e:	d9e6      	bls.n	800ab5e <_encode_uavcan_protocol_HardwareVersion+0x56>
            memset(buffer,0,8);
            canardEncodeScalar(buffer, 0, 8, &msg->unique_id[i]);
            chunk_cb(buffer, 8, ctx);
    }
    if (!tao) {
 800ab90:	f897 3020 	ldrb.w	r3, [r7, #32]
 800ab94:	f083 0301 	eor.w	r3, r3, #1
 800ab98:	b2db      	uxtb	r3, r3
 800ab9a:	2b00      	cmp	r3, #0
 800ab9c:	d010      	beq.n	800abc0 <_encode_uavcan_protocol_HardwareVersion+0xb8>
        memset(buffer,0,8);
 800ab9e:	68f8      	ldr	r0, [r7, #12]
 800aba0:	2100      	movs	r1, #0
 800aba2:	2208      	movs	r2, #8
 800aba4:	f002 f84a 	bl	800cc3c <memset>
        canardEncodeScalar(buffer, 0, 8, &msg->certificate_of_authenticity_len);
 800aba8:	68bb      	ldr	r3, [r7, #8]
 800abaa:	3312      	adds	r3, #18
 800abac:	68f8      	ldr	r0, [r7, #12]
 800abae:	2100      	movs	r1, #0
 800abb0:	2208      	movs	r2, #8
 800abb2:	f001 f921 	bl	800bdf8 <canardEncodeScalar>
        chunk_cb(buffer, 8, ctx);
 800abb6:	687b      	ldr	r3, [r7, #4]
 800abb8:	68f8      	ldr	r0, [r7, #12]
 800abba:	2108      	movs	r1, #8
 800abbc:	683a      	ldr	r2, [r7, #0]
 800abbe:	4798      	blx	r3
    }
    for (size_t i=0; i < msg->certificate_of_authenticity_len; i++) {
 800abc0:	2300      	movs	r3, #0
 800abc2:	613b      	str	r3, [r7, #16]
 800abc4:	e016      	b.n	800abf4 <_encode_uavcan_protocol_HardwareVersion+0xec>
            memset(buffer,0,8);
 800abc6:	68f8      	ldr	r0, [r7, #12]
 800abc8:	2100      	movs	r1, #0
 800abca:	2208      	movs	r2, #8
 800abcc:	f002 f836 	bl	800cc3c <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->certificate_of_authenticity[i]);
 800abd0:	693b      	ldr	r3, [r7, #16]
 800abd2:	3310      	adds	r3, #16
 800abd4:	68ba      	ldr	r2, [r7, #8]
 800abd6:	4413      	add	r3, r2
 800abd8:	3303      	adds	r3, #3
 800abda:	68f8      	ldr	r0, [r7, #12]
 800abdc:	2100      	movs	r1, #0
 800abde:	2208      	movs	r2, #8
 800abe0:	f001 f90a 	bl	800bdf8 <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800abe4:	687b      	ldr	r3, [r7, #4]
 800abe6:	68f8      	ldr	r0, [r7, #12]
 800abe8:	2108      	movs	r1, #8
 800abea:	683a      	ldr	r2, [r7, #0]
 800abec:	4798      	blx	r3
    if (!tao) {
        memset(buffer,0,8);
        canardEncodeScalar(buffer, 0, 8, &msg->certificate_of_authenticity_len);
        chunk_cb(buffer, 8, ctx);
    }
    for (size_t i=0; i < msg->certificate_of_authenticity_len; i++) {
 800abee:	693b      	ldr	r3, [r7, #16]
 800abf0:	3301      	adds	r3, #1
 800abf2:	613b      	str	r3, [r7, #16]
 800abf4:	68bb      	ldr	r3, [r7, #8]
 800abf6:	7c9b      	ldrb	r3, [r3, #18]
 800abf8:	461a      	mov	r2, r3
 800abfa:	693b      	ldr	r3, [r7, #16]
 800abfc:	429a      	cmp	r2, r3
 800abfe:	d8e2      	bhi.n	800abc6 <_encode_uavcan_protocol_HardwareVersion+0xbe>
            memset(buffer,0,8);
            canardEncodeScalar(buffer, 0, 8, &msg->certificate_of_authenticity[i]);
            chunk_cb(buffer, 8, ctx);
    }
}
 800ac00:	3718      	adds	r7, #24
 800ac02:	46bd      	mov	sp, r7
 800ac04:	bd80      	pop	{r7, pc}
 800ac06:	bf00      	nop

0800ac08 <_decode_uavcan_protocol_HardwareVersion>:

void _decode_uavcan_protocol_HardwareVersion(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_HardwareVersion_s* msg, bool tao) {
 800ac08:	b580      	push	{r7, lr}
 800ac0a:	b088      	sub	sp, #32
 800ac0c:	af02      	add	r7, sp, #8
 800ac0e:	60f8      	str	r0, [r7, #12]
 800ac10:	60b9      	str	r1, [r7, #8]
 800ac12:	607a      	str	r2, [r7, #4]
 800ac14:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->major);
 800ac16:	68bb      	ldr	r3, [r7, #8]
 800ac18:	681a      	ldr	r2, [r3, #0]
 800ac1a:	687b      	ldr	r3, [r7, #4]
 800ac1c:	9300      	str	r3, [sp, #0]
 800ac1e:	68f8      	ldr	r0, [r7, #12]
 800ac20:	4611      	mov	r1, r2
 800ac22:	2208      	movs	r2, #8
 800ac24:	2300      	movs	r3, #0
 800ac26:	f000 ff6f 	bl	800bb08 <canardDecodeScalar>
    *bit_ofs += 8;
 800ac2a:	68bb      	ldr	r3, [r7, #8]
 800ac2c:	681b      	ldr	r3, [r3, #0]
 800ac2e:	f103 0208 	add.w	r2, r3, #8
 800ac32:	68bb      	ldr	r3, [r7, #8]
 800ac34:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->minor);
 800ac36:	68bb      	ldr	r3, [r7, #8]
 800ac38:	681a      	ldr	r2, [r3, #0]
 800ac3a:	687b      	ldr	r3, [r7, #4]
 800ac3c:	3301      	adds	r3, #1
 800ac3e:	9300      	str	r3, [sp, #0]
 800ac40:	68f8      	ldr	r0, [r7, #12]
 800ac42:	4611      	mov	r1, r2
 800ac44:	2208      	movs	r2, #8
 800ac46:	2300      	movs	r3, #0
 800ac48:	f000 ff5e 	bl	800bb08 <canardDecodeScalar>
    *bit_ofs += 8;
 800ac4c:	68bb      	ldr	r3, [r7, #8]
 800ac4e:	681b      	ldr	r3, [r3, #0]
 800ac50:	f103 0208 	add.w	r2, r3, #8
 800ac54:	68bb      	ldr	r3, [r7, #8]
 800ac56:	601a      	str	r2, [r3, #0]

    for (size_t i=0; i < 16; i++) {
 800ac58:	2300      	movs	r3, #0
 800ac5a:	617b      	str	r3, [r7, #20]
 800ac5c:	e014      	b.n	800ac88 <_decode_uavcan_protocol_HardwareVersion+0x80>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->unique_id[i]);
 800ac5e:	68bb      	ldr	r3, [r7, #8]
 800ac60:	6819      	ldr	r1, [r3, #0]
 800ac62:	687a      	ldr	r2, [r7, #4]
 800ac64:	697b      	ldr	r3, [r7, #20]
 800ac66:	4413      	add	r3, r2
 800ac68:	3302      	adds	r3, #2
 800ac6a:	9300      	str	r3, [sp, #0]
 800ac6c:	68f8      	ldr	r0, [r7, #12]
 800ac6e:	2208      	movs	r2, #8
 800ac70:	2300      	movs	r3, #0
 800ac72:	f000 ff49 	bl	800bb08 <canardDecodeScalar>
        *bit_ofs += 8;
 800ac76:	68bb      	ldr	r3, [r7, #8]
 800ac78:	681b      	ldr	r3, [r3, #0]
 800ac7a:	f103 0208 	add.w	r2, r3, #8
 800ac7e:	68bb      	ldr	r3, [r7, #8]
 800ac80:	601a      	str	r2, [r3, #0]
    *bit_ofs += 8;

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->minor);
    *bit_ofs += 8;

    for (size_t i=0; i < 16; i++) {
 800ac82:	697b      	ldr	r3, [r7, #20]
 800ac84:	3301      	adds	r3, #1
 800ac86:	617b      	str	r3, [r7, #20]
 800ac88:	697b      	ldr	r3, [r7, #20]
 800ac8a:	2b0f      	cmp	r3, #15
 800ac8c:	d9e7      	bls.n	800ac5e <_decode_uavcan_protocol_HardwareVersion+0x56>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->unique_id[i]);
        *bit_ofs += 8;
    }

    if (!tao) {
 800ac8e:	78fb      	ldrb	r3, [r7, #3]
 800ac90:	f083 0301 	eor.w	r3, r3, #1
 800ac94:	b2db      	uxtb	r3, r3
 800ac96:	2b00      	cmp	r3, #0
 800ac98:	d011      	beq.n	800acbe <_decode_uavcan_protocol_HardwareVersion+0xb6>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->certificate_of_authenticity_len);
 800ac9a:	68bb      	ldr	r3, [r7, #8]
 800ac9c:	681a      	ldr	r2, [r3, #0]
 800ac9e:	687b      	ldr	r3, [r7, #4]
 800aca0:	3312      	adds	r3, #18
 800aca2:	9300      	str	r3, [sp, #0]
 800aca4:	68f8      	ldr	r0, [r7, #12]
 800aca6:	4611      	mov	r1, r2
 800aca8:	2208      	movs	r2, #8
 800acaa:	2300      	movs	r3, #0
 800acac:	f000 ff2c 	bl	800bb08 <canardDecodeScalar>
        *bit_ofs += 8;
 800acb0:	68bb      	ldr	r3, [r7, #8]
 800acb2:	681b      	ldr	r3, [r3, #0]
 800acb4:	f103 0208 	add.w	r2, r3, #8
 800acb8:	68bb      	ldr	r3, [r7, #8]
 800acba:	601a      	str	r2, [r3, #0]
 800acbc:	e00a      	b.n	800acd4 <_decode_uavcan_protocol_HardwareVersion+0xcc>
    } else {
        msg->certificate_of_authenticity_len = ((transfer->payload_len*8)-*bit_ofs)/8;
 800acbe:	68fb      	ldr	r3, [r7, #12]
 800acc0:	8a9b      	ldrh	r3, [r3, #20]
 800acc2:	00db      	lsls	r3, r3, #3
 800acc4:	461a      	mov	r2, r3
 800acc6:	68bb      	ldr	r3, [r7, #8]
 800acc8:	681b      	ldr	r3, [r3, #0]
 800acca:	1ad3      	subs	r3, r2, r3
 800accc:	08db      	lsrs	r3, r3, #3
 800acce:	b2da      	uxtb	r2, r3
 800acd0:	687b      	ldr	r3, [r7, #4]
 800acd2:	749a      	strb	r2, [r3, #18]
    }

    for (size_t i=0; i < msg->certificate_of_authenticity_len; i++) {
 800acd4:	2300      	movs	r3, #0
 800acd6:	613b      	str	r3, [r7, #16]
 800acd8:	e015      	b.n	800ad06 <_decode_uavcan_protocol_HardwareVersion+0xfe>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->certificate_of_authenticity[i]);
 800acda:	68bb      	ldr	r3, [r7, #8]
 800acdc:	6819      	ldr	r1, [r3, #0]
 800acde:	693b      	ldr	r3, [r7, #16]
 800ace0:	3310      	adds	r3, #16
 800ace2:	687a      	ldr	r2, [r7, #4]
 800ace4:	4413      	add	r3, r2
 800ace6:	3303      	adds	r3, #3
 800ace8:	9300      	str	r3, [sp, #0]
 800acea:	68f8      	ldr	r0, [r7, #12]
 800acec:	2208      	movs	r2, #8
 800acee:	2300      	movs	r3, #0
 800acf0:	f000 ff0a 	bl	800bb08 <canardDecodeScalar>
        *bit_ofs += 8;
 800acf4:	68bb      	ldr	r3, [r7, #8]
 800acf6:	681b      	ldr	r3, [r3, #0]
 800acf8:	f103 0208 	add.w	r2, r3, #8
 800acfc:	68bb      	ldr	r3, [r7, #8]
 800acfe:	601a      	str	r2, [r3, #0]
        *bit_ofs += 8;
    } else {
        msg->certificate_of_authenticity_len = ((transfer->payload_len*8)-*bit_ofs)/8;
    }

    for (size_t i=0; i < msg->certificate_of_authenticity_len; i++) {
 800ad00:	693b      	ldr	r3, [r7, #16]
 800ad02:	3301      	adds	r3, #1
 800ad04:	613b      	str	r3, [r7, #16]
 800ad06:	687b      	ldr	r3, [r7, #4]
 800ad08:	7c9b      	ldrb	r3, [r3, #18]
 800ad0a:	461a      	mov	r2, r3
 800ad0c:	693b      	ldr	r3, [r7, #16]
 800ad0e:	429a      	cmp	r2, r3
 800ad10:	d8e3      	bhi.n	800acda <_decode_uavcan_protocol_HardwareVersion+0xd2>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->certificate_of_authenticity[i]);
        *bit_ofs += 8;
    }

}
 800ad12:	3718      	adds	r7, #24
 800ad14:	46bd      	mov	sp, r7
 800ad16:	bd80      	pop	{r7, pc}

0800ad18 <_encode_uavcan_protocol_SoftwareVersion>:
    uint32_t bit_ofs = 0;
    _decode_uavcan_protocol_SoftwareVersion(transfer, &bit_ofs, msg, true);
    return (bit_ofs+7)/8;
}

void _encode_uavcan_protocol_SoftwareVersion(uint8_t* buffer, struct uavcan_protocol_SoftwareVersion_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800ad18:	b580      	push	{r7, lr}
 800ad1a:	b084      	sub	sp, #16
 800ad1c:	af00      	add	r7, sp, #0
 800ad1e:	60f8      	str	r0, [r7, #12]
 800ad20:	60b9      	str	r1, [r7, #8]
 800ad22:	607a      	str	r2, [r7, #4]
 800ad24:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
 800ad26:	68f8      	ldr	r0, [r7, #12]
 800ad28:	2100      	movs	r1, #0
 800ad2a:	2208      	movs	r2, #8
 800ad2c:	f001 ff86 	bl	800cc3c <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->major);
 800ad30:	68bb      	ldr	r3, [r7, #8]
 800ad32:	68f8      	ldr	r0, [r7, #12]
 800ad34:	2100      	movs	r1, #0
 800ad36:	2208      	movs	r2, #8
 800ad38:	f001 f85e 	bl	800bdf8 <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800ad3c:	687b      	ldr	r3, [r7, #4]
 800ad3e:	68f8      	ldr	r0, [r7, #12]
 800ad40:	2108      	movs	r1, #8
 800ad42:	683a      	ldr	r2, [r7, #0]
 800ad44:	4798      	blx	r3
    memset(buffer,0,8);
 800ad46:	68f8      	ldr	r0, [r7, #12]
 800ad48:	2100      	movs	r1, #0
 800ad4a:	2208      	movs	r2, #8
 800ad4c:	f001 ff76 	bl	800cc3c <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->minor);
 800ad50:	68bb      	ldr	r3, [r7, #8]
 800ad52:	3301      	adds	r3, #1
 800ad54:	68f8      	ldr	r0, [r7, #12]
 800ad56:	2100      	movs	r1, #0
 800ad58:	2208      	movs	r2, #8
 800ad5a:	f001 f84d 	bl	800bdf8 <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800ad5e:	687b      	ldr	r3, [r7, #4]
 800ad60:	68f8      	ldr	r0, [r7, #12]
 800ad62:	2108      	movs	r1, #8
 800ad64:	683a      	ldr	r2, [r7, #0]
 800ad66:	4798      	blx	r3
    memset(buffer,0,8);
 800ad68:	68f8      	ldr	r0, [r7, #12]
 800ad6a:	2100      	movs	r1, #0
 800ad6c:	2208      	movs	r2, #8
 800ad6e:	f001 ff65 	bl	800cc3c <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->optional_field_flags);
 800ad72:	68bb      	ldr	r3, [r7, #8]
 800ad74:	3302      	adds	r3, #2
 800ad76:	68f8      	ldr	r0, [r7, #12]
 800ad78:	2100      	movs	r1, #0
 800ad7a:	2208      	movs	r2, #8
 800ad7c:	f001 f83c 	bl	800bdf8 <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800ad80:	687b      	ldr	r3, [r7, #4]
 800ad82:	68f8      	ldr	r0, [r7, #12]
 800ad84:	2108      	movs	r1, #8
 800ad86:	683a      	ldr	r2, [r7, #0]
 800ad88:	4798      	blx	r3
    memset(buffer,0,8);
 800ad8a:	68f8      	ldr	r0, [r7, #12]
 800ad8c:	2100      	movs	r1, #0
 800ad8e:	2208      	movs	r2, #8
 800ad90:	f001 ff54 	bl	800cc3c <memset>
    canardEncodeScalar(buffer, 0, 32, &msg->vcs_commit);
 800ad94:	68bb      	ldr	r3, [r7, #8]
 800ad96:	3304      	adds	r3, #4
 800ad98:	68f8      	ldr	r0, [r7, #12]
 800ad9a:	2100      	movs	r1, #0
 800ad9c:	2220      	movs	r2, #32
 800ad9e:	f001 f82b 	bl	800bdf8 <canardEncodeScalar>
    chunk_cb(buffer, 32, ctx);
 800ada2:	687b      	ldr	r3, [r7, #4]
 800ada4:	68f8      	ldr	r0, [r7, #12]
 800ada6:	2120      	movs	r1, #32
 800ada8:	683a      	ldr	r2, [r7, #0]
 800adaa:	4798      	blx	r3
    memset(buffer,0,8);
 800adac:	68f8      	ldr	r0, [r7, #12]
 800adae:	2100      	movs	r1, #0
 800adb0:	2208      	movs	r2, #8
 800adb2:	f001 ff43 	bl	800cc3c <memset>
    canardEncodeScalar(buffer, 0, 64, &msg->image_crc);
 800adb6:	68bb      	ldr	r3, [r7, #8]
 800adb8:	3308      	adds	r3, #8
 800adba:	68f8      	ldr	r0, [r7, #12]
 800adbc:	2100      	movs	r1, #0
 800adbe:	2240      	movs	r2, #64	; 0x40
 800adc0:	f001 f81a 	bl	800bdf8 <canardEncodeScalar>
    chunk_cb(buffer, 64, ctx);
 800adc4:	687b      	ldr	r3, [r7, #4]
 800adc6:	68f8      	ldr	r0, [r7, #12]
 800adc8:	2140      	movs	r1, #64	; 0x40
 800adca:	683a      	ldr	r2, [r7, #0]
 800adcc:	4798      	blx	r3
}
 800adce:	3710      	adds	r7, #16
 800add0:	46bd      	mov	sp, r7
 800add2:	bd80      	pop	{r7, pc}

0800add4 <_decode_uavcan_protocol_SoftwareVersion>:

void _decode_uavcan_protocol_SoftwareVersion(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_SoftwareVersion_s* msg, bool tao) {
 800add4:	b580      	push	{r7, lr}
 800add6:	b086      	sub	sp, #24
 800add8:	af02      	add	r7, sp, #8
 800adda:	60f8      	str	r0, [r7, #12]
 800addc:	60b9      	str	r1, [r7, #8]
 800adde:	607a      	str	r2, [r7, #4]
 800ade0:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->major);
 800ade2:	68bb      	ldr	r3, [r7, #8]
 800ade4:	681a      	ldr	r2, [r3, #0]
 800ade6:	687b      	ldr	r3, [r7, #4]
 800ade8:	9300      	str	r3, [sp, #0]
 800adea:	68f8      	ldr	r0, [r7, #12]
 800adec:	4611      	mov	r1, r2
 800adee:	2208      	movs	r2, #8
 800adf0:	2300      	movs	r3, #0
 800adf2:	f000 fe89 	bl	800bb08 <canardDecodeScalar>
    *bit_ofs += 8;
 800adf6:	68bb      	ldr	r3, [r7, #8]
 800adf8:	681b      	ldr	r3, [r3, #0]
 800adfa:	f103 0208 	add.w	r2, r3, #8
 800adfe:	68bb      	ldr	r3, [r7, #8]
 800ae00:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->minor);
 800ae02:	68bb      	ldr	r3, [r7, #8]
 800ae04:	681a      	ldr	r2, [r3, #0]
 800ae06:	687b      	ldr	r3, [r7, #4]
 800ae08:	3301      	adds	r3, #1
 800ae0a:	9300      	str	r3, [sp, #0]
 800ae0c:	68f8      	ldr	r0, [r7, #12]
 800ae0e:	4611      	mov	r1, r2
 800ae10:	2208      	movs	r2, #8
 800ae12:	2300      	movs	r3, #0
 800ae14:	f000 fe78 	bl	800bb08 <canardDecodeScalar>
    *bit_ofs += 8;
 800ae18:	68bb      	ldr	r3, [r7, #8]
 800ae1a:	681b      	ldr	r3, [r3, #0]
 800ae1c:	f103 0208 	add.w	r2, r3, #8
 800ae20:	68bb      	ldr	r3, [r7, #8]
 800ae22:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->optional_field_flags);
 800ae24:	68bb      	ldr	r3, [r7, #8]
 800ae26:	681a      	ldr	r2, [r3, #0]
 800ae28:	687b      	ldr	r3, [r7, #4]
 800ae2a:	3302      	adds	r3, #2
 800ae2c:	9300      	str	r3, [sp, #0]
 800ae2e:	68f8      	ldr	r0, [r7, #12]
 800ae30:	4611      	mov	r1, r2
 800ae32:	2208      	movs	r2, #8
 800ae34:	2300      	movs	r3, #0
 800ae36:	f000 fe67 	bl	800bb08 <canardDecodeScalar>
    *bit_ofs += 8;
 800ae3a:	68bb      	ldr	r3, [r7, #8]
 800ae3c:	681b      	ldr	r3, [r3, #0]
 800ae3e:	f103 0208 	add.w	r2, r3, #8
 800ae42:	68bb      	ldr	r3, [r7, #8]
 800ae44:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 32, false, &msg->vcs_commit);
 800ae46:	68bb      	ldr	r3, [r7, #8]
 800ae48:	681a      	ldr	r2, [r3, #0]
 800ae4a:	687b      	ldr	r3, [r7, #4]
 800ae4c:	3304      	adds	r3, #4
 800ae4e:	9300      	str	r3, [sp, #0]
 800ae50:	68f8      	ldr	r0, [r7, #12]
 800ae52:	4611      	mov	r1, r2
 800ae54:	2220      	movs	r2, #32
 800ae56:	2300      	movs	r3, #0
 800ae58:	f000 fe56 	bl	800bb08 <canardDecodeScalar>
    *bit_ofs += 32;
 800ae5c:	68bb      	ldr	r3, [r7, #8]
 800ae5e:	681b      	ldr	r3, [r3, #0]
 800ae60:	f103 0220 	add.w	r2, r3, #32
 800ae64:	68bb      	ldr	r3, [r7, #8]
 800ae66:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 64, false, &msg->image_crc);
 800ae68:	68bb      	ldr	r3, [r7, #8]
 800ae6a:	681a      	ldr	r2, [r3, #0]
 800ae6c:	687b      	ldr	r3, [r7, #4]
 800ae6e:	3308      	adds	r3, #8
 800ae70:	9300      	str	r3, [sp, #0]
 800ae72:	68f8      	ldr	r0, [r7, #12]
 800ae74:	4611      	mov	r1, r2
 800ae76:	2240      	movs	r2, #64	; 0x40
 800ae78:	2300      	movs	r3, #0
 800ae7a:	f000 fe45 	bl	800bb08 <canardDecodeScalar>
    *bit_ofs += 64;
 800ae7e:	68bb      	ldr	r3, [r7, #8]
 800ae80:	681b      	ldr	r3, [r3, #0]
 800ae82:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800ae86:	68bb      	ldr	r3, [r7, #8]
 800ae88:	601a      	str	r2, [r3, #0]

}
 800ae8a:	3710      	adds	r7, #16
 800ae8c:	46bd      	mov	sp, r7
 800ae8e:	bd80      	pop	{r7, pc}

0800ae90 <encode_func.lto_priv.38>:
#include <uavcan.protocol.GetNodeInfo_req.h>
#include <uavcan.protocol.GetNodeInfo_res.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800ae90:	b580      	push	{r7, lr}
 800ae92:	b084      	sub	sp, #16
 800ae94:	af00      	add	r7, sp, #0
 800ae96:	60f8      	str	r0, [r7, #12]
 800ae98:	60b9      	str	r1, [r7, #8]
 800ae9a:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_GetNodeInfo_req(msg, chunk_cb, ctx);
 800ae9c:	68f8      	ldr	r0, [r7, #12]
 800ae9e:	68b9      	ldr	r1, [r7, #8]
 800aea0:	687a      	ldr	r2, [r7, #4]
 800aea2:	f000 f811 	bl	800aec8 <encode_uavcan_protocol_GetNodeInfo_req>
}
 800aea6:	3710      	adds	r7, #16
 800aea8:	46bd      	mov	sp, r7
 800aeaa:	bd80      	pop	{r7, pc}

0800aeac <decode_func.lto_priv.45>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800aeac:	b580      	push	{r7, lr}
 800aeae:	b082      	sub	sp, #8
 800aeb0:	af00      	add	r7, sp, #0
 800aeb2:	6078      	str	r0, [r7, #4]
 800aeb4:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_GetNodeInfo_req(transfer, msg);
 800aeb6:	6878      	ldr	r0, [r7, #4]
 800aeb8:	6839      	ldr	r1, [r7, #0]
 800aeba:	f000 f819 	bl	800aef0 <decode_uavcan_protocol_GetNodeInfo_req>
 800aebe:	4603      	mov	r3, r0
}
 800aec0:	4618      	mov	r0, r3
 800aec2:	3708      	adds	r7, #8
 800aec4:	46bd      	mov	sp, r7
 800aec6:	bd80      	pop	{r7, pc}

0800aec8 <encode_uavcan_protocol_GetNodeInfo_req>:
    encode_func,
    decode_func,
    &uavcan_protocol_GetNodeInfo_res_descriptor
};

void encode_uavcan_protocol_GetNodeInfo_req(struct uavcan_protocol_GetNodeInfo_req_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800aec8:	b580      	push	{r7, lr}
 800aeca:	b088      	sub	sp, #32
 800aecc:	af02      	add	r7, sp, #8
 800aece:	60f8      	str	r0, [r7, #12]
 800aed0:	60b9      	str	r1, [r7, #8]
 800aed2:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_GetNodeInfo_req(buffer, msg, chunk_cb, ctx, true);
 800aed4:	f107 0210 	add.w	r2, r7, #16
 800aed8:	2301      	movs	r3, #1
 800aeda:	9300      	str	r3, [sp, #0]
 800aedc:	4610      	mov	r0, r2
 800aede:	68f9      	ldr	r1, [r7, #12]
 800aee0:	68ba      	ldr	r2, [r7, #8]
 800aee2:	687b      	ldr	r3, [r7, #4]
 800aee4:	f000 f81a 	bl	800af1c <_encode_uavcan_protocol_GetNodeInfo_req>
}
 800aee8:	3718      	adds	r7, #24
 800aeea:	46bd      	mov	sp, r7
 800aeec:	bd80      	pop	{r7, pc}
 800aeee:	bf00      	nop

0800aef0 <decode_uavcan_protocol_GetNodeInfo_req>:

uint32_t decode_uavcan_protocol_GetNodeInfo_req(const CanardRxTransfer* transfer, struct uavcan_protocol_GetNodeInfo_req_s* msg) {
 800aef0:	b580      	push	{r7, lr}
 800aef2:	b084      	sub	sp, #16
 800aef4:	af00      	add	r7, sp, #0
 800aef6:	6078      	str	r0, [r7, #4]
 800aef8:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800aefa:	2300      	movs	r3, #0
 800aefc:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_GetNodeInfo_req(transfer, &bit_ofs, msg, true);
 800aefe:	f107 030c 	add.w	r3, r7, #12
 800af02:	6878      	ldr	r0, [r7, #4]
 800af04:	4619      	mov	r1, r3
 800af06:	683a      	ldr	r2, [r7, #0]
 800af08:	2301      	movs	r3, #1
 800af0a:	f000 f813 	bl	800af34 <_decode_uavcan_protocol_GetNodeInfo_req>
    return (bit_ofs+7)/8;
 800af0e:	68fb      	ldr	r3, [r7, #12]
 800af10:	3307      	adds	r3, #7
 800af12:	08db      	lsrs	r3, r3, #3
}
 800af14:	4618      	mov	r0, r3
 800af16:	3710      	adds	r7, #16
 800af18:	46bd      	mov	sp, r7
 800af1a:	bd80      	pop	{r7, pc}

0800af1c <_encode_uavcan_protocol_GetNodeInfo_req>:

void _encode_uavcan_protocol_GetNodeInfo_req(uint8_t* buffer, struct uavcan_protocol_GetNodeInfo_req_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800af1c:	b480      	push	{r7}
 800af1e:	b085      	sub	sp, #20
 800af20:	af00      	add	r7, sp, #0
 800af22:	60f8      	str	r0, [r7, #12]
 800af24:	60b9      	str	r1, [r7, #8]
 800af26:	607a      	str	r2, [r7, #4]
 800af28:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

}
 800af2a:	3714      	adds	r7, #20
 800af2c:	46bd      	mov	sp, r7
 800af2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800af32:	4770      	bx	lr

0800af34 <_decode_uavcan_protocol_GetNodeInfo_req>:

void _decode_uavcan_protocol_GetNodeInfo_req(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_GetNodeInfo_req_s* msg, bool tao) {
 800af34:	b480      	push	{r7}
 800af36:	b085      	sub	sp, #20
 800af38:	af00      	add	r7, sp, #0
 800af3a:	60f8      	str	r0, [r7, #12]
 800af3c:	60b9      	str	r1, [r7, #8]
 800af3e:	607a      	str	r2, [r7, #4]
 800af40:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

}
 800af42:	3714      	adds	r7, #20
 800af44:	46bd      	mov	sp, r7
 800af46:	f85d 7b04 	ldr.w	r7, [sp], #4
 800af4a:	4770      	bx	lr

0800af4c <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 800af4c:	b480      	push	{r7}
 800af4e:	af00      	add	r7, sp, #0

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 800af50:	46bd      	mov	sp, r7
 800af52:	f85d 7b04 	ldr.w	r7, [sp], #4
 800af56:	4770      	bx	lr

0800af58 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 800af58:	b480      	push	{r7}
 800af5a:	af00      	add	r7, sp, #0
 800af5c:	46bd      	mov	sp, r7
 800af5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800af62:	4770      	bx	lr

0800af64 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 800af64:	b480      	push	{r7}
 800af66:	af00      	add	r7, sp, #0
 800af68:	e7fe      	b.n	800af68 <__default_exit+0x4>
 800af6a:	bf00      	nop

0800af6c <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 800af6c:	b480      	push	{r7}
 800af6e:	b085      	sub	sp, #20
 800af70:	af00      	add	r7, sp, #0
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 800af72:	4b18      	ldr	r3, [pc, #96]	; (800afd4 <__init_ram_areas+0x68>)
 800af74:	60fb      	str	r3, [r7, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 800af76:	68fb      	ldr	r3, [r7, #12]
 800af78:	681b      	ldr	r3, [r3, #0]
 800af7a:	60bb      	str	r3, [r7, #8]
    uint32_t *p = rap->init_area;
 800af7c:	68fb      	ldr	r3, [r7, #12]
 800af7e:	685b      	ldr	r3, [r3, #4]
 800af80:	607b      	str	r3, [r7, #4]
 800af82:	e009      	b.n	800af98 <__init_ram_areas+0x2c>

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 800af84:	68bb      	ldr	r3, [r7, #8]
 800af86:	681a      	ldr	r2, [r3, #0]
 800af88:	687b      	ldr	r3, [r7, #4]
 800af8a:	601a      	str	r2, [r3, #0]
      p++;
 800af8c:	687b      	ldr	r3, [r7, #4]
 800af8e:	3304      	adds	r3, #4
 800af90:	607b      	str	r3, [r7, #4]
      tp++;
 800af92:	68bb      	ldr	r3, [r7, #8]
 800af94:	3304      	adds	r3, #4
 800af96:	60bb      	str	r3, [r7, #8]
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800af98:	68fb      	ldr	r3, [r7, #12]
 800af9a:	689a      	ldr	r2, [r3, #8]
 800af9c:	687b      	ldr	r3, [r7, #4]
 800af9e:	429a      	cmp	r2, r3
 800afa0:	d8f0      	bhi.n	800af84 <__init_ram_areas+0x18>
 800afa2:	e005      	b.n	800afb0 <__init_ram_areas+0x44>
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 800afa4:	687b      	ldr	r3, [r7, #4]
 800afa6:	2200      	movs	r2, #0
 800afa8:	601a      	str	r2, [r3, #0]
      p++;
 800afaa:	687b      	ldr	r3, [r7, #4]
 800afac:	3304      	adds	r3, #4
 800afae:	607b      	str	r3, [r7, #4]
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800afb0:	68fb      	ldr	r3, [r7, #12]
 800afb2:	68da      	ldr	r2, [r3, #12]
 800afb4:	687b      	ldr	r3, [r7, #4]
 800afb6:	429a      	cmp	r2, r3
 800afb8:	d8f4      	bhi.n	800afa4 <__init_ram_areas+0x38>
      *p = 0;
      p++;
    }
    rap++;
 800afba:	68fb      	ldr	r3, [r7, #12]
 800afbc:	3310      	adds	r3, #16
 800afbe:	60fb      	str	r3, [r7, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800afc0:	68fb      	ldr	r3, [r7, #12]
 800afc2:	4a05      	ldr	r2, [pc, #20]	; (800afd8 <__init_ram_areas+0x6c>)
 800afc4:	4293      	cmp	r3, r2
 800afc6:	d3d6      	bcc.n	800af76 <__init_ram_areas+0xa>
#endif
}
 800afc8:	3714      	adds	r7, #20
 800afca:	46bd      	mov	sp, r7
 800afcc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800afd0:	4770      	bx	lr
 800afd2:	bf00      	nop
 800afd4:	0800cda8 	.word	0x0800cda8
 800afd8:	0800ce28 	.word	0x0800ce28

0800afdc <BusFault_Handler>:
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
__attribute__((weak))
void _unhandled_exception(void) {
 800afdc:	b480      	push	{r7}
 800afde:	af00      	add	r7, sp, #0
 800afe0:	e7fe      	b.n	800afe0 <BusFault_Handler+0x4>
 800afe2:	bf00      	nop

0800afe4 <NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800afe4:	b480      	push	{r7}
 800afe6:	b085      	sub	sp, #20
 800afe8:	af00      	add	r7, sp, #0
 800afea:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800afec:	687b      	ldr	r3, [r7, #4]
 800afee:	f003 0307 	and.w	r3, r3, #7
 800aff2:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800aff4:	4b0c      	ldr	r3, [pc, #48]	; (800b028 <NVIC_SetPriorityGrouping+0x44>)
 800aff6:	68db      	ldr	r3, [r3, #12]
 800aff8:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800affa:	68ba      	ldr	r2, [r7, #8]
 800affc:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800b000:	4013      	ands	r3, r2
 800b002:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 800b004:	68fb      	ldr	r3, [r7, #12]
 800b006:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800b008:	68bb      	ldr	r3, [r7, #8]
 800b00a:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 800b00c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800b010:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800b014:	60bb      	str	r3, [r7, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800b016:	4a04      	ldr	r2, [pc, #16]	; (800b028 <NVIC_SetPriorityGrouping+0x44>)
 800b018:	68bb      	ldr	r3, [r7, #8]
 800b01a:	60d3      	str	r3, [r2, #12]
}
 800b01c:	3714      	adds	r7, #20
 800b01e:	46bd      	mov	sp, r7
 800b020:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b024:	4770      	bx	lr
 800b026:	bf00      	nop
 800b028:	e000ed00 	.word	0xe000ed00

0800b02c <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800b02c:	b480      	push	{r7}
 800b02e:	b083      	sub	sp, #12
 800b030:	af00      	add	r7, sp, #0
 800b032:	4603      	mov	r3, r0
 800b034:	6039      	str	r1, [r7, #0]
 800b036:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) < 0)
 800b038:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800b03c:	2b00      	cmp	r3, #0
 800b03e:	da0b      	bge.n	800b058 <NVIC_SetPriority+0x2c>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b040:	490d      	ldr	r1, [pc, #52]	; (800b078 <NVIC_SetPriority+0x4c>)
 800b042:	79fb      	ldrb	r3, [r7, #7]
 800b044:	f003 030f 	and.w	r3, r3, #15
 800b048:	3b04      	subs	r3, #4
 800b04a:	683a      	ldr	r2, [r7, #0]
 800b04c:	b2d2      	uxtb	r2, r2
 800b04e:	0112      	lsls	r2, r2, #4
 800b050:	b2d2      	uxtb	r2, r2
 800b052:	440b      	add	r3, r1
 800b054:	761a      	strb	r2, [r3, #24]
 800b056:	e009      	b.n	800b06c <NVIC_SetPriority+0x40>
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b058:	4908      	ldr	r1, [pc, #32]	; (800b07c <NVIC_SetPriority+0x50>)
 800b05a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800b05e:	683a      	ldr	r2, [r7, #0]
 800b060:	b2d2      	uxtb	r2, r2
 800b062:	0112      	lsls	r2, r2, #4
 800b064:	b2d2      	uxtb	r2, r2
 800b066:	440b      	add	r3, r1
 800b068:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 800b06c:	370c      	adds	r7, #12
 800b06e:	46bd      	mov	sp, r7
 800b070:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b074:	4770      	bx	lr
 800b076:	bf00      	nop
 800b078:	e000ed00 	.word	0xe000ed00
 800b07c:	e000e100 	.word	0xe000e100

0800b080 <port_init.lto_priv.272>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 800b080:	b580      	push	{r7, lr}
 800b082:	af00      	add	r7, sp, #0

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 800b084:	2003      	movs	r0, #3
 800b086:	f7ff ffad 	bl	800afe4 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800b08a:	4a0b      	ldr	r2, [pc, #44]	; (800b0b8 <port_init.lto_priv.272+0x38>)
 800b08c:	4b0a      	ldr	r3, [pc, #40]	; (800b0b8 <port_init.lto_priv.272+0x38>)
 800b08e:	68db      	ldr	r3, [r3, #12]
 800b090:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800b094:	60d3      	str	r3, [r2, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800b096:	4a09      	ldr	r2, [pc, #36]	; (800b0bc <port_init.lto_priv.272+0x3c>)
 800b098:	4b08      	ldr	r3, [pc, #32]	; (800b0bc <port_init.lto_priv.272+0x3c>)
 800b09a:	681b      	ldr	r3, [r3, #0]
 800b09c:	f043 0301 	orr.w	r3, r3, #1
 800b0a0:	6013      	str	r3, [r2, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 800b0a2:	f06f 0004 	mvn.w	r0, #4
 800b0a6:	2101      	movs	r1, #1
 800b0a8:	f7ff ffc0 	bl	800b02c <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 800b0ac:	f06f 0001 	mvn.w	r0, #1
 800b0b0:	2102      	movs	r1, #2
 800b0b2:	f7ff ffbb 	bl	800b02c <NVIC_SetPriority>

    /* MPU is enabled.*/
    mpuEnable(MPU_CTRL_PRIVDEFENA);
  }
#endif
}
 800b0b6:	bd80      	pop	{r7, pc}
 800b0b8:	e000edf0 	.word	0xe000edf0
 800b0bc:	e0001000 	.word	0xe0001000

0800b0c0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800b0c0:	b480      	push	{r7}
 800b0c2:	b083      	sub	sp, #12
 800b0c4:	af00      	add	r7, sp, #0
 800b0c6:	2320      	movs	r3, #32
 800b0c8:	607b      	str	r3, [r7, #4]
 800b0ca:	687b      	ldr	r3, [r7, #4]
 800b0cc:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b0d0:	370c      	adds	r7, #12
 800b0d2:	46bd      	mov	sp, r7
 800b0d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b0d8:	4770      	bx	lr
 800b0da:	bf00      	nop

0800b0dc <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800b0dc:	b480      	push	{r7}
 800b0de:	b083      	sub	sp, #12
 800b0e0:	af00      	add	r7, sp, #0
 800b0e2:	2300      	movs	r3, #0
 800b0e4:	607b      	str	r3, [r7, #4]
 800b0e6:	687b      	ldr	r3, [r7, #4]
 800b0e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b0ec:	370c      	adds	r7, #12
 800b0ee:	46bd      	mov	sp, r7
 800b0f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b0f4:	4770      	bx	lr
 800b0f6:	bf00      	nop

0800b0f8 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800b0f8:	b580      	push	{r7, lr}
 800b0fa:	af00      	add	r7, sp, #0

  port_lock();
 800b0fc:	f7ff ffe0 	bl	800b0c0 <port_lock>
}
 800b100:	bd80      	pop	{r7, pc}
 800b102:	bf00      	nop

0800b104 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800b104:	b580      	push	{r7, lr}
 800b106:	af00      	add	r7, sp, #0

  port_unlock();
 800b108:	f7ff ffe8 	bl	800b0dc <port_unlock>
}
 800b10c:	bd80      	pop	{r7, pc}
 800b10e:	bf00      	nop

0800b110 <port_disable.lto_priv.270>:
/**
 * @brief   Disables all the interrupt sources.
 * @note    In this port it disables all the interrupt sources by raising
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {
 800b110:	b480      	push	{r7}
 800b112:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800b114:	b672      	cpsid	i

  __disable_irq();
}
 800b116:	46bd      	mov	sp, r7
 800b118:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b11c:	4770      	bx	lr
 800b11e:	bf00      	nop

0800b120 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 800b120:	b480      	push	{r7}
 800b122:	b083      	sub	sp, #12
 800b124:	af00      	add	r7, sp, #0
 800b126:	2300      	movs	r3, #0
 800b128:	607b      	str	r3, [r7, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800b12a:	687b      	ldr	r3, [r7, #4]
 800b12c:	f383 8811 	msr	BASEPRI, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800b130:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 800b132:	370c      	adds	r7, #12
 800b134:	46bd      	mov	sp, r7
 800b136:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b13a:	4770      	bx	lr

0800b13c <port_wait_for_interrupt.lto_priv.273>:
 *          The simplest implementation is an empty function or macro but this
 *          would not take advantage of architecture-specific power saving
 *          modes.
 * @note    Implemented as an inlined @p WFI instruction.
 */
static inline void port_wait_for_interrupt(void) {
 800b13c:	b480      	push	{r7}
 800b13e:	af00      	add	r7, sp, #0

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 800b140:	46bd      	mov	sp, r7
 800b142:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b146:	4770      	bx	lr

0800b148 <st_lld_get_counter>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 800b148:	b480      	push	{r7}
 800b14a:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 800b14c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b150:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b152:	b29b      	uxth	r3, r3
}
 800b154:	4618      	mov	r0, r3
 800b156:	46bd      	mov	sp, r7
 800b158:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b15c:	4770      	bx	lr
 800b15e:	bf00      	nop

0800b160 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 800b160:	b580      	push	{r7, lr}
 800b162:	af00      	add	r7, sp, #0

  stStopAlarm();
 800b164:	f7fd f888 	bl	8008278 <stStopAlarm>
}
 800b168:	bd80      	pop	{r7, pc}
 800b16a:	bf00      	nop

0800b16c <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 800b16c:	b580      	push	{r7, lr}
 800b16e:	b082      	sub	sp, #8
 800b170:	af00      	add	r7, sp, #0
 800b172:	4603      	mov	r3, r0
 800b174:	80fb      	strh	r3, [r7, #6]

  stSetAlarm(time);
 800b176:	88fb      	ldrh	r3, [r7, #6]
 800b178:	4618      	mov	r0, r3
 800b17a:	f7fd f883 	bl	8008284 <stSetAlarm>
}
 800b17e:	3708      	adds	r7, #8
 800b180:	46bd      	mov	sp, r7
 800b182:	bd80      	pop	{r7, pc}

0800b184 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 800b184:	b580      	push	{r7, lr}
 800b186:	af00      	add	r7, sp, #0

  return stGetCounter();
 800b188:	f7ff ffde 	bl	800b148 <st_lld_get_counter>
 800b18c:	4603      	mov	r3, r0
}
 800b18e:	4618      	mov	r0, r3
 800b190:	bd80      	pop	{r7, pc}
 800b192:	bf00      	nop

0800b194 <chSysEnable.lto_priv.271>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 800b194:	b580      	push	{r7, lr}
 800b196:	af00      	add	r7, sp, #0

  _dbg_check_enable();
 800b198:	f7fe fc6c 	bl	8009a74 <_dbg_check_enable>
  port_enable();
 800b19c:	f7ff ffc0 	bl	800b120 <port_enable>
}
 800b1a0:	bd80      	pop	{r7, pc}
 800b1a2:	bf00      	nop

0800b1a4 <chSysLockFromISR.lto_priv.256>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800b1a4:	b580      	push	{r7, lr}
 800b1a6:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 800b1a8:	f7ff ffa6 	bl	800b0f8 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800b1ac:	f7fe fca0 	bl	8009af0 <_dbg_check_lock_from_isr>
}
 800b1b0:	bd80      	pop	{r7, pc}
 800b1b2:	bf00      	nop

0800b1b4 <chSysUnlockFromISR.lto_priv.254>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800b1b4:	b580      	push	{r7, lr}
 800b1b6:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
 800b1b8:	f7fe fcb0 	bl	8009b1c <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800b1bc:	f7ff ffa2 	bl	800b104 <port_unlock_from_isr>
}
 800b1c0:	bd80      	pop	{r7, pc}
 800b1c2:	bf00      	nop

0800b1c4 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 800b1c4:	b580      	push	{r7, lr}
 800b1c6:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 800b1c8:	f7ff ffdc 	bl	800b184 <port_timer_get_time>
 800b1cc:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800b1ce:	4618      	mov	r0, r3
 800b1d0:	bd80      	pop	{r7, pc}
 800b1d2:	bf00      	nop

0800b1d4 <chVTDoTickI.lto_priv.269>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 800b1d4:	b580      	push	{r7, lr}
 800b1d6:	b084      	sub	sp, #16
 800b1d8:	af00      	add	r7, sp, #0

  chDbgCheckClassI();
 800b1da:	f7fe fced 	bl	8009bb8 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 800b1de:	4b36      	ldr	r3, [pc, #216]	; (800b2b8 <chVTDoTickI.lto_priv.269+0xe4>)
 800b1e0:	69db      	ldr	r3, [r3, #28]
 800b1e2:	60fb      	str	r3, [r7, #12]
  now = chVTGetSystemTimeX();
 800b1e4:	f7ff ffee 	bl	800b1c4 <chVTGetSystemTimeX>
 800b1e8:	4603      	mov	r3, r0
 800b1ea:	817b      	strh	r3, [r7, #10]
 800b1ec:	e02c      	b.n	800b248 <chVTDoTickI.lto_priv.269+0x74>
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 800b1ee:	4b32      	ldr	r3, [pc, #200]	; (800b2b8 <chVTDoTickI.lto_priv.269+0xe4>)
 800b1f0:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800b1f2:	68fb      	ldr	r3, [r7, #12]
 800b1f4:	891b      	ldrh	r3, [r3, #8]
 800b1f6:	4413      	add	r3, r2
 800b1f8:	b29a      	uxth	r2, r3
 800b1fa:	4b2f      	ldr	r3, [pc, #188]	; (800b2b8 <chVTDoTickI.lto_priv.269+0xe4>)
 800b1fc:	84da      	strh	r2, [r3, #38]	; 0x26

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800b1fe:	68fb      	ldr	r3, [r7, #12]
 800b200:	681b      	ldr	r3, [r3, #0]
 800b202:	4a2e      	ldr	r2, [pc, #184]	; (800b2bc <chVTDoTickI.lto_priv.269+0xe8>)
 800b204:	605a      	str	r2, [r3, #4]
    ch.vtlist.next = vtp->next;
 800b206:	68fb      	ldr	r3, [r7, #12]
 800b208:	681b      	ldr	r3, [r3, #0]
 800b20a:	4a2b      	ldr	r2, [pc, #172]	; (800b2b8 <chVTDoTickI.lto_priv.269+0xe4>)
 800b20c:	61d3      	str	r3, [r2, #28]
    fn = vtp->func;
 800b20e:	68fb      	ldr	r3, [r7, #12]
 800b210:	68db      	ldr	r3, [r3, #12]
 800b212:	607b      	str	r3, [r7, #4]
    vtp->func = NULL;
 800b214:	68fb      	ldr	r3, [r7, #12]
 800b216:	2200      	movs	r2, #0
 800b218:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800b21a:	4b27      	ldr	r3, [pc, #156]	; (800b2b8 <chVTDoTickI.lto_priv.269+0xe4>)
 800b21c:	69db      	ldr	r3, [r3, #28]
 800b21e:	4a27      	ldr	r2, [pc, #156]	; (800b2bc <chVTDoTickI.lto_priv.269+0xe8>)
 800b220:	4293      	cmp	r3, r2
 800b222:	d101      	bne.n	800b228 <chVTDoTickI.lto_priv.269+0x54>
      port_timer_stop_alarm();
 800b224:	f7ff ff9c 	bl	800b160 <port_timer_stop_alarm>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
 800b228:	f7ff ffc4 	bl	800b1b4 <chSysUnlockFromISR.lto_priv.254>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 800b22c:	68fb      	ldr	r3, [r7, #12]
 800b22e:	691a      	ldr	r2, [r3, #16]
 800b230:	687b      	ldr	r3, [r7, #4]
 800b232:	4610      	mov	r0, r2
 800b234:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
 800b236:	f7ff ffb5 	bl	800b1a4 <chSysLockFromISR.lto_priv.256>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 800b23a:	4b1f      	ldr	r3, [pc, #124]	; (800b2b8 <chVTDoTickI.lto_priv.269+0xe4>)
 800b23c:	69db      	ldr	r3, [r3, #28]
 800b23e:	60fb      	str	r3, [r7, #12]
    now = chVTGetSystemTimeX();
 800b240:	f7ff ffc0 	bl	800b1c4 <chVTGetSystemTimeX>
 800b244:	4603      	mov	r3, r0
 800b246:	817b      	strh	r3, [r7, #10]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 800b248:	68fb      	ldr	r3, [r7, #12]
 800b24a:	891a      	ldrh	r2, [r3, #8]
 800b24c:	4b1a      	ldr	r3, [pc, #104]	; (800b2b8 <chVTDoTickI.lto_priv.269+0xe4>)
 800b24e:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 800b250:	8979      	ldrh	r1, [r7, #10]
 800b252:	1acb      	subs	r3, r1, r3
 800b254:	b29b      	uxth	r3, r3
 800b256:	429a      	cmp	r2, r3
 800b258:	d9c9      	bls.n	800b1ee <chVTDoTickI.lto_priv.269+0x1a>
    vtp = ch.vtlist.next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800b25a:	4b17      	ldr	r3, [pc, #92]	; (800b2b8 <chVTDoTickI.lto_priv.269+0xe4>)
 800b25c:	69db      	ldr	r3, [r3, #28]
 800b25e:	4a17      	ldr	r2, [pc, #92]	; (800b2bc <chVTDoTickI.lto_priv.269+0xe8>)
 800b260:	4293      	cmp	r3, r2
 800b262:	d026      	beq.n	800b2b2 <chVTDoTickI.lto_priv.269+0xde>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 800b264:	4b14      	ldr	r3, [pc, #80]	; (800b2b8 <chVTDoTickI.lto_priv.269+0xe4>)
 800b266:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800b268:	68fb      	ldr	r3, [r7, #12]
 800b26a:	891b      	ldrh	r3, [r3, #8]
 800b26c:	4413      	add	r3, r2
 800b26e:	b29a      	uxth	r2, r3
 800b270:	897b      	ldrh	r3, [r7, #10]
 800b272:	1ad3      	subs	r3, r2, r3
 800b274:	813b      	strh	r3, [r7, #8]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800b276:	893b      	ldrh	r3, [r7, #8]
 800b278:	2b01      	cmp	r3, #1
 800b27a:	d801      	bhi.n	800b280 <chVTDoTickI.lto_priv.269+0xac>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800b27c:	2302      	movs	r3, #2
 800b27e:	813b      	strh	r3, [r7, #8]
  }
  port_timer_set_alarm(now + delta);
 800b280:	897a      	ldrh	r2, [r7, #10]
 800b282:	893b      	ldrh	r3, [r7, #8]
 800b284:	4413      	add	r3, r2
 800b286:	b29b      	uxth	r3, r3
 800b288:	4618      	mov	r0, r3
 800b28a:	f7ff ff6f 	bl	800b16c <port_timer_set_alarm>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.lasttime) <=
 800b28e:	f7ff ff99 	bl	800b1c4 <chVTGetSystemTimeX>
 800b292:	4603      	mov	r3, r0
 800b294:	461a      	mov	r2, r3
 800b296:	4b08      	ldr	r3, [pc, #32]	; (800b2b8 <chVTDoTickI.lto_priv.269+0xe4>)
 800b298:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 800b29a:	1ad2      	subs	r2, r2, r3
 800b29c:	8979      	ldrh	r1, [r7, #10]
 800b29e:	893b      	ldrh	r3, [r7, #8]
 800b2a0:	440b      	add	r3, r1
 800b2a2:	4905      	ldr	r1, [pc, #20]	; (800b2b8 <chVTDoTickI.lto_priv.269+0xe4>)
 800b2a4:	8cc9      	ldrh	r1, [r1, #38]	; 0x26
 800b2a6:	1a5b      	subs	r3, r3, r1
 800b2a8:	429a      	cmp	r2, r3
 800b2aa:	dd02      	ble.n	800b2b2 <chVTDoTickI.lto_priv.269+0xde>
 800b2ac:	4804      	ldr	r0, [pc, #16]	; (800b2c0 <chVTDoTickI.lto_priv.269+0xec>)
 800b2ae:	f7fe fba5 	bl	80099fc <chSysHalt>
              (now + delta - ch.vtlist.lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800b2b2:	3710      	adds	r7, #16
 800b2b4:	46bd      	mov	sp, r7
 800b2b6:	bd80      	pop	{r7, pc}
 800b2b8:	20001330 	.word	0x20001330
 800b2bc:	2000134c 	.word	0x2000134c
 800b2c0:	0800ce40 	.word	0x0800ce40

0800b2c4 <_local_ctor_4>:
#include <modules/pubsub/pubsub.h>
#include <modules/worker_thread/worker_thread.h>

WORKER_THREAD_TAKEOVER_MAIN(lpwork_thread, LOWPRIO)
 800b2c4:	b580      	push	{r7, lr}
 800b2c6:	af00      	add	r7, sp, #0
 800b2c8:	4802      	ldr	r0, [pc, #8]	; (800b2d4 <_local_ctor_4+0x10>)
 800b2ca:	4903      	ldr	r1, [pc, #12]	; (800b2d8 <_local_ctor_4+0x14>)
 800b2cc:	2202      	movs	r2, #2
 800b2ce:	f7fc fd6b 	bl	8007da8 <worker_thread_init>
 800b2d2:	bd80      	pop	{r7, pc}
 800b2d4:	20000a20 	.word	0x20000a20
 800b2d8:	0800ccc8 	.word	0x0800ccc8

0800b2dc <main>:
 800b2dc:	b580      	push	{r7, lr}
 800b2de:	af00      	add	r7, sp, #0
 800b2e0:	4802      	ldr	r0, [pc, #8]	; (800b2ec <main+0x10>)
 800b2e2:	f7fa fdc1 	bl	8005e68 <worker_thread_takeover>
 800b2e6:	2300      	movs	r3, #0
 800b2e8:	4618      	mov	r0, r3
 800b2ea:	bd80      	pop	{r7, pc}
 800b2ec:	20000a20 	.word	0x20000a20

0800b2f0 <_local_ctor_5>:
WORKER_THREAD_SPAWN(can_thread, LOWPRIO, 4096)
 800b2f0:	b580      	push	{r7, lr}
 800b2f2:	af00      	add	r7, sp, #0
 800b2f4:	4805      	ldr	r0, [pc, #20]	; (800b30c <_local_ctor_5+0x1c>)
 800b2f6:	4906      	ldr	r1, [pc, #24]	; (800b310 <_local_ctor_5+0x20>)
 800b2f8:	2202      	movs	r2, #2
 800b2fa:	f7fc fd55 	bl	8007da8 <worker_thread_init>
 800b2fe:	4803      	ldr	r0, [pc, #12]	; (800b30c <_local_ctor_5+0x1c>)
 800b300:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800b304:	f7fc fd76 	bl	8007df4 <worker_thread_start>
 800b308:	bd80      	pop	{r7, pc}
 800b30a:	bf00      	nop
 800b30c:	20000a3c 	.word	0x20000a3c
 800b310:	0800ccd8 	.word	0x0800ccd8

0800b314 <_local_ctor_7>:

PUBSUB_TOPIC_GROUP_CREATE(default_topic_group, 2048)
 800b314:	b580      	push	{r7, lr}
 800b316:	af00      	add	r7, sp, #0
 800b318:	4803      	ldr	r0, [pc, #12]	; (800b328 <_local_ctor_7+0x14>)
 800b31a:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800b31e:	4a03      	ldr	r2, [pc, #12]	; (800b32c <_local_ctor_7+0x18>)
 800b320:	f7fc fa0e 	bl	8007740 <pubsub_create_topic_group>
 800b324:	bd80      	pop	{r7, pc}
 800b326:	bf00      	nop
 800b328:	20000a58 	.word	0x20000a58
 800b32c:	20000a68 	.word	0x20000a68

0800b330 <canardInit>:
                void* mem_arena,
                size_t mem_arena_size,
                CanardOnTransferReception on_reception,
                CanardShouldAcceptTransfer should_accept,
                void* user_reference)
{
 800b330:	b580      	push	{r7, lr}
 800b332:	b086      	sub	sp, #24
 800b334:	af00      	add	r7, sp, #0
 800b336:	60f8      	str	r0, [r7, #12]
 800b338:	60b9      	str	r1, [r7, #8]
 800b33a:	607a      	str	r2, [r7, #4]
 800b33c:	603b      	str	r3, [r7, #0]
     * If your application fails here, make sure it's not built in 64-bit mode.
     * Refer to the design documentation for more info.
     */
    CANARD_ASSERT(CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE >= 6);

    memset(out_ins, 0, sizeof(*out_ins));
 800b33e:	68f8      	ldr	r0, [r7, #12]
 800b340:	2100      	movs	r1, #0
 800b342:	2224      	movs	r2, #36	; 0x24
 800b344:	f001 fc7a 	bl	800cc3c <memset>

    out_ins->node_id = CANARD_BROADCAST_NODE_ID;
 800b348:	68fb      	ldr	r3, [r7, #12]
 800b34a:	2200      	movs	r2, #0
 800b34c:	701a      	strb	r2, [r3, #0]
    out_ins->on_reception = on_reception;
 800b34e:	68fb      	ldr	r3, [r7, #12]
 800b350:	683a      	ldr	r2, [r7, #0]
 800b352:	609a      	str	r2, [r3, #8]
    out_ins->should_accept = should_accept;
 800b354:	68fb      	ldr	r3, [r7, #12]
 800b356:	6a3a      	ldr	r2, [r7, #32]
 800b358:	605a      	str	r2, [r3, #4]
    out_ins->rx_states = NULL;
 800b35a:	68fb      	ldr	r3, [r7, #12]
 800b35c:	2200      	movs	r2, #0
 800b35e:	619a      	str	r2, [r3, #24]
    out_ins->tx_queue = NULL;
 800b360:	68fb      	ldr	r3, [r7, #12]
 800b362:	2200      	movs	r2, #0
 800b364:	61da      	str	r2, [r3, #28]
    out_ins->user_reference = user_reference;
 800b366:	68fb      	ldr	r3, [r7, #12]
 800b368:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b36a:	621a      	str	r2, [r3, #32]

    size_t pool_capacity = mem_arena_size / CANARD_MEM_BLOCK_SIZE;
 800b36c:	687b      	ldr	r3, [r7, #4]
 800b36e:	095b      	lsrs	r3, r3, #5
 800b370:	617b      	str	r3, [r7, #20]
    if (pool_capacity > 0xFFFFU)
 800b372:	697b      	ldr	r3, [r7, #20]
 800b374:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800b378:	d302      	bcc.n	800b380 <canardInit+0x50>
    {
        pool_capacity = 0xFFFFU;
 800b37a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b37e:	617b      	str	r3, [r7, #20]
    }

    initPoolAllocator(&out_ins->allocator, mem_arena, (uint16_t)pool_capacity);
 800b380:	68fb      	ldr	r3, [r7, #12]
 800b382:	f103 020c 	add.w	r2, r3, #12
 800b386:	697b      	ldr	r3, [r7, #20]
 800b388:	b29b      	uxth	r3, r3
 800b38a:	4610      	mov	r0, r2
 800b38c:	68b9      	ldr	r1, [r7, #8]
 800b38e:	461a      	mov	r2, r3
 800b390:	f001 fa66 	bl	800c860 <initPoolAllocator>
}
 800b394:	3718      	adds	r7, #24
 800b396:	46bd      	mov	sp, r7
 800b398:	bd80      	pop	{r7, pc}
 800b39a:	bf00      	nop

0800b39c <canardGetUserReference>:

void* canardGetUserReference(CanardInstance* ins)
{
 800b39c:	b480      	push	{r7}
 800b39e:	b083      	sub	sp, #12
 800b3a0:	af00      	add	r7, sp, #0
 800b3a2:	6078      	str	r0, [r7, #4]
    CANARD_ASSERT(ins != NULL);
    return ins->user_reference;
 800b3a4:	687b      	ldr	r3, [r7, #4]
 800b3a6:	6a1b      	ldr	r3, [r3, #32]
}
 800b3a8:	4618      	mov	r0, r3
 800b3aa:	370c      	adds	r7, #12
 800b3ac:	46bd      	mov	sp, r7
 800b3ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3b2:	4770      	bx	lr

0800b3b4 <canardSetLocalNodeID>:

void canardSetLocalNodeID(CanardInstance* ins, uint8_t self_node_id)
{
 800b3b4:	b480      	push	{r7}
 800b3b6:	b083      	sub	sp, #12
 800b3b8:	af00      	add	r7, sp, #0
 800b3ba:	6078      	str	r0, [r7, #4]
 800b3bc:	460b      	mov	r3, r1
 800b3be:	70fb      	strb	r3, [r7, #3]
    CANARD_ASSERT(ins != NULL);

    if ((ins->node_id == CANARD_BROADCAST_NODE_ID) &&
 800b3c0:	687b      	ldr	r3, [r7, #4]
 800b3c2:	781b      	ldrb	r3, [r3, #0]
 800b3c4:	2b00      	cmp	r3, #0
 800b3c6:	d109      	bne.n	800b3dc <canardSetLocalNodeID+0x28>
 800b3c8:	78fb      	ldrb	r3, [r7, #3]
 800b3ca:	2b00      	cmp	r3, #0
 800b3cc:	d006      	beq.n	800b3dc <canardSetLocalNodeID+0x28>
        (self_node_id >= CANARD_MIN_NODE_ID) &&
        (self_node_id <= CANARD_MAX_NODE_ID))
 800b3ce:	78fb      	ldrb	r3, [r7, #3]
void canardSetLocalNodeID(CanardInstance* ins, uint8_t self_node_id)
{
    CANARD_ASSERT(ins != NULL);

    if ((ins->node_id == CANARD_BROADCAST_NODE_ID) &&
        (self_node_id >= CANARD_MIN_NODE_ID) &&
 800b3d0:	b25b      	sxtb	r3, r3
 800b3d2:	2b00      	cmp	r3, #0
 800b3d4:	db02      	blt.n	800b3dc <canardSetLocalNodeID+0x28>
        (self_node_id <= CANARD_MAX_NODE_ID))
    {
        ins->node_id = self_node_id;
 800b3d6:	687b      	ldr	r3, [r7, #4]
 800b3d8:	78fa      	ldrb	r2, [r7, #3]
 800b3da:	701a      	strb	r2, [r3, #0]
    }
    else
    {
        CANARD_ASSERT(false);
    }
}
 800b3dc:	370c      	adds	r7, #12
 800b3de:	46bd      	mov	sp, r7
 800b3e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3e4:	4770      	bx	lr
 800b3e6:	bf00      	nop

0800b3e8 <canardGetLocalNodeID>:

uint8_t canardGetLocalNodeID(const CanardInstance* ins)
{
 800b3e8:	b480      	push	{r7}
 800b3ea:	b083      	sub	sp, #12
 800b3ec:	af00      	add	r7, sp, #0
 800b3ee:	6078      	str	r0, [r7, #4]
    return ins->node_id;
 800b3f0:	687b      	ldr	r3, [r7, #4]
 800b3f2:	781b      	ldrb	r3, [r3, #0]
}
 800b3f4:	4618      	mov	r0, r3
 800b3f6:	370c      	adds	r7, #12
 800b3f8:	46bd      	mov	sp, r7
 800b3fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3fe:	4770      	bx	lr

0800b400 <canardHandleRxFrame>:
    ins->tx_queue = item->next;
    freeBlock(&ins->allocator, item);
}

void canardHandleRxFrame(CanardInstance* ins, const CanardCANFrame* frame, uint64_t timestamp_usec)
{
 800b400:	b5b0      	push	{r4, r5, r7, lr}
 800b402:	b0a0      	sub	sp, #128	; 0x80
 800b404:	af02      	add	r7, sp, #8
 800b406:	60f8      	str	r0, [r7, #12]
 800b408:	60b9      	str	r1, [r7, #8]
 800b40a:	e9c7 2300 	strd	r2, r3, [r7]
    const CanardTransferType transfer_type = extractTransferType(frame->id);
 800b40e:	68bb      	ldr	r3, [r7, #8]
 800b410:	681b      	ldr	r3, [r3, #0]
 800b412:	4618      	mov	r0, r3
 800b414:	f000 fdfe 	bl	800c014 <extractTransferType>
 800b418:	4603      	mov	r3, r0
 800b41a:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
    const uint8_t destination_node_id = (transfer_type == CanardTransferTypeBroadcast) ?
 800b41e:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800b422:	2b02      	cmp	r3, #2
 800b424:	d007      	beq.n	800b436 <canardHandleRxFrame+0x36>
                                        (uint8_t)CANARD_BROADCAST_NODE_ID :
                                        DEST_ID_FROM_ID(frame->id);
 800b426:	68bb      	ldr	r3, [r7, #8]
 800b428:	681b      	ldr	r3, [r3, #0]
 800b42a:	0a1b      	lsrs	r3, r3, #8
}

void canardHandleRxFrame(CanardInstance* ins, const CanardCANFrame* frame, uint64_t timestamp_usec)
{
    const CanardTransferType transfer_type = extractTransferType(frame->id);
    const uint8_t destination_node_id = (transfer_type == CanardTransferTypeBroadcast) ?
 800b42c:	b2db      	uxtb	r3, r3
 800b42e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800b432:	b2db      	uxtb	r3, r3
 800b434:	e000      	b.n	800b438 <canardHandleRxFrame+0x38>
 800b436:	2300      	movs	r3, #0
 800b438:	f887 305e 	strb.w	r3, [r7, #94]	; 0x5e
                                        (uint8_t)CANARD_BROADCAST_NODE_ID :
                                        DEST_ID_FROM_ID(frame->id);

    // TODO: This function should maintain statistics of transfer errors and such.

    if ((frame->id & CANARD_CAN_FRAME_EFF) == 0 ||
 800b43c:	68bb      	ldr	r3, [r7, #8]
 800b43e:	681b      	ldr	r3, [r3, #0]
 800b440:	2b00      	cmp	r3, #0
 800b442:	f280 8308 	bge.w	800ba56 <canardHandleRxFrame+0x656>
        (frame->id & CANARD_CAN_FRAME_RTR) != 0 ||
 800b446:	68bb      	ldr	r3, [r7, #8]
 800b448:	681b      	ldr	r3, [r3, #0]
 800b44a:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
                                        (uint8_t)CANARD_BROADCAST_NODE_ID :
                                        DEST_ID_FROM_ID(frame->id);

    // TODO: This function should maintain statistics of transfer errors and such.

    if ((frame->id & CANARD_CAN_FRAME_EFF) == 0 ||
 800b44e:	2b00      	cmp	r3, #0
 800b450:	f040 8301 	bne.w	800ba56 <canardHandleRxFrame+0x656>
        (frame->id & CANARD_CAN_FRAME_RTR) != 0 ||
        (frame->id & CANARD_CAN_FRAME_ERR) != 0 ||
 800b454:	68bb      	ldr	r3, [r7, #8]
 800b456:	681b      	ldr	r3, [r3, #0]
 800b458:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
                                        DEST_ID_FROM_ID(frame->id);

    // TODO: This function should maintain statistics of transfer errors and such.

    if ((frame->id & CANARD_CAN_FRAME_EFF) == 0 ||
        (frame->id & CANARD_CAN_FRAME_RTR) != 0 ||
 800b45c:	2b00      	cmp	r3, #0
 800b45e:	f040 82fa 	bne.w	800ba56 <canardHandleRxFrame+0x656>
        (frame->id & CANARD_CAN_FRAME_ERR) != 0 ||
        (frame->data_len < 1))
 800b462:	68bb      	ldr	r3, [r7, #8]
 800b464:	7b1b      	ldrb	r3, [r3, #12]

    // TODO: This function should maintain statistics of transfer errors and such.

    if ((frame->id & CANARD_CAN_FRAME_EFF) == 0 ||
        (frame->id & CANARD_CAN_FRAME_RTR) != 0 ||
        (frame->id & CANARD_CAN_FRAME_ERR) != 0 ||
 800b466:	2b00      	cmp	r3, #0
 800b468:	f000 82f5 	beq.w	800ba56 <canardHandleRxFrame+0x656>
        (frame->data_len < 1))
    {
        return;     // Unsupported frame, not UAVCAN - ignore
    }

    if (transfer_type != CanardTransferTypeBroadcast &&
 800b46c:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800b470:	2b02      	cmp	r3, #2
 800b472:	d009      	beq.n	800b488 <canardHandleRxFrame+0x88>
        destination_node_id != canardGetLocalNodeID(ins))
 800b474:	68f8      	ldr	r0, [r7, #12]
 800b476:	f7ff ffb7 	bl	800b3e8 <canardGetLocalNodeID>
 800b47a:	4603      	mov	r3, r0
 800b47c:	461a      	mov	r2, r3
        (frame->data_len < 1))
    {
        return;     // Unsupported frame, not UAVCAN - ignore
    }

    if (transfer_type != CanardTransferTypeBroadcast &&
 800b47e:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
 800b482:	4293      	cmp	r3, r2
 800b484:	f040 82e7 	bne.w	800ba56 <canardHandleRxFrame+0x656>
        destination_node_id != canardGetLocalNodeID(ins))
    {
        return;     // Address mismatch
    }

    const uint8_t priority = PRIORITY_FROM_ID(frame->id);
 800b488:	68bb      	ldr	r3, [r7, #8]
 800b48a:	681b      	ldr	r3, [r3, #0]
 800b48c:	0e1b      	lsrs	r3, r3, #24
 800b48e:	b2db      	uxtb	r3, r3
 800b490:	f003 031f 	and.w	r3, r3, #31
 800b494:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
    const uint8_t source_node_id = SOURCE_ID_FROM_ID(frame->id);
 800b498:	68bb      	ldr	r3, [r7, #8]
 800b49a:	681b      	ldr	r3, [r3, #0]
 800b49c:	b2db      	uxtb	r3, r3
 800b49e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800b4a2:	f887 305c 	strb.w	r3, [r7, #92]	; 0x5c
    const uint16_t data_type_id = extractDataType(frame->id);
 800b4a6:	68bb      	ldr	r3, [r7, #8]
 800b4a8:	681b      	ldr	r3, [r3, #0]
 800b4aa:	4618      	mov	r0, r3
 800b4ac:	f000 fd90 	bl	800bfd0 <extractDataType>
 800b4b0:	4603      	mov	r3, r0
 800b4b2:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
    const uint32_t transfer_descriptor =
            MAKE_TRANSFER_DESCRIPTOR(data_type_id, transfer_type, source_node_id, destination_node_id);
 800b4b6:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 800b4ba:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800b4be:	041b      	lsls	r3, r3, #16
 800b4c0:	431a      	orrs	r2, r3
 800b4c2:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 800b4c6:	049b      	lsls	r3, r3, #18
 800b4c8:	431a      	orrs	r2, r3
 800b4ca:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
 800b4ce:	065b      	lsls	r3, r3, #25
    }

    const uint8_t priority = PRIORITY_FROM_ID(frame->id);
    const uint8_t source_node_id = SOURCE_ID_FROM_ID(frame->id);
    const uint16_t data_type_id = extractDataType(frame->id);
    const uint32_t transfer_descriptor =
 800b4d0:	4313      	orrs	r3, r2
 800b4d2:	657b      	str	r3, [r7, #84]	; 0x54
            MAKE_TRANSFER_DESCRIPTOR(data_type_id, transfer_type, source_node_id, destination_node_id);

    const uint8_t tail_byte = frame->data[frame->data_len - 1];
 800b4d4:	68bb      	ldr	r3, [r7, #8]
 800b4d6:	7b1b      	ldrb	r3, [r3, #12]
 800b4d8:	3b01      	subs	r3, #1
 800b4da:	68ba      	ldr	r2, [r7, #8]
 800b4dc:	4413      	add	r3, r2
 800b4de:	791b      	ldrb	r3, [r3, #4]
 800b4e0:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53

    CanardRxState* rx_state = NULL;
 800b4e4:	2300      	movs	r3, #0
 800b4e6:	677b      	str	r3, [r7, #116]	; 0x74

    if (IS_START_OF_TRANSFER(tail_byte))
 800b4e8:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b4ec:	09db      	lsrs	r3, r3, #7
 800b4ee:	b2db      	uxtb	r3, r3
 800b4f0:	f003 0301 	and.w	r3, r3, #1
 800b4f4:	2b00      	cmp	r3, #0
 800b4f6:	d02b      	beq.n	800b550 <canardHandleRxFrame+0x150>
    {
        uint64_t data_type_signature = 0;
 800b4f8:	f04f 0200 	mov.w	r2, #0
 800b4fc:	f04f 0300 	mov.w	r3, #0
 800b500:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30

        if (ins->should_accept(ins, &data_type_signature, data_type_id, transfer_type, source_node_id))
 800b504:	68fb      	ldr	r3, [r7, #12]
 800b506:	685c      	ldr	r4, [r3, #4]
 800b508:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800b50c:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 800b510:	f897 505f 	ldrb.w	r5, [r7, #95]	; 0x5f
 800b514:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 800b518:	9300      	str	r3, [sp, #0]
 800b51a:	68f8      	ldr	r0, [r7, #12]
 800b51c:	462b      	mov	r3, r5
 800b51e:	47a0      	blx	r4
 800b520:	4603      	mov	r3, r0
 800b522:	2b00      	cmp	r3, #0
 800b524:	f000 8296 	beq.w	800ba54 <canardHandleRxFrame+0x654>
        {
            rx_state = traverseRxStates(ins, transfer_descriptor);
 800b528:	68f8      	ldr	r0, [r7, #12]
 800b52a:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800b52c:	f000 fd96 	bl	800c05c <traverseRxStates>
 800b530:	6778      	str	r0, [r7, #116]	; 0x74

            if(rx_state == NULL)
 800b532:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b534:	2b00      	cmp	r3, #0
 800b536:	f000 828d 	beq.w	800ba54 <canardHandleRxFrame+0x654>
            {
                return; // No allocator room for this frame
            }

            rx_state->calculated_crc = crcAddSignature(0xFFFFU, data_type_signature);
 800b53a:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 800b53e:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800b542:	f001 f93f 	bl	800c7c4 <crcAddSignature>
 800b546:	4603      	mov	r3, r0
 800b548:	461a      	mov	r2, r3
 800b54a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b54c:	82da      	strh	r2, [r3, #22]
 800b54e:	e00a      	b.n	800b566 <canardHandleRxFrame+0x166>
            return;     // The application doesn't want this transfer
        }
    }
    else
    {
        rx_state = findRxState(ins->rx_states, transfer_descriptor);
 800b550:	68fb      	ldr	r3, [r7, #12]
 800b552:	699b      	ldr	r3, [r3, #24]
 800b554:	4618      	mov	r0, r3
 800b556:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800b558:	f000 fdb0 	bl	800c0bc <findRxState>
 800b55c:	6778      	str	r0, [r7, #116]	; 0x74

        if (rx_state == NULL)
 800b55e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b560:	2b00      	cmp	r3, #0
 800b562:	f000 8278 	beq.w	800ba56 <canardHandleRxFrame+0x656>
    }

    CANARD_ASSERT(rx_state != NULL);    // All paths that lead to NULL should be terminated with return above

    // Resolving the state flags:
    const bool not_initialized = rx_state->timestamp_usec == 0;
 800b566:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b568:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800b56c:	4313      	orrs	r3, r2
 800b56e:	2b00      	cmp	r3, #0
 800b570:	bf0c      	ite	eq
 800b572:	2301      	moveq	r3, #1
 800b574:	2300      	movne	r3, #0
 800b576:	f887 3052 	strb.w	r3, [r7, #82]	; 0x52
    const bool tid_timed_out = (timestamp_usec - rx_state->timestamp_usec) > TRANSFER_TIMEOUT_USEC;
 800b57a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b57c:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800b580:	e9d7 0100 	ldrd	r0, r1, [r7]
 800b584:	1a82      	subs	r2, r0, r2
 800b586:	eb61 0303 	sbc.w	r3, r1, r3
 800b58a:	48b7      	ldr	r0, [pc, #732]	; (800b868 <canardHandleRxFrame+0x468>)
 800b58c:	f04f 0100 	mov.w	r1, #0
 800b590:	4299      	cmp	r1, r3
 800b592:	bf08      	it	eq
 800b594:	4290      	cmpeq	r0, r2
 800b596:	bf34      	ite	cc
 800b598:	2301      	movcc	r3, #1
 800b59a:	2300      	movcs	r3, #0
 800b59c:	f887 3051 	strb.w	r3, [r7, #81]	; 0x51
    const bool first_frame = IS_START_OF_TRANSFER(tail_byte);
 800b5a0:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b5a4:	09db      	lsrs	r3, r3, #7
 800b5a6:	b2db      	uxtb	r3, r3
 800b5a8:	f003 0301 	and.w	r3, r3, #1
 800b5ac:	2b00      	cmp	r3, #0
 800b5ae:	bf14      	ite	ne
 800b5b0:	2301      	movne	r3, #1
 800b5b2:	2300      	moveq	r3, #0
 800b5b4:	f887 3050 	strb.w	r3, [r7, #80]	; 0x50
    const bool not_previous_tid =
        computeTransferIDForwardDistance((uint8_t) rx_state->transfer_id, TRANSFER_ID_FROM_TAIL_BYTE(tail_byte)) > 1;
 800b5b8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b5ba:	7e5b      	ldrb	r3, [r3, #25]
 800b5bc:	f3c3 0384 	ubfx	r3, r3, #2, #5
 800b5c0:	b2db      	uxtb	r3, r3
 800b5c2:	461a      	mov	r2, r3
 800b5c4:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b5c8:	f003 031f 	and.w	r3, r3, #31
 800b5cc:	b2db      	uxtb	r3, r3
 800b5ce:	4610      	mov	r0, r2
 800b5d0:	4619      	mov	r1, r3
 800b5d2:	f000 fcc1 	bl	800bf58 <computeTransferIDForwardDistance>
 800b5d6:	4603      	mov	r3, r0

    // Resolving the state flags:
    const bool not_initialized = rx_state->timestamp_usec == 0;
    const bool tid_timed_out = (timestamp_usec - rx_state->timestamp_usec) > TRANSFER_TIMEOUT_USEC;
    const bool first_frame = IS_START_OF_TRANSFER(tail_byte);
    const bool not_previous_tid =
 800b5d8:	2b01      	cmp	r3, #1
 800b5da:	bfcc      	ite	gt
 800b5dc:	2301      	movgt	r3, #1
 800b5de:	2300      	movle	r3, #0
 800b5e0:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
        computeTransferIDForwardDistance((uint8_t) rx_state->transfer_id, TRANSFER_ID_FROM_TAIL_BYTE(tail_byte)) > 1;

    const bool need_restart =
            (not_initialized) ||
            (tid_timed_out) ||
 800b5e4:	f897 3052 	ldrb.w	r3, [r7, #82]	; 0x52
 800b5e8:	2b00      	cmp	r3, #0
 800b5ea:	d10b      	bne.n	800b604 <canardHandleRxFrame+0x204>
    const bool first_frame = IS_START_OF_TRANSFER(tail_byte);
    const bool not_previous_tid =
        computeTransferIDForwardDistance((uint8_t) rx_state->transfer_id, TRANSFER_ID_FROM_TAIL_BYTE(tail_byte)) > 1;

    const bool need_restart =
            (not_initialized) ||
 800b5ec:	f897 3051 	ldrb.w	r3, [r7, #81]	; 0x51
 800b5f0:	2b00      	cmp	r3, #0
 800b5f2:	d107      	bne.n	800b604 <canardHandleRxFrame+0x204>
            (tid_timed_out) ||
 800b5f4:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
 800b5f8:	2b00      	cmp	r3, #0
 800b5fa:	d005      	beq.n	800b608 <canardHandleRxFrame+0x208>
            (first_frame && not_previous_tid);
 800b5fc:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 800b600:	2b00      	cmp	r3, #0
 800b602:	d001      	beq.n	800b608 <canardHandleRxFrame+0x208>
    const bool not_previous_tid =
        computeTransferIDForwardDistance((uint8_t) rx_state->transfer_id, TRANSFER_ID_FROM_TAIL_BYTE(tail_byte)) > 1;

    const bool need_restart =
            (not_initialized) ||
            (tid_timed_out) ||
 800b604:	2301      	movs	r3, #1
 800b606:	e000      	b.n	800b60a <canardHandleRxFrame+0x20a>
 800b608:	2300      	movs	r3, #0
    const bool tid_timed_out = (timestamp_usec - rx_state->timestamp_usec) > TRANSFER_TIMEOUT_USEC;
    const bool first_frame = IS_START_OF_TRANSFER(tail_byte);
    const bool not_previous_tid =
        computeTransferIDForwardDistance((uint8_t) rx_state->transfer_id, TRANSFER_ID_FROM_TAIL_BYTE(tail_byte)) > 1;

    const bool need_restart =
 800b60a:	f887 304e 	strb.w	r3, [r7, #78]	; 0x4e
 800b60e:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 800b612:	f003 0301 	and.w	r3, r3, #1
 800b616:	f887 304e 	strb.w	r3, [r7, #78]	; 0x4e
            (not_initialized) ||
            (tid_timed_out) ||
            (first_frame && not_previous_tid);

    if (need_restart)
 800b61a:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 800b61e:	2b00      	cmp	r3, #0
 800b620:	d02a      	beq.n	800b678 <canardHandleRxFrame+0x278>
    {
        rx_state->transfer_id = TRANSFER_ID_FROM_TAIL_BYTE(tail_byte);
 800b622:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b626:	f003 031f 	and.w	r3, r3, #31
 800b62a:	b2d9      	uxtb	r1, r3
 800b62c:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800b62e:	7e53      	ldrb	r3, [r2, #25]
 800b630:	f361 0386 	bfi	r3, r1, #2, #5
 800b634:	7653      	strb	r3, [r2, #25]
        rx_state->next_toggle = 0;
 800b636:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800b638:	7e53      	ldrb	r3, [r2, #25]
 800b63a:	f36f 13c7 	bfc	r3, #7, #1
 800b63e:	7653      	strb	r3, [r2, #25]
        releaseStatePayload(ins, rx_state);
 800b640:	68f8      	ldr	r0, [r7, #12]
 800b642:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800b644:	f000 fda8 	bl	800c198 <releaseStatePayload>
        if (!IS_START_OF_TRANSFER(tail_byte)) // missed the first frame
 800b648:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b64c:	09db      	lsrs	r3, r3, #7
 800b64e:	b2db      	uxtb	r3, r3
 800b650:	f003 0301 	and.w	r3, r3, #1
 800b654:	2b00      	cmp	r3, #0
 800b656:	d10f      	bne.n	800b678 <canardHandleRxFrame+0x278>
        {
            rx_state->transfer_id += 1;
 800b658:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b65a:	7e5b      	ldrb	r3, [r3, #25]
 800b65c:	f3c3 0384 	ubfx	r3, r3, #2, #5
 800b660:	b2db      	uxtb	r3, r3
 800b662:	3301      	adds	r3, #1
 800b664:	b2db      	uxtb	r3, r3
 800b666:	f003 031f 	and.w	r3, r3, #31
 800b66a:	b2d9      	uxtb	r1, r3
 800b66c:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800b66e:	7e53      	ldrb	r3, [r2, #25]
 800b670:	f361 0386 	bfi	r3, r1, #2, #5
 800b674:	7653      	strb	r3, [r2, #25]
 800b676:	e1ee      	b.n	800ba56 <canardHandleRxFrame+0x656>
            return;
        }
    }

    if (IS_START_OF_TRANSFER(tail_byte) && IS_END_OF_TRANSFER(tail_byte)) // single frame transfer
 800b678:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b67c:	09db      	lsrs	r3, r3, #7
 800b67e:	b2db      	uxtb	r3, r3
 800b680:	f003 0301 	and.w	r3, r3, #1
 800b684:	2b00      	cmp	r3, #0
 800b686:	d054      	beq.n	800b732 <canardHandleRxFrame+0x332>
 800b688:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b68c:	099b      	lsrs	r3, r3, #6
 800b68e:	b2db      	uxtb	r3, r3
 800b690:	f003 0301 	and.w	r3, r3, #1
 800b694:	2b00      	cmp	r3, #0
 800b696:	d04c      	beq.n	800b732 <canardHandleRxFrame+0x332>
    {
        rx_state->timestamp_usec = timestamp_usec;
 800b698:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800b69a:	e9d7 2300 	ldrd	r2, r3, [r7]
 800b69e:	e9c1 2302 	strd	r2, r3, [r1, #8]
        CanardRxTransfer rx_transfer = {
 800b6a2:	f107 0310 	add.w	r3, r7, #16
 800b6a6:	2200      	movs	r2, #0
 800b6a8:	601a      	str	r2, [r3, #0]
 800b6aa:	3304      	adds	r3, #4
 800b6ac:	2200      	movs	r2, #0
 800b6ae:	601a      	str	r2, [r3, #0]
 800b6b0:	3304      	adds	r3, #4
 800b6b2:	2200      	movs	r2, #0
 800b6b4:	601a      	str	r2, [r3, #0]
 800b6b6:	3304      	adds	r3, #4
 800b6b8:	2200      	movs	r2, #0
 800b6ba:	601a      	str	r2, [r3, #0]
 800b6bc:	3304      	adds	r3, #4
 800b6be:	2200      	movs	r2, #0
 800b6c0:	601a      	str	r2, [r3, #0]
 800b6c2:	3304      	adds	r3, #4
 800b6c4:	2200      	movs	r2, #0
 800b6c6:	601a      	str	r2, [r3, #0]
 800b6c8:	3304      	adds	r3, #4
 800b6ca:	2200      	movs	r2, #0
 800b6cc:	601a      	str	r2, [r3, #0]
 800b6ce:	3304      	adds	r3, #4
 800b6d0:	2200      	movs	r2, #0
 800b6d2:	601a      	str	r2, [r3, #0]
 800b6d4:	3304      	adds	r3, #4
 800b6d6:	e9d7 2300 	ldrd	r2, r3, [r7]
 800b6da:	e9c7 2304 	strd	r2, r3, [r7, #16]
            .timestamp_usec = timestamp_usec,
            .payload_head = frame->data,
 800b6de:	68bb      	ldr	r3, [r7, #8]
 800b6e0:	3304      	adds	r3, #4
    }

    if (IS_START_OF_TRANSFER(tail_byte) && IS_END_OF_TRANSFER(tail_byte)) // single frame transfer
    {
        rx_state->timestamp_usec = timestamp_usec;
        CanardRxTransfer rx_transfer = {
 800b6e2:	61bb      	str	r3, [r7, #24]
            .timestamp_usec = timestamp_usec,
            .payload_head = frame->data,
            .payload_len = (uint8_t)(frame->data_len - 1U),
 800b6e4:	68bb      	ldr	r3, [r7, #8]
 800b6e6:	7b1b      	ldrb	r3, [r3, #12]
 800b6e8:	3b01      	subs	r3, #1
 800b6ea:	b2db      	uxtb	r3, r3
    }

    if (IS_START_OF_TRANSFER(tail_byte) && IS_END_OF_TRANSFER(tail_byte)) // single frame transfer
    {
        rx_state->timestamp_usec = timestamp_usec;
        CanardRxTransfer rx_transfer = {
 800b6ec:	b29b      	uxth	r3, r3
 800b6ee:	84bb      	strh	r3, [r7, #36]	; 0x24
 800b6f0:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 800b6f4:	84fb      	strh	r3, [r7, #38]	; 0x26
 800b6f6:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800b6fa:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
            .timestamp_usec = timestamp_usec,
            .payload_head = frame->data,
            .payload_len = (uint8_t)(frame->data_len - 1U),
            .data_type_id = data_type_id,
            .transfer_type = transfer_type,
            .transfer_id = TRANSFER_ID_FROM_TAIL_BYTE(tail_byte),
 800b6fe:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b702:	f003 031f 	and.w	r3, r3, #31
 800b706:	b2db      	uxtb	r3, r3
    }

    if (IS_START_OF_TRANSFER(tail_byte) && IS_END_OF_TRANSFER(tail_byte)) // single frame transfer
    {
        rx_state->timestamp_usec = timestamp_usec;
        CanardRxTransfer rx_transfer = {
 800b708:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
 800b70c:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 800b710:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
 800b714:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 800b718:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
            .transfer_id = TRANSFER_ID_FROM_TAIL_BYTE(tail_byte),
            .priority = priority,
            .source_node_id = source_node_id
        };

        ins->on_reception(ins, &rx_transfer);
 800b71c:	68fb      	ldr	r3, [r7, #12]
 800b71e:	689b      	ldr	r3, [r3, #8]
 800b720:	f107 0210 	add.w	r2, r7, #16
 800b724:	68f8      	ldr	r0, [r7, #12]
 800b726:	4611      	mov	r1, r2
 800b728:	4798      	blx	r3

        prepareForNextTransfer(rx_state);
 800b72a:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800b72c:	f000 fc2e 	bl	800bf8c <prepareForNextTransfer>
 800b730:	e191      	b.n	800ba56 <canardHandleRxFrame+0x656>
        return;
    }

    if (TOGGLE_BIT(tail_byte) != rx_state->next_toggle)
 800b732:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b736:	095b      	lsrs	r3, r3, #5
 800b738:	b2db      	uxtb	r3, r3
 800b73a:	f003 0301 	and.w	r3, r3, #1
 800b73e:	2b00      	cmp	r3, #0
 800b740:	bf14      	ite	ne
 800b742:	2301      	movne	r3, #1
 800b744:	2300      	moveq	r3, #0
 800b746:	b2db      	uxtb	r3, r3
 800b748:	461a      	mov	r2, r3
 800b74a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b74c:	7e5b      	ldrb	r3, [r3, #25]
 800b74e:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800b752:	b2db      	uxtb	r3, r3
 800b754:	429a      	cmp	r2, r3
 800b756:	f040 817e 	bne.w	800ba56 <canardHandleRxFrame+0x656>
    {
        return; // wrong toggle
    }

    if (TRANSFER_ID_FROM_TAIL_BYTE(tail_byte) != rx_state->transfer_id)
 800b75a:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b75e:	f003 031f 	and.w	r3, r3, #31
 800b762:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800b764:	7e52      	ldrb	r2, [r2, #25]
 800b766:	f3c2 0284 	ubfx	r2, r2, #2, #5
 800b76a:	b2d2      	uxtb	r2, r2
 800b76c:	4293      	cmp	r3, r2
 800b76e:	f040 8172 	bne.w	800ba56 <canardHandleRxFrame+0x656>
    {
        return; // unexpected tid
    }

    if (IS_START_OF_TRANSFER(tail_byte) && !IS_END_OF_TRANSFER(tail_byte))      // Beginning of multi frame transfer
 800b772:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b776:	09db      	lsrs	r3, r3, #7
 800b778:	b2db      	uxtb	r3, r3
 800b77a:	f003 0301 	and.w	r3, r3, #1
 800b77e:	2b00      	cmp	r3, #0
 800b780:	d048      	beq.n	800b814 <canardHandleRxFrame+0x414>
 800b782:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b786:	099b      	lsrs	r3, r3, #6
 800b788:	b2db      	uxtb	r3, r3
 800b78a:	f003 0301 	and.w	r3, r3, #1
 800b78e:	2b00      	cmp	r3, #0
 800b790:	d140      	bne.n	800b814 <canardHandleRxFrame+0x414>
    {
        if (frame->data_len <= 3)
 800b792:	68bb      	ldr	r3, [r7, #8]
 800b794:	7b1b      	ldrb	r3, [r3, #12]
 800b796:	2b03      	cmp	r3, #3
 800b798:	f240 815d 	bls.w	800ba56 <canardHandleRxFrame+0x656>
        {
            return;     // Not enough data
        }

        // take off the crc and store the payload
        rx_state->timestamp_usec = timestamp_usec;
 800b79c:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800b79e:	e9d7 2300 	ldrd	r2, r3, [r7]
 800b7a2:	e9c1 2302 	strd	r2, r3, [r1, #8]
        const int ret = bufferBlockPushBytes(&ins->allocator, rx_state, frame->data + 2,
 800b7a6:	68fb      	ldr	r3, [r7, #12]
 800b7a8:	f103 010c 	add.w	r1, r3, #12
 800b7ac:	68bb      	ldr	r3, [r7, #8]
 800b7ae:	1d9a      	adds	r2, r3, #6
                                             (uint8_t) (frame->data_len - 3));
 800b7b0:	68bb      	ldr	r3, [r7, #8]
 800b7b2:	7b1b      	ldrb	r3, [r3, #12]
            return;     // Not enough data
        }

        // take off the crc and store the payload
        rx_state->timestamp_usec = timestamp_usec;
        const int ret = bufferBlockPushBytes(&ins->allocator, rx_state, frame->data + 2,
 800b7b4:	3b03      	subs	r3, #3
 800b7b6:	b2db      	uxtb	r3, r3
 800b7b8:	4608      	mov	r0, r1
 800b7ba:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800b7bc:	f000 fd14 	bl	800c1e8 <bufferBlockPushBytes>
 800b7c0:	64b8      	str	r0, [r7, #72]	; 0x48
                                             (uint8_t) (frame->data_len - 3));
        if (ret < 0)
 800b7c2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b7c4:	2b00      	cmp	r3, #0
 800b7c6:	da07      	bge.n	800b7d8 <canardHandleRxFrame+0x3d8>
        {
            releaseStatePayload(ins, rx_state);
 800b7c8:	68f8      	ldr	r0, [r7, #12]
 800b7ca:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800b7cc:	f000 fce4 	bl	800c198 <releaseStatePayload>
            prepareForNextTransfer(rx_state);
 800b7d0:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800b7d2:	f000 fbdb 	bl	800bf8c <prepareForNextTransfer>
 800b7d6:	e13e      	b.n	800ba56 <canardHandleRxFrame+0x656>
            return;
        }
        rx_state->payload_crc = ((uint16_t) frame->data[0]) | ((uint16_t) frame->data[1] << 8);
 800b7d8:	68bb      	ldr	r3, [r7, #8]
 800b7da:	791b      	ldrb	r3, [r3, #4]
 800b7dc:	b29a      	uxth	r2, r3
 800b7de:	68bb      	ldr	r3, [r7, #8]
 800b7e0:	795b      	ldrb	r3, [r3, #5]
 800b7e2:	021b      	lsls	r3, r3, #8
 800b7e4:	b29b      	uxth	r3, r3
 800b7e6:	4313      	orrs	r3, r2
 800b7e8:	b29b      	uxth	r3, r3
 800b7ea:	b29a      	uxth	r2, r3
 800b7ec:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b7ee:	829a      	strh	r2, [r3, #20]
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc,
 800b7f0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b7f2:	8ad9      	ldrh	r1, [r3, #22]
 800b7f4:	68bb      	ldr	r3, [r7, #8]
 800b7f6:	1d9a      	adds	r2, r3, #6
                                          frame->data + 2, (uint8_t)(frame->data_len - 3));
 800b7f8:	68bb      	ldr	r3, [r7, #8]
 800b7fa:	7b1b      	ldrb	r3, [r3, #12]
 800b7fc:	3b03      	subs	r3, #3
 800b7fe:	b2db      	uxtb	r3, r3
            releaseStatePayload(ins, rx_state);
            prepareForNextTransfer(rx_state);
            return;
        }
        rx_state->payload_crc = ((uint16_t) frame->data[0]) | ((uint16_t) frame->data[1] << 8);
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc,
 800b800:	4608      	mov	r0, r1
 800b802:	4611      	mov	r1, r2
 800b804:	461a      	mov	r2, r3
 800b806:	f001 f80d 	bl	800c824 <crcAdd>
 800b80a:	4603      	mov	r3, r0
 800b80c:	461a      	mov	r2, r3
 800b80e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b810:	82da      	strh	r2, [r3, #22]
 800b812:	e10e      	b.n	800ba32 <canardHandleRxFrame+0x632>
                                          frame->data + 2, (uint8_t)(frame->data_len - 3));
    }
    else if (!IS_START_OF_TRANSFER(tail_byte) && !IS_END_OF_TRANSFER(tail_byte))    // Middle of a multi-frame transfer
 800b814:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b818:	09db      	lsrs	r3, r3, #7
 800b81a:	b2db      	uxtb	r3, r3
 800b81c:	f003 0301 	and.w	r3, r3, #1
 800b820:	2b00      	cmp	r3, #0
 800b822:	d135      	bne.n	800b890 <canardHandleRxFrame+0x490>
 800b824:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b828:	099b      	lsrs	r3, r3, #6
 800b82a:	b2db      	uxtb	r3, r3
 800b82c:	f003 0301 	and.w	r3, r3, #1
 800b830:	2b00      	cmp	r3, #0
 800b832:	d12d      	bne.n	800b890 <canardHandleRxFrame+0x490>
    {
        const int ret = bufferBlockPushBytes(&ins->allocator, rx_state, frame->data,
 800b834:	68fb      	ldr	r3, [r7, #12]
 800b836:	f103 010c 	add.w	r1, r3, #12
 800b83a:	68bb      	ldr	r3, [r7, #8]
 800b83c:	1d1a      	adds	r2, r3, #4
                                             (uint8_t) (frame->data_len - 1));
 800b83e:	68bb      	ldr	r3, [r7, #8]
 800b840:	7b1b      	ldrb	r3, [r3, #12]
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc,
                                          frame->data + 2, (uint8_t)(frame->data_len - 3));
    }
    else if (!IS_START_OF_TRANSFER(tail_byte) && !IS_END_OF_TRANSFER(tail_byte))    // Middle of a multi-frame transfer
    {
        const int ret = bufferBlockPushBytes(&ins->allocator, rx_state, frame->data,
 800b842:	3b01      	subs	r3, #1
 800b844:	b2db      	uxtb	r3, r3
 800b846:	4608      	mov	r0, r1
 800b848:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800b84a:	f000 fccd 	bl	800c1e8 <bufferBlockPushBytes>
 800b84e:	6478      	str	r0, [r7, #68]	; 0x44
                                             (uint8_t) (frame->data_len - 1));
        if (ret < 0)
 800b850:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b852:	2b00      	cmp	r3, #0
 800b854:	da0a      	bge.n	800b86c <canardHandleRxFrame+0x46c>
        {
            releaseStatePayload(ins, rx_state);
 800b856:	68f8      	ldr	r0, [r7, #12]
 800b858:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800b85a:	f000 fc9d 	bl	800c198 <releaseStatePayload>
            prepareForNextTransfer(rx_state);
 800b85e:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800b860:	f000 fb94 	bl	800bf8c <prepareForNextTransfer>
 800b864:	e0f7      	b.n	800ba56 <canardHandleRxFrame+0x656>
 800b866:	bf00      	nop
 800b868:	001e8480 	.word	0x001e8480
            return;
        }
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc,
 800b86c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b86e:	8ad9      	ldrh	r1, [r3, #22]
                                          frame->data, (uint8_t)(frame->data_len - 1));
 800b870:	68bb      	ldr	r3, [r7, #8]
 800b872:	1d1a      	adds	r2, r3, #4
 800b874:	68bb      	ldr	r3, [r7, #8]
 800b876:	7b1b      	ldrb	r3, [r3, #12]
 800b878:	3b01      	subs	r3, #1
 800b87a:	b2db      	uxtb	r3, r3
        {
            releaseStatePayload(ins, rx_state);
            prepareForNextTransfer(rx_state);
            return;
        }
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc,
 800b87c:	4608      	mov	r0, r1
 800b87e:	4611      	mov	r1, r2
 800b880:	461a      	mov	r2, r3
 800b882:	f000 ffcf 	bl	800c824 <crcAdd>
 800b886:	4603      	mov	r3, r0
 800b888:	461a      	mov	r2, r3
 800b88a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b88c:	82da      	strh	r2, [r3, #22]
 800b88e:	e0d0      	b.n	800ba32 <canardHandleRxFrame+0x632>
                                          frame->data, (uint8_t)(frame->data_len - 1));
    }
    else                                                                            // End of a multi-frame transfer
    {
        const uint8_t frame_payload_size = (uint8_t)(frame->data_len - 1);
 800b890:	68bb      	ldr	r3, [r7, #8]
 800b892:	7b1b      	ldrb	r3, [r3, #12]
 800b894:	3b01      	subs	r3, #1
 800b896:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43

        uint8_t tail_offset = 0;
 800b89a:	2300      	movs	r3, #0
 800b89c:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73

        if (rx_state->payload_len < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE)
 800b8a0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b8a2:	8b1b      	ldrh	r3, [r3, #24]
 800b8a4:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b8a8:	b29b      	uxth	r3, r3
 800b8aa:	2b05      	cmp	r3, #5
 800b8ac:	d823      	bhi.n	800b8f6 <canardHandleRxFrame+0x4f6>
        {
            // Copy the beginning of the frame into the head, point the tail pointer to the remainder
            for (size_t i = rx_state->payload_len;
 800b8ae:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b8b0:	8b1b      	ldrh	r3, [r3, #24]
 800b8b2:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b8b6:	b29b      	uxth	r3, r3
 800b8b8:	66fb      	str	r3, [r7, #108]	; 0x6c
 800b8ba:	e012      	b.n	800b8e2 <canardHandleRxFrame+0x4e2>
                 (i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) && (tail_offset < frame_payload_size);
                 i++, tail_offset++)
            {
                rx_state->buffer_head[i] = frame->data[tail_offset];
 800b8bc:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800b8c0:	68ba      	ldr	r2, [r7, #8]
 800b8c2:	4413      	add	r3, r2
 800b8c4:	7919      	ldrb	r1, [r3, #4]
 800b8c6:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800b8c8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800b8ca:	4413      	add	r3, r2
 800b8cc:	3318      	adds	r3, #24
 800b8ce:	460a      	mov	r2, r1
 800b8d0:	709a      	strb	r2, [r3, #2]
        if (rx_state->payload_len < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE)
        {
            // Copy the beginning of the frame into the head, point the tail pointer to the remainder
            for (size_t i = rx_state->payload_len;
                 (i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) && (tail_offset < frame_payload_size);
                 i++, tail_offset++)
 800b8d2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800b8d4:	3301      	adds	r3, #1
 800b8d6:	66fb      	str	r3, [r7, #108]	; 0x6c
 800b8d8:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800b8dc:	3301      	adds	r3, #1
 800b8de:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
        uint8_t tail_offset = 0;

        if (rx_state->payload_len < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE)
        {
            // Copy the beginning of the frame into the head, point the tail pointer to the remainder
            for (size_t i = rx_state->payload_len;
 800b8e2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800b8e4:	2b05      	cmp	r3, #5
 800b8e6:	d840      	bhi.n	800b96a <canardHandleRxFrame+0x56a>
                 (i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) && (tail_offset < frame_payload_size);
 800b8e8:	f897 2073 	ldrb.w	r2, [r7, #115]	; 0x73
 800b8ec:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800b8f0:	429a      	cmp	r2, r3
 800b8f2:	d3e3      	bcc.n	800b8bc <canardHandleRxFrame+0x4bc>
 800b8f4:	e039      	b.n	800b96a <canardHandleRxFrame+0x56a>
            }
        }
        else
        {
            // Like above, except that the beginning goes into the last block of the storage
            CanardBufferBlock* block = rx_state->buffer_blocks;
 800b8f6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b8f8:	685b      	ldr	r3, [r3, #4]
 800b8fa:	66bb      	str	r3, [r7, #104]	; 0x68
            if (block != NULL)          // If there's no middle, that's fine, we'll use only head and tail
 800b8fc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800b8fe:	2b00      	cmp	r3, #0
 800b900:	d033      	beq.n	800b96a <canardHandleRxFrame+0x56a>
            {
                size_t offset = CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE;    // Payload offset of the first block
 800b902:	2306      	movs	r3, #6
 800b904:	667b      	str	r3, [r7, #100]	; 0x64
 800b906:	e005      	b.n	800b914 <canardHandleRxFrame+0x514>
                while (block->next != NULL)
                {
                    block = block->next;
 800b908:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800b90a:	681b      	ldr	r3, [r3, #0]
 800b90c:	66bb      	str	r3, [r7, #104]	; 0x68
                    offset += CANARD_BUFFER_BLOCK_DATA_SIZE;
 800b90e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800b910:	331c      	adds	r3, #28
 800b912:	667b      	str	r3, [r7, #100]	; 0x64
            // Like above, except that the beginning goes into the last block of the storage
            CanardBufferBlock* block = rx_state->buffer_blocks;
            if (block != NULL)          // If there's no middle, that's fine, we'll use only head and tail
            {
                size_t offset = CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE;    // Payload offset of the first block
                while (block->next != NULL)
 800b914:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800b916:	681b      	ldr	r3, [r3, #0]
 800b918:	2b00      	cmp	r3, #0
 800b91a:	d1f5      	bne.n	800b908 <canardHandleRxFrame+0x508>
                    block = block->next;
                    offset += CANARD_BUFFER_BLOCK_DATA_SIZE;
                }
                CANARD_ASSERT(block != NULL);

                const size_t offset_within_block = rx_state->payload_len - offset;
 800b91c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b91e:	8b1b      	ldrh	r3, [r3, #24]
 800b920:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b924:	b29b      	uxth	r3, r3
 800b926:	461a      	mov	r2, r3
 800b928:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800b92a:	1ad3      	subs	r3, r2, r3
 800b92c:	63fb      	str	r3, [r7, #60]	; 0x3c
                CANARD_ASSERT(offset_within_block < CANARD_BUFFER_BLOCK_DATA_SIZE);

                for (size_t i = offset_within_block;
 800b92e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b930:	663b      	str	r3, [r7, #96]	; 0x60
 800b932:	e011      	b.n	800b958 <canardHandleRxFrame+0x558>
                     (i < CANARD_BUFFER_BLOCK_DATA_SIZE) && (tail_offset < frame_payload_size);
                     i++, tail_offset++)
                {
                    block->data[i] = frame->data[tail_offset];
 800b934:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800b938:	68ba      	ldr	r2, [r7, #8]
 800b93a:	4413      	add	r3, r2
 800b93c:	7919      	ldrb	r1, [r3, #4]
 800b93e:	6eba      	ldr	r2, [r7, #104]	; 0x68
 800b940:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800b942:	4413      	add	r3, r2
 800b944:	460a      	mov	r2, r1
 800b946:	711a      	strb	r2, [r3, #4]
                const size_t offset_within_block = rx_state->payload_len - offset;
                CANARD_ASSERT(offset_within_block < CANARD_BUFFER_BLOCK_DATA_SIZE);

                for (size_t i = offset_within_block;
                     (i < CANARD_BUFFER_BLOCK_DATA_SIZE) && (tail_offset < frame_payload_size);
                     i++, tail_offset++)
 800b948:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800b94a:	3301      	adds	r3, #1
 800b94c:	663b      	str	r3, [r7, #96]	; 0x60
 800b94e:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800b952:	3301      	adds	r3, #1
 800b954:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
                CANARD_ASSERT(block != NULL);

                const size_t offset_within_block = rx_state->payload_len - offset;
                CANARD_ASSERT(offset_within_block < CANARD_BUFFER_BLOCK_DATA_SIZE);

                for (size_t i = offset_within_block;
 800b958:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800b95a:	2b1b      	cmp	r3, #27
 800b95c:	d805      	bhi.n	800b96a <canardHandleRxFrame+0x56a>
                     (i < CANARD_BUFFER_BLOCK_DATA_SIZE) && (tail_offset < frame_payload_size);
 800b95e:	f897 2073 	ldrb.w	r2, [r7, #115]	; 0x73
 800b962:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800b966:	429a      	cmp	r2, r3
 800b968:	d3e4      	bcc.n	800b934 <canardHandleRxFrame+0x534>
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
 800b96a:	e9d7 2300 	ldrd	r2, r3, [r7]
 800b96e:	e9c7 2304 	strd	r2, r3, [r7, #16]
            .timestamp_usec = timestamp_usec,
            .payload_head = rx_state->buffer_head,
 800b972:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b974:	331a      	adds	r3, #26
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
 800b976:	61bb      	str	r3, [r7, #24]
            .timestamp_usec = timestamp_usec,
            .payload_head = rx_state->buffer_head,
            .payload_middle = rx_state->buffer_blocks,
 800b978:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b97a:	685b      	ldr	r3, [r3, #4]
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
 800b97c:	61fb      	str	r3, [r7, #28]
            .timestamp_usec = timestamp_usec,
            .payload_head = rx_state->buffer_head,
            .payload_middle = rx_state->buffer_blocks,
            .payload_tail = (tail_offset >= frame_payload_size) ? NULL : (&frame->data[tail_offset]),
 800b97e:	f897 2073 	ldrb.w	r2, [r7, #115]	; 0x73
 800b982:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800b986:	429a      	cmp	r2, r3
 800b988:	d205      	bcs.n	800b996 <canardHandleRxFrame+0x596>
 800b98a:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800b98e:	68ba      	ldr	r2, [r7, #8]
 800b990:	4413      	add	r3, r2
 800b992:	3304      	adds	r3, #4
 800b994:	e000      	b.n	800b998 <canardHandleRxFrame+0x598>
 800b996:	2300      	movs	r3, #0
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
 800b998:	623b      	str	r3, [r7, #32]
            .timestamp_usec = timestamp_usec,
            .payload_head = rx_state->buffer_head,
            .payload_middle = rx_state->buffer_blocks,
            .payload_tail = (tail_offset >= frame_payload_size) ? NULL : (&frame->data[tail_offset]),
            .payload_len = (uint16_t)(rx_state->payload_len + frame_payload_size),
 800b99a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b99c:	8b1b      	ldrh	r3, [r3, #24]
 800b99e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b9a2:	b29b      	uxth	r3, r3
 800b9a4:	461a      	mov	r2, r3
 800b9a6:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800b9aa:	b29b      	uxth	r3, r3
 800b9ac:	4413      	add	r3, r2
 800b9ae:	b29b      	uxth	r3, r3
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
 800b9b0:	84bb      	strh	r3, [r7, #36]	; 0x24
 800b9b2:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 800b9b6:	84fb      	strh	r3, [r7, #38]	; 0x26
 800b9b8:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800b9bc:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
            .payload_middle = rx_state->buffer_blocks,
            .payload_tail = (tail_offset >= frame_payload_size) ? NULL : (&frame->data[tail_offset]),
            .payload_len = (uint16_t)(rx_state->payload_len + frame_payload_size),
            .data_type_id = data_type_id,
            .transfer_type = transfer_type,
            .transfer_id = TRANSFER_ID_FROM_TAIL_BYTE(tail_byte),
 800b9c0:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800b9c4:	f003 031f 	and.w	r3, r3, #31
 800b9c8:	b2db      	uxtb	r3, r3
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
 800b9ca:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
 800b9ce:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 800b9d2:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
 800b9d6:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 800b9da:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
            .transfer_id = TRANSFER_ID_FROM_TAIL_BYTE(tail_byte),
            .priority = priority,
            .source_node_id = source_node_id
        };

        rx_state->buffer_blocks = NULL;     // Block list ownership has been transferred to rx_transfer!
 800b9de:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b9e0:	2200      	movs	r2, #0
 800b9e2:	605a      	str	r2, [r3, #4]

        // CRC validation
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc, frame->data, frame->data_len - 1U);
 800b9e4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b9e6:	8ad9      	ldrh	r1, [r3, #22]
 800b9e8:	68bb      	ldr	r3, [r7, #8]
 800b9ea:	1d1a      	adds	r2, r3, #4
 800b9ec:	68bb      	ldr	r3, [r7, #8]
 800b9ee:	7b1b      	ldrb	r3, [r3, #12]
 800b9f0:	3b01      	subs	r3, #1
 800b9f2:	4608      	mov	r0, r1
 800b9f4:	4611      	mov	r1, r2
 800b9f6:	461a      	mov	r2, r3
 800b9f8:	f000 ff14 	bl	800c824 <crcAdd>
 800b9fc:	4603      	mov	r3, r0
 800b9fe:	461a      	mov	r2, r3
 800ba00:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ba02:	82da      	strh	r2, [r3, #22]
        if (rx_state->calculated_crc == rx_state->payload_crc)
 800ba04:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ba06:	8ada      	ldrh	r2, [r3, #22]
 800ba08:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ba0a:	8a9b      	ldrh	r3, [r3, #20]
 800ba0c:	429a      	cmp	r2, r3
 800ba0e:	d106      	bne.n	800ba1e <canardHandleRxFrame+0x61e>
        {
            ins->on_reception(ins, &rx_transfer);
 800ba10:	68fb      	ldr	r3, [r7, #12]
 800ba12:	689b      	ldr	r3, [r3, #8]
 800ba14:	f107 0210 	add.w	r2, r7, #16
 800ba18:	68f8      	ldr	r0, [r7, #12]
 800ba1a:	4611      	mov	r1, r2
 800ba1c:	4798      	blx	r3
        }

        // Making sure the payload is released even if the application didn't bother with it
        canardReleaseRxTransferPayload(ins, &rx_transfer);
 800ba1e:	f107 0310 	add.w	r3, r7, #16
 800ba22:	68f8      	ldr	r0, [r7, #12]
 800ba24:	4619      	mov	r1, r3
 800ba26:	f000 fa6d 	bl	800bf04 <canardReleaseRxTransferPayload>
        prepareForNextTransfer(rx_state);
 800ba2a:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800ba2c:	f000 faae 	bl	800bf8c <prepareForNextTransfer>
 800ba30:	e011      	b.n	800ba56 <canardHandleRxFrame+0x656>
        return;
    }

    rx_state->next_toggle ^= 1;
 800ba32:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ba34:	7e5b      	ldrb	r3, [r3, #25]
 800ba36:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800ba3a:	b2db      	uxtb	r3, r3
 800ba3c:	f083 0301 	eor.w	r3, r3, #1
 800ba40:	b2db      	uxtb	r3, r3
 800ba42:	f003 0301 	and.w	r3, r3, #1
 800ba46:	b2d9      	uxtb	r1, r3
 800ba48:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800ba4a:	7e53      	ldrb	r3, [r2, #25]
 800ba4c:	f361 13c7 	bfi	r3, r1, #7, #1
 800ba50:	7653      	strb	r3, [r2, #25]
 800ba52:	e000      	b.n	800ba56 <canardHandleRxFrame+0x656>
        {
            rx_state = traverseRxStates(ins, transfer_descriptor);

            if(rx_state == NULL)
            {
                return; // No allocator room for this frame
 800ba54:	bf00      	nop
        prepareForNextTransfer(rx_state);
        return;
    }

    rx_state->next_toggle ^= 1;
}
 800ba56:	3778      	adds	r7, #120	; 0x78
 800ba58:	46bd      	mov	sp, r7
 800ba5a:	bdb0      	pop	{r4, r5, r7, pc}

0800ba5c <canardCleanupStaleTransfers>:

void canardCleanupStaleTransfers(CanardInstance* ins, uint64_t current_time_usec)
{
 800ba5c:	b580      	push	{r7, lr}
 800ba5e:	b086      	sub	sp, #24
 800ba60:	af00      	add	r7, sp, #0
 800ba62:	60f8      	str	r0, [r7, #12]
 800ba64:	e9c7 2300 	strd	r2, r3, [r7]
    CanardRxState* prev = ins->rx_states, * state = ins->rx_states;
 800ba68:	68fb      	ldr	r3, [r7, #12]
 800ba6a:	699b      	ldr	r3, [r3, #24]
 800ba6c:	617b      	str	r3, [r7, #20]
 800ba6e:	68fb      	ldr	r3, [r7, #12]
 800ba70:	699b      	ldr	r3, [r3, #24]
 800ba72:	613b      	str	r3, [r7, #16]
 800ba74:	e03f      	b.n	800baf6 <canardCleanupStaleTransfers+0x9a>

    while (state != NULL)
    {
        if ((current_time_usec - state->timestamp_usec) > TRANSFER_TIMEOUT_USEC)
 800ba76:	693b      	ldr	r3, [r7, #16]
 800ba78:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800ba7c:	e9d7 0100 	ldrd	r0, r1, [r7]
 800ba80:	1a82      	subs	r2, r0, r2
 800ba82:	eb61 0303 	sbc.w	r3, r1, r3
 800ba86:	481f      	ldr	r0, [pc, #124]	; (800bb04 <canardCleanupStaleTransfers+0xa8>)
 800ba88:	f04f 0100 	mov.w	r1, #0
 800ba8c:	4299      	cmp	r1, r3
 800ba8e:	bf08      	it	eq
 800ba90:	4290      	cmpeq	r0, r2
 800ba92:	d22b      	bcs.n	800baec <canardCleanupStaleTransfers+0x90>
        {
            if (state == ins->rx_states)
 800ba94:	68fb      	ldr	r3, [r7, #12]
 800ba96:	699a      	ldr	r2, [r3, #24]
 800ba98:	693b      	ldr	r3, [r7, #16]
 800ba9a:	429a      	cmp	r2, r3
 800ba9c:	d114      	bne.n	800bac8 <canardCleanupStaleTransfers+0x6c>
            {
                releaseStatePayload(ins, state);
 800ba9e:	68f8      	ldr	r0, [r7, #12]
 800baa0:	6939      	ldr	r1, [r7, #16]
 800baa2:	f000 fb79 	bl	800c198 <releaseStatePayload>
                ins->rx_states = ins->rx_states->next;
 800baa6:	68fb      	ldr	r3, [r7, #12]
 800baa8:	699b      	ldr	r3, [r3, #24]
 800baaa:	681a      	ldr	r2, [r3, #0]
 800baac:	68fb      	ldr	r3, [r7, #12]
 800baae:	619a      	str	r2, [r3, #24]
                freeBlock(&ins->allocator, state);
 800bab0:	68fb      	ldr	r3, [r7, #12]
 800bab2:	330c      	adds	r3, #12
 800bab4:	4618      	mov	r0, r3
 800bab6:	6939      	ldr	r1, [r7, #16]
 800bab8:	f000 ff2a 	bl	800c910 <freeBlock>
                state = ins->rx_states;
 800babc:	68fb      	ldr	r3, [r7, #12]
 800babe:	699b      	ldr	r3, [r3, #24]
 800bac0:	613b      	str	r3, [r7, #16]
                prev = state;
 800bac2:	693b      	ldr	r3, [r7, #16]
 800bac4:	617b      	str	r3, [r7, #20]
            else
            {
                releaseStatePayload(ins, state);
                prev->next = state->next;
                freeBlock(&ins->allocator, state);
                state = prev->next;
 800bac6:	e016      	b.n	800baf6 <canardCleanupStaleTransfers+0x9a>
                state = ins->rx_states;
                prev = state;
            }
            else
            {
                releaseStatePayload(ins, state);
 800bac8:	68f8      	ldr	r0, [r7, #12]
 800baca:	6939      	ldr	r1, [r7, #16]
 800bacc:	f000 fb64 	bl	800c198 <releaseStatePayload>
                prev->next = state->next;
 800bad0:	693b      	ldr	r3, [r7, #16]
 800bad2:	681a      	ldr	r2, [r3, #0]
 800bad4:	697b      	ldr	r3, [r7, #20]
 800bad6:	601a      	str	r2, [r3, #0]
                freeBlock(&ins->allocator, state);
 800bad8:	68fb      	ldr	r3, [r7, #12]
 800bada:	330c      	adds	r3, #12
 800badc:	4618      	mov	r0, r3
 800bade:	6939      	ldr	r1, [r7, #16]
 800bae0:	f000 ff16 	bl	800c910 <freeBlock>
                state = prev->next;
 800bae4:	697b      	ldr	r3, [r7, #20]
 800bae6:	681b      	ldr	r3, [r3, #0]
 800bae8:	613b      	str	r3, [r7, #16]
 800baea:	e004      	b.n	800baf6 <canardCleanupStaleTransfers+0x9a>
            }
        }
        else
        {
            prev = state;
 800baec:	693b      	ldr	r3, [r7, #16]
 800baee:	617b      	str	r3, [r7, #20]
            state = state->next;
 800baf0:	693b      	ldr	r3, [r7, #16]
 800baf2:	681b      	ldr	r3, [r3, #0]
 800baf4:	613b      	str	r3, [r7, #16]

void canardCleanupStaleTransfers(CanardInstance* ins, uint64_t current_time_usec)
{
    CanardRxState* prev = ins->rx_states, * state = ins->rx_states;

    while (state != NULL)
 800baf6:	693b      	ldr	r3, [r7, #16]
 800baf8:	2b00      	cmp	r3, #0
 800bafa:	d1bc      	bne.n	800ba76 <canardCleanupStaleTransfers+0x1a>
        {
            prev = state;
            state = state->next;
        }
    }
}
 800bafc:	3718      	adds	r7, #24
 800bafe:	46bd      	mov	sp, r7
 800bb00:	bd80      	pop	{r7, pc}
 800bb02:	bf00      	nop
 800bb04:	001e8480 	.word	0x001e8480

0800bb08 <canardDecodeScalar>:
int canardDecodeScalar(const CanardRxTransfer* transfer,
                       uint32_t bit_offset,
                       uint8_t bit_length,
                       bool value_is_signed,
                       void* out_value)
{
 800bb08:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800bb0c:	b089      	sub	sp, #36	; 0x24
 800bb0e:	af00      	add	r7, sp, #0
 800bb10:	60f8      	str	r0, [r7, #12]
 800bb12:	60b9      	str	r1, [r7, #8]
 800bb14:	4611      	mov	r1, r2
 800bb16:	461a      	mov	r2, r3
 800bb18:	460b      	mov	r3, r1
 800bb1a:	71fb      	strb	r3, [r7, #7]
 800bb1c:	4613      	mov	r3, r2
 800bb1e:	71bb      	strb	r3, [r7, #6]
    if (transfer == NULL || out_value == NULL)
 800bb20:	68fb      	ldr	r3, [r7, #12]
 800bb22:	2b00      	cmp	r3, #0
 800bb24:	d002      	beq.n	800bb2c <canardDecodeScalar+0x24>
 800bb26:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800bb28:	2b00      	cmp	r3, #0
 800bb2a:	d102      	bne.n	800bb32 <canardDecodeScalar+0x2a>
    {
        return -CANARD_ERROR_INVALID_ARGUMENT;
 800bb2c:	f06f 0301 	mvn.w	r3, #1
 800bb30:	e15d      	b.n	800bdee <canardDecodeScalar+0x2e6>
    }

    if (bit_length < 1 || bit_length > 64)
 800bb32:	79fb      	ldrb	r3, [r7, #7]
 800bb34:	2b00      	cmp	r3, #0
 800bb36:	d002      	beq.n	800bb3e <canardDecodeScalar+0x36>
 800bb38:	79fb      	ldrb	r3, [r7, #7]
 800bb3a:	2b40      	cmp	r3, #64	; 0x40
 800bb3c:	d902      	bls.n	800bb44 <canardDecodeScalar+0x3c>
    {
        return -CANARD_ERROR_INVALID_ARGUMENT;
 800bb3e:	f06f 0301 	mvn.w	r3, #1
 800bb42:	e154      	b.n	800bdee <canardDecodeScalar+0x2e6>
    }

    if (bit_length == 1 && value_is_signed)
 800bb44:	79fb      	ldrb	r3, [r7, #7]
 800bb46:	2b01      	cmp	r3, #1
 800bb48:	d105      	bne.n	800bb56 <canardDecodeScalar+0x4e>
 800bb4a:	79bb      	ldrb	r3, [r7, #6]
 800bb4c:	2b00      	cmp	r3, #0
 800bb4e:	d002      	beq.n	800bb56 <canardDecodeScalar+0x4e>
    {
        return -CANARD_ERROR_INVALID_ARGUMENT;
 800bb50:	f06f 0301 	mvn.w	r3, #1
 800bb54:	e14b      	b.n	800bdee <canardDecodeScalar+0x2e6>
        uint64_t u64;
        int64_t  s64;           ///< Also double, possibly float, possibly long double (depends on implementation)
        uint8_t bytes[8];
    } storage;

    memset(&storage, 0, sizeof(storage));   // This is important
 800bb56:	f107 0310 	add.w	r3, r7, #16
 800bb5a:	4618      	mov	r0, r3
 800bb5c:	2100      	movs	r1, #0
 800bb5e:	2208      	movs	r2, #8
 800bb60:	f001 f86c 	bl	800cc3c <memset>

    const int result = descatterTransferPayload(transfer, bit_offset, bit_length, &storage.bytes[0]);
 800bb64:	79fa      	ldrb	r2, [r7, #7]
 800bb66:	f107 0310 	add.w	r3, r7, #16
 800bb6a:	68f8      	ldr	r0, [r7, #12]
 800bb6c:	68b9      	ldr	r1, [r7, #8]
 800bb6e:	f000 fcc9 	bl	800c504 <descatterTransferPayload>
 800bb72:	61b8      	str	r0, [r7, #24]
    if (result <= 0)
 800bb74:	69bb      	ldr	r3, [r7, #24]
 800bb76:	2b00      	cmp	r3, #0
 800bb78:	dc01      	bgt.n	800bb7e <canardDecodeScalar+0x76>
    {
        return result;
 800bb7a:	69bb      	ldr	r3, [r7, #24]
 800bb7c:	e137      	b.n	800bdee <canardDecodeScalar+0x2e6>
     * The bit copy algorithm assumes that more significant bits have lower index, so we need to shift some.
     * Extra most significant bits will be filled with zeroes, which is fine.
     * Coverity Scan mistakenly believes that the array may be overrun if bit_length == 64; however, this branch will
     * not be taken if bit_length == 64, because 64 % 8 == 0.
     */
    if ((bit_length % 8) != 0)
 800bb7e:	79fb      	ldrb	r3, [r7, #7]
 800bb80:	f003 0307 	and.w	r3, r3, #7
 800bb84:	b2db      	uxtb	r3, r3
 800bb86:	2b00      	cmp	r3, #0
 800bb88:	d018      	beq.n	800bbbc <canardDecodeScalar+0xb4>
    {
        // coverity[overrun-local]
        storage.bytes[bit_length / 8] = (uint8_t)(storage.bytes[bit_length / 8] >> ((8 - (bit_length % 8)) & 7));
 800bb8a:	79fb      	ldrb	r3, [r7, #7]
 800bb8c:	08db      	lsrs	r3, r3, #3
 800bb8e:	b2db      	uxtb	r3, r3
 800bb90:	4619      	mov	r1, r3
 800bb92:	79fb      	ldrb	r3, [r7, #7]
 800bb94:	08db      	lsrs	r3, r3, #3
 800bb96:	b2db      	uxtb	r3, r3
 800bb98:	f107 0220 	add.w	r2, r7, #32
 800bb9c:	4413      	add	r3, r2
 800bb9e:	f813 3c10 	ldrb.w	r3, [r3, #-16]
 800bba2:	461a      	mov	r2, r3
 800bba4:	79fb      	ldrb	r3, [r7, #7]
 800bba6:	425b      	negs	r3, r3
 800bba8:	f003 0307 	and.w	r3, r3, #7
 800bbac:	fa42 f303 	asr.w	r3, r2, r3
 800bbb0:	b2da      	uxtb	r2, r3
 800bbb2:	f107 0320 	add.w	r3, r7, #32
 800bbb6:	440b      	add	r3, r1
 800bbb8:	f803 2c10 	strb.w	r2, [r3, #-16]
    }

    /*
     * Determining the closest standard byte length - this will be needed for byte reordering and sign bit extension.
     */
    uint8_t std_byte_length = 0;
 800bbbc:	2300      	movs	r3, #0
 800bbbe:	77fb      	strb	r3, [r7, #31]
    if      (bit_length == 1)   { std_byte_length = sizeof(bool); }
 800bbc0:	79fb      	ldrb	r3, [r7, #7]
 800bbc2:	2b01      	cmp	r3, #1
 800bbc4:	d102      	bne.n	800bbcc <canardDecodeScalar+0xc4>
 800bbc6:	2301      	movs	r3, #1
 800bbc8:	77fb      	strb	r3, [r7, #31]
 800bbca:	e01a      	b.n	800bc02 <canardDecodeScalar+0xfa>
    else if (bit_length <= 8)   { std_byte_length = 1; }
 800bbcc:	79fb      	ldrb	r3, [r7, #7]
 800bbce:	2b08      	cmp	r3, #8
 800bbd0:	d802      	bhi.n	800bbd8 <canardDecodeScalar+0xd0>
 800bbd2:	2301      	movs	r3, #1
 800bbd4:	77fb      	strb	r3, [r7, #31]
 800bbd6:	e014      	b.n	800bc02 <canardDecodeScalar+0xfa>
    else if (bit_length <= 16)  { std_byte_length = 2; }
 800bbd8:	79fb      	ldrb	r3, [r7, #7]
 800bbda:	2b10      	cmp	r3, #16
 800bbdc:	d802      	bhi.n	800bbe4 <canardDecodeScalar+0xdc>
 800bbde:	2302      	movs	r3, #2
 800bbe0:	77fb      	strb	r3, [r7, #31]
 800bbe2:	e00e      	b.n	800bc02 <canardDecodeScalar+0xfa>
    else if (bit_length <= 32)  { std_byte_length = 4; }
 800bbe4:	79fb      	ldrb	r3, [r7, #7]
 800bbe6:	2b20      	cmp	r3, #32
 800bbe8:	d802      	bhi.n	800bbf0 <canardDecodeScalar+0xe8>
 800bbea:	2304      	movs	r3, #4
 800bbec:	77fb      	strb	r3, [r7, #31]
 800bbee:	e008      	b.n	800bc02 <canardDecodeScalar+0xfa>
    else if (bit_length <= 64)  { std_byte_length = 8; }
 800bbf0:	79fb      	ldrb	r3, [r7, #7]
 800bbf2:	2b40      	cmp	r3, #64	; 0x40
 800bbf4:	d802      	bhi.n	800bbfc <canardDecodeScalar+0xf4>
 800bbf6:	2308      	movs	r3, #8
 800bbf8:	77fb      	strb	r3, [r7, #31]
 800bbfa:	e002      	b.n	800bc02 <canardDecodeScalar+0xfa>
    else
    {
        CANARD_ASSERT(false);
        return -CANARD_ERROR_INTERNAL;
 800bbfc:	f06f 0308 	mvn.w	r3, #8
 800bc00:	e0f5      	b.n	800bdee <canardDecodeScalar+0x2e6>
    CANARD_ASSERT((std_byte_length > 0) && (std_byte_length <= 8));

    /*
     * Flipping the byte order if needed.
     */
    if (isBigEndian())
 800bc02:	f000 fd6f 	bl	800c6e4 <isBigEndian>
 800bc06:	4603      	mov	r3, r0
 800bc08:	2b00      	cmp	r3, #0
 800bc0a:	d006      	beq.n	800bc1a <canardDecodeScalar+0x112>
    {
        swapByteOrder(&storage.bytes[0], std_byte_length);
 800bc0c:	7ffb      	ldrb	r3, [r7, #31]
 800bc0e:	f107 0210 	add.w	r2, r7, #16
 800bc12:	4610      	mov	r0, r2
 800bc14:	4619      	mov	r1, r3
 800bc16:	f000 fd77 	bl	800c708 <swapByteOrder>
    }

    /*
     * Extending the sign bit if needed. I miss templates.
     */
    if (value_is_signed && (std_byte_length * 8 != bit_length))
 800bc1a:	79bb      	ldrb	r3, [r7, #6]
 800bc1c:	2b00      	cmp	r3, #0
 800bc1e:	f000 8099 	beq.w	800bd54 <canardDecodeScalar+0x24c>
 800bc22:	7ffb      	ldrb	r3, [r7, #31]
 800bc24:	00da      	lsls	r2, r3, #3
 800bc26:	79fb      	ldrb	r3, [r7, #7]
 800bc28:	429a      	cmp	r2, r3
 800bc2a:	f000 8093 	beq.w	800bd54 <canardDecodeScalar+0x24c>
    {
        if (bit_length <= 8)
 800bc2e:	79fb      	ldrb	r3, [r7, #7]
 800bc30:	2b08      	cmp	r3, #8
 800bc32:	d818      	bhi.n	800bc66 <canardDecodeScalar+0x15e>
        {
            if ((storage.s8 & (1U << (bit_length - 1))) != 0)                           // If the sign bit is set...
 800bc34:	7c3b      	ldrb	r3, [r7, #16]
 800bc36:	b25a      	sxtb	r2, r3
 800bc38:	79fb      	ldrb	r3, [r7, #7]
 800bc3a:	3b01      	subs	r3, #1
 800bc3c:	fa22 f303 	lsr.w	r3, r2, r3
 800bc40:	f003 0301 	and.w	r3, r3, #1
 800bc44:	2b00      	cmp	r3, #0
 800bc46:	f000 8085 	beq.w	800bd54 <canardDecodeScalar+0x24c>
            {
                storage.s8 |= (uint8_t) 0xFFU & (uint8_t) ~((1U << bit_length) - 1U);   // ...set all bits above it.
 800bc4a:	7c39      	ldrb	r1, [r7, #16]
 800bc4c:	79fb      	ldrb	r3, [r7, #7]
 800bc4e:	2201      	movs	r2, #1
 800bc50:	fa02 f303 	lsl.w	r3, r2, r3
 800bc54:	b2db      	uxtb	r3, r3
 800bc56:	425b      	negs	r3, r3
 800bc58:	b2db      	uxtb	r3, r3
 800bc5a:	b2db      	uxtb	r3, r3
 800bc5c:	460a      	mov	r2, r1
 800bc5e:	4313      	orrs	r3, r2
 800bc60:	b2db      	uxtb	r3, r3
 800bc62:	743b      	strb	r3, [r7, #16]
 800bc64:	e076      	b.n	800bd54 <canardDecodeScalar+0x24c>
            }
        }
        else if (bit_length <= 16)
 800bc66:	79fb      	ldrb	r3, [r7, #7]
 800bc68:	2b10      	cmp	r3, #16
 800bc6a:	d817      	bhi.n	800bc9c <canardDecodeScalar+0x194>
        {
            if ((storage.s16 & (1U << (bit_length - 1))) != 0)
 800bc6c:	8a3b      	ldrh	r3, [r7, #16]
 800bc6e:	b21a      	sxth	r2, r3
 800bc70:	79fb      	ldrb	r3, [r7, #7]
 800bc72:	3b01      	subs	r3, #1
 800bc74:	fa22 f303 	lsr.w	r3, r2, r3
 800bc78:	f003 0301 	and.w	r3, r3, #1
 800bc7c:	2b00      	cmp	r3, #0
 800bc7e:	d069      	beq.n	800bd54 <canardDecodeScalar+0x24c>
            {
                storage.s16 |= (uint16_t) 0xFFFFU & (uint16_t) ~((1U << bit_length) - 1U);
 800bc80:	8a39      	ldrh	r1, [r7, #16]
 800bc82:	79fb      	ldrb	r3, [r7, #7]
 800bc84:	2201      	movs	r2, #1
 800bc86:	fa02 f303 	lsl.w	r3, r2, r3
 800bc8a:	b29b      	uxth	r3, r3
 800bc8c:	425b      	negs	r3, r3
 800bc8e:	b29b      	uxth	r3, r3
 800bc90:	b29b      	uxth	r3, r3
 800bc92:	460a      	mov	r2, r1
 800bc94:	4313      	orrs	r3, r2
 800bc96:	b29b      	uxth	r3, r3
 800bc98:	823b      	strh	r3, [r7, #16]
 800bc9a:	e05b      	b.n	800bd54 <canardDecodeScalar+0x24c>
            }
        }
        else if (bit_length <= 32)
 800bc9c:	79fb      	ldrb	r3, [r7, #7]
 800bc9e:	2b20      	cmp	r3, #32
 800bca0:	d813      	bhi.n	800bcca <canardDecodeScalar+0x1c2>
        {
            if ((storage.s32 & (((uint32_t) 1) << (bit_length - 1))) != 0)
 800bca2:	693b      	ldr	r3, [r7, #16]
 800bca4:	461a      	mov	r2, r3
 800bca6:	79fb      	ldrb	r3, [r7, #7]
 800bca8:	3b01      	subs	r3, #1
 800bcaa:	fa22 f303 	lsr.w	r3, r2, r3
 800bcae:	f003 0301 	and.w	r3, r3, #1
 800bcb2:	2b00      	cmp	r3, #0
 800bcb4:	d04e      	beq.n	800bd54 <canardDecodeScalar+0x24c>
            {
                storage.s32 |= (uint32_t) 0xFFFFFFFFUL & (uint32_t) ~((((uint32_t) 1) << bit_length) - 1U);
 800bcb6:	693b      	ldr	r3, [r7, #16]
 800bcb8:	4619      	mov	r1, r3
 800bcba:	79fb      	ldrb	r3, [r7, #7]
 800bcbc:	2201      	movs	r2, #1
 800bcbe:	fa02 f303 	lsl.w	r3, r2, r3
 800bcc2:	425b      	negs	r3, r3
 800bcc4:	430b      	orrs	r3, r1
 800bcc6:	613b      	str	r3, [r7, #16]
 800bcc8:	e044      	b.n	800bd54 <canardDecodeScalar+0x24c>
            }
        }
        else if (bit_length < 64)   // Strictly less, this is not a typo
 800bcca:	79fb      	ldrb	r3, [r7, #7]
 800bccc:	2b3f      	cmp	r3, #63	; 0x3f
 800bcce:	d83e      	bhi.n	800bd4e <canardDecodeScalar+0x246>
        {
            if ((storage.s64 & (((uint64_t) 1) << (bit_length - 1))) != 0)
 800bcd0:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800bcd4:	79f9      	ldrb	r1, [r7, #7]
 800bcd6:	3901      	subs	r1, #1
 800bcd8:	f1c1 0620 	rsb	r6, r1, #32
 800bcdc:	f1a1 0020 	sub.w	r0, r1, #32
 800bce0:	fa22 f801 	lsr.w	r8, r2, r1
 800bce4:	fa03 f606 	lsl.w	r6, r3, r6
 800bce8:	ea48 0806 	orr.w	r8, r8, r6
 800bcec:	fa23 f000 	lsr.w	r0, r3, r0
 800bcf0:	ea48 0800 	orr.w	r8, r8, r0
 800bcf4:	fa23 f901 	lsr.w	r9, r3, r1
 800bcf8:	f04f 0201 	mov.w	r2, #1
 800bcfc:	f04f 0300 	mov.w	r3, #0
 800bd00:	ea02 0208 	and.w	r2, r2, r8
 800bd04:	ea03 0309 	and.w	r3, r3, r9
 800bd08:	4313      	orrs	r3, r2
 800bd0a:	d023      	beq.n	800bd54 <canardDecodeScalar+0x24c>
            {
                storage.s64 |= (uint64_t) 0xFFFFFFFFFFFFFFFFULL & (uint64_t) ~((((uint64_t) 1) << bit_length) - 1U);
 800bd0c:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800bd10:	4690      	mov	r8, r2
 800bd12:	4699      	mov	r9, r3
 800bd14:	79f9      	ldrb	r1, [r7, #7]
 800bd16:	f04f 0201 	mov.w	r2, #1
 800bd1a:	f04f 0300 	mov.w	r3, #0
 800bd1e:	f1a1 0620 	sub.w	r6, r1, #32
 800bd22:	f1c1 0020 	rsb	r0, r1, #32
 800bd26:	fa03 f501 	lsl.w	r5, r3, r1
 800bd2a:	fa02 f606 	lsl.w	r6, r2, r6
 800bd2e:	4335      	orrs	r5, r6
 800bd30:	fa22 f000 	lsr.w	r0, r2, r0
 800bd34:	4305      	orrs	r5, r0
 800bd36:	fa02 f401 	lsl.w	r4, r2, r1
 800bd3a:	4262      	negs	r2, r4
 800bd3c:	eb65 0345 	sbc.w	r3, r5, r5, lsl #1
 800bd40:	ea42 0208 	orr.w	r2, r2, r8
 800bd44:	ea43 0309 	orr.w	r3, r3, r9
 800bd48:	e9c7 2304 	strd	r2, r3, [r7, #16]
 800bd4c:	e002      	b.n	800bd54 <canardDecodeScalar+0x24c>
            }
        }
        else
        {
            CANARD_ASSERT(false);
            return -CANARD_ERROR_INTERNAL;
 800bd4e:	f06f 0308 	mvn.w	r3, #8
 800bd52:	e04c      	b.n	800bdee <canardDecodeScalar+0x2e6>
    }

    /*
     * Copying the result out.
     */
    if (value_is_signed)
 800bd54:	79bb      	ldrb	r3, [r7, #6]
 800bd56:	2b00      	cmp	r3, #0
 800bd58:	d020      	beq.n	800bd9c <canardDecodeScalar+0x294>
    {
        if      (bit_length <= 8)   { *( (int8_t*) out_value) = storage.s8;  }
 800bd5a:	79fb      	ldrb	r3, [r7, #7]
 800bd5c:	2b08      	cmp	r3, #8
 800bd5e:	d803      	bhi.n	800bd68 <canardDecodeScalar+0x260>
 800bd60:	7c3a      	ldrb	r2, [r7, #16]
 800bd62:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800bd64:	701a      	strb	r2, [r3, #0]
 800bd66:	e041      	b.n	800bdec <canardDecodeScalar+0x2e4>
        else if (bit_length <= 16)  { *((int16_t*) out_value) = storage.s16; }
 800bd68:	79fb      	ldrb	r3, [r7, #7]
 800bd6a:	2b10      	cmp	r3, #16
 800bd6c:	d803      	bhi.n	800bd76 <canardDecodeScalar+0x26e>
 800bd6e:	8a3a      	ldrh	r2, [r7, #16]
 800bd70:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800bd72:	801a      	strh	r2, [r3, #0]
 800bd74:	e03a      	b.n	800bdec <canardDecodeScalar+0x2e4>
        else if (bit_length <= 32)  { *((int32_t*) out_value) = storage.s32; }
 800bd76:	79fb      	ldrb	r3, [r7, #7]
 800bd78:	2b20      	cmp	r3, #32
 800bd7a:	d803      	bhi.n	800bd84 <canardDecodeScalar+0x27c>
 800bd7c:	693a      	ldr	r2, [r7, #16]
 800bd7e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800bd80:	601a      	str	r2, [r3, #0]
 800bd82:	e033      	b.n	800bdec <canardDecodeScalar+0x2e4>
        else if (bit_length <= 64)  { *((int64_t*) out_value) = storage.s64; }
 800bd84:	79fb      	ldrb	r3, [r7, #7]
 800bd86:	2b40      	cmp	r3, #64	; 0x40
 800bd88:	d805      	bhi.n	800bd96 <canardDecodeScalar+0x28e>
 800bd8a:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800bd8e:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800bd90:	e9c1 2300 	strd	r2, r3, [r1]
 800bd94:	e02a      	b.n	800bdec <canardDecodeScalar+0x2e4>
        else
        {
            CANARD_ASSERT(false);
            return -CANARD_ERROR_INTERNAL;
 800bd96:	f06f 0308 	mvn.w	r3, #8
 800bd9a:	e028      	b.n	800bdee <canardDecodeScalar+0x2e6>
        }
    }
    else
    {
        if      (bit_length == 1)   { *(    (bool*) out_value) = storage.boolean; }
 800bd9c:	79fb      	ldrb	r3, [r7, #7]
 800bd9e:	2b01      	cmp	r3, #1
 800bda0:	d103      	bne.n	800bdaa <canardDecodeScalar+0x2a2>
 800bda2:	7c3a      	ldrb	r2, [r7, #16]
 800bda4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800bda6:	701a      	strb	r2, [r3, #0]
 800bda8:	e020      	b.n	800bdec <canardDecodeScalar+0x2e4>
        else if (bit_length <= 8)   { *( (uint8_t*) out_value) = storage.u8;  }
 800bdaa:	79fb      	ldrb	r3, [r7, #7]
 800bdac:	2b08      	cmp	r3, #8
 800bdae:	d803      	bhi.n	800bdb8 <canardDecodeScalar+0x2b0>
 800bdb0:	7c3a      	ldrb	r2, [r7, #16]
 800bdb2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800bdb4:	701a      	strb	r2, [r3, #0]
 800bdb6:	e019      	b.n	800bdec <canardDecodeScalar+0x2e4>
        else if (bit_length <= 16)  { *((uint16_t*) out_value) = storage.u16; }
 800bdb8:	79fb      	ldrb	r3, [r7, #7]
 800bdba:	2b10      	cmp	r3, #16
 800bdbc:	d803      	bhi.n	800bdc6 <canardDecodeScalar+0x2be>
 800bdbe:	8a3a      	ldrh	r2, [r7, #16]
 800bdc0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800bdc2:	801a      	strh	r2, [r3, #0]
 800bdc4:	e012      	b.n	800bdec <canardDecodeScalar+0x2e4>
        else if (bit_length <= 32)  { *((uint32_t*) out_value) = storage.u32; }
 800bdc6:	79fb      	ldrb	r3, [r7, #7]
 800bdc8:	2b20      	cmp	r3, #32
 800bdca:	d803      	bhi.n	800bdd4 <canardDecodeScalar+0x2cc>
 800bdcc:	693a      	ldr	r2, [r7, #16]
 800bdce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800bdd0:	601a      	str	r2, [r3, #0]
 800bdd2:	e00b      	b.n	800bdec <canardDecodeScalar+0x2e4>
        else if (bit_length <= 64)  { *((uint64_t*) out_value) = storage.u64; }
 800bdd4:	79fb      	ldrb	r3, [r7, #7]
 800bdd6:	2b40      	cmp	r3, #64	; 0x40
 800bdd8:	d805      	bhi.n	800bde6 <canardDecodeScalar+0x2de>
 800bdda:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800bdde:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800bde0:	e9c1 2300 	strd	r2, r3, [r1]
 800bde4:	e002      	b.n	800bdec <canardDecodeScalar+0x2e4>
        else
        {
            CANARD_ASSERT(false);
            return -CANARD_ERROR_INTERNAL;
 800bde6:	f06f 0308 	mvn.w	r3, #8
 800bdea:	e000      	b.n	800bdee <canardDecodeScalar+0x2e6>
        }
    }

    CANARD_ASSERT(result <= bit_length);
    CANARD_ASSERT(result > 0);
    return result;
 800bdec:	69bb      	ldr	r3, [r7, #24]
}
 800bdee:	4618      	mov	r0, r3
 800bdf0:	3724      	adds	r7, #36	; 0x24
 800bdf2:	46bd      	mov	sp, r7
 800bdf4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800bdf8 <canardEncodeScalar>:

void canardEncodeScalar(void* destination,
                        uint32_t bit_offset,
                        uint8_t bit_length,
                        const void* value)
{
 800bdf8:	b580      	push	{r7, lr}
 800bdfa:	b08a      	sub	sp, #40	; 0x28
 800bdfc:	af02      	add	r7, sp, #8
 800bdfe:	60f8      	str	r0, [r7, #12]
 800be00:	60b9      	str	r1, [r7, #8]
 800be02:	603b      	str	r3, [r7, #0]
 800be04:	4613      	mov	r3, r2
 800be06:	71fb      	strb	r3, [r7, #7]
     * Maybe not the best solution, but it simplifies the API.
     */
    CANARD_ASSERT(destination != NULL);
    CANARD_ASSERT(value != NULL);

    if (bit_length > 64)
 800be08:	79fb      	ldrb	r3, [r7, #7]
 800be0a:	2b40      	cmp	r3, #64	; 0x40
 800be0c:	d901      	bls.n	800be12 <canardEncodeScalar+0x1a>
    {
        CANARD_ASSERT(false);
        bit_length = 64;
 800be0e:	2340      	movs	r3, #64	; 0x40
 800be10:	71fb      	strb	r3, [r7, #7]
    }

    if (bit_length < 1)
 800be12:	79fb      	ldrb	r3, [r7, #7]
 800be14:	2b00      	cmp	r3, #0
 800be16:	d101      	bne.n	800be1c <canardEncodeScalar+0x24>
    {
        CANARD_ASSERT(false);
        bit_length = 1;
 800be18:	2301      	movs	r3, #1
 800be1a:	71fb      	strb	r3, [r7, #7]
        uint32_t u32;
        uint64_t u64;
        uint8_t bytes[8];
    } storage;

    memset(&storage, 0, sizeof(storage));
 800be1c:	f107 0310 	add.w	r3, r7, #16
 800be20:	4618      	mov	r0, r3
 800be22:	2100      	movs	r1, #0
 800be24:	2208      	movs	r2, #8
 800be26:	f000 ff09 	bl	800cc3c <memset>

    uint8_t std_byte_length = 0;
 800be2a:	2300      	movs	r3, #0
 800be2c:	77fb      	strb	r3, [r7, #31]

    // Extra most significant bits can be safely ignored here.
    if      (bit_length == 1)   { std_byte_length = sizeof(bool);   storage.boolean = (*((bool*) value) != 0); }
 800be2e:	79fb      	ldrb	r3, [r7, #7]
 800be30:	2b01      	cmp	r3, #1
 800be32:	d10a      	bne.n	800be4a <canardEncodeScalar+0x52>
 800be34:	2301      	movs	r3, #1
 800be36:	77fb      	strb	r3, [r7, #31]
 800be38:	683b      	ldr	r3, [r7, #0]
 800be3a:	781b      	ldrb	r3, [r3, #0]
 800be3c:	2b00      	cmp	r3, #0
 800be3e:	bf14      	ite	ne
 800be40:	2301      	movne	r3, #1
 800be42:	2300      	moveq	r3, #0
 800be44:	b2db      	uxtb	r3, r3
 800be46:	743b      	strb	r3, [r7, #16]
 800be48:	e024      	b.n	800be94 <canardEncodeScalar+0x9c>
    else if (bit_length <= 8)   { std_byte_length = 1;              storage.u8  = *((uint8_t*) value);  }
 800be4a:	79fb      	ldrb	r3, [r7, #7]
 800be4c:	2b08      	cmp	r3, #8
 800be4e:	d805      	bhi.n	800be5c <canardEncodeScalar+0x64>
 800be50:	2301      	movs	r3, #1
 800be52:	77fb      	strb	r3, [r7, #31]
 800be54:	683b      	ldr	r3, [r7, #0]
 800be56:	781b      	ldrb	r3, [r3, #0]
 800be58:	743b      	strb	r3, [r7, #16]
 800be5a:	e01b      	b.n	800be94 <canardEncodeScalar+0x9c>
    else if (bit_length <= 16)  { std_byte_length = 2;              storage.u16 = *((uint16_t*) value); }
 800be5c:	79fb      	ldrb	r3, [r7, #7]
 800be5e:	2b10      	cmp	r3, #16
 800be60:	d805      	bhi.n	800be6e <canardEncodeScalar+0x76>
 800be62:	2302      	movs	r3, #2
 800be64:	77fb      	strb	r3, [r7, #31]
 800be66:	683b      	ldr	r3, [r7, #0]
 800be68:	881b      	ldrh	r3, [r3, #0]
 800be6a:	823b      	strh	r3, [r7, #16]
 800be6c:	e012      	b.n	800be94 <canardEncodeScalar+0x9c>
    else if (bit_length <= 32)  { std_byte_length = 4;              storage.u32 = *((uint32_t*) value); }
 800be6e:	79fb      	ldrb	r3, [r7, #7]
 800be70:	2b20      	cmp	r3, #32
 800be72:	d805      	bhi.n	800be80 <canardEncodeScalar+0x88>
 800be74:	2304      	movs	r3, #4
 800be76:	77fb      	strb	r3, [r7, #31]
 800be78:	683b      	ldr	r3, [r7, #0]
 800be7a:	681b      	ldr	r3, [r3, #0]
 800be7c:	613b      	str	r3, [r7, #16]
 800be7e:	e009      	b.n	800be94 <canardEncodeScalar+0x9c>
    else if (bit_length <= 64)  { std_byte_length = 8;              storage.u64 = *((uint64_t*) value); }
 800be80:	79fb      	ldrb	r3, [r7, #7]
 800be82:	2b40      	cmp	r3, #64	; 0x40
 800be84:	d806      	bhi.n	800be94 <canardEncodeScalar+0x9c>
 800be86:	2308      	movs	r3, #8
 800be88:	77fb      	strb	r3, [r7, #31]
 800be8a:	683b      	ldr	r3, [r7, #0]
 800be8c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800be90:	e9c7 2304 	strd	r2, r3, [r7, #16]
        CANARD_ASSERT(false);
    }

    CANARD_ASSERT(std_byte_length > 0);

    if (isBigEndian())
 800be94:	f000 fc26 	bl	800c6e4 <isBigEndian>
 800be98:	4603      	mov	r3, r0
 800be9a:	2b00      	cmp	r3, #0
 800be9c:	d006      	beq.n	800beac <canardEncodeScalar+0xb4>
    {
        swapByteOrder(&storage.bytes[0], std_byte_length);
 800be9e:	7ffb      	ldrb	r3, [r7, #31]
 800bea0:	f107 0210 	add.w	r2, r7, #16
 800bea4:	4610      	mov	r0, r2
 800bea6:	4619      	mov	r1, r3
 800bea8:	f000 fc2e 	bl	800c708 <swapByteOrder>
     * Extra least significant bits will be filled with zeroes, which is fine.
     * Extra most significant bits will be discarded here.
     * Coverity Scan mistakenly believes that the array may be overrun if bit_length == 64; however, this branch will
     * not be taken if bit_length == 64, because 64 % 8 == 0.
     */
    if ((bit_length % 8) != 0)
 800beac:	79fb      	ldrb	r3, [r7, #7]
 800beae:	f003 0307 	and.w	r3, r3, #7
 800beb2:	b2db      	uxtb	r3, r3
 800beb4:	2b00      	cmp	r3, #0
 800beb6:	d018      	beq.n	800beea <canardEncodeScalar+0xf2>
    {
        // coverity[overrun-local]
        storage.bytes[bit_length / 8] = (uint8_t)(storage.bytes[bit_length / 8] << ((8 - (bit_length % 8)) & 7));
 800beb8:	79fb      	ldrb	r3, [r7, #7]
 800beba:	08db      	lsrs	r3, r3, #3
 800bebc:	b2db      	uxtb	r3, r3
 800bebe:	4619      	mov	r1, r3
 800bec0:	79fb      	ldrb	r3, [r7, #7]
 800bec2:	08db      	lsrs	r3, r3, #3
 800bec4:	b2db      	uxtb	r3, r3
 800bec6:	f107 0220 	add.w	r2, r7, #32
 800beca:	4413      	add	r3, r2
 800becc:	f813 3c10 	ldrb.w	r3, [r3, #-16]
 800bed0:	461a      	mov	r2, r3
 800bed2:	79fb      	ldrb	r3, [r7, #7]
 800bed4:	425b      	negs	r3, r3
 800bed6:	f003 0307 	and.w	r3, r3, #7
 800beda:	fa02 f303 	lsl.w	r3, r2, r3
 800bede:	b2da      	uxtb	r2, r3
 800bee0:	f107 0320 	add.w	r3, r7, #32
 800bee4:	440b      	add	r3, r1
 800bee6:	f803 2c10 	strb.w	r2, [r3, #-16]
    }

    /*
     * Now, the storage contains properly serialized scalar. Copying it out.
     */
    copyBitArray(&storage.bytes[0], 0, bit_length, (uint8_t*) destination, bit_offset);
 800beea:	79fa      	ldrb	r2, [r7, #7]
 800beec:	f107 0110 	add.w	r1, r7, #16
 800bef0:	68bb      	ldr	r3, [r7, #8]
 800bef2:	9300      	str	r3, [sp, #0]
 800bef4:	4608      	mov	r0, r1
 800bef6:	2100      	movs	r1, #0
 800bef8:	68fb      	ldr	r3, [r7, #12]
 800befa:	f000 fa89 	bl	800c410 <copyBitArray>
}
 800befe:	3720      	adds	r7, #32
 800bf00:	46bd      	mov	sp, r7
 800bf02:	bd80      	pop	{r7, pc}

0800bf04 <canardReleaseRxTransferPayload>:

void canardReleaseRxTransferPayload(CanardInstance* ins, CanardRxTransfer* transfer)
{
 800bf04:	b580      	push	{r7, lr}
 800bf06:	b084      	sub	sp, #16
 800bf08:	af00      	add	r7, sp, #0
 800bf0a:	6078      	str	r0, [r7, #4]
 800bf0c:	6039      	str	r1, [r7, #0]
 800bf0e:	e00f      	b.n	800bf30 <canardReleaseRxTransferPayload+0x2c>
    while (transfer->payload_middle != NULL)
    {
        CanardBufferBlock* const temp = transfer->payload_middle->next;
 800bf10:	683b      	ldr	r3, [r7, #0]
 800bf12:	68db      	ldr	r3, [r3, #12]
 800bf14:	681b      	ldr	r3, [r3, #0]
 800bf16:	60fb      	str	r3, [r7, #12]
        freeBlock(&ins->allocator, transfer->payload_middle);
 800bf18:	687b      	ldr	r3, [r7, #4]
 800bf1a:	f103 020c 	add.w	r2, r3, #12
 800bf1e:	683b      	ldr	r3, [r7, #0]
 800bf20:	68db      	ldr	r3, [r3, #12]
 800bf22:	4610      	mov	r0, r2
 800bf24:	4619      	mov	r1, r3
 800bf26:	f000 fcf3 	bl	800c910 <freeBlock>
        transfer->payload_middle = temp;
 800bf2a:	683b      	ldr	r3, [r7, #0]
 800bf2c:	68fa      	ldr	r2, [r7, #12]
 800bf2e:	60da      	str	r2, [r3, #12]
    copyBitArray(&storage.bytes[0], 0, bit_length, (uint8_t*) destination, bit_offset);
}

void canardReleaseRxTransferPayload(CanardInstance* ins, CanardRxTransfer* transfer)
{
    while (transfer->payload_middle != NULL)
 800bf30:	683b      	ldr	r3, [r7, #0]
 800bf32:	68db      	ldr	r3, [r3, #12]
 800bf34:	2b00      	cmp	r3, #0
 800bf36:	d1eb      	bne.n	800bf10 <canardReleaseRxTransferPayload+0xc>
        CanardBufferBlock* const temp = transfer->payload_middle->next;
        freeBlock(&ins->allocator, transfer->payload_middle);
        transfer->payload_middle = temp;
    }

    transfer->payload_middle = NULL;
 800bf38:	683b      	ldr	r3, [r7, #0]
 800bf3a:	2200      	movs	r2, #0
 800bf3c:	60da      	str	r2, [r3, #12]
    transfer->payload_head = NULL;
 800bf3e:	683b      	ldr	r3, [r7, #0]
 800bf40:	2200      	movs	r2, #0
 800bf42:	609a      	str	r2, [r3, #8]
    transfer->payload_tail = NULL;
 800bf44:	683b      	ldr	r3, [r7, #0]
 800bf46:	2200      	movs	r2, #0
 800bf48:	611a      	str	r2, [r3, #16]
    transfer->payload_len = 0;
 800bf4a:	683b      	ldr	r3, [r7, #0]
 800bf4c:	2200      	movs	r2, #0
 800bf4e:	829a      	strh	r2, [r3, #20]
}
 800bf50:	3710      	adds	r7, #16
 800bf52:	46bd      	mov	sp, r7
 800bf54:	bd80      	pop	{r7, pc}
 800bf56:	bf00      	nop

0800bf58 <computeTransferIDForwardDistance>:

/*
 * Internal (static functions)
 */
CANARD_INTERNAL int computeTransferIDForwardDistance(uint8_t a, uint8_t b)
{
 800bf58:	b480      	push	{r7}
 800bf5a:	b085      	sub	sp, #20
 800bf5c:	af00      	add	r7, sp, #0
 800bf5e:	4603      	mov	r3, r0
 800bf60:	460a      	mov	r2, r1
 800bf62:	71fb      	strb	r3, [r7, #7]
 800bf64:	4613      	mov	r3, r2
 800bf66:	71bb      	strb	r3, [r7, #6]
    int d = b - a;
 800bf68:	79ba      	ldrb	r2, [r7, #6]
 800bf6a:	79fb      	ldrb	r3, [r7, #7]
 800bf6c:	1ad3      	subs	r3, r2, r3
 800bf6e:	60fb      	str	r3, [r7, #12]
    if (d < 0)
 800bf70:	68fb      	ldr	r3, [r7, #12]
 800bf72:	2b00      	cmp	r3, #0
 800bf74:	da02      	bge.n	800bf7c <computeTransferIDForwardDistance+0x24>
    {
        d += 1 << TRANSFER_ID_BIT_LEN;
 800bf76:	68fb      	ldr	r3, [r7, #12]
 800bf78:	3320      	adds	r3, #32
 800bf7a:	60fb      	str	r3, [r7, #12]
    }
    return d;
 800bf7c:	68fb      	ldr	r3, [r7, #12]
}
 800bf7e:	4618      	mov	r0, r3
 800bf80:	3714      	adds	r7, #20
 800bf82:	46bd      	mov	sp, r7
 800bf84:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf88:	4770      	bx	lr
 800bf8a:	bf00      	nop

0800bf8c <prepareForNextTransfer>:

/**
 * preps the rx state for the next transfer. does not delete the state
 */
CANARD_INTERNAL void prepareForNextTransfer(CanardRxState* state)
{
 800bf8c:	b480      	push	{r7}
 800bf8e:	b083      	sub	sp, #12
 800bf90:	af00      	add	r7, sp, #0
 800bf92:	6078      	str	r0, [r7, #4]
    CANARD_ASSERT(state->buffer_blocks == NULL);
    state->transfer_id += 1;
 800bf94:	687b      	ldr	r3, [r7, #4]
 800bf96:	7e5b      	ldrb	r3, [r3, #25]
 800bf98:	f3c3 0384 	ubfx	r3, r3, #2, #5
 800bf9c:	b2db      	uxtb	r3, r3
 800bf9e:	3301      	adds	r3, #1
 800bfa0:	b2db      	uxtb	r3, r3
 800bfa2:	f003 031f 	and.w	r3, r3, #31
 800bfa6:	b2d9      	uxtb	r1, r3
 800bfa8:	687a      	ldr	r2, [r7, #4]
 800bfaa:	7e53      	ldrb	r3, [r2, #25]
 800bfac:	f361 0386 	bfi	r3, r1, #2, #5
 800bfb0:	7653      	strb	r3, [r2, #25]
    state->payload_len = 0;
 800bfb2:	687a      	ldr	r2, [r7, #4]
 800bfb4:	8b13      	ldrh	r3, [r2, #24]
 800bfb6:	f36f 0309 	bfc	r3, #0, #10
 800bfba:	8313      	strh	r3, [r2, #24]
    state->next_toggle = 0;
 800bfbc:	687a      	ldr	r2, [r7, #4]
 800bfbe:	7e53      	ldrb	r3, [r2, #25]
 800bfc0:	f36f 13c7 	bfc	r3, #7, #1
 800bfc4:	7653      	strb	r3, [r2, #25]
}
 800bfc6:	370c      	adds	r7, #12
 800bfc8:	46bd      	mov	sp, r7
 800bfca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bfce:	4770      	bx	lr

0800bfd0 <extractDataType>:

/**
 * returns data type from id
 */
CANARD_INTERNAL uint16_t extractDataType(uint32_t id)
{
 800bfd0:	b580      	push	{r7, lr}
 800bfd2:	b084      	sub	sp, #16
 800bfd4:	af00      	add	r7, sp, #0
 800bfd6:	6078      	str	r0, [r7, #4]
    if (extractTransferType(id) == CanardTransferTypeBroadcast)
 800bfd8:	6878      	ldr	r0, [r7, #4]
 800bfda:	f000 f81b 	bl	800c014 <extractTransferType>
 800bfde:	4603      	mov	r3, r0
 800bfe0:	2b02      	cmp	r3, #2
 800bfe2:	d10e      	bne.n	800c002 <extractDataType+0x32>
    {
        uint16_t dtid = MSG_TYPE_FROM_ID(id);
 800bfe4:	687b      	ldr	r3, [r7, #4]
 800bfe6:	0a1b      	lsrs	r3, r3, #8
 800bfe8:	81fb      	strh	r3, [r7, #14]
        if (SOURCE_ID_FROM_ID(id) == CANARD_BROADCAST_NODE_ID)
 800bfea:	687b      	ldr	r3, [r7, #4]
 800bfec:	b2db      	uxtb	r3, r3
 800bfee:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800bff2:	2b00      	cmp	r3, #0
 800bff4:	d103      	bne.n	800bffe <extractDataType+0x2e>
        {
            dtid &= (1U << ANON_MSG_DATA_TYPE_ID_BIT_LEN) - 1U;
 800bff6:	89fb      	ldrh	r3, [r7, #14]
 800bff8:	f003 0303 	and.w	r3, r3, #3
 800bffc:	81fb      	strh	r3, [r7, #14]
        }
        return dtid;
 800bffe:	89fb      	ldrh	r3, [r7, #14]
 800c000:	e003      	b.n	800c00a <extractDataType+0x3a>
    }
    else
    {
        return (uint16_t) SRV_TYPE_FROM_ID(id);
 800c002:	687b      	ldr	r3, [r7, #4]
 800c004:	0c1b      	lsrs	r3, r3, #16
 800c006:	b2db      	uxtb	r3, r3
 800c008:	b29b      	uxth	r3, r3
    }
}
 800c00a:	4618      	mov	r0, r3
 800c00c:	3710      	adds	r7, #16
 800c00e:	46bd      	mov	sp, r7
 800c010:	bd80      	pop	{r7, pc}
 800c012:	bf00      	nop

0800c014 <extractTransferType>:

/**
 * returns transfer type from id
 */
CANARD_INTERNAL CanardTransferType extractTransferType(uint32_t id)
{
 800c014:	b480      	push	{r7}
 800c016:	b085      	sub	sp, #20
 800c018:	af00      	add	r7, sp, #0
 800c01a:	6078      	str	r0, [r7, #4]
    const bool is_service = SERVICE_NOT_MSG_FROM_ID(id);
 800c01c:	687b      	ldr	r3, [r7, #4]
 800c01e:	09db      	lsrs	r3, r3, #7
 800c020:	f003 0301 	and.w	r3, r3, #1
 800c024:	2b00      	cmp	r3, #0
 800c026:	bf14      	ite	ne
 800c028:	2301      	movne	r3, #1
 800c02a:	2300      	moveq	r3, #0
 800c02c:	73fb      	strb	r3, [r7, #15]
    if (!is_service)
 800c02e:	7bfb      	ldrb	r3, [r7, #15]
 800c030:	f083 0301 	eor.w	r3, r3, #1
 800c034:	b2db      	uxtb	r3, r3
 800c036:	2b00      	cmp	r3, #0
 800c038:	d001      	beq.n	800c03e <extractTransferType+0x2a>
    {
        return CanardTransferTypeBroadcast;
 800c03a:	2302      	movs	r3, #2
 800c03c:	e008      	b.n	800c050 <extractTransferType+0x3c>
    }
    else if (REQUEST_NOT_RESPONSE_FROM_ID(id) == 1)
 800c03e:	687b      	ldr	r3, [r7, #4]
 800c040:	0bdb      	lsrs	r3, r3, #15
 800c042:	f003 0301 	and.w	r3, r3, #1
 800c046:	2b00      	cmp	r3, #0
 800c048:	d001      	beq.n	800c04e <extractTransferType+0x3a>
    {
        return CanardTransferTypeRequest;
 800c04a:	2301      	movs	r3, #1
 800c04c:	e000      	b.n	800c050 <extractTransferType+0x3c>
    }
    else
    {
        return CanardTransferTypeResponse;
 800c04e:	2300      	movs	r3, #0
    }
}
 800c050:	4618      	mov	r0, r3
 800c052:	3714      	adds	r7, #20
 800c054:	46bd      	mov	sp, r7
 800c056:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c05a:	4770      	bx	lr

0800c05c <traverseRxStates>:
/**
 * Traverses the list of CanardRxState's and returns a pointer to the CanardRxState
 * with either the Id or a new one at the end
 */
CANARD_INTERNAL CanardRxState* traverseRxStates(CanardInstance* ins, uint32_t transfer_descriptor)
{
 800c05c:	b580      	push	{r7, lr}
 800c05e:	b084      	sub	sp, #16
 800c060:	af00      	add	r7, sp, #0
 800c062:	6078      	str	r0, [r7, #4]
 800c064:	6039      	str	r1, [r7, #0]
    CanardRxState* states = ins->rx_states;
 800c066:	687b      	ldr	r3, [r7, #4]
 800c068:	699b      	ldr	r3, [r3, #24]
 800c06a:	60fb      	str	r3, [r7, #12]

    if (states == NULL) // initialize CanardRxStates
 800c06c:	68fb      	ldr	r3, [r7, #12]
 800c06e:	2b00      	cmp	r3, #0
 800c070:	d110      	bne.n	800c094 <traverseRxStates+0x38>
    {
        states = createRxState(&ins->allocator, transfer_descriptor);
 800c072:	687b      	ldr	r3, [r7, #4]
 800c074:	330c      	adds	r3, #12
 800c076:	4618      	mov	r0, r3
 800c078:	6839      	ldr	r1, [r7, #0]
 800c07a:	f000 f857 	bl	800c12c <createRxState>
 800c07e:	60f8      	str	r0, [r7, #12]
        
        if(states == NULL)
 800c080:	68fb      	ldr	r3, [r7, #12]
 800c082:	2b00      	cmp	r3, #0
 800c084:	d101      	bne.n	800c08a <traverseRxStates+0x2e>
        {
            return NULL;
 800c086:	2300      	movs	r3, #0
 800c088:	e013      	b.n	800c0b2 <traverseRxStates+0x56>
        }

        ins->rx_states = states;
 800c08a:	687b      	ldr	r3, [r7, #4]
 800c08c:	68fa      	ldr	r2, [r7, #12]
 800c08e:	619a      	str	r2, [r3, #24]
        return states;
 800c090:	68fb      	ldr	r3, [r7, #12]
 800c092:	e00e      	b.n	800c0b2 <traverseRxStates+0x56>
    }

    states = findRxState(states, transfer_descriptor);
 800c094:	68f8      	ldr	r0, [r7, #12]
 800c096:	6839      	ldr	r1, [r7, #0]
 800c098:	f000 f810 	bl	800c0bc <findRxState>
 800c09c:	60f8      	str	r0, [r7, #12]
    if (states != NULL)
 800c09e:	68fb      	ldr	r3, [r7, #12]
 800c0a0:	2b00      	cmp	r3, #0
 800c0a2:	d001      	beq.n	800c0a8 <traverseRxStates+0x4c>
    {
        return states;
 800c0a4:	68fb      	ldr	r3, [r7, #12]
 800c0a6:	e004      	b.n	800c0b2 <traverseRxStates+0x56>
    }
    else
    {
        return prependRxState(ins, transfer_descriptor);
 800c0a8:	6878      	ldr	r0, [r7, #4]
 800c0aa:	6839      	ldr	r1, [r7, #0]
 800c0ac:	f000 f820 	bl	800c0f0 <prependRxState>
 800c0b0:	4603      	mov	r3, r0
    }
}
 800c0b2:	4618      	mov	r0, r3
 800c0b4:	3710      	adds	r7, #16
 800c0b6:	46bd      	mov	sp, r7
 800c0b8:	bd80      	pop	{r7, pc}
 800c0ba:	bf00      	nop

0800c0bc <findRxState>:

/**
 * returns pointer to the rx state of transfer descriptor or null if not found
 */
CANARD_INTERNAL CanardRxState* findRxState(CanardRxState* state, uint32_t transfer_descriptor)
{
 800c0bc:	b480      	push	{r7}
 800c0be:	b083      	sub	sp, #12
 800c0c0:	af00      	add	r7, sp, #0
 800c0c2:	6078      	str	r0, [r7, #4]
 800c0c4:	6039      	str	r1, [r7, #0]
 800c0c6:	e009      	b.n	800c0dc <findRxState+0x20>
    while (state != NULL)
    {
        if (state->dtid_tt_snid_dnid == transfer_descriptor)
 800c0c8:	687b      	ldr	r3, [r7, #4]
 800c0ca:	691a      	ldr	r2, [r3, #16]
 800c0cc:	683b      	ldr	r3, [r7, #0]
 800c0ce:	429a      	cmp	r2, r3
 800c0d0:	d101      	bne.n	800c0d6 <findRxState+0x1a>
        {
            return state;
 800c0d2:	687b      	ldr	r3, [r7, #4]
 800c0d4:	e006      	b.n	800c0e4 <findRxState+0x28>
        }
        state = state->next;
 800c0d6:	687b      	ldr	r3, [r7, #4]
 800c0d8:	681b      	ldr	r3, [r3, #0]
 800c0da:	607b      	str	r3, [r7, #4]
/**
 * returns pointer to the rx state of transfer descriptor or null if not found
 */
CANARD_INTERNAL CanardRxState* findRxState(CanardRxState* state, uint32_t transfer_descriptor)
{
    while (state != NULL)
 800c0dc:	687b      	ldr	r3, [r7, #4]
 800c0de:	2b00      	cmp	r3, #0
 800c0e0:	d1f2      	bne.n	800c0c8 <findRxState+0xc>
        {
            return state;
        }
        state = state->next;
    }
    return NULL;
 800c0e2:	2300      	movs	r3, #0
}
 800c0e4:	4618      	mov	r0, r3
 800c0e6:	370c      	adds	r7, #12
 800c0e8:	46bd      	mov	sp, r7
 800c0ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c0ee:	4770      	bx	lr

0800c0f0 <prependRxState>:

/**
 * prepends rx state to the canard instance rx_states
 */
CANARD_INTERNAL CanardRxState* prependRxState(CanardInstance* ins, uint32_t transfer_descriptor)
{
 800c0f0:	b580      	push	{r7, lr}
 800c0f2:	b084      	sub	sp, #16
 800c0f4:	af00      	add	r7, sp, #0
 800c0f6:	6078      	str	r0, [r7, #4]
 800c0f8:	6039      	str	r1, [r7, #0]
    CanardRxState* state = createRxState(&ins->allocator, transfer_descriptor);
 800c0fa:	687b      	ldr	r3, [r7, #4]
 800c0fc:	330c      	adds	r3, #12
 800c0fe:	4618      	mov	r0, r3
 800c100:	6839      	ldr	r1, [r7, #0]
 800c102:	f000 f813 	bl	800c12c <createRxState>
 800c106:	60f8      	str	r0, [r7, #12]

    if(state == NULL)
 800c108:	68fb      	ldr	r3, [r7, #12]
 800c10a:	2b00      	cmp	r3, #0
 800c10c:	d101      	bne.n	800c112 <prependRxState+0x22>
    {
        return NULL;
 800c10e:	2300      	movs	r3, #0
 800c110:	e007      	b.n	800c122 <prependRxState+0x32>
    }

    state->next = ins->rx_states;
 800c112:	687b      	ldr	r3, [r7, #4]
 800c114:	699a      	ldr	r2, [r3, #24]
 800c116:	68fb      	ldr	r3, [r7, #12]
 800c118:	601a      	str	r2, [r3, #0]
    ins->rx_states = state;
 800c11a:	687b      	ldr	r3, [r7, #4]
 800c11c:	68fa      	ldr	r2, [r7, #12]
 800c11e:	619a      	str	r2, [r3, #24]
    return state;
 800c120:	68fb      	ldr	r3, [r7, #12]
}
 800c122:	4618      	mov	r0, r3
 800c124:	3710      	adds	r7, #16
 800c126:	46bd      	mov	sp, r7
 800c128:	bd80      	pop	{r7, pc}
 800c12a:	bf00      	nop

0800c12c <createRxState>:

CANARD_INTERNAL CanardRxState* createRxState(CanardPoolAllocator* allocator, uint32_t transfer_descriptor)
{
 800c12c:	b580      	push	{r7, lr}
 800c12e:	b08c      	sub	sp, #48	; 0x30
 800c130:	af00      	add	r7, sp, #0
 800c132:	6078      	str	r0, [r7, #4]
 800c134:	6039      	str	r1, [r7, #0]
    CanardRxState init = {
 800c136:	f107 0308 	add.w	r3, r7, #8
 800c13a:	2200      	movs	r2, #0
 800c13c:	601a      	str	r2, [r3, #0]
 800c13e:	3304      	adds	r3, #4
 800c140:	2200      	movs	r2, #0
 800c142:	601a      	str	r2, [r3, #0]
 800c144:	3304      	adds	r3, #4
 800c146:	2200      	movs	r2, #0
 800c148:	601a      	str	r2, [r3, #0]
 800c14a:	3304      	adds	r3, #4
 800c14c:	2200      	movs	r2, #0
 800c14e:	601a      	str	r2, [r3, #0]
 800c150:	3304      	adds	r3, #4
 800c152:	2200      	movs	r2, #0
 800c154:	601a      	str	r2, [r3, #0]
 800c156:	3304      	adds	r3, #4
 800c158:	2200      	movs	r2, #0
 800c15a:	601a      	str	r2, [r3, #0]
 800c15c:	3304      	adds	r3, #4
 800c15e:	2200      	movs	r2, #0
 800c160:	601a      	str	r2, [r3, #0]
 800c162:	3304      	adds	r3, #4
 800c164:	2200      	movs	r2, #0
 800c166:	601a      	str	r2, [r3, #0]
 800c168:	3304      	adds	r3, #4
 800c16a:	683b      	ldr	r3, [r7, #0]
 800c16c:	61bb      	str	r3, [r7, #24]
        .next = NULL,
        .buffer_blocks = NULL,
        .dtid_tt_snid_dnid = transfer_descriptor
    };

    CanardRxState* state = (CanardRxState*) allocateBlock(allocator);
 800c16e:	6878      	ldr	r0, [r7, #4]
 800c170:	f000 fba4 	bl	800c8bc <allocateBlock>
 800c174:	62f8      	str	r0, [r7, #44]	; 0x2c
    if (state == NULL)
 800c176:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c178:	2b00      	cmp	r3, #0
 800c17a:	d101      	bne.n	800c180 <createRxState+0x54>
    {
        return NULL;
 800c17c:	2300      	movs	r3, #0
 800c17e:	e007      	b.n	800c190 <createRxState+0x64>
    }
    memcpy(state, &init, sizeof(*state));
 800c180:	f107 0308 	add.w	r3, r7, #8
 800c184:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800c186:	4619      	mov	r1, r3
 800c188:	2220      	movs	r2, #32
 800c18a:	f000 fd31 	bl	800cbf0 <memcpy>

    return state;
 800c18e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 800c190:	4618      	mov	r0, r3
 800c192:	3730      	adds	r7, #48	; 0x30
 800c194:	46bd      	mov	sp, r7
 800c196:	bd80      	pop	{r7, pc}

0800c198 <releaseStatePayload>:

CANARD_INTERNAL uint64_t releaseStatePayload(CanardInstance* ins, CanardRxState* rxstate)
{
 800c198:	b580      	push	{r7, lr}
 800c19a:	b084      	sub	sp, #16
 800c19c:	af00      	add	r7, sp, #0
 800c19e:	6078      	str	r0, [r7, #4]
 800c1a0:	6039      	str	r1, [r7, #0]
 800c1a2:	e00f      	b.n	800c1c4 <releaseStatePayload+0x2c>
    while (rxstate->buffer_blocks != NULL)
    {
        CanardBufferBlock* const temp = rxstate->buffer_blocks->next;
 800c1a4:	683b      	ldr	r3, [r7, #0]
 800c1a6:	685b      	ldr	r3, [r3, #4]
 800c1a8:	681b      	ldr	r3, [r3, #0]
 800c1aa:	60fb      	str	r3, [r7, #12]
        freeBlock(&ins->allocator, rxstate->buffer_blocks);
 800c1ac:	687b      	ldr	r3, [r7, #4]
 800c1ae:	f103 020c 	add.w	r2, r3, #12
 800c1b2:	683b      	ldr	r3, [r7, #0]
 800c1b4:	685b      	ldr	r3, [r3, #4]
 800c1b6:	4610      	mov	r0, r2
 800c1b8:	4619      	mov	r1, r3
 800c1ba:	f000 fba9 	bl	800c910 <freeBlock>
        rxstate->buffer_blocks = temp;
 800c1be:	683b      	ldr	r3, [r7, #0]
 800c1c0:	68fa      	ldr	r2, [r7, #12]
 800c1c2:	605a      	str	r2, [r3, #4]
    return state;
}

CANARD_INTERNAL uint64_t releaseStatePayload(CanardInstance* ins, CanardRxState* rxstate)
{
    while (rxstate->buffer_blocks != NULL)
 800c1c4:	683b      	ldr	r3, [r7, #0]
 800c1c6:	685b      	ldr	r3, [r3, #4]
 800c1c8:	2b00      	cmp	r3, #0
 800c1ca:	d1eb      	bne.n	800c1a4 <releaseStatePayload+0xc>
    {
        CanardBufferBlock* const temp = rxstate->buffer_blocks->next;
        freeBlock(&ins->allocator, rxstate->buffer_blocks);
        rxstate->buffer_blocks = temp;
    }
    rxstate->payload_len = 0;
 800c1cc:	683a      	ldr	r2, [r7, #0]
 800c1ce:	8b13      	ldrh	r3, [r2, #24]
 800c1d0:	f36f 0309 	bfc	r3, #0, #10
 800c1d4:	8313      	strh	r3, [r2, #24]
    return CANARD_OK;
 800c1d6:	f04f 0200 	mov.w	r2, #0
 800c1da:	f04f 0300 	mov.w	r3, #0
}
 800c1de:	4610      	mov	r0, r2
 800c1e0:	4619      	mov	r1, r3
 800c1e2:	3710      	adds	r7, #16
 800c1e4:	46bd      	mov	sp, r7
 800c1e6:	bd80      	pop	{r7, pc}

0800c1e8 <bufferBlockPushBytes>:
 */
CANARD_INTERNAL int bufferBlockPushBytes(CanardPoolAllocator* allocator,
                                         CanardRxState* state,
                                         const uint8_t* data,
                                         uint8_t data_len)
{
 800c1e8:	b580      	push	{r7, lr}
 800c1ea:	b08a      	sub	sp, #40	; 0x28
 800c1ec:	af00      	add	r7, sp, #0
 800c1ee:	60f8      	str	r0, [r7, #12]
 800c1f0:	60b9      	str	r1, [r7, #8]
 800c1f2:	607a      	str	r2, [r7, #4]
 800c1f4:	70fb      	strb	r3, [r7, #3]
    uint16_t data_index = 0;
 800c1f6:	2300      	movs	r3, #0
 800c1f8:	84fb      	strh	r3, [r7, #38]	; 0x26

    // if head is not full, add data to head
    if ((int) CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE - (int) state->payload_len > 0)
 800c1fa:	68bb      	ldr	r3, [r7, #8]
 800c1fc:	8b1b      	ldrh	r3, [r3, #24]
 800c1fe:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800c202:	b29b      	uxth	r3, r3
 800c204:	f1c3 0306 	rsb	r3, r3, #6
 800c208:	2b00      	cmp	r3, #0
 800c20a:	dd36      	ble.n	800c27a <bufferBlockPushBytes+0x92>
    {
        for (uint16_t i = (uint16_t)state->payload_len;
 800c20c:	68bb      	ldr	r3, [r7, #8]
 800c20e:	8b1b      	ldrh	r3, [r3, #24]
 800c210:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800c214:	b29b      	uxth	r3, r3
 800c216:	84bb      	strh	r3, [r7, #36]	; 0x24
 800c218:	e00e      	b.n	800c238 <bufferBlockPushBytes+0x50>
             i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE && data_index < data_len;
             i++, data_index++)
        {
            state->buffer_head[i] = data[data_index];
 800c21a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800c21c:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800c21e:	6879      	ldr	r1, [r7, #4]
 800c220:	440a      	add	r2, r1
 800c222:	7811      	ldrb	r1, [r2, #0]
 800c224:	68ba      	ldr	r2, [r7, #8]
 800c226:	4413      	add	r3, r2
 800c228:	460a      	mov	r2, r1
 800c22a:	769a      	strb	r2, [r3, #26]
    // if head is not full, add data to head
    if ((int) CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE - (int) state->payload_len > 0)
    {
        for (uint16_t i = (uint16_t)state->payload_len;
             i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE && data_index < data_len;
             i++, data_index++)
 800c22c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800c22e:	3301      	adds	r3, #1
 800c230:	84bb      	strh	r3, [r7, #36]	; 0x24
 800c232:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800c234:	3301      	adds	r3, #1
 800c236:	84fb      	strh	r3, [r7, #38]	; 0x26
    uint16_t data_index = 0;

    // if head is not full, add data to head
    if ((int) CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE - (int) state->payload_len > 0)
    {
        for (uint16_t i = (uint16_t)state->payload_len;
 800c238:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800c23a:	2b05      	cmp	r3, #5
 800c23c:	d804      	bhi.n	800c248 <bufferBlockPushBytes+0x60>
             i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE && data_index < data_len;
 800c23e:	78fb      	ldrb	r3, [r7, #3]
 800c240:	b29b      	uxth	r3, r3
 800c242:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800c244:	429a      	cmp	r2, r3
 800c246:	d3e8      	bcc.n	800c21a <bufferBlockPushBytes+0x32>
             i++, data_index++)
        {
            state->buffer_head[i] = data[data_index];
        }
        if (data_index >= data_len)
 800c248:	78fb      	ldrb	r3, [r7, #3]
 800c24a:	b29b      	uxth	r3, r3
 800c24c:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800c24e:	429a      	cmp	r2, r3
 800c250:	d313      	bcc.n	800c27a <bufferBlockPushBytes+0x92>
        {
            state->payload_len += data_len;
 800c252:	68bb      	ldr	r3, [r7, #8]
 800c254:	8b1b      	ldrh	r3, [r3, #24]
 800c256:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800c25a:	b29b      	uxth	r3, r3
 800c25c:	461a      	mov	r2, r3
 800c25e:	78fb      	ldrb	r3, [r7, #3]
 800c260:	b29b      	uxth	r3, r3
 800c262:	4413      	add	r3, r2
 800c264:	b29b      	uxth	r3, r3
 800c266:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800c26a:	b299      	uxth	r1, r3
 800c26c:	68ba      	ldr	r2, [r7, #8]
 800c26e:	8b13      	ldrh	r3, [r2, #24]
 800c270:	f361 0309 	bfi	r3, r1, #0, #10
 800c274:	8313      	strh	r3, [r2, #24]
            return 1;
 800c276:	2301      	movs	r3, #1
 800c278:	e0ae      	b.n	800c3d8 <bufferBlockPushBytes+0x1f0>
        }
    } // head is full.

    uint8_t index_at_nth_block =
        (((state->payload_len) - CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) % CANARD_BUFFER_BLOCK_DATA_SIZE);
 800c27a:	68bb      	ldr	r3, [r7, #8]
 800c27c:	8b1b      	ldrh	r3, [r3, #24]
 800c27e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800c282:	b29b      	uxth	r3, r3
 800c284:	1f9a      	subs	r2, r3, #6
 800c286:	0893      	lsrs	r3, r2, #2
 800c288:	4955      	ldr	r1, [pc, #340]	; (800c3e0 <bufferBlockPushBytes+0x1f8>)
 800c28a:	fba1 3103 	umull	r3, r1, r1, r3
 800c28e:	460b      	mov	r3, r1
 800c290:	00db      	lsls	r3, r3, #3
 800c292:	1a5b      	subs	r3, r3, r1
 800c294:	009b      	lsls	r3, r3, #2
 800c296:	1ad3      	subs	r3, r2, r3
            state->payload_len += data_len;
            return 1;
        }
    } // head is full.

    uint8_t index_at_nth_block =
 800c298:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        (((state->payload_len) - CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) % CANARD_BUFFER_BLOCK_DATA_SIZE);

    // get to current block
    CanardBufferBlock* block = NULL;
 800c29c:	2300      	movs	r3, #0
 800c29e:	61fb      	str	r3, [r7, #28]

    // buffer blocks uninitialized
    if (state->buffer_blocks == NULL)
 800c2a0:	68bb      	ldr	r3, [r7, #8]
 800c2a2:	685b      	ldr	r3, [r3, #4]
 800c2a4:	2b00      	cmp	r3, #0
 800c2a6:	d113      	bne.n	800c2d0 <bufferBlockPushBytes+0xe8>
    {
        state->buffer_blocks = createBufferBlock(allocator);
 800c2a8:	68f8      	ldr	r0, [r7, #12]
 800c2aa:	f000 f89b 	bl	800c3e4 <createBufferBlock>
 800c2ae:	4602      	mov	r2, r0
 800c2b0:	68bb      	ldr	r3, [r7, #8]
 800c2b2:	605a      	str	r2, [r3, #4]

        if (state->buffer_blocks == NULL)
 800c2b4:	68bb      	ldr	r3, [r7, #8]
 800c2b6:	685b      	ldr	r3, [r3, #4]
 800c2b8:	2b00      	cmp	r3, #0
 800c2ba:	d102      	bne.n	800c2c2 <bufferBlockPushBytes+0xda>
        {
            return -CANARD_ERROR_OUT_OF_MEMORY;
 800c2bc:	f06f 0302 	mvn.w	r3, #2
 800c2c0:	e08a      	b.n	800c3d8 <bufferBlockPushBytes+0x1f0>
        }

        block = state->buffer_blocks;
 800c2c2:	68bb      	ldr	r3, [r7, #8]
 800c2c4:	685b      	ldr	r3, [r3, #4]
 800c2c6:	61fb      	str	r3, [r7, #28]
        index_at_nth_block = 0;
 800c2c8:	2300      	movs	r3, #0
 800c2ca:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800c2ce:	e06b      	b.n	800c3a8 <bufferBlockPushBytes+0x1c0>
    }
    else
    {
        uint8_t nth_block = 1;
 800c2d0:	2301      	movs	r3, #1
 800c2d2:	76fb      	strb	r3, [r7, #27]

        // get to block
        block = state->buffer_blocks;
 800c2d4:	68bb      	ldr	r3, [r7, #8]
 800c2d6:	685b      	ldr	r3, [r3, #4]
 800c2d8:	61fb      	str	r3, [r7, #28]
 800c2da:	e005      	b.n	800c2e8 <bufferBlockPushBytes+0x100>
        while (block->next != NULL)
        {
            nth_block++;
 800c2dc:	7efb      	ldrb	r3, [r7, #27]
 800c2de:	3301      	adds	r3, #1
 800c2e0:	76fb      	strb	r3, [r7, #27]
            block = block->next;
 800c2e2:	69fb      	ldr	r3, [r7, #28]
 800c2e4:	681b      	ldr	r3, [r3, #0]
 800c2e6:	61fb      	str	r3, [r7, #28]
    {
        uint8_t nth_block = 1;

        // get to block
        block = state->buffer_blocks;
        while (block->next != NULL)
 800c2e8:	69fb      	ldr	r3, [r7, #28]
 800c2ea:	681b      	ldr	r3, [r3, #0]
 800c2ec:	2b00      	cmp	r3, #0
 800c2ee:	d1f5      	bne.n	800c2dc <bufferBlockPushBytes+0xf4>
        {
            nth_block++;
            block = block->next;
        }

        const uint8_t num_buffer_blocks = (((state->payload_len + data_len) - CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) /
 800c2f0:	68bb      	ldr	r3, [r7, #8]
 800c2f2:	8b1b      	ldrh	r3, [r3, #24]
 800c2f4:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800c2f8:	b29b      	uxth	r3, r3
 800c2fa:	461a      	mov	r2, r3
 800c2fc:	78fb      	ldrb	r3, [r7, #3]
 800c2fe:	4413      	add	r3, r2
 800c300:	3b06      	subs	r3, #6
 800c302:	089b      	lsrs	r3, r3, #2
 800c304:	4a36      	ldr	r2, [pc, #216]	; (800c3e0 <bufferBlockPushBytes+0x1f8>)
 800c306:	fba2 2303 	umull	r2, r3, r2, r3
 800c30a:	b2db      	uxtb	r3, r3
 800c30c:	3301      	adds	r3, #1
 800c30e:	75fb      	strb	r3, [r7, #23]
                                           CANARD_BUFFER_BLOCK_DATA_SIZE) + 1;

        if (num_buffer_blocks > nth_block && index_at_nth_block == 0)
 800c310:	7dfa      	ldrb	r2, [r7, #23]
 800c312:	7efb      	ldrb	r3, [r7, #27]
 800c314:	429a      	cmp	r2, r3
 800c316:	d947      	bls.n	800c3a8 <bufferBlockPushBytes+0x1c0>
 800c318:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800c31c:	2b00      	cmp	r3, #0
 800c31e:	d143      	bne.n	800c3a8 <bufferBlockPushBytes+0x1c0>
        {
            block->next = createBufferBlock(allocator);
 800c320:	68f8      	ldr	r0, [r7, #12]
 800c322:	f000 f85f 	bl	800c3e4 <createBufferBlock>
 800c326:	4602      	mov	r2, r0
 800c328:	69fb      	ldr	r3, [r7, #28]
 800c32a:	601a      	str	r2, [r3, #0]
            if (block->next == NULL)
 800c32c:	69fb      	ldr	r3, [r7, #28]
 800c32e:	681b      	ldr	r3, [r3, #0]
 800c330:	2b00      	cmp	r3, #0
 800c332:	d102      	bne.n	800c33a <bufferBlockPushBytes+0x152>
            {
                return -CANARD_ERROR_OUT_OF_MEMORY;
 800c334:	f06f 0302 	mvn.w	r3, #2
 800c338:	e04e      	b.n	800c3d8 <bufferBlockPushBytes+0x1f0>
            }
            block = block->next;
 800c33a:	69fb      	ldr	r3, [r7, #28]
 800c33c:	681b      	ldr	r3, [r3, #0]
 800c33e:	61fb      	str	r3, [r7, #28]
 800c340:	e032      	b.n	800c3a8 <bufferBlockPushBytes+0x1c0>
    }

    // add data to current block until it becomes full, add new block if necessary
    while (data_index < data_len)
    {
        for (uint16_t i = index_at_nth_block;
 800c342:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800c346:	833b      	strh	r3, [r7, #24]
 800c348:	e00e      	b.n	800c368 <bufferBlockPushBytes+0x180>
             i < CANARD_BUFFER_BLOCK_DATA_SIZE && data_index < data_len;
             i++, data_index++)
        {
            block->data[i] = data[data_index];
 800c34a:	8b3b      	ldrh	r3, [r7, #24]
 800c34c:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800c34e:	6879      	ldr	r1, [r7, #4]
 800c350:	440a      	add	r2, r1
 800c352:	7811      	ldrb	r1, [r2, #0]
 800c354:	69fa      	ldr	r2, [r7, #28]
 800c356:	4413      	add	r3, r2
 800c358:	460a      	mov	r2, r1
 800c35a:	711a      	strb	r2, [r3, #4]
    // add data to current block until it becomes full, add new block if necessary
    while (data_index < data_len)
    {
        for (uint16_t i = index_at_nth_block;
             i < CANARD_BUFFER_BLOCK_DATA_SIZE && data_index < data_len;
             i++, data_index++)
 800c35c:	8b3b      	ldrh	r3, [r7, #24]
 800c35e:	3301      	adds	r3, #1
 800c360:	833b      	strh	r3, [r7, #24]
 800c362:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800c364:	3301      	adds	r3, #1
 800c366:	84fb      	strh	r3, [r7, #38]	; 0x26
    }

    // add data to current block until it becomes full, add new block if necessary
    while (data_index < data_len)
    {
        for (uint16_t i = index_at_nth_block;
 800c368:	8b3b      	ldrh	r3, [r7, #24]
 800c36a:	2b1b      	cmp	r3, #27
 800c36c:	d804      	bhi.n	800c378 <bufferBlockPushBytes+0x190>
             i < CANARD_BUFFER_BLOCK_DATA_SIZE && data_index < data_len;
 800c36e:	78fb      	ldrb	r3, [r7, #3]
 800c370:	b29b      	uxth	r3, r3
 800c372:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800c374:	429a      	cmp	r2, r3
 800c376:	d3e8      	bcc.n	800c34a <bufferBlockPushBytes+0x162>
             i++, data_index++)
        {
            block->data[i] = data[data_index];
        }

        if (data_index < data_len)
 800c378:	78fb      	ldrb	r3, [r7, #3]
 800c37a:	b29b      	uxth	r3, r3
 800c37c:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800c37e:	429a      	cmp	r2, r3
 800c380:	d212      	bcs.n	800c3a8 <bufferBlockPushBytes+0x1c0>
        {
            block->next = createBufferBlock(allocator);
 800c382:	68f8      	ldr	r0, [r7, #12]
 800c384:	f000 f82e 	bl	800c3e4 <createBufferBlock>
 800c388:	4602      	mov	r2, r0
 800c38a:	69fb      	ldr	r3, [r7, #28]
 800c38c:	601a      	str	r2, [r3, #0]
            if (block->next == NULL)
 800c38e:	69fb      	ldr	r3, [r7, #28]
 800c390:	681b      	ldr	r3, [r3, #0]
 800c392:	2b00      	cmp	r3, #0
 800c394:	d102      	bne.n	800c39c <bufferBlockPushBytes+0x1b4>
            {
                return -CANARD_ERROR_OUT_OF_MEMORY;
 800c396:	f06f 0302 	mvn.w	r3, #2
 800c39a:	e01d      	b.n	800c3d8 <bufferBlockPushBytes+0x1f0>
            }
            block = block->next;
 800c39c:	69fb      	ldr	r3, [r7, #28]
 800c39e:	681b      	ldr	r3, [r3, #0]
 800c3a0:	61fb      	str	r3, [r7, #28]
            index_at_nth_block = 0;
 800c3a2:	2300      	movs	r3, #0
 800c3a4:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
            block = block->next;
        }
    }

    // add data to current block until it becomes full, add new block if necessary
    while (data_index < data_len)
 800c3a8:	78fb      	ldrb	r3, [r7, #3]
 800c3aa:	b29b      	uxth	r3, r3
 800c3ac:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800c3ae:	429a      	cmp	r2, r3
 800c3b0:	d3c7      	bcc.n	800c342 <bufferBlockPushBytes+0x15a>
            block = block->next;
            index_at_nth_block = 0;
        }
    }

    state->payload_len += data_len;
 800c3b2:	68bb      	ldr	r3, [r7, #8]
 800c3b4:	8b1b      	ldrh	r3, [r3, #24]
 800c3b6:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800c3ba:	b29b      	uxth	r3, r3
 800c3bc:	461a      	mov	r2, r3
 800c3be:	78fb      	ldrb	r3, [r7, #3]
 800c3c0:	b29b      	uxth	r3, r3
 800c3c2:	4413      	add	r3, r2
 800c3c4:	b29b      	uxth	r3, r3
 800c3c6:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800c3ca:	b299      	uxth	r1, r3
 800c3cc:	68ba      	ldr	r2, [r7, #8]
 800c3ce:	8b13      	ldrh	r3, [r2, #24]
 800c3d0:	f361 0309 	bfi	r3, r1, #0, #10
 800c3d4:	8313      	strh	r3, [r2, #24]

    return 1;
 800c3d6:	2301      	movs	r3, #1
}
 800c3d8:	4618      	mov	r0, r3
 800c3da:	3728      	adds	r7, #40	; 0x28
 800c3dc:	46bd      	mov	sp, r7
 800c3de:	bd80      	pop	{r7, pc}
 800c3e0:	24924925 	.word	0x24924925

0800c3e4 <createBufferBlock>:

CANARD_INTERNAL CanardBufferBlock* createBufferBlock(CanardPoolAllocator* allocator)
{
 800c3e4:	b580      	push	{r7, lr}
 800c3e6:	b084      	sub	sp, #16
 800c3e8:	af00      	add	r7, sp, #0
 800c3ea:	6078      	str	r0, [r7, #4]
    CanardBufferBlock* block = (CanardBufferBlock*) allocateBlock(allocator);
 800c3ec:	6878      	ldr	r0, [r7, #4]
 800c3ee:	f000 fa65 	bl	800c8bc <allocateBlock>
 800c3f2:	60f8      	str	r0, [r7, #12]
    if (block == NULL)
 800c3f4:	68fb      	ldr	r3, [r7, #12]
 800c3f6:	2b00      	cmp	r3, #0
 800c3f8:	d101      	bne.n	800c3fe <createBufferBlock+0x1a>
    {
        return NULL;
 800c3fa:	2300      	movs	r3, #0
 800c3fc:	e003      	b.n	800c406 <createBufferBlock+0x22>
    }
    block->next = NULL;
 800c3fe:	68fb      	ldr	r3, [r7, #12]
 800c400:	2200      	movs	r2, #0
 800c402:	601a      	str	r2, [r3, #0]
    return block;
 800c404:	68fb      	ldr	r3, [r7, #12]
}
 800c406:	4618      	mov	r0, r3
 800c408:	3710      	adds	r7, #16
 800c40a:	46bd      	mov	sp, r7
 800c40c:	bd80      	pop	{r7, pc}
 800c40e:	bf00      	nop

0800c410 <copyBitArray>:
/**
 * Bit array copy routine, originally developed by Ben Dyer for Libuavcan. Thanks Ben.
 */
void copyBitArray(const uint8_t* src, uint32_t src_offset, uint32_t src_len,
                        uint8_t* dst, uint32_t dst_offset)
{
 800c410:	b480      	push	{r7}
 800c412:	b089      	sub	sp, #36	; 0x24
 800c414:	af00      	add	r7, sp, #0
 800c416:	60f8      	str	r0, [r7, #12]
 800c418:	60b9      	str	r1, [r7, #8]
 800c41a:	607a      	str	r2, [r7, #4]
 800c41c:	603b      	str	r3, [r7, #0]
    CANARD_ASSERT(src_len > 0U);

    // Normalizing inputs
    src += src_offset / 8;
 800c41e:	68bb      	ldr	r3, [r7, #8]
 800c420:	08db      	lsrs	r3, r3, #3
 800c422:	68fa      	ldr	r2, [r7, #12]
 800c424:	4413      	add	r3, r2
 800c426:	60fb      	str	r3, [r7, #12]
    dst += dst_offset / 8;
 800c428:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c42a:	08db      	lsrs	r3, r3, #3
 800c42c:	683a      	ldr	r2, [r7, #0]
 800c42e:	4413      	add	r3, r2
 800c430:	603b      	str	r3, [r7, #0]

    src_offset %= 8;
 800c432:	68bb      	ldr	r3, [r7, #8]
 800c434:	f003 0307 	and.w	r3, r3, #7
 800c438:	60bb      	str	r3, [r7, #8]
    dst_offset %= 8;
 800c43a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c43c:	f003 0307 	and.w	r3, r3, #7
 800c440:	62bb      	str	r3, [r7, #40]	; 0x28

    const size_t last_bit = src_offset + src_len;
 800c442:	68ba      	ldr	r2, [r7, #8]
 800c444:	687b      	ldr	r3, [r7, #4]
 800c446:	4413      	add	r3, r2
 800c448:	61fb      	str	r3, [r7, #28]
 800c44a:	e051      	b.n	800c4f0 <copyBitArray+0xe0>
    while (last_bit - src_offset)
    {
        const uint8_t src_bit_offset = (uint8_t)(src_offset % 8U);
 800c44c:	68bb      	ldr	r3, [r7, #8]
 800c44e:	b2db      	uxtb	r3, r3
 800c450:	f003 0307 	and.w	r3, r3, #7
 800c454:	76fb      	strb	r3, [r7, #27]
        const uint8_t dst_bit_offset = (uint8_t)(dst_offset % 8U);
 800c456:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c458:	b2db      	uxtb	r3, r3
 800c45a:	f003 0307 	and.w	r3, r3, #7
 800c45e:	76bb      	strb	r3, [r7, #26]

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
 800c460:	7eba      	ldrb	r2, [r7, #26]
 800c462:	7efb      	ldrb	r3, [r7, #27]
 800c464:	4293      	cmp	r3, r2
 800c466:	bf38      	it	cc
 800c468:	4613      	movcc	r3, r2
 800c46a:	767b      	strb	r3, [r7, #25]
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);
 800c46c:	7e7b      	ldrb	r3, [r7, #25]
 800c46e:	f1c3 0208 	rsb	r2, r3, #8
 800c472:	69f9      	ldr	r1, [r7, #28]
 800c474:	68bb      	ldr	r3, [r7, #8]
 800c476:	1acb      	subs	r3, r1, r3
 800c478:	4293      	cmp	r3, r2
 800c47a:	bf28      	it	cs
 800c47c:	4613      	movcs	r3, r2
 800c47e:	617b      	str	r3, [r7, #20]

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
 800c480:	697b      	ldr	r3, [r7, #20]
 800c482:	f44f 427f 	mov.w	r2, #65280	; 0xff00
 800c486:	fa22 f303 	lsr.w	r3, r2, r3
 800c48a:	b2db      	uxtb	r3, r3
 800c48c:	461a      	mov	r2, r3
 800c48e:	7ebb      	ldrb	r3, [r7, #26]
 800c490:	fa42 f303 	asr.w	r3, r2, r3
 800c494:	74fb      	strb	r3, [r7, #19]
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);
 800c496:	68bb      	ldr	r3, [r7, #8]
 800c498:	08db      	lsrs	r3, r3, #3
 800c49a:	68fa      	ldr	r2, [r7, #12]
 800c49c:	4413      	add	r3, r2
 800c49e:	781b      	ldrb	r3, [r3, #0]
 800c4a0:	461a      	mov	r2, r3
 800c4a2:	7efb      	ldrb	r3, [r7, #27]
 800c4a4:	409a      	lsls	r2, r3
 800c4a6:	7ebb      	ldrb	r3, [r7, #26]
 800c4a8:	fa42 f303 	asr.w	r3, r2, r3
 800c4ac:	74bb      	strb	r3, [r7, #18]

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));
 800c4ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c4b0:	08db      	lsrs	r3, r3, #3
 800c4b2:	683a      	ldr	r2, [r7, #0]
 800c4b4:	4413      	add	r3, r2
 800c4b6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800c4b8:	08d2      	lsrs	r2, r2, #3
 800c4ba:	6839      	ldr	r1, [r7, #0]
 800c4bc:	440a      	add	r2, r1
 800c4be:	7812      	ldrb	r2, [r2, #0]
 800c4c0:	b2d1      	uxtb	r1, r2
 800c4c2:	7cfa      	ldrb	r2, [r7, #19]
 800c4c4:	43d2      	mvns	r2, r2
 800c4c6:	b2d2      	uxtb	r2, r2
 800c4c8:	400a      	ands	r2, r1
 800c4ca:	b2d0      	uxtb	r0, r2
 800c4cc:	7cb9      	ldrb	r1, [r7, #18]
 800c4ce:	7cfa      	ldrb	r2, [r7, #19]
 800c4d0:	400a      	ands	r2, r1
 800c4d2:	b2d2      	uxtb	r2, r2
 800c4d4:	b2d2      	uxtb	r2, r2
 800c4d6:	4601      	mov	r1, r0
 800c4d8:	430a      	orrs	r2, r1
 800c4da:	b2d2      	uxtb	r2, r2
 800c4dc:	b2d2      	uxtb	r2, r2
 800c4de:	701a      	strb	r2, [r3, #0]

        src_offset += copy_bits;
 800c4e0:	68ba      	ldr	r2, [r7, #8]
 800c4e2:	697b      	ldr	r3, [r7, #20]
 800c4e4:	4413      	add	r3, r2
 800c4e6:	60bb      	str	r3, [r7, #8]
        dst_offset += copy_bits;
 800c4e8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800c4ea:	697b      	ldr	r3, [r7, #20]
 800c4ec:	4413      	add	r3, r2
 800c4ee:	62bb      	str	r3, [r7, #40]	; 0x28

    src_offset %= 8;
    dst_offset %= 8;

    const size_t last_bit = src_offset + src_len;
    while (last_bit - src_offset)
 800c4f0:	69fa      	ldr	r2, [r7, #28]
 800c4f2:	68bb      	ldr	r3, [r7, #8]
 800c4f4:	429a      	cmp	r2, r3
 800c4f6:	d1a9      	bne.n	800c44c <copyBitArray+0x3c>
        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));

        src_offset += copy_bits;
        dst_offset += copy_bits;
    }
}
 800c4f8:	3724      	adds	r7, #36	; 0x24
 800c4fa:	46bd      	mov	sp, r7
 800c4fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c500:	4770      	bx	lr
 800c502:	bf00      	nop

0800c504 <descatterTransferPayload>:

CANARD_INTERNAL int descatterTransferPayload(const CanardRxTransfer* transfer,
                                             uint32_t bit_offset,
                                             uint8_t bit_length,
                                             void* output)
{
 800c504:	b580      	push	{r7, lr}
 800c506:	b090      	sub	sp, #64	; 0x40
 800c508:	af02      	add	r7, sp, #8
 800c50a:	60f8      	str	r0, [r7, #12]
 800c50c:	60b9      	str	r1, [r7, #8]
 800c50e:	603b      	str	r3, [r7, #0]
 800c510:	4613      	mov	r3, r2
 800c512:	71fb      	strb	r3, [r7, #7]
    CANARD_ASSERT(transfer != 0);

    if (bit_offset >= transfer->payload_len * 8)
 800c514:	68fb      	ldr	r3, [r7, #12]
 800c516:	8a9b      	ldrh	r3, [r3, #20]
 800c518:	00db      	lsls	r3, r3, #3
 800c51a:	461a      	mov	r2, r3
 800c51c:	68bb      	ldr	r3, [r7, #8]
 800c51e:	429a      	cmp	r2, r3
 800c520:	d801      	bhi.n	800c526 <descatterTransferPayload+0x22>
    {
        return 0;       // Out of range, reading zero bits
 800c522:	2300      	movs	r3, #0
 800c524:	e0da      	b.n	800c6dc <descatterTransferPayload+0x1d8>
    }

    if (bit_offset + bit_length > transfer->payload_len * 8)
 800c526:	79fa      	ldrb	r2, [r7, #7]
 800c528:	68bb      	ldr	r3, [r7, #8]
 800c52a:	4413      	add	r3, r2
 800c52c:	68fa      	ldr	r2, [r7, #12]
 800c52e:	8a92      	ldrh	r2, [r2, #20]
 800c530:	00d2      	lsls	r2, r2, #3
 800c532:	4293      	cmp	r3, r2
 800c534:	d908      	bls.n	800c548 <descatterTransferPayload+0x44>
    {
        bit_length = (uint8_t)(transfer->payload_len * 8 - bit_offset);
 800c536:	68fb      	ldr	r3, [r7, #12]
 800c538:	8a9b      	ldrh	r3, [r3, #20]
 800c53a:	b2db      	uxtb	r3, r3
 800c53c:	00db      	lsls	r3, r3, #3
 800c53e:	b2da      	uxtb	r2, r3
 800c540:	68bb      	ldr	r3, [r7, #8]
 800c542:	b2db      	uxtb	r3, r3
 800c544:	1ad3      	subs	r3, r2, r3
 800c546:	71fb      	strb	r3, [r7, #7]
    }

    CANARD_ASSERT(bit_length > 0);

    if ((transfer->payload_middle != NULL) || (transfer->payload_tail != NULL)) // Multi frame
 800c548:	68fb      	ldr	r3, [r7, #12]
 800c54a:	68db      	ldr	r3, [r3, #12]
 800c54c:	2b00      	cmp	r3, #0
 800c54e:	d104      	bne.n	800c55a <descatterTransferPayload+0x56>
 800c550:	68fb      	ldr	r3, [r7, #12]
 800c552:	691b      	ldr	r3, [r3, #16]
 800c554:	2b00      	cmp	r3, #0
 800c556:	f000 80b6 	beq.w	800c6c6 <descatterTransferPayload+0x1c2>
        /*
         * This part is hideously complicated and probably should be redesigned.
         * The objective here is to copy the requested number of bits from scattered storage into the temporary
         * local storage. We go through great pains to ensure that all corner cases are handled correctly.
         */
        uint32_t input_bit_offset = bit_offset;
 800c55a:	68bb      	ldr	r3, [r7, #8]
 800c55c:	637b      	str	r3, [r7, #52]	; 0x34
        uint8_t output_bit_offset = 0;
 800c55e:	2300      	movs	r3, #0
 800c560:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
        uint8_t remaining_bit_length = bit_length;
 800c564:	79fb      	ldrb	r3, [r7, #7]
 800c566:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32

        // Reading head
        if (input_bit_offset < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8)
 800c56a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c56c:	2b2f      	cmp	r3, #47	; 0x2f
 800c56e:	d827      	bhi.n	800c5c0 <descatterTransferPayload+0xbc>
        {
            const uint8_t amount = MIN(remaining_bit_length,
 800c570:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c572:	f1c3 0230 	rsb	r2, r3, #48	; 0x30
 800c576:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800c57a:	4293      	cmp	r3, r2
 800c57c:	bf28      	it	cs
 800c57e:	4613      	movcs	r3, r2
 800c580:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
                                       CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8U - input_bit_offset);

            copyBitArray(&transfer->payload_head[0], input_bit_offset, amount, (uint8_t*) output, 0);
 800c584:	68fb      	ldr	r3, [r7, #12]
 800c586:	6899      	ldr	r1, [r3, #8]
 800c588:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 800c58c:	2300      	movs	r3, #0
 800c58e:	9300      	str	r3, [sp, #0]
 800c590:	4608      	mov	r0, r1
 800c592:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800c594:	683b      	ldr	r3, [r7, #0]
 800c596:	f7ff ff3b 	bl	800c410 <copyBitArray>

            input_bit_offset += amount;
 800c59a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800c59e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800c5a0:	4413      	add	r3, r2
 800c5a2:	637b      	str	r3, [r7, #52]	; 0x34
            output_bit_offset += amount;
 800c5a4:	f897 2033 	ldrb.w	r2, [r7, #51]	; 0x33
 800c5a8:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800c5ac:	4413      	add	r3, r2
 800c5ae:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
            remaining_bit_length -= amount;
 800c5b2:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 800c5b6:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800c5ba:	1ad3      	subs	r3, r2, r3
 800c5bc:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
        }

        // Reading middle
        uint32_t remaining_bits = transfer->payload_len * 8U - CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8U;
 800c5c0:	68fb      	ldr	r3, [r7, #12]
 800c5c2:	8a9b      	ldrh	r3, [r3, #20]
 800c5c4:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800c5c8:	3b06      	subs	r3, #6
 800c5ca:	00db      	lsls	r3, r3, #3
 800c5cc:	62fb      	str	r3, [r7, #44]	; 0x2c
        uint32_t block_bit_offset = CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8U;
 800c5ce:	2330      	movs	r3, #48	; 0x30
 800c5d0:	62bb      	str	r3, [r7, #40]	; 0x28
        const CanardBufferBlock* block = transfer->payload_middle;
 800c5d2:	68fb      	ldr	r3, [r7, #12]
 800c5d4:	68db      	ldr	r3, [r3, #12]
 800c5d6:	627b      	str	r3, [r7, #36]	; 0x24
 800c5d8:	e046      	b.n	800c668 <descatterTransferPayload+0x164>

        while ((block != NULL) && (remaining_bit_length > 0))
        {
            CANARD_ASSERT(remaining_bits > 0);
            const uint32_t block_end_bit_offset = block_bit_offset + MIN(CANARD_BUFFER_BLOCK_DATA_SIZE * 8,
 800c5da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c5dc:	2be0      	cmp	r3, #224	; 0xe0
 800c5de:	bf28      	it	cs
 800c5e0:	23e0      	movcs	r3, #224	; 0xe0
 800c5e2:	461a      	mov	r2, r3
 800c5e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c5e6:	4413      	add	r3, r2
 800c5e8:	61fb      	str	r3, [r7, #28]
                                                                         remaining_bits);

            // Perform copy if we've reached the requested offset, otherwise jump over this block and try next
            if (block_end_bit_offset > input_bit_offset)
 800c5ea:	69fa      	ldr	r2, [r7, #28]
 800c5ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c5ee:	429a      	cmp	r2, r3
 800c5f0:	d92f      	bls.n	800c652 <descatterTransferPayload+0x14e>
            {
                const uint8_t amount = (uint8_t) MIN(remaining_bit_length, block_end_bit_offset - input_bit_offset);
 800c5f2:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 800c5f6:	69f9      	ldr	r1, [r7, #28]
 800c5f8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c5fa:	1acb      	subs	r3, r1, r3
 800c5fc:	429a      	cmp	r2, r3
 800c5fe:	d306      	bcc.n	800c60e <descatterTransferPayload+0x10a>
 800c600:	69fb      	ldr	r3, [r7, #28]
 800c602:	b2da      	uxtb	r2, r3
 800c604:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c606:	b2db      	uxtb	r3, r3
 800c608:	1ad3      	subs	r3, r2, r3
 800c60a:	b2db      	uxtb	r3, r3
 800c60c:	e001      	b.n	800c612 <descatterTransferPayload+0x10e>
 800c60e:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800c612:	76fb      	strb	r3, [r7, #27]

                CANARD_ASSERT(input_bit_offset >= block_bit_offset);
                const uint32_t bit_offset_within_block = input_bit_offset - block_bit_offset;
 800c614:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800c616:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c618:	1ad3      	subs	r3, r2, r3
 800c61a:	617b      	str	r3, [r7, #20]

                copyBitArray(&block->data[0], bit_offset_within_block, amount, (uint8_t*) output, output_bit_offset);
 800c61c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c61e:	1d19      	adds	r1, r3, #4
 800c620:	7efa      	ldrb	r2, [r7, #27]
 800c622:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800c626:	9300      	str	r3, [sp, #0]
 800c628:	4608      	mov	r0, r1
 800c62a:	6979      	ldr	r1, [r7, #20]
 800c62c:	683b      	ldr	r3, [r7, #0]
 800c62e:	f7ff feef 	bl	800c410 <copyBitArray>

                input_bit_offset += amount;
 800c632:	7efb      	ldrb	r3, [r7, #27]
 800c634:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800c636:	4413      	add	r3, r2
 800c638:	637b      	str	r3, [r7, #52]	; 0x34
                output_bit_offset += amount;
 800c63a:	f897 2033 	ldrb.w	r2, [r7, #51]	; 0x33
 800c63e:	7efb      	ldrb	r3, [r7, #27]
 800c640:	4413      	add	r3, r2
 800c642:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
                remaining_bit_length -= amount;
 800c646:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 800c64a:	7efb      	ldrb	r3, [r7, #27]
 800c64c:	1ad3      	subs	r3, r2, r3
 800c64e:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
            }

            CANARD_ASSERT(block_end_bit_offset > block_bit_offset);
            remaining_bits -= block_end_bit_offset - block_bit_offset;
 800c652:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800c654:	69fb      	ldr	r3, [r7, #28]
 800c656:	1ad3      	subs	r3, r2, r3
 800c658:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c65a:	4413      	add	r3, r2
 800c65c:	62fb      	str	r3, [r7, #44]	; 0x2c
            block_bit_offset = block_end_bit_offset;
 800c65e:	69fb      	ldr	r3, [r7, #28]
 800c660:	62bb      	str	r3, [r7, #40]	; 0x28
            block = block->next;
 800c662:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c664:	681b      	ldr	r3, [r3, #0]
 800c666:	627b      	str	r3, [r7, #36]	; 0x24
        // Reading middle
        uint32_t remaining_bits = transfer->payload_len * 8U - CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8U;
        uint32_t block_bit_offset = CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8U;
        const CanardBufferBlock* block = transfer->payload_middle;

        while ((block != NULL) && (remaining_bit_length > 0))
 800c668:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c66a:	2b00      	cmp	r3, #0
 800c66c:	d003      	beq.n	800c676 <descatterTransferPayload+0x172>
 800c66e:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800c672:	2b00      	cmp	r3, #0
 800c674:	d1b1      	bne.n	800c5da <descatterTransferPayload+0xd6>
        }

        CANARD_ASSERT(remaining_bit_length <= remaining_bits);

        // Reading tail
        if ((transfer->payload_tail != NULL) && (remaining_bit_length > 0))
 800c676:	68fb      	ldr	r3, [r7, #12]
 800c678:	691b      	ldr	r3, [r3, #16]
 800c67a:	2b00      	cmp	r3, #0
 800c67c:	d02d      	beq.n	800c6da <descatterTransferPayload+0x1d6>
 800c67e:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800c682:	2b00      	cmp	r3, #0
 800c684:	d029      	beq.n	800c6da <descatterTransferPayload+0x1d6>
        {
            CANARD_ASSERT(input_bit_offset >= block_bit_offset);
            const uint32_t offset = input_bit_offset - block_bit_offset;
 800c686:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800c688:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c68a:	1ad3      	subs	r3, r2, r3
 800c68c:	613b      	str	r3, [r7, #16]

            copyBitArray(&transfer->payload_tail[0], offset, remaining_bit_length, (uint8_t*) output,
 800c68e:	68fb      	ldr	r3, [r7, #12]
 800c690:	6919      	ldr	r1, [r3, #16]
 800c692:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 800c696:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800c69a:	9300      	str	r3, [sp, #0]
 800c69c:	4608      	mov	r0, r1
 800c69e:	6939      	ldr	r1, [r7, #16]
 800c6a0:	683b      	ldr	r3, [r7, #0]
 800c6a2:	f7ff feb5 	bl	800c410 <copyBitArray>
                         output_bit_offset);

            input_bit_offset += remaining_bit_length;
 800c6a6:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800c6aa:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800c6ac:	4413      	add	r3, r2
 800c6ae:	637b      	str	r3, [r7, #52]	; 0x34
            output_bit_offset += remaining_bit_length;
 800c6b0:	f897 2033 	ldrb.w	r2, [r7, #51]	; 0x33
 800c6b4:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800c6b8:	4413      	add	r3, r2
 800c6ba:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
            remaining_bit_length = 0;
 800c6be:	2300      	movs	r3, #0
 800c6c0:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
 800c6c4:	e009      	b.n	800c6da <descatterTransferPayload+0x1d6>
        CANARD_ASSERT(output_bit_offset <= 64);
        CANARD_ASSERT(remaining_bit_length == 0);
    }
    else                                                                    // Single frame
    {
        copyBitArray(&transfer->payload_head[0], bit_offset, bit_length, (uint8_t*) output, 0);
 800c6c6:	68fb      	ldr	r3, [r7, #12]
 800c6c8:	6899      	ldr	r1, [r3, #8]
 800c6ca:	79fa      	ldrb	r2, [r7, #7]
 800c6cc:	2300      	movs	r3, #0
 800c6ce:	9300      	str	r3, [sp, #0]
 800c6d0:	4608      	mov	r0, r1
 800c6d2:	68b9      	ldr	r1, [r7, #8]
 800c6d4:	683b      	ldr	r3, [r7, #0]
 800c6d6:	f7ff fe9b 	bl	800c410 <copyBitArray>
    }

    return bit_length;
 800c6da:	79fb      	ldrb	r3, [r7, #7]
}
 800c6dc:	4618      	mov	r0, r3
 800c6de:	3738      	adds	r7, #56	; 0x38
 800c6e0:	46bd      	mov	sp, r7
 800c6e2:	bd80      	pop	{r7, pc}

0800c6e4 <isBigEndian>:

CANARD_INTERNAL bool isBigEndian(void)
{
 800c6e4:	b480      	push	{r7}
 800c6e6:	b083      	sub	sp, #12
 800c6e8:	af00      	add	r7, sp, #0
    union
    {
        uint16_t a;
        uint8_t b[2];
    } u;
    u.a = 1;
 800c6ea:	2301      	movs	r3, #1
 800c6ec:	80bb      	strh	r3, [r7, #4]
    return u.b[1] == 1;                             // Some don't...
 800c6ee:	797b      	ldrb	r3, [r7, #5]
 800c6f0:	2b01      	cmp	r3, #1
 800c6f2:	bf0c      	ite	eq
 800c6f4:	2301      	moveq	r3, #1
 800c6f6:	2300      	movne	r3, #0
 800c6f8:	b2db      	uxtb	r3, r3
#endif
}
 800c6fa:	4618      	mov	r0, r3
 800c6fc:	370c      	adds	r7, #12
 800c6fe:	46bd      	mov	sp, r7
 800c700:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c704:	4770      	bx	lr
 800c706:	bf00      	nop

0800c708 <swapByteOrder>:

CANARD_INTERNAL void swapByteOrder(void* data, unsigned size)
{
 800c708:	b480      	push	{r7}
 800c70a:	b087      	sub	sp, #28
 800c70c:	af00      	add	r7, sp, #0
 800c70e:	6078      	str	r0, [r7, #4]
 800c710:	6039      	str	r1, [r7, #0]
    CANARD_ASSERT(data != NULL);

    uint8_t* const bytes = (uint8_t*) data;
 800c712:	687b      	ldr	r3, [r7, #4]
 800c714:	60fb      	str	r3, [r7, #12]

    unsigned fwd = 0;
 800c716:	2300      	movs	r3, #0
 800c718:	617b      	str	r3, [r7, #20]
    unsigned rev = size - 1;
 800c71a:	683b      	ldr	r3, [r7, #0]
 800c71c:	3b01      	subs	r3, #1
 800c71e:	613b      	str	r3, [r7, #16]
 800c720:	e017      	b.n	800c752 <swapByteOrder+0x4a>

    while (fwd < rev)
    {
        const uint8_t x = bytes[fwd];
 800c722:	68fa      	ldr	r2, [r7, #12]
 800c724:	697b      	ldr	r3, [r7, #20]
 800c726:	4413      	add	r3, r2
 800c728:	781b      	ldrb	r3, [r3, #0]
 800c72a:	72fb      	strb	r3, [r7, #11]
        bytes[fwd] = bytes[rev];
 800c72c:	68fa      	ldr	r2, [r7, #12]
 800c72e:	697b      	ldr	r3, [r7, #20]
 800c730:	4413      	add	r3, r2
 800c732:	68f9      	ldr	r1, [r7, #12]
 800c734:	693a      	ldr	r2, [r7, #16]
 800c736:	440a      	add	r2, r1
 800c738:	7812      	ldrb	r2, [r2, #0]
 800c73a:	701a      	strb	r2, [r3, #0]
        bytes[rev] = x;
 800c73c:	68fa      	ldr	r2, [r7, #12]
 800c73e:	693b      	ldr	r3, [r7, #16]
 800c740:	4413      	add	r3, r2
 800c742:	7afa      	ldrb	r2, [r7, #11]
 800c744:	701a      	strb	r2, [r3, #0]
        fwd++;
 800c746:	697b      	ldr	r3, [r7, #20]
 800c748:	3301      	adds	r3, #1
 800c74a:	617b      	str	r3, [r7, #20]
        rev--;
 800c74c:	693b      	ldr	r3, [r7, #16]
 800c74e:	3b01      	subs	r3, #1
 800c750:	613b      	str	r3, [r7, #16]
    uint8_t* const bytes = (uint8_t*) data;

    unsigned fwd = 0;
    unsigned rev = size - 1;

    while (fwd < rev)
 800c752:	697a      	ldr	r2, [r7, #20]
 800c754:	693b      	ldr	r3, [r7, #16]
 800c756:	429a      	cmp	r2, r3
 800c758:	d3e3      	bcc.n	800c722 <swapByteOrder+0x1a>
        bytes[fwd] = bytes[rev];
        bytes[rev] = x;
        fwd++;
        rev--;
    }
}
 800c75a:	371c      	adds	r7, #28
 800c75c:	46bd      	mov	sp, r7
 800c75e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c762:	4770      	bx	lr

0800c764 <crcAddByte>:

/*
 * CRC functions
 */
CANARD_INTERNAL uint16_t crcAddByte(uint16_t crc_val, uint8_t byte)
{
 800c764:	b480      	push	{r7}
 800c766:	b085      	sub	sp, #20
 800c768:	af00      	add	r7, sp, #0
 800c76a:	4603      	mov	r3, r0
 800c76c:	460a      	mov	r2, r1
 800c76e:	80fb      	strh	r3, [r7, #6]
 800c770:	4613      	mov	r3, r2
 800c772:	717b      	strb	r3, [r7, #5]
    crc_val ^= (uint16_t) ((uint16_t) (byte) << 8);
 800c774:	797b      	ldrb	r3, [r7, #5]
 800c776:	b29b      	uxth	r3, r3
 800c778:	021b      	lsls	r3, r3, #8
 800c77a:	b29a      	uxth	r2, r3
 800c77c:	88fb      	ldrh	r3, [r7, #6]
 800c77e:	4053      	eors	r3, r2
 800c780:	80fb      	strh	r3, [r7, #6]
    for (int j = 0; j < 8; j++)
 800c782:	2300      	movs	r3, #0
 800c784:	60fb      	str	r3, [r7, #12]
 800c786:	e012      	b.n	800c7ae <crcAddByte+0x4a>
    {
        if (crc_val & 0x8000U)
 800c788:	88fb      	ldrh	r3, [r7, #6]
 800c78a:	b21b      	sxth	r3, r3
 800c78c:	2b00      	cmp	r3, #0
 800c78e:	da08      	bge.n	800c7a2 <crcAddByte+0x3e>
        {
            crc_val = (uint16_t) ((uint16_t) (crc_val << 1) ^ 0x1021U);
 800c790:	88fb      	ldrh	r3, [r7, #6]
 800c792:	005b      	lsls	r3, r3, #1
 800c794:	b29b      	uxth	r3, r3
 800c796:	f483 5381 	eor.w	r3, r3, #4128	; 0x1020
 800c79a:	f083 0301 	eor.w	r3, r3, #1
 800c79e:	80fb      	strh	r3, [r7, #6]
 800c7a0:	e002      	b.n	800c7a8 <crcAddByte+0x44>
        }
        else
        {
            crc_val = (uint16_t) (crc_val << 1);
 800c7a2:	88fb      	ldrh	r3, [r7, #6]
 800c7a4:	005b      	lsls	r3, r3, #1
 800c7a6:	80fb      	strh	r3, [r7, #6]
 * CRC functions
 */
CANARD_INTERNAL uint16_t crcAddByte(uint16_t crc_val, uint8_t byte)
{
    crc_val ^= (uint16_t) ((uint16_t) (byte) << 8);
    for (int j = 0; j < 8; j++)
 800c7a8:	68fb      	ldr	r3, [r7, #12]
 800c7aa:	3301      	adds	r3, #1
 800c7ac:	60fb      	str	r3, [r7, #12]
 800c7ae:	68fb      	ldr	r3, [r7, #12]
 800c7b0:	2b07      	cmp	r3, #7
 800c7b2:	dde9      	ble.n	800c788 <crcAddByte+0x24>
        else
        {
            crc_val = (uint16_t) (crc_val << 1);
        }
    }
    return crc_val;
 800c7b4:	88fb      	ldrh	r3, [r7, #6]
}
 800c7b6:	4618      	mov	r0, r3
 800c7b8:	3714      	adds	r7, #20
 800c7ba:	46bd      	mov	sp, r7
 800c7bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7c0:	4770      	bx	lr
 800c7c2:	bf00      	nop

0800c7c4 <crcAddSignature>:

CANARD_INTERNAL uint16_t crcAddSignature(uint16_t crc_val, uint64_t data_type_signature)
{
 800c7c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c7c6:	b087      	sub	sp, #28
 800c7c8:	af00      	add	r7, sp, #0
 800c7ca:	4601      	mov	r1, r0
 800c7cc:	e9c7 2300 	strd	r2, r3, [r7]
 800c7d0:	460b      	mov	r3, r1
 800c7d2:	81fb      	strh	r3, [r7, #14]
    for (int shift_val = 0; shift_val < 64; shift_val += 8)
 800c7d4:	2300      	movs	r3, #0
 800c7d6:	617b      	str	r3, [r7, #20]
 800c7d8:	e01b      	b.n	800c812 <crcAddSignature+0x4e>
    {
        crc_val = crcAddByte(crc_val, (uint8_t) (data_type_signature >> shift_val));
 800c7da:	e9d7 2300 	ldrd	r2, r3, [r7]
 800c7de:	6979      	ldr	r1, [r7, #20]
 800c7e0:	f1c1 0620 	rsb	r6, r1, #32
 800c7e4:	f1a1 0020 	sub.w	r0, r1, #32
 800c7e8:	fa22 f401 	lsr.w	r4, r2, r1
 800c7ec:	fa03 f606 	lsl.w	r6, r3, r6
 800c7f0:	4334      	orrs	r4, r6
 800c7f2:	fa23 f000 	lsr.w	r0, r3, r0
 800c7f6:	4304      	orrs	r4, r0
 800c7f8:	fa23 f501 	lsr.w	r5, r3, r1
 800c7fc:	b2e3      	uxtb	r3, r4
 800c7fe:	89fa      	ldrh	r2, [r7, #14]
 800c800:	4610      	mov	r0, r2
 800c802:	4619      	mov	r1, r3
 800c804:	f7ff ffae 	bl	800c764 <crcAddByte>
 800c808:	4603      	mov	r3, r0
 800c80a:	81fb      	strh	r3, [r7, #14]
    return crc_val;
}

CANARD_INTERNAL uint16_t crcAddSignature(uint16_t crc_val, uint64_t data_type_signature)
{
    for (int shift_val = 0; shift_val < 64; shift_val += 8)
 800c80c:	697b      	ldr	r3, [r7, #20]
 800c80e:	3308      	adds	r3, #8
 800c810:	617b      	str	r3, [r7, #20]
 800c812:	697b      	ldr	r3, [r7, #20]
 800c814:	2b3f      	cmp	r3, #63	; 0x3f
 800c816:	dde0      	ble.n	800c7da <crcAddSignature+0x16>
    {
        crc_val = crcAddByte(crc_val, (uint8_t) (data_type_signature >> shift_val));
    }
    return crc_val;
 800c818:	89fb      	ldrh	r3, [r7, #14]
}
 800c81a:	4618      	mov	r0, r3
 800c81c:	371c      	adds	r7, #28
 800c81e:	46bd      	mov	sp, r7
 800c820:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c822:	bf00      	nop

0800c824 <crcAdd>:

CANARD_INTERNAL uint16_t crcAdd(uint16_t crc_val, const uint8_t* bytes, size_t len)
{
 800c824:	b580      	push	{r7, lr}
 800c826:	b084      	sub	sp, #16
 800c828:	af00      	add	r7, sp, #0
 800c82a:	4603      	mov	r3, r0
 800c82c:	60b9      	str	r1, [r7, #8]
 800c82e:	607a      	str	r2, [r7, #4]
 800c830:	81fb      	strh	r3, [r7, #14]
 800c832:	e00a      	b.n	800c84a <crcAdd+0x26>
    while (len--)
    {
        crc_val = crcAddByte(crc_val, *bytes++);
 800c834:	68bb      	ldr	r3, [r7, #8]
 800c836:	1c5a      	adds	r2, r3, #1
 800c838:	60ba      	str	r2, [r7, #8]
 800c83a:	781b      	ldrb	r3, [r3, #0]
 800c83c:	89fa      	ldrh	r2, [r7, #14]
 800c83e:	4610      	mov	r0, r2
 800c840:	4619      	mov	r1, r3
 800c842:	f7ff ff8f 	bl	800c764 <crcAddByte>
 800c846:	4603      	mov	r3, r0
 800c848:	81fb      	strh	r3, [r7, #14]
    return crc_val;
}

CANARD_INTERNAL uint16_t crcAdd(uint16_t crc_val, const uint8_t* bytes, size_t len)
{
    while (len--)
 800c84a:	687b      	ldr	r3, [r7, #4]
 800c84c:	1e5a      	subs	r2, r3, #1
 800c84e:	607a      	str	r2, [r7, #4]
 800c850:	2b00      	cmp	r3, #0
 800c852:	d1ef      	bne.n	800c834 <crcAdd+0x10>
    {
        crc_val = crcAddByte(crc_val, *bytes++);
    }
    return crc_val;
 800c854:	89fb      	ldrh	r3, [r7, #14]
}
 800c856:	4618      	mov	r0, r3
 800c858:	3710      	adds	r7, #16
 800c85a:	46bd      	mov	sp, r7
 800c85c:	bd80      	pop	{r7, pc}
 800c85e:	bf00      	nop

0800c860 <initPoolAllocator>:
 *  Pool Allocator functions
 */
CANARD_INTERNAL void initPoolAllocator(CanardPoolAllocator* allocator,
                                       CanardPoolAllocatorBlock* buf,
                                       uint16_t buf_len)
{
 800c860:	b480      	push	{r7}
 800c862:	b087      	sub	sp, #28
 800c864:	af00      	add	r7, sp, #0
 800c866:	60f8      	str	r0, [r7, #12]
 800c868:	60b9      	str	r1, [r7, #8]
 800c86a:	4613      	mov	r3, r2
 800c86c:	80fb      	strh	r3, [r7, #6]
    size_t current_index = 0;
 800c86e:	2300      	movs	r3, #0
 800c870:	617b      	str	r3, [r7, #20]
    CanardPoolAllocatorBlock** current_block = &(allocator->free_list);
 800c872:	68fb      	ldr	r3, [r7, #12]
 800c874:	613b      	str	r3, [r7, #16]
 800c876:	e00b      	b.n	800c890 <initPoolAllocator+0x30>
    while (current_index < buf_len)
    {
        *current_block = &buf[current_index];
 800c878:	697b      	ldr	r3, [r7, #20]
 800c87a:	015b      	lsls	r3, r3, #5
 800c87c:	68ba      	ldr	r2, [r7, #8]
 800c87e:	441a      	add	r2, r3
 800c880:	693b      	ldr	r3, [r7, #16]
 800c882:	601a      	str	r2, [r3, #0]
        current_block = &((*current_block)->next);
 800c884:	693b      	ldr	r3, [r7, #16]
 800c886:	681b      	ldr	r3, [r3, #0]
 800c888:	613b      	str	r3, [r7, #16]
        current_index++;
 800c88a:	697b      	ldr	r3, [r7, #20]
 800c88c:	3301      	adds	r3, #1
 800c88e:	617b      	str	r3, [r7, #20]
                                       CanardPoolAllocatorBlock* buf,
                                       uint16_t buf_len)
{
    size_t current_index = 0;
    CanardPoolAllocatorBlock** current_block = &(allocator->free_list);
    while (current_index < buf_len)
 800c890:	88fa      	ldrh	r2, [r7, #6]
 800c892:	697b      	ldr	r3, [r7, #20]
 800c894:	429a      	cmp	r2, r3
 800c896:	d8ef      	bhi.n	800c878 <initPoolAllocator+0x18>
    {
        *current_block = &buf[current_index];
        current_block = &((*current_block)->next);
        current_index++;
    }
    *current_block = NULL;
 800c898:	693b      	ldr	r3, [r7, #16]
 800c89a:	2200      	movs	r2, #0
 800c89c:	601a      	str	r2, [r3, #0]

    allocator->statistics.capacity_blocks = buf_len;
 800c89e:	68fb      	ldr	r3, [r7, #12]
 800c8a0:	88fa      	ldrh	r2, [r7, #6]
 800c8a2:	809a      	strh	r2, [r3, #4]
    allocator->statistics.current_usage_blocks = 0;
 800c8a4:	68fb      	ldr	r3, [r7, #12]
 800c8a6:	2200      	movs	r2, #0
 800c8a8:	80da      	strh	r2, [r3, #6]
    allocator->statistics.peak_usage_blocks = 0;
 800c8aa:	68fb      	ldr	r3, [r7, #12]
 800c8ac:	2200      	movs	r2, #0
 800c8ae:	811a      	strh	r2, [r3, #8]
}
 800c8b0:	371c      	adds	r7, #28
 800c8b2:	46bd      	mov	sp, r7
 800c8b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c8b8:	4770      	bx	lr
 800c8ba:	bf00      	nop

0800c8bc <allocateBlock>:

CANARD_INTERNAL void* allocateBlock(CanardPoolAllocator* allocator)
{
 800c8bc:	b480      	push	{r7}
 800c8be:	b085      	sub	sp, #20
 800c8c0:	af00      	add	r7, sp, #0
 800c8c2:	6078      	str	r0, [r7, #4]
    // Check if there are any blocks available in the free list.
    if (allocator->free_list == NULL)
 800c8c4:	687b      	ldr	r3, [r7, #4]
 800c8c6:	681b      	ldr	r3, [r3, #0]
 800c8c8:	2b00      	cmp	r3, #0
 800c8ca:	d101      	bne.n	800c8d0 <allocateBlock+0x14>
    {
        return NULL;
 800c8cc:	2300      	movs	r3, #0
 800c8ce:	e018      	b.n	800c902 <allocateBlock+0x46>
    }

    // Take first available block and prepares next block for use.
    void* result = allocator->free_list;
 800c8d0:	687b      	ldr	r3, [r7, #4]
 800c8d2:	681b      	ldr	r3, [r3, #0]
 800c8d4:	60fb      	str	r3, [r7, #12]
    allocator->free_list = allocator->free_list->next;
 800c8d6:	687b      	ldr	r3, [r7, #4]
 800c8d8:	681b      	ldr	r3, [r3, #0]
 800c8da:	681a      	ldr	r2, [r3, #0]
 800c8dc:	687b      	ldr	r3, [r7, #4]
 800c8de:	601a      	str	r2, [r3, #0]

    // Update statistics
    allocator->statistics.current_usage_blocks++;
 800c8e0:	687b      	ldr	r3, [r7, #4]
 800c8e2:	88db      	ldrh	r3, [r3, #6]
 800c8e4:	3301      	adds	r3, #1
 800c8e6:	b29a      	uxth	r2, r3
 800c8e8:	687b      	ldr	r3, [r7, #4]
 800c8ea:	80da      	strh	r2, [r3, #6]
    if (allocator->statistics.peak_usage_blocks < allocator->statistics.current_usage_blocks)
 800c8ec:	687b      	ldr	r3, [r7, #4]
 800c8ee:	891a      	ldrh	r2, [r3, #8]
 800c8f0:	687b      	ldr	r3, [r7, #4]
 800c8f2:	88db      	ldrh	r3, [r3, #6]
 800c8f4:	429a      	cmp	r2, r3
 800c8f6:	d203      	bcs.n	800c900 <allocateBlock+0x44>
    {
        allocator->statistics.peak_usage_blocks = allocator->statistics.current_usage_blocks;
 800c8f8:	687b      	ldr	r3, [r7, #4]
 800c8fa:	88da      	ldrh	r2, [r3, #6]
 800c8fc:	687b      	ldr	r3, [r7, #4]
 800c8fe:	811a      	strh	r2, [r3, #8]
    }

    return result;
 800c900:	68fb      	ldr	r3, [r7, #12]
}
 800c902:	4618      	mov	r0, r3
 800c904:	3714      	adds	r7, #20
 800c906:	46bd      	mov	sp, r7
 800c908:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c90c:	4770      	bx	lr
 800c90e:	bf00      	nop

0800c910 <freeBlock>:

CANARD_INTERNAL void freeBlock(CanardPoolAllocator* allocator, void* p)
{
 800c910:	b480      	push	{r7}
 800c912:	b085      	sub	sp, #20
 800c914:	af00      	add	r7, sp, #0
 800c916:	6078      	str	r0, [r7, #4]
 800c918:	6039      	str	r1, [r7, #0]
    CanardPoolAllocatorBlock* block = (CanardPoolAllocatorBlock*) p;
 800c91a:	683b      	ldr	r3, [r7, #0]
 800c91c:	60fb      	str	r3, [r7, #12]

    block->next = allocator->free_list;
 800c91e:	687b      	ldr	r3, [r7, #4]
 800c920:	681a      	ldr	r2, [r3, #0]
 800c922:	68fb      	ldr	r3, [r7, #12]
 800c924:	601a      	str	r2, [r3, #0]
    allocator->free_list = block;
 800c926:	687b      	ldr	r3, [r7, #4]
 800c928:	68fa      	ldr	r2, [r7, #12]
 800c92a:	601a      	str	r2, [r3, #0]

    CANARD_ASSERT(allocator->statistics.current_usage_blocks > 0);
    allocator->statistics.current_usage_blocks--;
 800c92c:	687b      	ldr	r3, [r7, #4]
 800c92e:	88db      	ldrh	r3, [r3, #6]
 800c930:	3b01      	subs	r3, #1
 800c932:	b29a      	uxth	r2, r3
 800c934:	687b      	ldr	r3, [r7, #4]
 800c936:	80da      	strh	r2, [r3, #6]
}
 800c938:	3714      	adds	r7, #20
 800c93a:	46bd      	mov	sp, r7
 800c93c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c940:	4770      	bx	lr
 800c942:	bf00      	nop

0800c944 <encode_func.lto_priv.32>:
#include <uavcan.protocol.NodeStatus.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800c944:	b580      	push	{r7, lr}
 800c946:	b084      	sub	sp, #16
 800c948:	af00      	add	r7, sp, #0
 800c94a:	60f8      	str	r0, [r7, #12]
 800c94c:	60b9      	str	r1, [r7, #8]
 800c94e:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_NodeStatus(msg, chunk_cb, ctx);
 800c950:	68f8      	ldr	r0, [r7, #12]
 800c952:	68b9      	ldr	r1, [r7, #8]
 800c954:	687a      	ldr	r2, [r7, #4]
 800c956:	f000 f811 	bl	800c97c <encode_uavcan_protocol_NodeStatus>
}
 800c95a:	3710      	adds	r7, #16
 800c95c:	46bd      	mov	sp, r7
 800c95e:	bd80      	pop	{r7, pc}

0800c960 <decode_func.lto_priv.39>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800c960:	b580      	push	{r7, lr}
 800c962:	b082      	sub	sp, #8
 800c964:	af00      	add	r7, sp, #0
 800c966:	6078      	str	r0, [r7, #4]
 800c968:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_NodeStatus(transfer, msg);
 800c96a:	6878      	ldr	r0, [r7, #4]
 800c96c:	6839      	ldr	r1, [r7, #0]
 800c96e:	f000 f819 	bl	800c9a4 <decode_uavcan_protocol_NodeStatus>
 800c972:	4603      	mov	r3, r0
}
 800c974:	4618      	mov	r0, r3
 800c976:	3708      	adds	r7, #8
 800c978:	46bd      	mov	sp, r7
 800c97a:	bd80      	pop	{r7, pc}

0800c97c <encode_uavcan_protocol_NodeStatus>:
    encode_func,
    decode_func,
    NULL
};

void encode_uavcan_protocol_NodeStatus(struct uavcan_protocol_NodeStatus_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800c97c:	b580      	push	{r7, lr}
 800c97e:	b088      	sub	sp, #32
 800c980:	af02      	add	r7, sp, #8
 800c982:	60f8      	str	r0, [r7, #12]
 800c984:	60b9      	str	r1, [r7, #8]
 800c986:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_NodeStatus(buffer, msg, chunk_cb, ctx, true);
 800c988:	f107 0210 	add.w	r2, r7, #16
 800c98c:	2301      	movs	r3, #1
 800c98e:	9300      	str	r3, [sp, #0]
 800c990:	4610      	mov	r0, r2
 800c992:	68f9      	ldr	r1, [r7, #12]
 800c994:	68ba      	ldr	r2, [r7, #8]
 800c996:	687b      	ldr	r3, [r7, #4]
 800c998:	f000 f81a 	bl	800c9d0 <_encode_uavcan_protocol_NodeStatus>
}
 800c99c:	3718      	adds	r7, #24
 800c99e:	46bd      	mov	sp, r7
 800c9a0:	bd80      	pop	{r7, pc}
 800c9a2:	bf00      	nop

0800c9a4 <decode_uavcan_protocol_NodeStatus>:

uint32_t decode_uavcan_protocol_NodeStatus(const CanardRxTransfer* transfer, struct uavcan_protocol_NodeStatus_s* msg) {
 800c9a4:	b580      	push	{r7, lr}
 800c9a6:	b084      	sub	sp, #16
 800c9a8:	af00      	add	r7, sp, #0
 800c9aa:	6078      	str	r0, [r7, #4]
 800c9ac:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800c9ae:	2300      	movs	r3, #0
 800c9b0:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_NodeStatus(transfer, &bit_ofs, msg, true);
 800c9b2:	f107 030c 	add.w	r3, r7, #12
 800c9b6:	6878      	ldr	r0, [r7, #4]
 800c9b8:	4619      	mov	r1, r3
 800c9ba:	683a      	ldr	r2, [r7, #0]
 800c9bc:	2301      	movs	r3, #1
 800c9be:	f000 f865 	bl	800ca8c <_decode_uavcan_protocol_NodeStatus>
    return (bit_ofs+7)/8;
 800c9c2:	68fb      	ldr	r3, [r7, #12]
 800c9c4:	3307      	adds	r3, #7
 800c9c6:	08db      	lsrs	r3, r3, #3
}
 800c9c8:	4618      	mov	r0, r3
 800c9ca:	3710      	adds	r7, #16
 800c9cc:	46bd      	mov	sp, r7
 800c9ce:	bd80      	pop	{r7, pc}

0800c9d0 <_encode_uavcan_protocol_NodeStatus>:

void _encode_uavcan_protocol_NodeStatus(uint8_t* buffer, struct uavcan_protocol_NodeStatus_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800c9d0:	b580      	push	{r7, lr}
 800c9d2:	b084      	sub	sp, #16
 800c9d4:	af00      	add	r7, sp, #0
 800c9d6:	60f8      	str	r0, [r7, #12]
 800c9d8:	60b9      	str	r1, [r7, #8]
 800c9da:	607a      	str	r2, [r7, #4]
 800c9dc:	603b      	str	r3, [r7, #0]
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
 800c9de:	68f8      	ldr	r0, [r7, #12]
 800c9e0:	2100      	movs	r1, #0
 800c9e2:	2208      	movs	r2, #8
 800c9e4:	f000 f92a 	bl	800cc3c <memset>
    canardEncodeScalar(buffer, 0, 32, &msg->uptime_sec);
 800c9e8:	68bb      	ldr	r3, [r7, #8]
 800c9ea:	68f8      	ldr	r0, [r7, #12]
 800c9ec:	2100      	movs	r1, #0
 800c9ee:	2220      	movs	r2, #32
 800c9f0:	f7ff fa02 	bl	800bdf8 <canardEncodeScalar>
    chunk_cb(buffer, 32, ctx);
 800c9f4:	687b      	ldr	r3, [r7, #4]
 800c9f6:	68f8      	ldr	r0, [r7, #12]
 800c9f8:	2120      	movs	r1, #32
 800c9fa:	683a      	ldr	r2, [r7, #0]
 800c9fc:	4798      	blx	r3
    memset(buffer,0,8);
 800c9fe:	68f8      	ldr	r0, [r7, #12]
 800ca00:	2100      	movs	r1, #0
 800ca02:	2208      	movs	r2, #8
 800ca04:	f000 f91a 	bl	800cc3c <memset>
    canardEncodeScalar(buffer, 0, 2, &msg->health);
 800ca08:	68bb      	ldr	r3, [r7, #8]
 800ca0a:	3304      	adds	r3, #4
 800ca0c:	68f8      	ldr	r0, [r7, #12]
 800ca0e:	2100      	movs	r1, #0
 800ca10:	2202      	movs	r2, #2
 800ca12:	f7ff f9f1 	bl	800bdf8 <canardEncodeScalar>
    chunk_cb(buffer, 2, ctx);
 800ca16:	687b      	ldr	r3, [r7, #4]
 800ca18:	68f8      	ldr	r0, [r7, #12]
 800ca1a:	2102      	movs	r1, #2
 800ca1c:	683a      	ldr	r2, [r7, #0]
 800ca1e:	4798      	blx	r3
    memset(buffer,0,8);
 800ca20:	68f8      	ldr	r0, [r7, #12]
 800ca22:	2100      	movs	r1, #0
 800ca24:	2208      	movs	r2, #8
 800ca26:	f000 f909 	bl	800cc3c <memset>
    canardEncodeScalar(buffer, 0, 3, &msg->mode);
 800ca2a:	68bb      	ldr	r3, [r7, #8]
 800ca2c:	3305      	adds	r3, #5
 800ca2e:	68f8      	ldr	r0, [r7, #12]
 800ca30:	2100      	movs	r1, #0
 800ca32:	2203      	movs	r2, #3
 800ca34:	f7ff f9e0 	bl	800bdf8 <canardEncodeScalar>
    chunk_cb(buffer, 3, ctx);
 800ca38:	687b      	ldr	r3, [r7, #4]
 800ca3a:	68f8      	ldr	r0, [r7, #12]
 800ca3c:	2103      	movs	r1, #3
 800ca3e:	683a      	ldr	r2, [r7, #0]
 800ca40:	4798      	blx	r3
    memset(buffer,0,8);
 800ca42:	68f8      	ldr	r0, [r7, #12]
 800ca44:	2100      	movs	r1, #0
 800ca46:	2208      	movs	r2, #8
 800ca48:	f000 f8f8 	bl	800cc3c <memset>
    canardEncodeScalar(buffer, 0, 3, &msg->sub_mode);
 800ca4c:	68bb      	ldr	r3, [r7, #8]
 800ca4e:	3306      	adds	r3, #6
 800ca50:	68f8      	ldr	r0, [r7, #12]
 800ca52:	2100      	movs	r1, #0
 800ca54:	2203      	movs	r2, #3
 800ca56:	f7ff f9cf 	bl	800bdf8 <canardEncodeScalar>
    chunk_cb(buffer, 3, ctx);
 800ca5a:	687b      	ldr	r3, [r7, #4]
 800ca5c:	68f8      	ldr	r0, [r7, #12]
 800ca5e:	2103      	movs	r1, #3
 800ca60:	683a      	ldr	r2, [r7, #0]
 800ca62:	4798      	blx	r3
    memset(buffer,0,8);
 800ca64:	68f8      	ldr	r0, [r7, #12]
 800ca66:	2100      	movs	r1, #0
 800ca68:	2208      	movs	r2, #8
 800ca6a:	f000 f8e7 	bl	800cc3c <memset>
    canardEncodeScalar(buffer, 0, 16, &msg->vendor_specific_status_code);
 800ca6e:	68bb      	ldr	r3, [r7, #8]
 800ca70:	3308      	adds	r3, #8
 800ca72:	68f8      	ldr	r0, [r7, #12]
 800ca74:	2100      	movs	r1, #0
 800ca76:	2210      	movs	r2, #16
 800ca78:	f7ff f9be 	bl	800bdf8 <canardEncodeScalar>
    chunk_cb(buffer, 16, ctx);
 800ca7c:	687b      	ldr	r3, [r7, #4]
 800ca7e:	68f8      	ldr	r0, [r7, #12]
 800ca80:	2110      	movs	r1, #16
 800ca82:	683a      	ldr	r2, [r7, #0]
 800ca84:	4798      	blx	r3
}
 800ca86:	3710      	adds	r7, #16
 800ca88:	46bd      	mov	sp, r7
 800ca8a:	bd80      	pop	{r7, pc}

0800ca8c <_decode_uavcan_protocol_NodeStatus>:

void _decode_uavcan_protocol_NodeStatus(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_NodeStatus_s* msg, bool tao) {
 800ca8c:	b580      	push	{r7, lr}
 800ca8e:	b086      	sub	sp, #24
 800ca90:	af02      	add	r7, sp, #8
 800ca92:	60f8      	str	r0, [r7, #12]
 800ca94:	60b9      	str	r1, [r7, #8]
 800ca96:	607a      	str	r2, [r7, #4]
 800ca98:	70fb      	strb	r3, [r7, #3]
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 32, false, &msg->uptime_sec);
 800ca9a:	68bb      	ldr	r3, [r7, #8]
 800ca9c:	681a      	ldr	r2, [r3, #0]
 800ca9e:	687b      	ldr	r3, [r7, #4]
 800caa0:	9300      	str	r3, [sp, #0]
 800caa2:	68f8      	ldr	r0, [r7, #12]
 800caa4:	4611      	mov	r1, r2
 800caa6:	2220      	movs	r2, #32
 800caa8:	2300      	movs	r3, #0
 800caaa:	f7ff f82d 	bl	800bb08 <canardDecodeScalar>
    *bit_ofs += 32;
 800caae:	68bb      	ldr	r3, [r7, #8]
 800cab0:	681b      	ldr	r3, [r3, #0]
 800cab2:	f103 0220 	add.w	r2, r3, #32
 800cab6:	68bb      	ldr	r3, [r7, #8]
 800cab8:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 2, false, &msg->health);
 800caba:	68bb      	ldr	r3, [r7, #8]
 800cabc:	681a      	ldr	r2, [r3, #0]
 800cabe:	687b      	ldr	r3, [r7, #4]
 800cac0:	3304      	adds	r3, #4
 800cac2:	9300      	str	r3, [sp, #0]
 800cac4:	68f8      	ldr	r0, [r7, #12]
 800cac6:	4611      	mov	r1, r2
 800cac8:	2202      	movs	r2, #2
 800caca:	2300      	movs	r3, #0
 800cacc:	f7ff f81c 	bl	800bb08 <canardDecodeScalar>
    *bit_ofs += 2;
 800cad0:	68bb      	ldr	r3, [r7, #8]
 800cad2:	681b      	ldr	r3, [r3, #0]
 800cad4:	1c9a      	adds	r2, r3, #2
 800cad6:	68bb      	ldr	r3, [r7, #8]
 800cad8:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 3, false, &msg->mode);
 800cada:	68bb      	ldr	r3, [r7, #8]
 800cadc:	681a      	ldr	r2, [r3, #0]
 800cade:	687b      	ldr	r3, [r7, #4]
 800cae0:	3305      	adds	r3, #5
 800cae2:	9300      	str	r3, [sp, #0]
 800cae4:	68f8      	ldr	r0, [r7, #12]
 800cae6:	4611      	mov	r1, r2
 800cae8:	2203      	movs	r2, #3
 800caea:	2300      	movs	r3, #0
 800caec:	f7ff f80c 	bl	800bb08 <canardDecodeScalar>
    *bit_ofs += 3;
 800caf0:	68bb      	ldr	r3, [r7, #8]
 800caf2:	681b      	ldr	r3, [r3, #0]
 800caf4:	1cda      	adds	r2, r3, #3
 800caf6:	68bb      	ldr	r3, [r7, #8]
 800caf8:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 3, false, &msg->sub_mode);
 800cafa:	68bb      	ldr	r3, [r7, #8]
 800cafc:	681a      	ldr	r2, [r3, #0]
 800cafe:	687b      	ldr	r3, [r7, #4]
 800cb00:	3306      	adds	r3, #6
 800cb02:	9300      	str	r3, [sp, #0]
 800cb04:	68f8      	ldr	r0, [r7, #12]
 800cb06:	4611      	mov	r1, r2
 800cb08:	2203      	movs	r2, #3
 800cb0a:	2300      	movs	r3, #0
 800cb0c:	f7fe fffc 	bl	800bb08 <canardDecodeScalar>
    *bit_ofs += 3;
 800cb10:	68bb      	ldr	r3, [r7, #8]
 800cb12:	681b      	ldr	r3, [r3, #0]
 800cb14:	1cda      	adds	r2, r3, #3
 800cb16:	68bb      	ldr	r3, [r7, #8]
 800cb18:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 16, false, &msg->vendor_specific_status_code);
 800cb1a:	68bb      	ldr	r3, [r7, #8]
 800cb1c:	681a      	ldr	r2, [r3, #0]
 800cb1e:	687b      	ldr	r3, [r7, #4]
 800cb20:	3308      	adds	r3, #8
 800cb22:	9300      	str	r3, [sp, #0]
 800cb24:	68f8      	ldr	r0, [r7, #12]
 800cb26:	4611      	mov	r1, r2
 800cb28:	2210      	movs	r2, #16
 800cb2a:	2300      	movs	r3, #0
 800cb2c:	f7fe ffec 	bl	800bb08 <canardDecodeScalar>
    *bit_ofs += 16;
 800cb30:	68bb      	ldr	r3, [r7, #8]
 800cb32:	681b      	ldr	r3, [r3, #0]
 800cb34:	f103 0210 	add.w	r2, r3, #16
 800cb38:	68bb      	ldr	r3, [r7, #8]
 800cb3a:	601a      	str	r2, [r3, #0]

}
 800cb3c:	3710      	adds	r7, #16
 800cb3e:	46bd      	mov	sp, r7
 800cb40:	bd80      	pop	{r7, pc}
 800cb42:	bf00      	nop

0800cb44 <encode_func.lto_priv.33>:
#include <uavcan.protocol.RestartNode_res.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800cb44:	b580      	push	{r7, lr}
 800cb46:	b084      	sub	sp, #16
 800cb48:	af00      	add	r7, sp, #0
 800cb4a:	60f8      	str	r0, [r7, #12]
 800cb4c:	60b9      	str	r1, [r7, #8]
 800cb4e:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_RestartNode_res(msg, chunk_cb, ctx);
 800cb50:	68f8      	ldr	r0, [r7, #12]
 800cb52:	68b9      	ldr	r1, [r7, #8]
 800cb54:	687a      	ldr	r2, [r7, #4]
 800cb56:	f000 f811 	bl	800cb7c <encode_uavcan_protocol_RestartNode_res>
}
 800cb5a:	3710      	adds	r7, #16
 800cb5c:	46bd      	mov	sp, r7
 800cb5e:	bd80      	pop	{r7, pc}

0800cb60 <decode_func.lto_priv.40>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800cb60:	b580      	push	{r7, lr}
 800cb62:	b082      	sub	sp, #8
 800cb64:	af00      	add	r7, sp, #0
 800cb66:	6078      	str	r0, [r7, #4]
 800cb68:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_RestartNode_res(transfer, msg);
 800cb6a:	6878      	ldr	r0, [r7, #4]
 800cb6c:	6839      	ldr	r1, [r7, #0]
 800cb6e:	f000 f819 	bl	800cba4 <decode_uavcan_protocol_RestartNode_res>
 800cb72:	4603      	mov	r3, r0
}
 800cb74:	4618      	mov	r0, r3
 800cb76:	3708      	adds	r7, #8
 800cb78:	46bd      	mov	sp, r7
 800cb7a:	bd80      	pop	{r7, pc}

0800cb7c <encode_uavcan_protocol_RestartNode_res>:
    encode_func,
    decode_func,
    NULL
};

void encode_uavcan_protocol_RestartNode_res(struct uavcan_protocol_RestartNode_res_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
 800cb7c:	b580      	push	{r7, lr}
 800cb7e:	b088      	sub	sp, #32
 800cb80:	af02      	add	r7, sp, #8
 800cb82:	60f8      	str	r0, [r7, #12]
 800cb84:	60b9      	str	r1, [r7, #8]
 800cb86:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_RestartNode_res(buffer, msg, chunk_cb, ctx, true);
 800cb88:	f107 0210 	add.w	r2, r7, #16
 800cb8c:	2301      	movs	r3, #1
 800cb8e:	9300      	str	r3, [sp, #0]
 800cb90:	4610      	mov	r0, r2
 800cb92:	68f9      	ldr	r1, [r7, #12]
 800cb94:	68ba      	ldr	r2, [r7, #8]
 800cb96:	687b      	ldr	r3, [r7, #4]
 800cb98:	f7fd fce6 	bl	800a568 <_encode_uavcan_protocol_RestartNode_res>
}
 800cb9c:	3718      	adds	r7, #24
 800cb9e:	46bd      	mov	sp, r7
 800cba0:	bd80      	pop	{r7, pc}
 800cba2:	bf00      	nop

0800cba4 <decode_uavcan_protocol_RestartNode_res>:

uint32_t decode_uavcan_protocol_RestartNode_res(const CanardRxTransfer* transfer, struct uavcan_protocol_RestartNode_res_s* msg) {
 800cba4:	b580      	push	{r7, lr}
 800cba6:	b084      	sub	sp, #16
 800cba8:	af00      	add	r7, sp, #0
 800cbaa:	6078      	str	r0, [r7, #4]
 800cbac:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800cbae:	2300      	movs	r3, #0
 800cbb0:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_RestartNode_res(transfer, &bit_ofs, msg, true);
 800cbb2:	f107 030c 	add.w	r3, r7, #12
 800cbb6:	6878      	ldr	r0, [r7, #4]
 800cbb8:	4619      	mov	r1, r3
 800cbba:	683a      	ldr	r2, [r7, #0]
 800cbbc:	2301      	movs	r3, #1
 800cbbe:	f7fd fced 	bl	800a59c <_decode_uavcan_protocol_RestartNode_res>
    return (bit_ofs+7)/8;
 800cbc2:	68fb      	ldr	r3, [r7, #12]
 800cbc4:	3307      	adds	r3, #7
 800cbc6:	08db      	lsrs	r3, r3, #3
}
 800cbc8:	4618      	mov	r0, r3
 800cbca:	3710      	adds	r7, #16
 800cbcc:	46bd      	mov	sp, r7
 800cbce:	bd80      	pop	{r7, pc}

0800cbd0 <memcmp>:
 800cbd0:	b510      	push	{r4, lr}
 800cbd2:	440a      	add	r2, r1
 800cbd4:	1e44      	subs	r4, r0, #1
 800cbd6:	4291      	cmp	r1, r2
 800cbd8:	d008      	beq.n	800cbec <memcmp+0x1c>
 800cbda:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 800cbde:	7808      	ldrb	r0, [r1, #0]
 800cbe0:	4283      	cmp	r3, r0
 800cbe2:	d001      	beq.n	800cbe8 <memcmp+0x18>
 800cbe4:	1a18      	subs	r0, r3, r0
 800cbe6:	bd10      	pop	{r4, pc}
 800cbe8:	3101      	adds	r1, #1
 800cbea:	e7f4      	b.n	800cbd6 <memcmp+0x6>
 800cbec:	2000      	movs	r0, #0
 800cbee:	bd10      	pop	{r4, pc}

0800cbf0 <memcpy>:
 800cbf0:	b510      	push	{r4, lr}
 800cbf2:	1e43      	subs	r3, r0, #1
 800cbf4:	440a      	add	r2, r1
 800cbf6:	4291      	cmp	r1, r2
 800cbf8:	d004      	beq.n	800cc04 <memcpy+0x14>
 800cbfa:	f811 4b01 	ldrb.w	r4, [r1], #1
 800cbfe:	f803 4f01 	strb.w	r4, [r3, #1]!
 800cc02:	e7f8      	b.n	800cbf6 <memcpy+0x6>
 800cc04:	bd10      	pop	{r4, pc}

0800cc06 <memmove>:
 800cc06:	4281      	cmp	r1, r0
 800cc08:	b510      	push	{r4, lr}
 800cc0a:	eb01 0302 	add.w	r3, r1, r2
 800cc0e:	d301      	bcc.n	800cc14 <memmove+0xe>
 800cc10:	1e42      	subs	r2, r0, #1
 800cc12:	e00b      	b.n	800cc2c <memmove+0x26>
 800cc14:	4298      	cmp	r0, r3
 800cc16:	d2fb      	bcs.n	800cc10 <memmove+0xa>
 800cc18:	1881      	adds	r1, r0, r2
 800cc1a:	1ad2      	subs	r2, r2, r3
 800cc1c:	42d3      	cmn	r3, r2
 800cc1e:	d004      	beq.n	800cc2a <memmove+0x24>
 800cc20:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800cc24:	f801 4d01 	strb.w	r4, [r1, #-1]!
 800cc28:	e7f8      	b.n	800cc1c <memmove+0x16>
 800cc2a:	bd10      	pop	{r4, pc}
 800cc2c:	4299      	cmp	r1, r3
 800cc2e:	d004      	beq.n	800cc3a <memmove+0x34>
 800cc30:	f811 4b01 	ldrb.w	r4, [r1], #1
 800cc34:	f802 4f01 	strb.w	r4, [r2, #1]!
 800cc38:	e7f8      	b.n	800cc2c <memmove+0x26>
 800cc3a:	bd10      	pop	{r4, pc}

0800cc3c <memset>:
 800cc3c:	4603      	mov	r3, r0
 800cc3e:	4402      	add	r2, r0
 800cc40:	4293      	cmp	r3, r2
 800cc42:	d002      	beq.n	800cc4a <memset+0xe>
 800cc44:	f803 1b01 	strb.w	r1, [r3], #1
 800cc48:	e7fa      	b.n	800cc40 <memset+0x4>
 800cc4a:	4770      	bx	lr
